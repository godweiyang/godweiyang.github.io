<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从多线程到多进程：如何让你的小电影下载飞快？</title>
      <link href="/2023/07/15/cpu-parallel/"/>
      <url>/2023/07/15/cpu-parallel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>你有没有遇到过这样的问题：在网络上找到很多部你迫不及待想看的小电影，却发现下载速度慢得令人抓狂？那么，你可能需要知道一些关于CPU多线程和多进程的知识，让我们一起揭开CPU的神秘面纱，看看它是如何让你的小电影下载飞快的吧！</p><p><img src="1.jpg" alt></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先回顾两个操作系统课学过的基本概念，“并行”和“并发”。并行指的是<strong>同一时刻</strong>有多个任务在同时执行；并发指的是在<strong>一段时间内</strong>有多个任务在执行，但是在<strong>同一时刻</strong>只能有一个任务在执行。所以并行是真的在同时干活，而并发实际上是在多个任务之间频繁切换，只是看起来像而已。举个通俗的例子，你一边听歌一边写代码，那你就是在并行干了两件事；但你一边打游戏写代码，那你就是在并发，只能在游戏死亡的时候切屏写两行代码，但看起来你同时干了两件事。</p><p>多线程和多进程都是用来同时处理任务的，但还是有很大不同，比如在python中：</p><ul><li>多线程是<strong>并发</strong>的（由于python的全局解释器锁GIL的存在），所以同一时刻只会有一个线程在干活（计算），其他线程只能摸鱼。当一个线程干活累了，开始等待补给送到（比如下载数据），操作系统就会切换到其他线程运行，不过同时也可能调用其它CPU核心。因此多线程更适合I/O密集型任务，比如同时下载很多部小电影，这样所有线程都可以等着，无需CPU核心干活。而如果用到计算密集型任务上，就会出现一个线程一直在干活，其他线程只能等它干完活才能继续干，这样就等同于串行了。此外多个线程共享同一块内存空间，因此数据是共享的。</li><li>多进程是<strong>并行</strong>的，每个进程运行在独立的CPU核心上，因此可以同一时刻同时干活。此外多个进程的内存空间完全独立，互不影响，创建多进程需要复制出很多块相同的内存空间，因此耗时耗资源。多进程适合计算密集型任务，比如并行给众多小电影去除马赛克，因为利用多个CPU核心同时干活，效率更高。但如果用多进程来进行I/O密集型任务，那么大部分CPU核心都没活干，都在等待下载数据，太浪费资源了。</li></ul><h2 id="使用方法和速度测试"><a href="#使用方法和速度测试" class="headerlink" title="使用方法和速度测试"></a>使用方法和速度测试</h2><p>python提供了不少的多线程和多进程API，非常好用。</p><p>基本思想就是进程池和线程池这两个概念，你可以把它理解成一个队列，队列长度为进程数或者线程数。然后不断往队列里提交任务，当队列满了后，其他任务就等待，直到队列中有任务执行结束，就随机再入队一个任务。</p><p>具体的用法和作用我都写在测试代码对应位置的注释里了，执行时间也加上了，很详细！代码也放下面链接了：<br><a href="https://github.com/godweiyang/cpu_parallel" target="_blank" rel="noopener">https://github.com/godweiyang/cpu_parallel</a></p><p>不想看的我直接总结一下，大多数时候：</p><ul><li><strong>计算密集型情况下，用多进程的<code>map_async</code>一次性传入所有任务列表。</strong></li><li><strong>I/O密集型情况下，CPU够多的话多进程<code>map_async</code>和多线程<code>map</code>都行，CPU很少的话用多线程<code>map</code>，都是一次性传入所有任务列表。</strong></li></ul><p>注意多进程不要定义很占内存的变量，因为每个子进程都会复制所有内存空间，可能会OOM，并且很耗时。</p><h3 id="计算密集型任务"><a href="#计算密集型任务" class="headerlink" title="计算密集型任务"></a>计算密集型任务</h3><p>测试的方法是计算1到n求和，一共同时计算5个不同的n，n比较大。显然这是一个计算密集型任务，非常吃CPU性能。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp<span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token triple-quoted-string string">'''计算1+2+...+n'''</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        s <span class="token operator">+=</span> i    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"sum({n})={s}"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> n<span class="token punctuation">,</span> s<span class="token triple-quoted-string string">'''统计函数运行时间'''</span><span class="token keyword">def</span> <span class="token function">get_duration</span><span class="token punctuation">(</span>func_name<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{func_name} >>>>>>>>>>>>>>>>>>>>>"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"args: {args}"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"kwargs: {kwargs}"</span><span class="token punctuation">)</span>    st <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>func_name<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"TIME: {time.time() - st}\n"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''单进程运行结果：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 19.151068449020386可以看出计算sum和最后获取到的result都是按照输入顺序串行的。'''</span><span class="token keyword">def</span> <span class="token function">single_process</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        result <span class="token operator">=</span> func<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">for</span> r <span class="token keyword">in</span> results<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多进程apply方法因为5个任务要按顺序提交，apply方法是阻塞的，每个任务都得等上一个任务结束后才能继续提交并执行，所以同一时刻只有一个进程在执行任务，等同于单进程串行。运行结果：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 18.436408758163452可以看出跟单进程串行执行几乎没有任何区别。'''</span><span class="token keyword">def</span> <span class="token function">multi_process_apply</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            result <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply<span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 同步，阻塞，直接返回计算结果</span>            results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result<span class="token punctuation">)</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> results<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多进程apply_async方法5个任务按顺序提交，但是会立即返回ApplyResult对象，是非阻塞的，这样一下子就提交了5个任务，进程池的队列大小是2，所以同时有2个任务在执行，最后通过ApplyResult.get()方法来获取对应任务的结果，这个方法会阻塞，直到获取到结果才会继续获取下一个的结果。运行结果（block=False）：sum(100000001)=5000000050000000sum(100000000)=4999999950000000results(100000000)=4999999950000000results(100000001)=5000000050000000sum(100000002)=5000000150000001results(100000002)=5000000150000001sum(100000003)=5000000250000003results(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000004)=5000000350000006TIME: 11.417532920837402可以看出，如果提交完5个任务之后没有进行block阻塞，那么一部分进程执行完sum计算之后，ApplyResult.get()会立刻获取到结果，然后输出result。并且sum的计算顺序也是无序的，因为5个任务是非阻塞的，一股脑全提交到进程池里了，没有执行的先后顺序。但是result的顺序还是跟输入顺序一样的，因为是用阻塞方法ApplyResult.get()一个个获取的，这样即使第一行sum(100000001)已经计算完了，也没有立刻输出result，而是等sum(100000000)计算完，才按顺序输出两者的result。时间上缩短了一半左右。运行结果（block=True）：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 11.41776990890503如果提交完5个任务之后进行了block阻塞，那么就会等这5个任务都执行完再输出result，这样的话计算sum的顺序依然是无序的，只是上面恰好按顺序执行了，输出result的话依然是有序的，并且不需要等待了，因为全都已经执行完了。时间上缩短了一半左右。'''</span><span class="token keyword">def</span> <span class="token function">multi_process_apply_async</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    apply_results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            apply_result <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 异步，不阻塞，返回ApplyResult对象</span>            apply_results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>apply_result<span class="token punctuation">)</span>        <span class="token keyword">if</span> block<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，等待所有进程结束</span>            pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> apply_result <span class="token keyword">in</span> apply_results<span class="token punctuation">:</span>            r <span class="token operator">=</span> apply_result<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 阻塞，按输入顺序返回计算结果</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多进程map方法map方法可以一次性提交一个可迭代的对象（例如这里的列表），然后方法内部会迭代这个对象，将元素依次送到func中执行，注意是无序执行的。map方法是阻塞的，也就是说所有任务全部执行完才会返回results，返回顺序也是有序的。如果一次性提交了所有任务构成的列表，那么map和apply_async几乎没有任何区别。如果手动对任务进行了分块，一块一块提交到map里，那么可能会更慢，因为同一块中的任务执行时间会有差异，会出现进程等待。运行结果：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 11.016913414001465这里sum计算也是碰巧有序了，实际上是无序随机执行的，results一定是有序的。时间上缩短了一半左右。'''</span><span class="token keyword">def</span> <span class="token function">multi_process_map</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        results <span class="token operator">=</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>func<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 同步，阻塞，按输入顺序返回所有进程的计算结果</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> results<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多进程map_async方法和map的区别就是非阻塞的，传入一个可迭代对象之后会立即返回MapResult对象，之后需要用MapResult.get()方法来阻塞获取计算结果，直到这个可迭代对象的任务全部执行完，返回结果列表，才会继续获取下一个可迭代对象的结果。这个过程其实和apply_async基本一样，只是把单个元素换成了可迭代对象。运行结果（block=False）：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 11.517432928085327如果不开block阻塞的话，所有的可迭代对象中的任务会一股脑全部新建起来，然后无序执行，最后按照输入顺序获取results，只不过下面例子中只传入了一个列表，因此和上面的map没有任何区别。时间上缩短了一半左右。运行结果（block=True）：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 11.51731562614441因为只传入了一个列表，所以MapResult.get()和block没有区别了。时间上缩短了一半左右。'''</span><span class="token keyword">def</span> <span class="token function">multi_process_map_async</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        map_results <span class="token operator">=</span> pool<span class="token punctuation">.</span>map_async<span class="token punctuation">(</span>func<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 异步，不阻塞，返回MapResult对象</span>        <span class="token keyword">if</span> block<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，等待所有进程结束</span>            pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>        map_results <span class="token operator">=</span> map_results<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 阻塞，按输入顺序返回计算结果</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> map_results<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多进程imap方法和map的区别就是，imap是非阻塞的，并且返回的是一个迭代器，不需要通过get方法一次性获取所有的计算结果，可以通过迭代器不断拿到已经执行完的进程结果，但是注意迭代器是按照输入顺序迭代的，因此靠前的任务还没执行完的话，是不会先输出后面的任务结果的。运行结果（block=False）：sum(100000001)=5000000050000000sum(100000000)=4999999950000000results(100000000)=4999999950000000results(100000001)=5000000050000000sum(100000002)=5000000150000001results(100000002)=5000000150000001sum(100000003)=5000000250000003results(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000004)=5000000350000006TIME: 11.41724157333374可以看出输出结果和apply_async的结果很像，都是执行完一部分就输出一部分，并且输出是有序的。时间上缩短了一半左右。运行结果（block=True）：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 11.418148040771484如果开启了block阻塞的话，那所有进程执行完才会有序输出结果。时间上缩短了一半左右。'''</span><span class="token keyword">def</span> <span class="token function">multi_process_imap</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        result_iter <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 异步，不阻塞，返回迭代器</span>        <span class="token keyword">if</span> block<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，等待所有进程结束</span>            pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> result_iter<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，按输入顺序返回计算结果</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多进程imap_unordered方法和imap区别就是迭代器输出结果的时候，先执行完的进程先输出结果，不一定要有序。运行结果（block=False）：sum(100000000)=4999999950000000results(100000000)=4999999950000000sum(100000001)=5000000050000000results(100000001)=5000000050000000sum(100000002)=5000000150000001results(100000002)=5000000150000001sum(100000003)=5000000250000003results(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000004)=5000000350000006TIME: 11.419070482254028跑的结果比较巧，正好有序了，其实sum和results可能是无序的。时间上缩短了一半左右。运行结果（block=True）：sum(100000000)=4999999950000000sum(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000000)=4999999950000000results(100000001)=5000000050000000results(100000002)=5000000150000001results(100000003)=5000000250000003results(100000004)=5000000350000006TIME: 11.718666076660156跑的结果比较巧，正好有序了，其实sum和results可能是无序的。时间上缩短了一半左右。'''</span><span class="token keyword">def</span> <span class="token function">multi_process_imap_unordered</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        result_iter <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap_unordered<span class="token punctuation">(</span>func<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 异步，不阻塞，返回迭代器</span>        <span class="token keyword">if</span> block<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，等待所有进程结束</span>            pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> result_iter<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，按进程结束顺序返回计算结果</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多线程submit方法submit方法是非阻塞的，会立刻返回Future对象，然后通过Future.result()获取计算结果，和多进程的apply_async很像，但是因为GIL的存在，同一时刻只会计算一个sum，所以等同于串行计算。运行结果：sum(100000001)=5000000050000000sum(100000000)=4999999950000000results(100000000)=4999999950000000results(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003results(100000002)=5000000150000001results(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000004)=5000000350000006TIME: 19.167519569396973可以看出sum计算是无序的，但是results是有序的，并且时间几乎等同于串行。'''</span><span class="token keyword">def</span> <span class="token function">multi_thread_submit</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    futures <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            future <span class="token operator">=</span> pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>func<span class="token punctuation">,</span> num<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 异步，不阻塞，返回Future对象</span>            futures<span class="token punctuation">.</span>append<span class="token punctuation">(</span>future<span class="token punctuation">)</span>        <span class="token keyword">for</span> future <span class="token keyword">in</span> futures<span class="token punctuation">:</span>            r <span class="token operator">=</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 阻塞，按输入顺序返回计算结果</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''多线程map方法和多进程的imap很像，也是输入一个可迭代对象，立刻返回一个迭代器，并且迭代器的输出也是有序的，阻塞的，如果执行顺序是乱的，那么输出就要等待了。运行结果：sum(100000000)=4999999950000000sum(100000001)=5000000050000000results(100000000)=4999999950000000results(100000001)=5000000050000000sum(100000002)=5000000150000001sum(100000003)=5000000250000003results(100000002)=5000000150000001results(100000003)=5000000250000003sum(100000004)=5000000350000006results(100000004)=5000000350000006TIME: 19.716532707214355这里也碰巧sum计算是有序的，实际上是无序的，但是results是有序的，并且时间几乎等同于串行。'''</span><span class="token keyword">def</span> <span class="token function">multi_thread_map</span><span class="token punctuation">(</span>parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span>parallel<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>        result_iter <span class="token operator">=</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>func<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 异步，不阻塞，返回迭代器</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> result_iter<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 阻塞，按输入顺序返回计算结果</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"results({r[0]})={r[1]}"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    start<span class="token punctuation">,</span> length <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">**</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span>    nums <span class="token operator">=</span> range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> start<span class="token operator">+</span>length<span class="token punctuation">)</span>    parallel <span class="token operator">=</span> <span class="token number">2</span>    get_duration<span class="token punctuation">(</span><span class="token string">"single_process"</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_apply"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_apply_async"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_apply_async"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_map"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_map_async"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_map_async"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_imap"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_imap"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_imap_unordered"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_process_imap_unordered"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> block<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_thread_submit"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>    get_duration<span class="token punctuation">(</span><span class="token string">"multi_thread_map"</span><span class="token punctuation">,</span> parallel<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="I-O密集型任务"><a href="#I-O密集型任务" class="headerlink" title="I/O密集型任务"></a>I/O密集型任务</h3><p>要想模拟I/O密集型任务很简单，不一定非要去下你们喜欢看的小电影，修改一下<code>func</code>函数，用<code>time.sleep(3)</code>替代<code>sum</code>计算，阻塞3秒就行了。这期间CPU会没事干，就跟下载小电影一样的效果。</p><p>因为是5个任务，每个阻塞3秒，所以串行情况下理论执行时间是15秒，那么我们直接看一下汇总结果吧。</p><p>可以看出单进程15秒，多进程除了<code>apply</code>都是9秒，这都和计算密集型任务结论完全一致。</p><p>唯一不同的是，多线程两个方法全都变的和多进程一样快了！这就验证了多线程在I/O密集型任务上和多进程没啥区别。</p><pre class="line-numbers language-text"><code class="language-text">single_process >>>>>>>>>>>>>>>>>>>>>args: (range(100000000, 100000005),)kwargs: {}TIME: 15.00304365158081multi_process_apply >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {}TIME: 15.082982540130615multi_process_apply_async >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': False}TIME: 9.077685832977295multi_process_apply_async >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': True}TIME: 9.075870275497437multi_process_map >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {}TIME: 9.07173490524292multi_process_map_async >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': False}TIME: 9.067619562149048multi_process_map_async >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': True}TIME: 9.076589584350586multi_process_imap >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': False}TIME: 9.06967830657959multi_process_imap >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': True}TIME: 9.074320793151855multi_process_imap_unordered >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': False}TIME: 9.069270849227905multi_process_imap_unordered >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {'block': True}TIME: 9.076633930206299multi_thread_submit >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {}TIME: 9.002540111541748multi_thread_map >>>>>>>>>>>>>>>>>>>>>args: (2, range(100000000, 100000005))kwargs: {}TIME: 9.002438068389893<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探秘火山之巅：我在字节跳动的三年奇妙旅程</title>
      <link href="/2023/07/15/volctrans-3-year/"/>
      <url>/2023/07/15/volctrans-3-year/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>本文由ChatGPT润色，朱自清文笔</p></blockquote><p>似乎已有半载的光阴，我未曾触笔述事。此半年来，工作路向浑然改变，乃至整个团队亦经历了沧海桑田的变迁。说我忙，其实也未必至于忙，但压力如山，犹如涛涛江水，使我心无余力来挥洒文墨。</p><p>简单的说，现时，我已迈离了火山翻译的工作台，但仍旧身在AI Lab之中，将我那一份热忱，在别的领域继续闪耀，犹如夕阳留照，也为曾经的事业散发余晖。</p><p>在此，我以一篇文字，作为记念，纪念我在火山翻译的三载光华岁月。</p><h2 id="初探世界"><a href="#初探世界" class="headerlink" title="初探世界"></a>初探世界</h2><p>疫情初歇，我初涉社会之门，从学校踏入世界的广漠。日复一日的新鲜感充满了我，每天，我都会拍下食堂的餐点分享到朋友圈，那时的饭菜，犹如人间美味，如今却是味同嚼蜡。</p><p>记得有一位同事曾如此戏谑：“只有实习生才会每日拍拍吃的”。当时，我不以为然，美食在眼，怎能不晒出来呢？然而两年过去，我已失去了那曾经的热情。</p><p>那半年的实习生涯，我主要从事一些探索性的工作，聚焦于Transformer模型的压缩与量化。转正之际，我还开发了一款机器翻译的iOS app，虽然模型大小被压缩至几十兆，但功能尚且简陋。</p><p>在此期间，我也有幸深入接触了LightSeq，这个伟大的开源项目。当时，它的star尚只有两三百，只是一个推理加速引擎。我助力它宣传，如今已累积超过2800个star，影响力小有所增。</p><p>实习期间，我遇到了我的首位mentor，同样，我也是他的首个实习生。他，技术熟练，人格魅力，是火山翻译中最帅气，最有男子气概，技术最出众的人。他在我身上留下了深刻的烙印，无论是在技术领域，还是在职场经验上，他都给我留下了深刻的影响。那个我深入接触的开源项目LightSeq，也是他一手策划推动的。</p><h2 id="光序之路"><a href="#光序之路" class="headerlink" title="光序之路"></a>光序之路</h2><p>这一年，我和导师共同开辟了一片崭新的疆域，从无到有，建立起了LightSeq训练加速引擎。在这期间，我叩开了CUDA的大门，初尝探索与发现的乐趣，甚至倾力打造了几篇初探CUDA的入门指南，期待让后继者少踏入一些陷阱。</p><p>我发现，写CUDA，与写开源项目的过程，充满了无尽的快乐。这快乐来自于一种难以名状的成就感，是因为我能为开源社区贡献自己的一份力量，为广大的人群带来福祉。这与某些项目大异其趣，那些项目让人只感觉自己在为公司鞠躬尽瘁，而缺少真实的动力。</p><p>在这一年，我也圆满的完成了学业，正式成为了字节跳动的一员，所以实际上，我在此的历练时间不过两年有余。</p><p>除了技术上的精进，我在宣发方面也并未松懈。我在字节内部社区发布的正能量帖子获得了前所未有的热烈回响，我还有幸登上了CEO的十周年演讲，我的故事甚至被印刷在了春节礼盒上。这一切，都让我对公司产生了强烈的归属感，我与它有了更深的羁绊。</p><h2 id="量化的翻涌"><a href="#量化的翻涌" class="headerlink" title="量化的翻涌"></a>量化的翻涌</h2><p>这一年，我的心灵主要浸润在量化技术的泉流之中。因为训练与推理的加速引擎，已经磨砺至尽善尽美，而我心中更期盼将量化的秤砣，巧妙地投入到训练与推理的洪流中。春去夏来，我主要灌注心血于量化推理（QAT）的研磨，秋风起，继续逐流推进量化训练的开发。</p><p>不绝如缕的努力，如灯塔般的宣传，使得star这一年突破了两千的峭壁，其名声也如晨星般，照亮了黑夜，日渐高涨。在这温暖的光芒下，我心中的兴奋难以言表。</p><p>不仅如此，训练的成果，居然得以登上超级计算领域的顶峰——SC大会，这样的机会，在我加入公司时是万万没有想到的。这不是纯粹的研究，也不是简单的开发，这是燃烧的激情与冷静的学术的交融。我同时肩负着工作与学术的双重任务，开源项目与论文发布的双翼搏击，此刻的我，恰如我心所期待的那般。</p><h2 id="雕琢新世纪"><a href="#雕琢新世纪" class="headerlink" title="雕琢新世纪"></a>雕琢新世纪</h2><p>辞去旧岁，迎来新元年之际，稳定扩散（Stable Diffusion，一种人工智能绘画技术）揭幕而出，颠覆了世界的视界。我在导师的催促之下，奉献于一项神秘的任务，亲手打造并服务于这一业务，而这引领我跨入了AI绘画这一未曾涉足的领域。如同磨砺的矛头，我用了一个季度的时间，走过了从浅显入门到深入领略的艰辛道路，逐渐地，整套流程的操作已然熟练于心。然而，意料之外，业务草木皆兵后的黯然消失让人唏嘘。虽然如此，收获亦非空虚，因我在这个过程中结识了不少领域中的翘楚，领会了很多尖端的技术，这将是我未来探索的宝贵财富。</p><p>后来，ChatGPT如猛虎下山，扫过各行各业，各大公司和学校纷纷掀起了自我训练LLM的热潮，连字节跳动也并未例外。我却未能及时把握这个机遇，改行研究计算机视觉（CV），具体的事宜我在此就不多言了，避嫌为妙。简而言之，随着部门的重组，我与相伴三年的火山翻译惜别，因毕竟，机器翻译也必须接纳大模型的洗礼。大模型的兴起，也为公司间的人才流动带来了无尽的可能，熟悉大模型操作的人才，将是炙手可热的宠儿。</p><p>如今，心底里的快乐，无疑并非昔日之充沛。然而，这亦是大势所趋，ChatGPT正驱使我们纷纷前行，迎接变革，有所压力，反倒正中其境。</p><h2 id="再别漕河泾"><a href="#再别漕河泾" class="headerlink" title="再别漕河泾"></a>再别漕河泾</h2><p>这是我在火山翻译度过的三载，一段异常快乐而充实的日子。有人戏谑我们的团队，号称字节中“最没字节味”的一股清流，那是因为我们的工作时间自由度大，工作环境轻松而愉快。然而，我更愿意把这种情形看作字节独特风貌的体现，是在这种环境下，我们才能更从容地创造出惊艳的成果，反倒是若将人们束缚在公司，加班加点，往往只会事与愿违。</p><p>火山翻译的使用率正逐渐下降，大家开始更多地选择chatgpt来进行翻译。诚然，后者在准确度和流畅度上还存在一些差距，但火山翻译更多的时候已经成为了我的文本编辑框，帮我整理和消除各种格式。</p><p>在不久的将来，大约两个月后，字节可能要迁移到杨浦工区，而我也将告别陪伴我三年的漕河泾。漕河泾虽不在市区，却也已经物涨价跌，房价一路攀升到每平米十万元。记得当年，我为了靠近公司，特地选在9号线沿线的松江泗泾购房，然而在搬迁后，我的通勤时间竟增加了一个小时。</p><p>我在思索，或许我应当重新开始，定期更新一些文章。回忆当初写CUDA做模型优化的日子，那些想要分享的观点和想法还有很多，也都颇为有趣。而现在的研究方向，我却在犹豫，毕竟是半路出家，深怕自己班门弄斧。但我想，我还是应当回归初心，写写算法题。这些文章或许能够帮助他人求职，或许有一天，我自己也能再次从中得益。</p><hr><blockquote><p>以下是原文</p></blockquote><p>已经有半年左右没更新过文章了，这半年工作方向有很大变动，甚至整个部门也发生了翻天覆地的变化。说忙也不算忙，但是压力倍增，也没多少心思写文章了。</p><p>简单来说，现在已经离开火山翻译了，但还是在AI Lab，继续在其他方向上发挥余热。</p><p>谨以此文，纪念我在火山翻译的三年美好时光。</p><h2 id="三年经历"><a href="#三年经历" class="headerlink" title="三年经历"></a>三年经历</h2><h3 id="2020-5-20-2020年末"><a href="#2020-5-20-2020年末" class="headerlink" title="2020.5.20 - 2020年末"></a>2020.5.20 - 2020年末</h3><p>这半年时间疫情刚结束，第一次从学校迈入社会的大门，每天都充斥着新鲜感。每天都要拍一拍公司食堂的伙食发朋友圈，那时候的饭菜是真好吃，现在已经大不如从前咯。</p><p>还记得一位同事当时跟我说：“只有实习生才会每天拍这些吃的”，当时不以为意，觉得这么好吃为啥不秀一秀，果然过了两年已经没有任何拍的动力了。</p><p>这半年时间因为是实习，所以主要做一些探索性的工作，聚焦于Transformer模型的压缩与量化，最后实习转正时还做了一个机器翻译的iOS app，模型大小压缩到只有几十兆，不过相当简陋了。</p><p>顺带还熟悉了一下LightSeq这个伟大的开源项目，当时star才两三百吧，只有推理加速引擎。帮忙做了一波宣传，现在已经2800多star了，也算是小有影响力了。</p><p>实习期间遇到了我的第一个mentor，我也是他的第一个实习生。作为火山翻译最帅最man技术最牛的人，他方方面面影响了我很多，不论是技术，还是职场经验，LightSeq也是他一手策划推动的。</p><h3 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h3><p>这一年时间和mentor一起从0到1搭建起了LightSeq训练加速引擎，从0开始学习了CUDA，还写了几篇CUDA入门教程，让后来的人少踩一点坑。</p><p>写CUDA还是快乐的，写开源项目也快乐。有一种莫名的成就感，为开源做贡献的成就感，造福很多很多人的成就感。不像有些项目，你做了就感觉纯粹是在给公司打工，没有那么大的动力。</p><p>这一年也顺利毕业了，正式转正成为了bytedancer，所以实际上到现在为止我的工龄才刚2年多。</p><p>除了技术，在宣发方面我也比较活跃，字节内部社区发的正能量帖子点赞量进入了历史前几，还上了CEO十周年演讲，故事被印刷在了春节礼盒上面，这更让我对公司产生了一种强烈的归属感。</p><h3 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h3><p>这一年主要聚焦于量化技术，因为训练和推理加速引擎都开发的差不多了，想更进一步地将量化应用到训练和推理上去。前半年主要开发了量化推理（QAT），后半年继续开发了量化训练，经过一波宣传，star在这一年突破了2000大关，知名度也越来越高。</p><p>训练相关成果还发表在了超算领域顶会SC，没想到来公司还能发顶会论文，工作学术两不误。但这又不是那种纯粹的做research，而是做开源项目的同时，顺便发了一篇论文，这才是我想要的状态。</p><h3 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h3><p>2022年底，stable diffusion（AI绘画）横空出世，mentor让我去给某业务做相关支持，于是机缘巧合之下从0开始学习了一波AI绘画技术。做了大概三四个月吧，整套流程都搞的差不多了，没想到业务没了，实在是可惜。不过也没白干，认识了不少这方面的大佬，也学到了很多相关技术。</p><p>再后来就是chatgpt横扫各个领域了，各大公司和学校都开始了自己训练LLM的旅程，字节肯定也不例外。不过我没赶上NLP这趟车，转而去做CV了，具体就不多说了，保密保密。简而言之，部门重组了，我也离开相伴了三年的火山翻译了，毕竟机器翻译也得拥抱大模型了。同时大模型也带来了机会，公司之间的跳槽与活水肯定也会越来越多，现在国内谁会做大模型那肯定是最吃香的。</p><p>简而言之，现在肯定是没有以前快乐的。不过大方向也是如此，chatgpt逼迫着大家追赶进步，有点压力是正常的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在火山翻译这三年是非常快乐的，有人说过，我们组是字节“最没有字节范”的组之一了，因为上班时间比较自由随意，工作轻松氛围好。但我觉得这反而是字节范的表现之一，这种环境下更容易创造出牛逼的成果出来，把人约束在公司加班反而可能适得其反。</p><p>火山翻译用的也越来越少了，现在都直接用chatgpt来翻译，准确度和流畅度还是有差距的。火山翻译网页更多时候是作为文本编辑框来给我消除文本格式用了。</p><p>再过两个多月，字节可能就要搬到杨浦工区了，我也即将离开待了三年之久的漕河泾。漕河泾虽说不算市区，但是房价也已经涨到了10万左右一平了。当初为了来公司上班，房子也特地买在了9号线沿线的松江泗泾，没想到搬完工区后通勤一下多了一个小时。</p><p>以后会重新定期更新一些文章吧。以前写CUDA做模型优化想写的东西还挺多的，也很有趣。现在做的方向不知道写啥好了，半路出家也不是非常熟悉，怕班门弄斧了。可能还是会回归初心吧，写写算法题，大家找工作也用得到，说不定哪天我自己又用到了呢。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节跳动 </tag>
            
            <tag> 火山翻译 </tag>
            
            <tag> AI Lab </tag>
            
            <tag> 工作体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零二二年终总结</title>
      <link href="/2022/12/12/2022-conclusion/"/>
      <url>/2022/12/12/2022-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote><blockquote><p>写于2022年12月13日</p></blockquote><p>不知不觉，年终总结坚持写了6年了，这几年每年都在12.13发布，因为这天🎂。还记得2017年第一次写的时候才大三，现在竟然都已经工作两年多了。回顾这一年的经历，挺魔幻的。</p><h2 id="封城两个月"><a href="#封城两个月" class="headerlink" title="封城两个月"></a>封城两个月</h2><p>今年上半年几乎是在封城中度过的。清楚地记得3.8妇女节这天，公司楼里出了第一个密接，所有人被召回在公司过了两夜。我们少数人作为顽固分子当晚执意不回去，最后第二天还是没办法回去隔离了，现在想想这些政策都挺可笑的，没有啥实际意义。</p><p>然后就是四五月份上海封城，在10平米的小房间里，和我的🐱一起硬生生呆了两个月。吃喝倒是不愁，当时小区里有户人家开小卖店的，所以过的还挺滋润的。甚至因为居家工作比较舒服，还想再多呆几个月。不过这几个月疫情反反复复，仍然是居家比较多。</p><p>生日这天，行程码就要淡出历史了，最近各地都放开了，大家多注意身体，虽然大概率最后都是要🐑的。</p><h2 id="全新的生活"><a href="#全新的生活" class="headerlink" title="全新的生活"></a>全新的生活</h2><p>8月份的时候，离开了住了两年多的小破屋，租了一间贵得多的一室一厅。60平确实比之前舒服太多了，做饭、休闲、居家工作都更轻松。猫也舒服了，整体客厅里跑酷来跑酷去，充分释放了天性。</p><p>最近还添置了戴森吸尘器，完美解决了困扰一年的猫毛打扫难的问题。平时做清洁也轻松多了，以往擦洗拖一套下来得快一个小时，还累死累活，现在十来分钟就能搞定。</p><p>服役了5年多的主机也淘汰了，虽然1080p下打打lol和pubg依然压力不大，但是最近换了4k显示器，而且偶尔要直播游戏，还是顶不住。DIY的最新电脑配置是i7-13700kf的，显卡准备抢一波7900xtx，12.13也就是今天发售，不知道之后会不会跌。主板和散热丐了点，其他都还不错。</p><p>中秋还和室友去了趟厦门，看了看没看过的海，见了见想见到的人。</p><h2 id="买🏠了"><a href="#买🏠了" class="headerlink" title="买🏠了"></a>买🏠了</h2><p>这一年陆陆续续一直在看房，从开始的二手房，到后来的新房。看的区域一直都是松江泗泾和佘山附近，因为在9号线，去公司近，就算以后跳槽或者搬公司了，去市区换乘也比较方便。最近认筹了泗泾站900米的星樾云栖，12.15开盘。100平的三房，近500总价，首付170左右，月供得一万六。24年底交房，这两年还得交房租，所以以后压力大了许多。</p><blockquote><p>（2022.12.20更新）已经拿下了，首付款、房贷、合同都已经搞定了，摇号摇了个71号，很不错，选了个111101，数字很nb。</p></blockquote><h2 id="好好干活"><a href="#好好干活" class="headerlink" title="好好干活"></a>好好干活</h2><p>今年工作上情况还不错，LightSeq3量化引擎开源了，发了一篇CCF-A论文，也完成了职场第一阶段的目标。后续工作方向更加艰难了，又是一个之前未曾涉足的领域，最近得恶补很多知识了，多看论文。好好干活吧，争取做出点成果来。最近AIGC非常火，又是stable diffusion，又是chatgpt，都是不错的赛道，上🚗！</p><p>公众号粉丝最近终于破万了，不容易，很久没经营了，摆烂，忙工作忙游戏，说白了还是懒。</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>留白。</p><p>最后特别感谢一个人，自始自终都一直在，从没离开过。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>历时一年，论文终于被国际顶会接收了</title>
      <link href="/2022/06/16/sc22/"/>
      <url>/2022/06/16/sc22/</url>
      
        <content type="html"><![CDATA[<p>就在昨天，超算领域的国际顶会SC22放榜了，我们组的论文也被接收了，得分44332（4分制）：<br><img src="1.jpg" alt></p><p><strong>论文地址：</strong><br><a href="https://arxiv.org/abs/2110.05722" target="_blank" rel="noopener">https://arxiv.org/abs/2110.05722</a><br><img src="3.png" alt></p><h2 id="SC会议是什么？"><a href="#SC会议是什么？" class="headerlink" title="SC会议是什么？"></a>SC会议是什么？</h2><p>可能很多同学都没听过SC是什么会议，SC会议全称“高性能计算、网络、存储和分析国际会议”（The International Conference for High Performance Computing, Networking, Storage, and Analysis），是高性能计算，体系结构领域顶级会议，<strong>CCF推荐A类会议</strong>。SC会议发表难度大，每年录用70篇左右的论文，录用率在25%左右。2022年投稿320篇，录用75篇（6篇修改中），录用率约为23%。SC22将于11月13-18日在美国达拉斯举行。</p><h2 id="论文写的啥？"><a href="#论文写的啥？" class="headerlink" title="论文写的啥？"></a>论文写的啥？</h2><p>这次中的论文标题是：“LightSeq2: Accelerated Training for Transformer-based Models on GPUs”，这是LightSeq第二期训练引擎相关论文，深入讲解了LightSeq训练引擎中用到的算子融合、显存管理等相关技术。LightSeq支持Transformer、BERT、GPT、ViT等多种模型的训练加速，在机器翻译任务上最高可以加速3倍。详细的技术原理介绍可以看下面的文章：<br><a href="https://zhuanlan.zhihu.com/p/383657837" target="_blank" rel="noopener">训练加速3倍！字节跳动推出业界首个NLP模型全流程加速引擎</a></p><h2 id="投稿过程是怎么样的？"><a href="#投稿过程是怎么样的？" class="headerlink" title="投稿过程是怎么样的？"></a>投稿过程是怎么样的？</h2><p>去年6月的时候，这篇论文的初稿就已经成型了。当时投了下半年的PPoPP国际顶会，但是评分很低，几乎都是拒绝。总结原因，一是因为这个会议和论文方向不是特别合得来，这个会议更注重分布式并行方向的成果；二是论文是按照NLP领域写作习惯来写的，写的也确实糟糕，所以被认为没有什么创新。</p><p>被拒之后请了UCSB的几位老师和学生进行了专业的修改，重新组织了论文的结构。相同的技术用更高级的话术来表达后，论文顿时高大上了起来。SC22的投稿过程非常漫长，从3月份一直持续到了6月份才出结果。而最终的终稿要一直持续到8月份，会议更是在11月才开启，整个过程持续了大半年。</p><h2 id="还能公费旅游不？"><a href="#还能公费旅游不？" class="headerlink" title="还能公费旅游不？"></a>还能公费旅游不？</h2><p>疫情原因，达拉斯现场是没办法去了，UCSB的几位老师同学可以帮忙去现场观摩观摩。还记得两年前的ACL20也是错过了去西雅图公费旅游的机会，今年又错过了达拉斯。会议可以错过，但愿人不要吧。</p><h2 id="我们组是做啥的？"><a href="#我们组是做啥的？" class="headerlink" title="我们组是做啥的？"></a>我们组是做啥的？</h2><p>我们组是字节跳动火山翻译团队，那自然就是做机器翻译的啦。而我呢是做模型优化方向的，LightSeq就是我们的主要项目：<br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p>之前也写过一篇我们组的详细介绍：<br><a href="https://zhuanlan.zhihu.com/p/472659682" target="_blank" rel="noopener">来字节快两年了，回答一些你们感兴趣的问题</a></p><h2 id="怎么进字节？"><a href="#怎么进字节？" class="headerlink" title="怎么进字节？"></a>怎么进字节？</h2><p><strong>内推链接：</strong><br><a href="https://job.toutiao.com/s/YB9MUpS" target="_blank" rel="noopener">https://job.toutiao.com/s/YB9MUpS</a></p><p><img src="2.png" alt></p><p>也强烈建议加我微信（godweiyang）沟通交流，岗位信息、内推进度等等都可以问我。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SC22 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 模型优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手推公式之“层归一化”梯度</title>
      <link href="/2022/05/22/layernorm-gradient/"/>
      <url>/2022/05/22/layernorm-gradient/</url>
      
        <content type="html"><![CDATA[<p>昨天推导了一下交叉熵的反向传播梯度，今天再来推导一下层归一化（LayerNorm），这是一种常见的归一化方法。</p><h1 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h1><p>假设待归一化的$m$维向量为$x$，均值和标准差分别是$\mu{(x)}$和$\sigma{(x)}$，LayerNorm的参数是$w$和$b$，那么层归一化后的输出为：<br>$$<br>y = w \odot \frac{x - \mu}{\sqrt{\sigma^2 + \epsilon}} + b<br>$$</p><p>这里的极小量$\epsilon$是为了防止标准差为0导致溢出。为了简单起见，我们不加上这一项，原公式也就变成了：<br>$$<br>y = w \odot \frac{x - \mu}{\sigma} + b<br>$$</p><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>假设损失函数$\mathcal{L}$对输出$y$的梯度是$\frac{\partial{\mathcal{L}}}{\partial{y}}$，那么这里需要求三个梯度：$\frac{\partial{\mathcal{L}}}{\partial{w}}$、$\frac{\partial{\mathcal{L}}}{\partial{b}}$和$\frac{\partial{\mathcal{L}}}{\partial{x}}$。</p><p>令$\hat x = \frac{x - \mu}{\sigma}$，那么原公式就变成了：<br>$$<br>y = w \odot \hat x + b<br>$$</p><p>两个参数的梯度非常简单：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathcal{L}}}{\partial{w_i}} &amp;= \frac{\partial{\mathcal{L}}}{\partial{y_i}} \cdot \frac{\partial{\mathcal{y_i}}}{\partial{w_i}} = \frac{\partial{\mathcal{L}}}{\partial{y_i}} \cdot \hat x_i \\<br>\frac{\partial{\mathcal{L}}}{\partial{b_i}} &amp;= \frac{\partial{\mathcal{L}}}{\partial{y_i}} \cdot \frac{\partial{\mathcal{y_i}}}{\partial{b_i}} = \frac{\partial{\mathcal{L}}}{\partial{y_i}}<br>\end{aligned}<br>$$</p><p>对输入$x$的梯度等于：<br>$$<br>\frac{\partial{\mathcal{L}}}{\partial{x_i}} = \frac{1}{\sigma} \cdot \left[\frac{\partial{\mathcal{L}}}{\partial{y_i}} \cdot w_i - \frac{1}{m}\cdot \left( \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j} + \hat x_i \cdot \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j \cdot \hat x_j}\right)\right]<br>$$</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>对输入$x$的梯度可以写成：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathcal{L}}}{\partial{x_i}} &amp;= \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot \frac{\partial{\mathcal{y_j}}}{\partial{\hat x_j}}} \cdot \frac{\partial{\mathcal{\hat x_j}}}{\partial{x_i}} \\<br>&amp;= \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j \cdot \frac{\partial{\mathcal{\hat x_j}}}{\partial{x_i}}}<br>\end{aligned}<br>$$</p><p>这里只需要计算最后一项就行了：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathcal{\hat x_j}}}{\partial{x_i}} &amp;= \frac{\partial}{\partial{x_i}}\left(\frac{x_j - \mu}{\sigma}\right) \\<br>&amp;= \frac{\partial{(x_j - \mu)}}{\partial x_i} \cdot \sigma^{-1} + (x_j - \mu) \cdot \frac{\partial\sigma}{\partial x_i} \cdot (-\sigma^{-2}) \\<br>&amp;= \left(\delta_{ij} - \frac{\partial{\mu}}{\partial x_i}\right) \cdot \sigma^{-1} - \sigma^{-2} \cdot (x_j - \mu) \cdot \frac{\partial\sigma}{\partial x_i}<br>\end{aligned}<br>$$</p><p>其中$\delta_{ij}$只有当$i=j$的时候才会等于1，否则都等于0。这里只需要求出均值和标准差对$x_i$的梯度就行了。直接给出结论，证明比较简单，放在了文末：<br>$$<br>\begin{aligned}<br>\frac{\partial \mu}{\partial x_i} &amp;= \frac{1}{m} \\<br>\frac{\partial \sigma}{\partial x_i} &amp;= \frac{1}{m} \cdot \sigma^{-1} \cdot (x_i - \mu)<br>\end{aligned}<br>$$</p><p>代入可以得到：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathcal{\hat x_j}}}{\partial{x_i}} &amp;= \left(\delta_{ij} - \frac{\partial{\mu}}{\partial x_i}\right) \cdot \sigma^{-1} - \sigma^{-2} \cdot (x_j - \mu) \cdot \frac{\partial\sigma}{\partial x_i} \\<br>&amp;= \left(\delta_{ij} - \frac{1}{m}\right) \cdot \sigma^{-1} - \sigma^{-2} \cdot (x_j - \mu) \cdot \frac{1}{m} \cdot \sigma^{-1} \cdot (x_i - \mu) \\<br>&amp;= \sigma^{-1} \cdot \delta_{ij} - \frac{1}{m} \cdot \sigma^{-1} - \frac{1}{m} \cdot \sigma^{-3} \cdot (x_i - \mu) \cdot (x_j - \mu) \\<br>&amp;=  \sigma^{-1} \cdot \delta_{ij} - \frac{1}{m} \cdot \sigma^{-1} - \frac{1}{m} \cdot \sigma^{-1} \cdot {\hat x_i} \cdot {\hat x_j}<br>\end{aligned}<br>$$</p><p>最后带入梯度$\frac{\partial{\mathcal{L}}}{\partial{x_i}}$中可以得到：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathcal{L}}}{\partial{x_i}} &amp;= \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j \cdot \frac{\partial{\mathcal{\hat x_j}}}{\partial{x_i}}} \\<br>&amp;= \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j \cdot \left(\sigma^{-1} \cdot \delta_{ij} - \frac{1}{m} \cdot \sigma^{-1} - \frac{1}{m} \cdot \sigma^{-1} \cdot {\hat x_i} \cdot {\hat x_j}\right)} \\<br>&amp;= \frac{1}{\sigma} \cdot \frac{\partial{\mathcal{L}}}{\partial{y_i}} \cdot w_i - \frac{1}{m \sigma} \cdot \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j} - \frac{\hat x_i}{m \sigma} \cdot \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j \cdot \hat x_j} \\<br>&amp;= \frac{1}{\sigma} \cdot \left[\frac{\partial{\mathcal{L}}}{\partial{y_i}} \cdot w_i - \frac{1}{m}\cdot \left( \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j} + \hat x_i \cdot \sum_j {\frac{\partial{\mathcal{L}}}{\partial{y_j}} \cdot w_j \cdot \hat x_j}\right)\right]<br>\end{aligned}<br>$$</p><h2 id="均值和标准差的梯度"><a href="#均值和标准差的梯度" class="headerlink" title="均值和标准差的梯度"></a>均值和标准差的梯度</h2><p>均值的梯度为：<br>$$<br>\begin{aligned}<br>\frac{\partial \mu}{\partial x_i} &amp;= \frac{\partial}{\partial x_i} \left(\frac{1}{m} \cdot \sum_j{x_j}\right) \\<br>&amp;= \frac{1}{m}<br>\end{aligned}<br>$$</p><p>标准差的计算公式可以写成$\sigma = \left[\mu(x^2) - \mu^2(x)\right]^{\frac{1}{2}}$，所以梯度为：<br>$$<br>\begin{aligned}<br>\frac{\partial \sigma}{\partial x_i} &amp;=  \frac{\partial}{\partial x_i} \left[\mu(x^2) - \mu^2(x)\right]^{\frac{1}{2}} \\<br>&amp;= \frac{1}{2} \cdot \left[\mu(x^2) - \mu^2(x)\right]^{-\frac{1}{2}} \cdot \left(\frac{2}{m} \cdot x_i - \frac{2}{m} \cdot \mu \right) \\<br>&amp;= \frac{1}{m} \cdot \sigma^{-1} \cdot (x_i - \mu)<br>\end{aligned}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> 梯度 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“交叉熵”反向传播推导</title>
      <link href="/2022/05/21/transformer-gradient/"/>
      <url>/2022/05/21/transformer-gradient/</url>
      
        <content type="html"><![CDATA[<p>交叉熵（CrossEntropy）是常见的损失函数，本文详细推导一下它的梯度，面试大厂或者工程实践中都可能会用到。</p><h1 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h1><p>假设分类任务类别数是$V$，隐层输出是$V$维向量$\mathbf{h}$，标准的one-hot向量是$\mathbf{y}$，正确的类别是$k$。那么交叉熵损失可以定义为：<br>$$<br>\mathcal{L}(\mathbf p, \mathbf q) = -\sum_i \mathbf{p}_i \log(\mathbf{q}_i)<br>$$<br>其中$\mathbf p = (1 - \alpha)  \mathbf y + \frac{\alpha}{V}\cdot \mathbf 1$，$\mathbf q = \mathrm{Softmax}(\mathbf h)$，$0\le \alpha\le 1$是平滑参数。Softmax函数大家都很熟悉了，具体形式为：$\mathbf{q}_i = \frac{e^{\mathbf{h}_i}}{\sum_{j}{e^{\mathbf{h}_j}}}$。</p><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>$\mathcal{L}$对$\mathbf{h}_i$的梯度要分两种情况：<br>$$<br>\frac{\partial{\mathcal{L}}}{\partial{\mathbf{h}_i}} = \left\{<br>\begin{array}{ll}<br>   \mathbf{q}_i -\frac{\alpha}{V}  - 1 + \alpha &amp; i = k \\<br>   \mathbf{q}_i -\frac{\alpha}{V} &amp; i\neq k<br>\end{array}  \right.<br>$$</p><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>根据求导法则有：<br>$$<br>\frac{\partial \mathcal{L}}{\partial \mathbf{h}_i} = -\sum_{j}{\frac{\partial{\mathcal{L}}}{\partial{\mathbf{q}_j}} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} = -\sum_{j}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}}<br>$$<br>其中$\frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}$就是Softmax函数的梯度（这个推导比较简单，放在了文末）：<br>$$<br>\frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}} = \left\{<br>\begin{array}{ll}<br>   \mathbf{q}_i (1 - \mathbf{q}_i)  &amp; j = i \\<br>    -\mathbf{q}_i \mathbf{q}_j &amp; j\neq i<br>\end{array}  \right.<br>$$</p><p>下面分两种情况讨论：</p><ol><li>当$i = k$时：<br>$$<br>\begin{aligned}<br>\frac{\partial \mathcal{L}}{\partial \mathbf{h}_i} &amp;= -\sum_{j}{\frac{\partial{\mathcal{L}}}{\partial{\mathbf{q}_j}} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} = -\sum_{j}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} \\<br>&amp;= -\frac{\mathbf{p}_k}{\mathbf{q}_k} \cdot \frac{\partial{\mathbf{q}_k}}{\partial{\mathbf{h}_i}} -\sum_{j \neq k}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} \\<br>&amp;= -\frac{\mathbf{p}_k}{\mathbf{q}_k} \cdot \mathbf{q}_k (1 - \mathbf{q}_k) -\sum_{j \neq k}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot (-\mathbf{q}_i \mathbf{q}_j)} \\<br>&amp;= \mathbf{p}_k (\mathbf{q}_k - 1)  + \mathbf{q}_i\sum_{j \neq k}{\mathbf{p}_j} \\<br>&amp;= (1 - \alpha + \frac{\alpha}{V})(\mathbf{q}_k - 1) +  (V - 1) \cdot \frac{\alpha}{V}\cdot \mathbf{q}_i \\<br>&amp;= \mathbf{q}_i -\frac{\alpha}{V}  - 1 + \alpha<br>\end{aligned}<br>$$</li><li>当$i \neq k$时：<br>$$<br>\begin{aligned}<br>\frac{\partial \mathcal{L}}{\partial \mathbf{h}_i} &amp;= -\sum_{j}{\frac{\partial{\mathcal{L}}}{\partial{\mathbf{q}_j}} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} = -\sum_{j}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} \\<br>&amp;= -\frac{\mathbf{p}_k}{\mathbf{q}_k} \cdot \frac{\partial{\mathbf{q}_k}}{\partial{\mathbf{h}_i}} -\frac{\mathbf{p}_i}{\mathbf{q}_i} \cdot \frac{\partial{\mathbf{q}_i}}{\partial{\mathbf{h}_i}} -\sum_{j \neq k, j \neq i}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot \frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}}} \\<br>&amp;= -\frac{\mathbf{p}_k}{\mathbf{q}_k} \cdot (-\mathbf{q}_k\mathbf{q}_i) -\frac{\mathbf{p}_i}{\mathbf{q}_i} \cdot \mathbf{q}_i (1 - \mathbf{q}_i) -\sum_{j \neq k, j \neq i}{\frac{\mathbf{p}_j}{\mathbf{q}_j} \cdot (-\mathbf{q}_i \mathbf{q}_j)} \\<br>&amp;= \mathbf{p}_k \mathbf{q}_i - \mathbf{p}_i (1 - \mathbf{q}_i) + \mathbf{q}_i\sum_{j \neq k, j \neq i}{\mathbf{p}_j} \\<br>&amp;= (1 - \alpha + \frac{\alpha}{V})\cdot\mathbf{q}_i - \frac{\alpha}{V} \cdot (1 - \mathbf{q}_i) + (V - 2) \cdot \frac{\alpha}{V}\cdot\mathbf{q}_i \\<br>&amp;= \mathbf{q}_i -\frac{\alpha}{V}<br>\end{aligned}<br>$$</li></ol><h2 id="Softmax梯度"><a href="#Softmax梯度" class="headerlink" title="Softmax梯度"></a>Softmax梯度</h2><p>回顾Softmax函数的形式：<br>$$<br>\mathbf{q}_j = \frac{e^{\mathbf{h}_j}}{\sum_{l}{e^{\mathbf{h}_l}}} = \frac{e^{\mathbf{h}_j}}{e^{\mathbf{h}_i} + \sum_{l \neq i}{e^{\mathbf{h}_l}}}<br>$$</p><p>这里也分两种情况讨论：</p><ol><li>当$j = i$时：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}} &amp;= \frac{e^{\mathbf{h}_j}}{e^{\mathbf{h}_i} + \sum_{l \neq i}{e^{\mathbf{h}_l}}} - \frac{e^{\mathbf{h}_j} \cdot e^{\mathbf{h}_j}}{\left(e^{\mathbf{h}_i} + \sum_{l \neq i}{e^{\mathbf{h}_l}}\right)^2} \\<br>&amp;= \mathbf{q}_j - \mathbf{q}_j\mathbf{q}_j \\<br>&amp;= \mathbf{q}_j (1 - \mathbf{q}_j)<br>\end{aligned}<br>$$</li><li>当$j \neq i$时：<br>$$<br>\begin{aligned}<br>\frac{\partial{\mathbf{q}_j}}{\partial{\mathbf{h}_i}} &amp;= - \frac{e^{\mathbf{h}_j} \cdot e^{\mathbf{h}_i}}{\left(e^{\mathbf{h}_i} + \sum_{l \neq i}{e^{\mathbf{h}_l}}\right)^2} \\<br>&amp;= -\mathbf{q}_j\mathbf{q}_i<br>\end{aligned}<br>$$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> 梯度 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拼图还能这么玩？</title>
      <link href="/2022/04/22/funny-media/"/>
      <url>/2022/04/22/funny-media/</url>
      
        <content type="html"><![CDATA[<p>这两天将我所有微信好友的头像弄出来了，一共5000多张。然后想着可以用它们来做些啥，最后用它们拼图玩。</p><p>Mac微信的头像保存在：</p><pre class="line-numbers language-txt"><code class="language-txt">~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.0b4.0.9/c1a30fcf75eedba12764b4d4170b977e/Avatar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中倒数第二个那一长串字符串每个人会不同，根据自己情况进行修改。</p><p>用到的代码在文章最后，github上也开源了：<br><a href="https://github.com/godweiyang/FunnyMedia" target="_blank" rel="noopener">https://github.com/godweiyang/FunnyMedia</a></p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>直接上最终效果图，首先是5000多张头像拼接成一张图片：<br><img src="avatar_30.jpg" alt><br>如果看不清的话可以放大看看细节：<br><img src="avatar_detail.png" alt></p><p>然后是5000多张头像拼成的杨超越：<br><img src="ycy_30.jpg" alt><br>如果看不清的话可以放大看看细节：<br><img src="ycy_detail.png" alt><br>杨超越的原图是这样的：<br><img src="ycy.jpeg" alt></p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>实现方法很简单，拼接的话就是把头像依次粘贴在一块大画布上的不同区域，就跟贴瓷砖一样。</p><p>为了实现用不同头像拼接出杨超越，就需要先将杨超越图片进行分割，每一块小区域寻找一个颜色最相近的头像粘贴上去。我直接将图像区域的RBG值求了加权平均，然后在头像中寻找RGB均值相等的粘贴上去。</p><p>代码放到文章最后了，运行命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">python3 image_stitch.py -d [图像合集目录] -i [待拼凑的图片] -s [小图最终的边长] -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中<code>-d</code>表示图像目录，你也可以放头像或者其他的图像；<code>-i</code>是你想拼成的大图路径，如果不设置的话就是直接把图像拼在一起；<code>-s</code>表示小图像最终的边长，实测设置为30效果最佳，图片大小和质量都比较好；<code>-r</code>表示是否随机排列图片。</p><p>此外之前还写过字符画视频的生成方法，代码也开源在同一个github上了：<br><a href="https://zhuanlan.zhihu.com/p/466993864" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/466993864</a><br><a href="https://github.com/godweiyang/FunnyMedia" target="_blank" rel="noopener">https://github.com/godweiyang/FunnyMedia</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> argparse<span class="token keyword">import</span> os<span class="token keyword">import</span> random<span class="token keyword">import</span> math<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> PIL<span class="token punctuation">.</span>Image <span class="token keyword">as</span> Image<span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token punctuation">,</span> trange<span class="token keyword">def</span> <span class="token function">generate1</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> size<span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"正在拼接尺寸：{size}..."</span><span class="token punctuation">)</span>    nums <span class="token operator">=</span> len<span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span>    nums_width <span class="token operator">=</span> int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>    nums_height <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token punctuation">(</span>nums <span class="token operator">+</span> nums_width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> nums_width<span class="token punctuation">)</span>    img_width <span class="token operator">=</span> nums_width <span class="token operator">*</span> size    img_height <span class="token operator">=</span> nums_height <span class="token operator">*</span> size    image <span class="token operator">=</span> Image<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>img_width<span class="token punctuation">,</span> img_height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"white"</span><span class="token punctuation">)</span>    x <span class="token operator">=</span> <span class="token number">0</span>    y <span class="token operator">=</span> <span class="token number">0</span>    files <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token keyword">if</span> rand<span class="token punctuation">:</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>files<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dir<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"图像打开失败"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            img <span class="token operator">=</span> img<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span> Image<span class="token punctuation">.</span>ANTIALIAS<span class="token punctuation">)</span>            image<span class="token punctuation">.</span>paste<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> size<span class="token punctuation">,</span> y <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span>            x <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> nums_width<span class="token punctuation">:</span>                x <span class="token operator">=</span> <span class="token number">0</span>                y <span class="token operator">+=</span> <span class="token number">1</span>            img<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    image<span class="token punctuation">.</span>save<span class="token punctuation">(</span>f<span class="token string">"avatar_{size}.jpg"</span><span class="token punctuation">)</span>    image<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">mean_pixel</span><span class="token punctuation">(</span>colors<span class="token punctuation">)</span><span class="token punctuation">:</span>    colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.3</span> <span class="token operator">*</span> r <span class="token operator">+</span> <span class="token number">0.59</span> <span class="token operator">*</span> g <span class="token operator">+</span> <span class="token number">0.11</span> <span class="token operator">*</span> b <span class="token keyword">for</span> r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b <span class="token keyword">in</span> colors<span class="token punctuation">]</span>    <span class="token keyword">return</span> int<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>colors<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">generate2</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> source<span class="token punctuation">,</span> size<span class="token punctuation">,</span> rand<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"正在拼接尺寸：{size}..."</span><span class="token punctuation">)</span>    files <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token keyword">if</span> rand<span class="token punctuation">:</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>files<span class="token punctuation">)</span>    image <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>source<span class="token punctuation">)</span>    image <span class="token operator">=</span> image<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">)</span>    img_width<span class="token punctuation">,</span> img_height <span class="token operator">=</span> image<span class="token punctuation">.</span>size    img_width <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>img_width <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> size<span class="token punctuation">)</span> <span class="token operator">*</span> size <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">10</span><span class="token punctuation">)</span>    img_height <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>img_height <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> size<span class="token punctuation">)</span> <span class="token operator">*</span> size <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">10</span><span class="token punctuation">)</span>    image <span class="token operator">=</span> image<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token punctuation">(</span>img_width<span class="token punctuation">,</span> img_height<span class="token punctuation">)</span><span class="token punctuation">,</span> Image<span class="token punctuation">.</span>ANTIALIAS<span class="token punctuation">)</span>    colors <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dir<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> IOError<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"图像打开失败"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            img <span class="token operator">=</span> img<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">)</span>            img <span class="token operator">=</span> img<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span> Image<span class="token punctuation">.</span>ANTIALIAS<span class="token punctuation">)</span>            colors<span class="token punctuation">[</span>mean_pixel<span class="token punctuation">(</span>img<span class="token punctuation">.</span>getdata<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            img<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>colors<span class="token punctuation">[</span>i <span class="token operator">-</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> colors<span class="token punctuation">[</span>i <span class="token operator">-</span> n<span class="token punctuation">]</span>                    <span class="token keyword">break</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>colors<span class="token punctuation">[</span>i <span class="token operator">+</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> colors<span class="token punctuation">[</span>i <span class="token operator">+</span> n<span class="token punctuation">]</span>                    <span class="token keyword">break</span>    index <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> trange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> img_width<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> img_height<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>            now_colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> ii <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> jj <span class="token keyword">in</span> range<span class="token punctuation">(</span>j<span class="token punctuation">,</span> j <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>                    now_colors<span class="token punctuation">.</span>append<span class="token punctuation">(</span>image<span class="token punctuation">.</span>getpixel<span class="token punctuation">(</span><span class="token punctuation">(</span>ii<span class="token punctuation">,</span> jj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            mean_color <span class="token operator">=</span> mean_pixel<span class="token punctuation">(</span>now_colors<span class="token punctuation">)</span>            img <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>                os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>                    dir<span class="token punctuation">,</span> colors<span class="token punctuation">[</span>mean_color<span class="token punctuation">]</span><span class="token punctuation">[</span>index<span class="token punctuation">[</span>mean_color<span class="token punctuation">]</span> <span class="token operator">%</span> len<span class="token punctuation">(</span>colors<span class="token punctuation">[</span>mean_color<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>            <span class="token punctuation">)</span>            img <span class="token operator">=</span> img<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">)</span>            img <span class="token operator">=</span> img<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span> Image<span class="token punctuation">.</span>ANTIALIAS<span class="token punctuation">)</span>            image<span class="token punctuation">.</span>paste<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>            img<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>            index<span class="token punctuation">[</span>mean_color<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    source_name <span class="token operator">=</span> <span class="token string">"."</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>source<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    image<span class="token punctuation">.</span>save<span class="token punctuation">(</span>f<span class="token string">"{source_name}_{size}.jpg"</span><span class="token punctuation">)</span>    image<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>        <span class="token string">"--dir"</span><span class="token punctuation">,</span> <span class="token string">"-d"</span><span class="token punctuation">,</span> type<span class="token operator">=</span>str<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">"avatar"</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">"directory of the avatars"</span>    <span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>        <span class="token string">"--img"</span><span class="token punctuation">,</span> <span class="token string">"-i"</span><span class="token punctuation">,</span> type<span class="token operator">=</span>str<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span> help<span class="token operator">=</span><span class="token string">"source image to be coverd"</span>    <span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>        <span class="token string">"--size"</span><span class="token punctuation">,</span>        <span class="token string">"-s"</span><span class="token punctuation">,</span>        type<span class="token operator">=</span>str<span class="token punctuation">,</span>        default<span class="token operator">=</span><span class="token string">"30"</span><span class="token punctuation">,</span>        help<span class="token operator">=</span><span class="token string">"size of each avatar (size1,size2,...)"</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>        <span class="token string">"--rand"</span><span class="token punctuation">,</span>        <span class="token string">"-r"</span><span class="token punctuation">,</span>        action<span class="token operator">=</span><span class="token string">"store_true"</span><span class="token punctuation">,</span>        help<span class="token operator">=</span><span class="token string">"whether to shuffle the avatars"</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    sizes <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> args<span class="token punctuation">.</span>size<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> size <span class="token keyword">in</span> sizes<span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>args<span class="token punctuation">.</span>img<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            generate1<span class="token punctuation">(</span>args<span class="token punctuation">.</span>dir<span class="token punctuation">,</span> size<span class="token punctuation">,</span> args<span class="token punctuation">.</span>rand<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            generate2<span class="token punctuation">(</span>args<span class="token punctuation">.</span>dir<span class="token punctuation">,</span> args<span class="token punctuation">.</span>img<span class="token punctuation">,</span> size<span class="token punctuation">,</span> args<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第20日，起飞了（文末有字节校招惊喜）</title>
      <link href="/2022/04/20/2022-4-20-life/"/>
      <url>/2022/04/20/2022-4-20-life/</url>
      
        <content type="html"><![CDATA[<p>封城第20天了，最近上海日新增又降到2w以下了，京东快递和外卖也部分恢复了，部分小区甚至都转成防范区了。这两天小区里核酸检测率都在95%以下，有300左右的人都没去做核酸，据说达不到要求的话没法申报解封。而我也已经4天没去做过核酸了，因为在家才是最安全的。今天因为需要拿快递，所以去贡献了一个人头，小区的检测率也勉强达标了。</p><p>今天破天荒点到了KFC，虽然只有一个三人份的套餐，花了130点了一份，解决了一天的伙食。配送的速度也非常快，半小时不到就送到了。但有一说一，味道大不如以前，比较咸，也不是非常脆，可能以前的厨师还在家隔离吧。</p><p><img src="1.jpeg" alt></p><p>今天下单了10天的猫砂终于到了。我的猫比较挑剔，小时候没教育好，所以只用纳基膨润土，其它的猫砂都会拉在地上。这次购入的36斤猫砂足够用好几个月了，这个牌子也比较便宜，一斤只要3块钱，算是纳基膨润土里最便宜的了。</p><p><img src="2.jpeg" alt></p><p>今天也不全都是顺利，早上醒来停电了，原来是忘了交电费。然后发现路由器坏了，可能需要刷固件。我原来的连接方式是客厅里放着光猫-主路由器，然后我房间里副路由器-主机，主副路由器之间无线桥接。当时500兆的宽带实测速度只有200多兆。而现在副路由器坏了，我只能直接从主机连网线到光猫上，实测速度飙升到了500兆，差不多72 MB/s。这下打游戏再也不用担心跳ping了，下载动作大片也是分分钟的事情了。</p><p><img src="3.png" alt></p><p>今天还在团购群里淘到了两盒牙膏、一大瓶洗洁精，都是好心同事买多了送我的，十分感谢。</p><h2 id="字节福利"><a href="#字节福利" class="headerlink" title="字节福利"></a>字节福利</h2><blockquote><p>字节跳动春招倒计时两周，将于4月30日16:00截止投递！还没投递的小伙伴可要抓紧了。</p></blockquote><p>我的内推码：A7FSJMK</p><p>内推链接：<br><a href="https://jobs.toutiao.com/s/F1MXbHJ" target="_blank" rel="noopener">https://jobs.toutiao.com/s/F1MXbHJ</a></p><p>我们部门还在招实习生哦，我们小组也在招，如果想做我实习生可以试一试哦。</p><p>AI-Lab NLP：<br><a href="https://job.toutiao.com/s/F1MtYBH" target="_blank" rel="noopener">https://job.toutiao.com/s/F1MtYBH</a></p><p>AI-Lab NLP（模型优化方向）：<br><a href="https://job.toutiao.com/s/F1rYVYF" target="_blank" rel="noopener">https://job.toutiao.com/s/F1rYVYF</a></p><p>而最后一场笔试时间是5月6日，为帮助大家更好地应对笔试，字节校园提供「双月模拟笔试· 3-4月场」供你实战，活动免费！</p><p><strong>4月23日19:00-21:00 本周六晚，不见不散！</strong>（悄悄说，参与上一次模拟笔试的同学，已有上百位顺利拿到offer！）</p><p>报名链接：<br><a href="https://wj.toutiao.com/q/153546/f1e3vL74/4010/#/" target="_blank" rel="noopener">https://wj.toutiao.com/q/153546/f1e3vL74/4010/#/</a></p><p>活动详情：<br><a href="https://bytedancecampus1.feishu.cn/docs/doccnoWp4Sp58222k6NgMomAlpu" target="_blank" rel="noopener">https://bytedancecampus1.feishu.cn/docs/doccnoWp4Sp58222k6NgMomAlpu</a></p><p>悄悄告诉你，优秀的同学还可以免笔试，直接面试哦。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第14日，囤了一波好货</title>
      <link href="/2022/04/14/2022-4-14-life/"/>
      <url>/2022/04/14/2022-4-14-life/</url>
      
        <content type="html"><![CDATA[<p>封城第14天了，今天去小区里小卖部买了一箱啤酒和30个鸡蛋，一共花了110，这下明天开始可以吃菜喝酒了，夜宵也可以荷包蛋自由了。京东上看了一下大概价格在90左右，看来这个小卖部还是挺良心的，现在外面团购最起码得两倍价格。</p><p><img src="1.jpeg" alt></p><p><img src="2.jpeg" alt></p><p>小卖部里东西还挺全的，米面粮油、速冻、调味料、蔬菜水果、冰淇淋饮料啥的基本都有。即使封小区了，老板也天天进货，让我们不需要团购也可以买到东西，不至于饿死。</p><p>此外给猫买的猫粮和猫砂也到了，虽然价格贵了一半以上，但也算是解了燃眉之急，再应付两个月不是问题。封城的大环境下，我和猫不饿死是最重要的两件事。</p><p><img src="3.jpeg" alt></p><p>今天分享一下夜宵解馋小吃：炸薯条，主要步骤如下：</p><ol><li>准备俩白白胖胖的土豆，去皮洗净，切成长条。</li><li>用水洗掉表面淀粉。</li><li>开水下锅，煮至半熟。</li><li>捞出沥干水分，冰箱冷冻或冷藏，锁住水分定型。</li><li>下宽油，油温9成热下油锅，炸至微微金黄，不时翻面。</li><li>捞出等两分钟，重新开火，热油下锅复炸一分钟。</li><li>沥干油后捞出，撒上方便面调料，开吃。</li></ol><p>如果嫌削土豆麻烦的，可以买冷冻薯条，直接炸。如果有空气炸锅的，也可以用，确实很方便。但是我更喜欢油炸的感觉，那是空气炸锅永远都比不了的。复炸也是必需的，不然薯条捞出来会变软。如果喜欢吃KFC那种软软的薯条，可以炸时间短一些。而我喜欢脆脆的，所以我炸的很久，可以吃出薯片的感觉。如果喜欢甜口的，可以加番茄酱。没有方便面调料，也可以用胡椒粉代替。最后的油过滤干净，还可以下次炒菜继续用。</p><p>如果像我一样从原始的土豆开始做，非常费时间。而且两三个大土豆也只能做出一大碗的薯条，几分钟就吃光了，根本停不下来。</p><p>今天没有做什么菜，中午吃的阳春面，晚上虾仁火腿炒饭，简单管饱。明天打算继续拍个黄瓜，莴笋蛋汤/凉拌莴笋/莴笋炒火腿，先把蔬菜清理一波。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第13日，大数据分析团购群的各种行为</title>
      <link href="/2022/04/13/2022-4-13-life/"/>
      <url>/2022/04/13/2022-4-13-life/</url>
      
        <content type="html"><![CDATA[<p>封城第13天了，小区终于发放了第3次物资。这次的物资是三次以来最丰富的一次，还算不错。但是由于天降暴雨，大米都进水了，蔬菜也都泡水了。再加上昨天刚团购到货，所以我基本不怎么需要这些物资。所以最后我只拿了三根火腿肠、土豆、抽纸，其他都分给了比较缺货的室友。</p><p><img src="4.jpeg" alt></p><p>此外我还用两颗大白菜、两根白萝卜、两根胡萝卜，去跟别人换了一包10根火腿肠，因为我不喜欢吃萝卜，而且白菜放久了也要坏，蔬菜太多了。你们觉得这买卖是亏了还是赚了？</p><p>因为这波封城，微信上加了12个团购群。我解密了一下微信的数据库，拿到了聊天记录，分析了一下团购群平时都在聊啥。解密的方法之前写过了，可以去看看历史文章：<br><a href="https://zhuanlan.zhihu.com/p/409662291" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/409662291</a></p><p><img src="1.png" alt></p><p>首先分析了一下这些团购群平时聊的最多的<strong>物资</strong>有哪些，主要是一些食品和生活用品。可以看出蔬菜、水果、鸡蛋、牛奶、面包、大米食品等占据了前几名，而且水果、牛奶、面包还超过了大米，说明了团购群里大米紧缺的人还是不如这几样多，或者很多人没有炊具，更想吃面包、水果等现成的。</p><p><img src="2.png" alt></p><p>然后分析了一波大家平时喜欢发什么词语。可以看出“谢谢”是最多的，看来大多数人还是比较客气的，没有太多戾气。其次就是团购，因为这本来就是团购群嘛。然后就是小区的地址、团购的物资等等。</p><p><img src="3.png" alt></p><p>最后看看大家都喜欢什么时候发消息、组织团购。上图以10分钟为间隔，可以看出凌晨几乎没啥消息，睡的都还挺早的。白天的消息数量稳步上升，在23点左右达到最高峰，这也可能是因为白天很多人要上班吧。</p><p>今天没有做肉菜，想尽快消灭团购的蔬菜，不然容易坏掉。所以炒了两个素菜：手撕包菜和青椒土豆丝。</p><p><img src="5.jpeg" alt></p><p><img src="6.jpeg" alt></p><p>分享一下菜谱吧：<br><strong>手撕包菜：</strong>  </p><ol><li>包菜一定要用手撕，我喜欢把中间的茎去掉，只用嫩嫩的叶子，撕小一点。</li><li>姜、蒜拍烂、切碎，干辣椒剪成小段。</li><li>热油，姜、蒜、干辣椒下锅爆香。</li><li>下入包菜，翻炒到包菜变软，加入生抽、蚝油、盐，可以适当加一点点的水爆炒一下，出锅。</li></ol><p><strong>青椒土豆丝：</strong>  </p><ol><li>青椒和土豆切丝，今天我切的格外细，看个人喜好。土豆丝记得泡在水里，防止变黄。</li><li>（可选）水烧开，土豆丝焯水几十秒断一下生，这样可以减少之后炒土豆丝的时间。当然这一步可以不做。</li><li>热油，青椒丝下锅爆炒，炒到断生。</li><li>土豆丝沥干后倒入锅中，翻炒，加入盐、鸡精、蚝油（可选）、生抽（可选），爆炒出锅。如果之前没有焯水的话，土豆丝得多炒一会儿，当心粘锅，可以适当加水缓解。</li></ol><p>两道菜都微辣，非常下饭。但我以后拒绝再炒带有干辣椒的菜了，太呛鼻了，咳嗽了很久。</p><p>最近上海疫情仍然看不到任何好转的迹象，每日新增维持在两万多，所以大家囤的菜量还是维持至少半个月以上吧，希望早日解封。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第12日，冰箱都快塞不下咯（附菜谱分享）</title>
      <link href="/2022/04/12/2022-4-12-life/"/>
      <url>/2022/04/12/2022-4-12-life/</url>
      
        <content type="html"><![CDATA[<p>封城第12天了，凌晨两点多公司组织团购的物资终于送到了。虽然200的价格有点贵，但半天就送到，我也知足了。</p><p><img src="8.jpeg" alt></p><p>这下我冰箱里的菜就有点多了，之前一股脑堆在了一起，导致不到一周有些蔬菜就烂了，特别是绿叶菜。吸取了之前的教训，这次我现将蔬菜都清洗了一遍，用保存猫粮的抽真空机将它们都封存了起来，然后再塞进冰箱。</p><p><img src="1.jpeg" alt="主粮"></p><p><img src="2.jpeg" alt="速食"></p><p><img src="3.jpeg" alt="蔬菜"></p><p><img src="4.jpeg" alt="肉禽"></p><p><img src="5.jpeg" alt="鸡蛋"></p><p><img src="6.jpeg" alt="饮料"></p><p>这些量应该足够支撑半个月了，主粮甚至可以坚持一个半月。不出意外的话，半个月以内应该不会再团购了，避免外出，减小被感染的风险。</p><p>昨天分享了一道蒜蓉大茄子，今天继续分享一道茄子做的菜：肉沫茄子。遥想当年在学校和室友吃食堂，有两个套餐饭是永远吃不腻的，实在不知道吃啥了就去吃它俩。一个是青椒肉丝盖饭，另一个就是肉沫茄子盖饭。</p><p>步骤如下：</p><ol><li>茄子切成条或者滚刀，加盐腌制10分钟，然后倒出碗里的水。</li><li>茄子加一点点淀粉，下油锅煎至微黄，盛出备用。</li><li>调一碗料汁：生抽、老抽、蚝油、白糖、淀粉、清水。水不要太多，半碗左右，看茄子的量，不然汤汁会太多了。</li><li>蒜和小米辣爆香，下入肉沫，豆瓣酱，炒出红油。</li><li>下入茄子，炒一会儿，倒入料汁，大火收汁到粘稠为止。最后可以撒上葱花点缀。</li></ol><p>注意料汁可以根据自己的喜好调整调料的用量，最好不要太多。汤汁也不要太多，最好收干，不然太太太咸了，浪费米饭。</p><p><img src="7.jpeg" alt></p><p>这波囤菜太多了，明天开始得多做两个菜了，一两周内把容易坏的蔬菜干掉。</p><p>很久没写技术文章了，最近会想一些有趣的主题，搞点有趣的技术分享给大家，比如抢菜脚本、抗原统计脚本之类的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第11日，只需要一个茄子就能让你干两碗饭（附菜谱分享）</title>
      <link href="/2022/04/11/2022-4-11-life/"/>
      <url>/2022/04/11/2022-4-11-life/</url>
      
        <content type="html"><![CDATA[<p>封城第11天了，今天没有做饭，起晚了，恶性循环，随便吃点老干妈拌饭了。</p><p><img src="2.jpeg" alt></p><p>今天团购了公司组织的一份菜，下面这些要203块，也是翻倍了吧，贵的一笔。不过他送的很快，今晚就直接到了，也算是解了燃眉之急吧。</p><p><img src="1.jpeg" alt></p><p>既然今天没做饭，我就分享一道非常下饭的快手菜吧：蒜蓉大茄子，这道菜非常简单，原材料只需要一个茄子，步骤如下：</p><ol><li>茄子切掉两头，直接下锅蒸15分钟，蒸熟为止。然后从中间劈开，摊平在盘子里。</li><li>调料汁：蒜和小米辣切碎，热油下锅炒香，加生抽、蚝油、盐、白糖，喜欢的话可以出锅前加入葱花。</li><li>热油直接浇在茄子上，浇均匀了，超级下饭的茄子就可以开吃了。</li></ol><p>这道菜的灵魂就是料汁，这料汁非常香，拌鞋底都好吃。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第10日，没蔬菜了（附菜谱分享）</title>
      <link href="/2022/04/10/2022-4-10-life/"/>
      <url>/2022/04/10/2022-4-10-life/</url>
      
        <content type="html"><![CDATA[<p>封城第10天了，今天发现我们小区美团买菜和叮咚买菜还是站点关闭，而隔壁小区的站点就是开门的，应该是那个站点出了什么异常。所以目前看来我们小区还是只能团购、盒马团购、京东物流。</p><p>京东的订单依然还没有开始处理，但是小区已经有人收到京东生鲜的快递了，看起来确实开始配送了，都要好起来了！</p><p>字节今天也给上海同学们发了补贴：2天年假+1500现金，此外危急情况的员工也可以一对一处理，这波感觉又得好好给字节卖命了。</p><p><img src="4.png" alt></p><p>药店一直是开着的，但是抢手的酒精等商品都是很难买到的，下午蹲到了一波。买了酒精和善存维生素片，防止蔬菜短缺导致维生素缺乏。这也也不用担心拿外卖和快递被感染了，酒精喷一喷就好多了。</p><p><img src="1.jpeg" alt></p><p><img src="2.jpeg" alt></p><p>今天蔬菜基本吃光了，只剩很多根黄瓜了。今天继续做了拿手菜之一：虾仁滑蛋，这道菜实在是太简单了，基本没有任何难度，所以大家都可以花个10分钟试试。</p><p><img src="3.jpeg" alt></p><p>步骤如下：</p><ol><li>虾仁加料酒、盐腌制10分钟，当然你嫌麻烦的话可以不腌制，直接跳过这一步。</li><li>碗里两勺淀粉、两勺清水、两个鸡蛋、适量盐，搅匀。</li><li>热锅热油，虾仁下锅，变红了就关火，不要炒老了。</li><li>虾仁+热油一起倒入蛋液碗里，搅匀。当然放凉了最好，其实问题不大。</li><li>锅里加热，一整碗全部倒下去。千万记住一定要<strong>最小最小的火</strong>，然后用铲子慢慢推动蛋液的边缘，四周都来回推一推，直到<strong>蛋液没有流动性</strong>。最后铲成大块出锅，喜欢的话撒上葱花。</li></ol><p>这里最关键的步骤就是小火和推动蛋液，这就是为什么这道菜叫“虾仁滑蛋”，而不是“虾仁炒蛋”。顺便告诉你们一招，蛋包饭也是类似的做法哦，只是最后不要铲碎，一整块蛋皮浇在米饭上。</p><p>明天又要上班了，相信上海的疫情应该快到峰值了，之后就会有转机，快递和外卖也要渐渐恢复了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封城第9日，情况好起来了（附菜谱分享）</title>
      <link href="/2022/04/09/2022-4-9-life/"/>
      <url>/2022/04/09/2022-4-9-life/</url>
      
        <content type="html"><![CDATA[<p>封城第9天了，情况貌似有转机了。美团买菜“站点关闭”的公告没了，偷偷上架了一批新菜，看来又可以抢购了。京东物流听说也快可以配送了，只要是京东物流的商品都可以下单了，但估计买的人太多了，配送时效很难保证（说是15号到）。</p><p><img src="1.jpeg" alt="记得选京东物流"></p><p>细数了一下囤货的余量，主食还有30斤大米、2斤面、几十个速冻水饺；蔬菜只剩几根黄瓜，一些快烂掉的青蒜、菠菜和菜苔了；肉还有三块鸡胸肉、3斤的虾仁、8个鸡翅、25个鸡蛋；零食还有300g的薯条、2根火腿；水果只剩2个苹果了。如果只看主食的话，撑过一个半月都没啥问题，菜的话每天蛋炒饭的话也能撑过大半个月吧。但能抢菜的话还是多买点吧，谁不想吃的更好一点呢？</p><p>今天开始准备分享一下每天做的菜肴（如果认真做了的话，否则就分享之前做过的）。</p><p>今天做了两个菜，也就是我做过很多遍的“拍黄瓜”和“可乐鸡翅”，但是今天的可乐鸡翅略有不同，是去骨的，名为“可乐薯骨鸡翅”。</p><p><img src="2.jpeg" alt="拍黄瓜"></p><p><img src="3.jpeg" alt="可乐薯骨鸡翅"></p><p>这两个菜都很简单，这里简单分享一下我的菜谱：</p><p><strong>拍黄瓜：</strong></p><ol><li>我用的水果黄瓜，因为没有蔬菜黄瓜了，蔬菜黄瓜需要把皮刮掉点。</li><li>然后两头切掉，用刀背拍烂，切成段，拍烂比直接切更入味。</li><li>调料汁：小米辣、蒜、生抽、蚝油、盐、白糖、香油。用量方面我个人没有特别讲究，从不按照菜谱上的克数来。生抽最多，其他稍微加一点就行，白糖&gt;盐。最后浇到黄瓜上就行了。</li></ol><p><strong>可乐薯骨鸡翅：</strong></p><ol><li>首先去骨，用刀或者剪刀断开两根骨头两断，旋转拧出，这一步很耗时（直接做可乐鸡翅的话，跳过这一步）。</li><li>土豆去皮、切条，塞进鸡翅里（如果是做油炸鸡翅，最好过一遍开水，防止内部不熟）。我没有土豆，所以我用的速冻薯条，效果不行（直接做可乐鸡翅的话，跳过这一步）。</li><li>加生姜、料酒、生抽、胡椒粉，放冰箱腌制半小时。</li><li>锅里不加油（如果不是不粘锅，最好加点油润一润），直接鸡翅放进去煎至两面金黄。</li><li>加可乐没过鸡翅，加一点料酒、老抽、白糖、蚝油，小火慢炖10分钟，记得翻面。</li><li>最后大火收汁，千万不要收过头，不然会有焦味。可以最后时刻小火慢慢收，记得翻翻面均匀裹上糖色。</li></ol><p>我由于爸妈工作原因（三班倒），所以8岁开始就自己炒饭、搞一些菜吃了。所以我做菜不喜欢严格遵循菜谱，一般看一遍大致流程就行了。而且我不喜欢严格按照他的调料克数来，都凭感觉和经验。当然新手建议严格按照菜谱来。</p><p>之后我还会分享更多我做过的菜，基本都是家常菜、中式菜，等疫情结束还打算向西餐领域进军。</p><p>现在到处封控，大家菜还是省着点吃吧，肉可以放冰箱多囤点，米面油多囤点，我都是按照封闭一个多月的标准来囤的。蔬菜放不久，囤一两周的量就行了。</p><p>最后再分享一下之前做过的一些菜，按顺序依次是：糖醋排骨、可乐鸡翅、肉末茄子、蒜泥茄子、糖醋里脊、脆皮炸鸡翅、拍黄瓜、荷兰豆炒虾仁、虾仁滑蛋、麻婆豆腐、青椒土豆丝、青蒜豆干炒腊肉、虾仁蒸蛋、柠檬手撕鸡、青椒肉丝、宫保鸡丁、枸杞菌菇炖鸡汤、火腿茄子汤、炸薯条、香辣牛肉酱、上汤西兰花、青菜豆腐汤、火腿炒鸡蛋。</p><p><img src="6.jpeg" alt></p><p><img src="7.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录“滋润”的隔离生活</title>
      <link href="/2022/04/07/2022-4-6-life/"/>
      <url>/2022/04/07/2022-4-6-life/</url>
      
        <content type="html"><![CDATA[<p>居家办公快一个月了，文章也很久没更新了，聊聊近况吧。</p><p>三八妇女节那天，公司被查出有密接，要求全员回公司隔离两天。这是头一次在公司过夜，打地铺、吃盒饭，空调开得很暖。可能因为睡得早，睡前又不玩手机了吧，这是我近几个月来睡的最香的两晚。早上也是起的非常早，8点不到就起了。除了睡在公司，没有游戏打，其他对于我这个单身狗来说其实和回家没有啥区别。</p><p><img src="1.jpeg" alt="地铺还是很舒服的"></p><p>两天后解封，走出公司大楼呼吸到新鲜空气的那一刻，就好像坐了很久的牢出狱一样。殊不知，这是近来最后一次见到公司了。当时上海的疫情已经有苗头了，但还没到那么严重的地步。之后的日子除了做核酸和拿外卖，就再也没出过家门一步了。后来上海疫情逐渐严重，小区也开始逐渐封闭了，只进不出。最近我们小区也有阳性了，每天还要冒着交叉感染的风险出去做核酸。说实话，如果不是因为不做健康码会变黄，我还真不愿意做。像我这种囤了很多菜，从来不出门的，几次检测都是阴性，那就再也不可能被感染了。</p><p>最近被讨论最多的问题就是买菜了，全国各地都在援助上海各种菜，但大家就是抢不到。还好我在小区封闭前抢到了一波，坚持一个月没有问题。今日的早起抢菜就如当年的早起QQ农场偷菜一样，一个是为了生存，一个是为了娱乐罢了。</p><p><img src="3.jpeg" alt="应有尽有"></p><p>做了一个月的菜，有点累了，主要是不想洗碗和择菜，想念公司吃现成的日子了。这几个月来做的菜也不少，有二十几种。有几个比较失败，例如宫保鸡丁，但大多数还是非常成功的。下图里的菜按顺序依次是：糖醋排骨、可乐鸡翅、肉末茄子、蒜泥茄子、糖醋里脊、脆皮炸鸡翅、拍黄瓜、荷兰豆炒虾仁、虾仁滑蛋、麻婆豆腐、青椒土豆丝、青蒜豆干炒腊肉、虾仁蒸蛋、柠檬手撕鸡、青椒肉丝、宫保鸡丁、枸杞菌菇炖鸡汤、火腿茄子汤、炸薯条、香辣牛肉酱、上汤西兰花、青菜豆腐汤、火腿炒鸡蛋。</p><p><img src="6.jpeg" alt="吃好喝好"></p><p><img src="7.jpeg" alt="不带重样"></p><p>隔离久了难免会出现心理问题，没有人说话，就连我家的猫好歹都能看看隔壁眉清目秀的狗。最近有不少谣言或者新闻，因为隔离太久跳楼之类的。最近负面的新闻谣言越来越多，疫情正在暴露出很多社会问题。还好我每天能上号打打游戏，跟兄弟们聊聊天，所以目前为止没有任何情绪波动。再加上每天做菜吃的也好，生活还是相当滋润的。</p><p><img src="5.jpeg" alt="一眼万年"></p><p>居家办公还是有影响的，效率变低很多，工作时间完全被打乱了。每天上午不想起来，睡到中午吃完饭才开始干活，深夜了兴致起来继续干活，真正做到了弹性工作。而且租的房子没有舒服的桌子、椅子和显示器，写一会儿代码就会腰酸背痛，更是拉低了效率。</p><p>最近开始面试实习生了，第一次面的时候很紧张，当面试官比当候选人还紧张，现在就轻松很多了。我面候选人不会怎么考八股文，除非你简历上真的什么都没有，实在没东西问，当然这种简历也不可能通过评估。所以我主要看候选人对自己论文和项目的描述是否清晰，细节是否熟悉，然后追问一些细节和拓展的知识点。代码题还是我考察的重点之一，我会根据候选人的能力出一些难度不同的代码题，很多甚至就是我公众号发过题解的原题。我不会要求候选人一定写出能够运行成功的代码，只要思路没问题，基本就ok了。</p><p>春招、暑期实习、日常实习、社招等仍然在进行中，找一个好的内推人非常重要。我经常看到有人网上随便找个内推码就投了简历，然后半个多月都没消息，也联系不到内推人，简历被锁住，浪费了很多时间。通过我内推的话，我可以帮你直接联系hr，简历修改、安排面试、催进度都没问题。</p><p>投我们部门的话进度更快，因为hr比较熟悉嘛，这里我精选了几个我们部门的岗位：</p><ol><li>首先是我自己的岗位，模型优化方向的都可以试试：<br><a href="https://job.toutiao.com/s/Ns1NKVs" target="_blank" rel="noopener">https://job.toutiao.com/s/Ns1NKVs</a></li><li>然后是NLP相关的：<br><a href="https://job.toutiao.com/s/Ns1hftq" target="_blank" rel="noopener">https://job.toutiao.com/s/Ns1hftq</a></li><li>我们组还有产品实习生：<br><a href="https://job.toutiao.com/s/Ns1uutB" target="_blank" rel="noopener">https://job.toutiao.com/s/Ns1uutB</a></li><li>运营实习生也有，适合学语言的同学：<br><a href="https://job.toutiao.com/s/Ns1SGRT" target="_blank" rel="noopener">https://job.toutiao.com/s/Ns1SGRT</a></li><li>所有岗位链接如下：<br><a href="https://jobs.toutiao.com/s/Ns1h1tU" target="_blank" rel="noopener">https://jobs.toutiao.com/s/Ns1h1tU</a></li></ol><p>公司内其他方向的岗位也很充足，CV、推荐系统、搜索、全栈等等，应有尽有。强烈建议用我的<strong>内推码（A7FSJMK）</strong>内推完之后加一下我<strong>微信（godweiyang）</strong>，有事可以直接咨询我。</p><p>这波封城少说还得持续两周，希望早日解封吧，对生活的影响实在太大了，上海加油。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫情 </tag>
            
            <tag> 隔离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来字节快两年了，回答一些你们感兴趣的问题</title>
      <link href="/2022/02/26/bytedance-hire-2022-2/"/>
      <url>/2022/02/26/bytedance-hire-2022-2/</url>
      
        <content type="html"><![CDATA[<p>最近字节跳动春招开始了，春招、暑期实习、社招、日常实习都可以准备起来了，具体的情况可以看我之前发的文章：</p><p><a href="https://mp.weixin.qq.com/s/9PvV7g_zy87puCGTsEje0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/9PvV7g_zy87puCGTsEje0A</a></p><p>这里还是用问答的形式来解答一些大家最感兴趣的问题，如果有其他问题可以直接留言或者加我微信（godweiyang）问我，有问必答！</p><p>想投我们部门的直接看最后两个问题。</p><h2 id="我是什么部门的？"><a href="#我是什么部门的？" class="headerlink" title="我是什么部门的？"></a>我是什么部门的？</h2><p>我是字节跳动AI Lab的火山翻译部门，所做的产品肯定就是火山翻译，当然我在部门里负责LightSeq模型训练推理加速引擎的开发。</p><p>火山翻译现在已经支持近百个语种的翻译，业务前景非常好，大家可以去试试效果：</p><p><a href="translate.volcengine.com">translate.volcengine.com</a></p><h2 id="我是负责啥的？"><a href="#我是负责啥的？" class="headerlink" title="我是负责啥的？"></a>我是负责啥的？</h2><p><a href="github.com/bytedance/lightseq">github.com/bytedance/lightseq</a></p><p>我是做LightSeq的，在我刚进部门时，LightSeq只有两位同事在开发，也只有推理引擎。而现在，连我在内一共有5位同事了，LightSeq也迭代了三个大版本了，囊括了模型训练、推理和量化等工具。</p><p>我们的目标不局限于机器翻译领域，而是要做业界最牛的机器学习工具，以后不管是NLP还是CV，只要用Transformer模型训练推理，都可以用LightSeq来加速和优化。所以我们不仅仅服务公司内的业务，还要打造出业界影响力，以后提到模型加速工具，LightSeq必定是绕不开的话题。</p><p>经过两年多的经营，现在LightSeq也算是小有名气了，在易用性和速度上肯定是业界一流的。</p><p><img src="1.png" alt></p><h2 id="平时用啥编程语言？"><a href="#平时用啥编程语言？" class="headerlink" title="平时用啥编程语言？"></a>平时用啥编程语言？</h2><p>组里的算法同学基本都用python，我的话因为涉及到CUDA，所以用c++和python都比较多。组里的后端还会用到go等语言。而深度学习框架的话，tensorflow和pytorch都有用的，看个人喜好。</p><h2 id="男女比例怎么样？"><a href="#男女比例怎么样？" class="headerlink" title="男女比例怎么样？"></a>男女比例怎么样？</h2><p>组里技术同学大多数还是男生，但是我们组还有运营和产品，绝大多数都是女生，综合下来五五开吧。整个公司而言的话，反正我每天走在大楼里到处是好看的女生，所以你懂的。</p><h2 id="公司伙食怎么样？"><a href="#公司伙食怎么样？" class="headerlink" title="公司伙食怎么样？"></a>公司伙食怎么样？</h2><p>每天包三餐，吃的肯定比学校食堂好太多了，但吃多了也腻了，因此隔三差五伙食就会变的特别好吃一点，也可能是我太挑食了。饮料也是半价购买，零食免费随意拿，但是好吃的得趁早抢。下午茶是水果、面包、酸奶、鸡翅等轮回。</p><h2 id="每天作息是啥样的？"><a href="#每天作息是啥样的？" class="headerlink" title="每天作息是啥样的？"></a>每天作息是啥样的？</h2><p>大多数人都会在10点到10点半之间到公司，有些部门甚至11点才到。11点50吃午饭，午休到14点继续干活，15点多会有下午茶，18点45吃晚饭。如果没啥事的话，吃完饭就能走了。如果比较忙的话，有些部门会加班到9点左右，极个别很忙的部门会到11点以后。至于我的话，你懂的。</p><h2 id="进AI-Lab是不是要求很高？"><a href="#进AI-Lab是不是要求很高？" class="headerlink" title="进AI Lab是不是要求很高？"></a>进AI Lab是不是要求很高？</h2><p>很多人担心自己是本科、学校不好、没有论文等一系列问题，所以进不来AI Lab。其实不然，我们不怎么看学校和学历吧，就算你是清华的又如何，很多死读书的都不大行，更别说清华硕了，论文也只是加分项。所以把你的代码能力提升起来，项目搞起来，深度学习相关的专业知识熟练起来，就没问题了。</p><h2 id="真有网上说的那么忙吗？"><a href="#真有网上说的那么忙吗？" class="headerlink" title="真有网上说的那么忙吗？"></a>真有网上说的那么忙吗？</h2><p>最近网上出现了各种不好的事情，可能是加班过多造成的，谁也说不准。其实刚刚作息也说过了，忙不忙看部门。有些部门是真的忙，没钱还干到深夜，有些部门又很闲，吃完晚饭直接走人。所以投递之前最好找个熟悉那个部门的人问一问真实情况，别踩了坑。</p><h2 id="组里做研究还是做业务多？"><a href="#组里做研究还是做业务多？" class="headerlink" title="组里做研究还是做业务多？"></a>组里做研究还是做业务多？</h2><p>业务为主，国内的AI Lab其实都差不多，我们火山翻译还算比较开放的，可以去做你感兴趣的研究，当然最好是能够落地应用，助力火山翻译上线的。如果有比较好的成果，还可以发论文或者申请专利。当然也有做文本生成、AI制药等方向，也有纯纯的研究岗位，只要你感兴趣，这里基本都能找到你想干的事。</p><h2 id="组里年龄都多大？有35岁危机吗？"><a href="#组里年龄都多大？有35岁危机吗？" class="headerlink" title="组里年龄都多大？有35岁危机吗？"></a>组里年龄都多大？有35岁危机吗？</h2><p>大多数人都不到30吧，都很年轻，更不存在什么35岁危机，因为几乎没有35岁的。只要你能力够强，就不存在35岁危机。</p><h2 id="组里有多少人？"><a href="#组里有多少人？" class="headerlink" title="组里有多少人？"></a>组里有多少人？</h2><p>几十号人吧，组里技术、运营、产品都有，从两年前十几人壮大到现在，不容易。</p><h2 id="组里转正率怎么样？"><a href="#组里转正率怎么样？" class="headerlink" title="组里转正率怎么样？"></a>组里转正率怎么样？</h2><p>很高，只要你好好干，问题不大。而其他部门就各不相同了，需要跟hr问清楚了。</p><h2 id="组里氛围怎么样？"><a href="#组里氛围怎么样？" class="headerlink" title="组里氛围怎么样？"></a>组里氛围怎么样？</h2><p>非常nice，其乐融融。有啥不会，随便问人，都是大神。喜欢打游戏？王者大神多的是，午休随便搞两把。聊八卦、拉家常，反正就把公司当家里就完事了。</p><h2 id="组里的技术怎么样？"><a href="#组里的技术怎么样？" class="headerlink" title="组里的技术怎么样？"></a>组里的技术怎么样？</h2><p>前沿论文和技术都天天更进的，每周都有很多很多的分享和报告。组里的大神南大、复旦和交大的居多（因为在上海嘛），反正来了这别愁碰到解决不了的问题。</p><h2 id="有团建吗？"><a href="#有团建吗？" class="headerlink" title="有团建吗？"></a>有团建吗？</h2><p>两个月左右一次吧，迪士尼、天目湖、轰趴等等等等，每双月有生日会，免费给大家买蛋糕吃，活动多的很。再加上公司还会经常节假日搞活动，各种送东西福利。</p><h2 id="会感到有压力吗？"><a href="#会感到有压力吗？" class="headerlink" title="会感到有压力吗？"></a>会感到有压力吗？</h2><p>压力肯定是有的，像我开发LightSeq，如果做得又好用速度又快，很多方案和技术都是需要自己去研究首创的，限定两个月搞出来？谁也说不准搞出来速度能有多快，然后又要不停优化，很多事情存在不确定性。但是有一定压力是好的，转化为动力，好好干活！</p><h2 id="组里的显卡多吗？"><a href="#组里的显卡多吗？" class="headerlink" title="组里的显卡多吗？"></a>组里的显卡多吗？</h2><p>V100和A100管饱，足够。</p><h2 id="入职即巅峰？"><a href="#入职即巅峰？" class="headerlink" title="入职即巅峰？"></a>入职即巅峰？</h2><p>字节比较扁平化嘛，很正常，但只要你工作做得好，绩效好，升职加薪还是没问题的。</p><h2 id="公司配什么电脑？"><a href="#公司配什么电脑？" class="headerlink" title="公司配什么电脑？"></a>公司配什么电脑？</h2><p>技术的话mac pro顶配，三四年后就免费送你了。非技术的你也可以选择windows电脑。</p><h2 id="允许同组谈恋爱吗？"><a href="#允许同组谈恋爱吗？" class="headerlink" title="允许同组谈恋爱吗？"></a>允许同组谈恋爱吗？</h2><p>没问题，报备一下就行了，话说我怎么还没找到对象？</p><h2 id="组里离职率高吗？"><a href="#组里离职率高吗？" class="headerlink" title="组里离职率高吗？"></a>组里离职率高吗？</h2><p>其他部门我不知道，我们部门从创立以来，几乎没有离职的，非常稳定。</p><h2 id="有跳槽打算吗？"><a href="#有跳槽打算吗？" class="headerlink" title="有跳槽打算吗？"></a>有跳槽打算吗？</h2><p>什么？我才刚毕业不到一年，按目前来说的话，怎么也得干个三四年吧，挺舒服的，没必要跳。</p><h2 id="吹了半天好，有啥缺点吗？"><a href="#吹了半天好，有啥缺点吗？" class="headerlink" title="吹了半天好，有啥缺点吗？"></a>吹了半天好，有啥缺点吗？</h2><p>缺点肯定也是有的，技术上还有提升空间，赶超谷歌翻译一直是我们的目标。各种平台、流程等等，还需要时间去优化。</p><h2 id="怎么一起来做LightSeq？"><a href="#怎么一起来做LightSeq？" class="headerlink" title="怎么一起来做LightSeq？"></a>怎么一起来做LightSeq？</h2><p>直接点阅读原文，或者看下图：</p><p><img src="1.jpg" alt></p><p>如果身边有合适的，也可以把岗位转发给他们。</p><h2 id="怎么来火山翻译部门？"><a href="#怎么来火山翻译部门？" class="headerlink" title="怎么来火山翻译部门？"></a>怎么来火山翻译部门？</h2><p>如果不想做LightSeq，想做其他NLP相关工作，可以直接投下面岗位：</p><p><a href="https://job.toutiao.com/s/Lo41WQ4" target="_blank" rel="noopener">https://job.toutiao.com/s/Lo41WQ4</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节春招开始了，整理了大家最关心的20个问题</title>
      <link href="/2022/02/17/bytedance-hire-2022-1/"/>
      <url>/2022/02/17/bytedance-hire-2022-1/</url>
      
        <content type="html"><![CDATA[<p>2023届的春招开始了，我给大家整理了一些最关心的问题。如果有任何其他疑问，请在评论区留言或者私信我。</p><h2 id="怎么投递？"><a href="#怎么投递？" class="headerlink" title="怎么投递？"></a>怎么投递？</h2><p>我的内推码：A7FSJMK</p><p><strong>校招和暑期实习投递：</strong><br>投递链接：<a href="https://jobs.toutiao.com/s/Lv6wSF7" target="_blank" rel="noopener">https://jobs.toutiao.com/s/Lv6wSF7</a><br>二维码：<br><img src="1.png" alt></p><p><strong>社招和日常实习投递：</strong><br>投递链接：<a href="https://job.toutiao.com/s/LvMyG6V" target="_blank" rel="noopener">https://job.toutiao.com/s/LvMyG6V</a><br>二维码：<br><img src="2.png" alt></p><h2 id="招聘对象有哪些？"><a href="#招聘对象有哪些？" class="headerlink" title="招聘对象有哪些？"></a>招聘对象有哪些？</h2><ul><li><strong>暑期实习</strong>：2022.9 ～ 2023.8 毕业。</li><li><strong>全职补录</strong>：2021.9 ～ 2022.8 毕业。</li></ul><h2 id="有哪些岗位？"><a href="#有哪些岗位？" class="headerlink" title="有哪些岗位？"></a>有哪些岗位？</h2><ul><li>研发、运营、产品、销售、职能/支持、设计、市场、游戏策划共八大类职位。</li></ul><h2 id="有几次投递机会？"><a href="#有几次投递机会？" class="headerlink" title="有几次投递机会？"></a>有几次投递机会？</h2><p><strong>2次</strong>投递机会，一定要投递自己最有把握的，不要广撒网！！！</p><h2 id="实习可以转正吗？"><a href="#实习可以转正吗？" class="headerlink" title="实习可以转正吗？"></a>实习可以转正吗？</h2><ul><li>暑期实习转正率<strong>81%</strong>，顺便偷偷告诉你，我们组基本都是转正留下的。</li></ul><h2 id="这次春招持续多久？"><a href="#这次春招持续多久？" class="headerlink" title="这次春招持续多久？"></a>这次春招持续多久？</h2><p>投递时间：2022.2.17 ～ 2022.4.30 。</p><h2 id="不知道投递啥职位怎么办？"><a href="#不知道投递啥职位怎么办？" class="headerlink" title="不知道投递啥职位怎么办？"></a>不知道投递啥职位怎么办？</h2><p>对职位有任何疑问，可以加我微信（微信号：godweiyang）询问，或者咨询HR。</p><h2 id="要是错过了春招怎么办？"><a href="#要是错过了春招怎么办？" class="headerlink" title="要是错过了春招怎么办？"></a>要是错过了春招怎么办？</h2><p>还可以投<strong>日常实习</strong>或者<strong>社招</strong>的，持续时间是 2022.2.10 ～ 2022.7.31 。</p><h2 id="实习通过后，入职时间能不能推迟？"><a href="#实习通过后，入职时间能不能推迟？" class="headerlink" title="实习通过后，入职时间能不能推迟？"></a>实习通过后，入职时间能不能推迟？</h2><p>入职时间都是可以商量的，想晚点来都没问题的。</p><h2 id="投递两个职位的话，系统会怎么处理？"><a href="#投递两个职位的话，系统会怎么处理？" class="headerlink" title="投递两个职位的话，系统会怎么处理？"></a>投递两个职位的话，系统会怎么处理？</h2><p>优先处理第一个投递的职位，另一个会被锁住。等第一个职位失败了，第二个职位就会解锁继续下去。当然祝大家第一个职位就直接通过啦！</p><h2 id="可以同时投实习和校招吗？"><a href="#可以同时投实习和校招吗？" class="headerlink" title="可以同时投实习和校招吗？"></a>可以同时投实习和校招吗？</h2><p>可以，系统会优先处理实习，等实习流程结束了再处理校招。</p><h2 id="投递完之后可以修改简历吗？"><a href="#投递完之后可以修改简历吗？" class="headerlink" title="投递完之后可以修改简历吗？"></a>投递完之后可以修改简历吗？</h2><p>不可以，大家一定要好好美化简历，慎重投递！</p><h2 id="怎么查看投递的进展？"><a href="#怎么查看投递的进展？" class="headerlink" title="怎么查看投递的进展？"></a>怎么查看投递的进展？</h2><p>可以在官网直接查看<strong>应聘记录</strong>，也可以加我微信（微信号：godweiyang）向我咨询，我会帮你后台查看进度。</p><h2 id="投递完很久没有消息怎么办？"><a href="#投递完很久没有消息怎么办？" class="headerlink" title="投递完很久没有消息怎么办？"></a>投递完很久没有消息怎么办？</h2><p>如果投递完超过一周还没任何消息，请加我微信（微信号：godweiyang）告诉我，我会帮你联系HR咨询原因，催进度。</p><h2 id="之前的投递对这次春招有影响吗？"><a href="#之前的投递对这次春招有影响吗？" class="headerlink" title="之前的投递对这次春招有影响吗？"></a>之前的投递对这次春招有影响吗？</h2><p>没有影响，只要你这次面的好，之前的失败不会有任何影响。</p><h2 id="有笔试吗？"><a href="#有笔试吗？" class="headerlink" title="有笔试吗？"></a>有笔试吗？</h2><p>研发类职位（后端、算法、客户端、前端、测试/测开、大数据、研发工程师-质量保障）一定会有，其他的等通知。</p><h2 id="笔试时间具体什么时候？"><a href="#笔试时间具体什么时候？" class="headerlink" title="笔试时间具体什么时候？"></a>笔试时间具体什么时候？</h2><p>2.27、3.13、3.27、4.17 的 19:00 ～ 21:00 。<br>3.6、3.20、4.10、5.6 的 10:00 ～ 12:00 。 </p><h2 id="错过了笔试还有机会吗？"><a href="#错过了笔试还有机会吗？" class="headerlink" title="错过了笔试还有机会吗？"></a>错过了笔试还有机会吗？</h2><p>错过一次笔试还可以参加下一次的，但同一个职位，错过两次笔试直接挂掉！</p><h2 id="笔试迟到了怎么办？"><a href="#笔试迟到了怎么办？" class="headerlink" title="笔试迟到了怎么办？"></a>笔试迟到了怎么办？</h2><p>迟到可以继续作答，但是时间不会给你推迟。</p><h2 id="有任何其他问题？"><a href="#有任何其他问题？" class="headerlink" title="有任何其他问题？"></a>有任何其他问题？</h2><p>请加我微信（微信号：godweiyang）咨询我，也可以在评论区留言。微信跟我说<strong>进内推群</strong>，我会经常在群里更新消息。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当年如果有这个，语文就不会不及格了</title>
      <link href="/2022/01/16/anchi-translation/"/>
      <url>/2022/01/16/anchi-translation/</url>
      
        <content type="html"><![CDATA[<p>最近在github上看到了一个项目，是小牛翻译开源的文言文-现代文平行语料，一共有967257个句对，地址在下面：<br><a href="https://github.com/NiuTrans/Classical-Modern" target="_blank" rel="noopener">https://github.com/NiuTrans/Classical-Modern</a></p><p>于是我突发奇想，何不用它来训练一个<strong>文言文-现代文互相翻译</strong>的模型呢？</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>来看看最终的翻译效果，先看一句舔狗经典语录：</p><blockquote><p><strong>现代文：</strong><br>昨天在工地扛沙袋，我一下子扛了三袋，工友们问我为什么这么能扛？我眼泪瞬间就下来了，是啊，为什么我这么能扛，就是扛不住想你。<br><strong>翻译成文言文：</strong><br>昨于工地荷沙囊，余忽肩三囊，工友问何以如此？吾泣须臾而下，为也，何吾之能负，负之不胜念。</p></blockquote><p>再来看一下朱自清《背影》中经典的一段话：</p><blockquote><p><strong>现代文：</strong><br>他往车外看了看，说：“我买几个橘子去。你就在此地，不要走动。”我看那边月台的栅栏外有几个卖东西的等着顾客。走到那边月台，须穿过铁道，须跳下去又爬上去。父亲是一个胖子，走过去自然要费事些。我本来要去的，他不肯，只好让他去。我看见他戴着黑布小帽，穿着黑布大马褂，深青布棉袍，蹒跚地走到铁道边，慢慢探身下去，尚不大难。可是他穿过铁道，要爬上那边月台，就不容易了。他用两手攀着上面，两脚再向上缩；他肥胖的身子向左微倾，显出努力的样子。这时我看见他的背影，我的泪很快地流下来了。<br><strong>翻译成文言文：</strong><br>车外顾曰：买橘数枚去，君在此，勿动也。余视其月台栅外有卖物数人待客。至其边月台，须穿铁道，须跳下复上。父为肥子，行自费。吾本将之，不肯，故许之。见著乌布小帽，乌布大马皂，深青布袍，乃至铁道侧，徐探其身，尚不难。然穿铁道，欲上其月台，未易也。以两手攀之，两足复上缩，肥身左微倾，有足力状。见其背影，余泪遽下。</p></blockquote><p>可以看出效果还是非常不错的，而文言文翻译成现代文的效果也非常不错。</p><p>也来看个例子，节选自陶渊明的《桃花源记》：</p><blockquote><p><strong>文言文：</strong><br>晋太元中，武陵人捕鱼为业。缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷。渔人甚异之，复前行，欲穷其林。<br>林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田、美池、桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人。黄发垂髫，并怡然自乐。<br><strong>翻译成现代文：</strong><br>晋太元年间，武陵人捕鱼为生。沿着溪水行走，忘记了路途的远近。忽然遇到桃花林，两岸数百步，其中没有杂树，芳草鲜美，落花缤纷。打鱼人觉得很奇怪，又往前走，想探寻那树林。<br>树林尽头水源，就见到一座山，山有小口，仿佛有光。就舍弃船，从洞口进去，起初非常狭窄，才通人，又走了几十步，豁然开朗。土地平旷，房屋庄严，有良田、美池、桑竹之类。田间小路相通，鸡犬相闻，其中往来种作，男女衣着，都和外面的人一样，黄发小孩，都怡然自得。</p></blockquote><p>这下广大中学生语文再也不用愁了。可惜我当年咋就没这好东西呢，不然语文也不会考那么差。</p><h2 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h2><p>训练方法非常简单，正好之前写过一个聊天机器人的训练教程，这次可以拿来直接用：<br><a href="https://godweiyang.com/2021/07/24/chatbot">https://godweiyang.com/2021/07/24/chatbot</a></p><p>训练代码在下面：<br><a href="https://github.com/godweiyang/chatbot" target="_blank" rel="noopener">https://github.com/godweiyang/chatbot</a></p><p>和训练聊天机器人唯一的不同就是训练数据，这里需要处理一下文言文-现代文语料，将其拆分成训练集和验证集，这里我写了个简单的脚本拆分整合了一下。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> ostrgs <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"Classical-Modern/target"</span><span class="token punctuation">)</span>f3 <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"data/train/train.src"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>f4 <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"data/train/train.trg"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>f5 <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"data/dev/dev.src"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>f6 <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"data/dev/dev.trg"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>cnt1 <span class="token operator">=</span> <span class="token number">0</span>cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> trg <span class="token keyword">in</span> trgs<span class="token punctuation">:</span>    src <span class="token operator">=</span> trg<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>    f1 <span class="token operator">=</span> open<span class="token punctuation">(</span>f<span class="token string">"Classical-Modern/source/{src}"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>    f2 <span class="token operator">=</span> open<span class="token punctuation">(</span>f<span class="token string">"Classical-Modern/target/{trg}"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f1<span class="token punctuation">:</span>        <span class="token keyword">if</span> cnt1 <span class="token operator">&lt;</span> <span class="token number">3000</span><span class="token punctuation">:</span>            f5<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            f3<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>        cnt1 <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f2<span class="token punctuation">:</span>        <span class="token keyword">if</span> cnt2 <span class="token operator">&lt;</span> <span class="token number">3000</span><span class="token punctuation">:</span>            f6<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            f4<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>        cnt2 <span class="token operator">+=</span> <span class="token number">1</span>    f1<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    f2<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cnt1<span class="token punctuation">)</span>f3<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f4<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f5<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f6<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以直接用和训练聊天机器人相同的方法训练了，这里不再赘述，我在8张A100显卡上训练了短短一两个小时效果就已经很不错了。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> 模型训练 </tag>
            
            <tag> 模型加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这道小学六年级的数学题，恕我直言没几个人会做</title>
      <link href="/2021/12/18/cuda-monte-carlo/"/>
      <url>/2021/12/18/cuda-monte-carlo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><img src="1.png" alt></p><p>今天网上冲浪的时候突然看到一道小学六年级的数学题，如上图所示，求阴影部分的面积。</p><p>我下意识就想到了微积分，这不就建立坐标系，求出交点，计算积分就行了嘛。转念一想，小学生哪里会积分，这道题一定有简单的解法。</p><p>经过一番努力，我尝试出了一共两种精确解法和一种近似解法，但都超出了小学生的理解范畴。</p><p>首先我们把图左右翻转一下，方便建立坐标系，如下图所示：<br><img src="2.png" alt></p><h2 id="积分方法"><a href="#积分方法" class="headerlink" title="积分方法"></a>积分方法</h2><p>首先联立半圆和对角线的方程：<br>$$<br>\begin{aligned}<br>x^2+(y-4)^2-16&amp;=0 \\<br>x+2y-4&amp;=0<br>\end{aligned}<br>$$</p><p>解出交点E的坐标是$(\frac{12}{5}, \frac{4}{5})$</p><p>所以可以直接求下面积分，得到要求的阴影面积：<br>$$<br>\int_{0}^{\frac{12}{5}}{\left(\sqrt{16-x^2}+4\right)}dx + \int_{\frac{12}{5}}^{4}{\left(2-\frac{1}{2}x\right)}dx<br>$$</p><p>利用简单的高等数学知识，可以解出答案是下面这样的，约等于1.252。<br>$$<br>\frac{32}{5} - 8 \arcsin{\frac{3}{5}}<br>$$</p><p>但是小学生肯定不会积分呀，就算高中生大多数都不会！</p><h2 id="间接计算"><a href="#间接计算" class="headerlink" title="间接计算"></a>间接计算</h2><p>既然我们不方便算这个不规则图形的面积，我们可以计算其他规则图形的面积，然后加减之后间接得到答案。</p><p>图中阴影部分面积其实等价于三角形ACE+梯形BOCE-扇形BOE，而这三部分其实都非常好算。</p><p>因为E的坐标是$(\frac{12}{5}, \frac{4}{5})$，所以最难算的就是扇形BOE的面积，也就是要求角OBE的大小。很轻松就可以得到角度是$\arcsin{\frac{3}{5}}$，所以三部分运算后可以得到和上面积分相同的答案。</p><p>这个方法初中生都会做了！但是对于小学生来说难度还是有点大了。</p><h2 id="蒙特卡洛采样方法"><a href="#蒙特卡洛采样方法" class="headerlink" title="蒙特卡洛采样方法"></a>蒙特卡洛采样方法</h2><p>如果往第一象限正方形内随机抛撒若干豆子，然后看掉落在阴影部分里的豆子所占的比例，那么就可以近似估计出阴影部分的面积了，这就叫蒙特卡洛采样。</p><p>那我们可以随机生成两个随机数，作为采样点的坐标，然后判断是否在阴影部分里，重复上述过程，记录次数就行了。</p><p>我这里写了C++和CUDA两个实现，CUDA可以并行采样，速度快很多。</p><p>执行的话，C++保存为<code>test.cpp</code>，然后执行<code>g++ test.cpp -o test</code>和<code>./test</code>。CUDA保存为<code>test.cu</code>，然后执行<code>nvcc test.cu -o test</code>和<code>./test</code>。</p><p>实测CUDA相同时间内可以采样的次数大约是100倍左右，主要受到原子写操作的局限，不然可以达到1000倍左右的加速。</p><p>但是小学生会CUDA吗？显然不可能。</p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ull<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  ull res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  ull cnt <span class="token operator">=</span> <span class="token number">1e8</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>ull i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> RAND_MAX<span class="token punctuation">;</span>    <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> RAND_MAX<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> y <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      res <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f\n"</span><span class="token punctuation">,</span> res <span class="token operator">*</span> <span class="token number">16.0</span> <span class="token operator">/</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CUDA实现"><a href="#CUDA实现" class="headerlink" title="CUDA实现"></a>CUDA实现</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;curand_kernel.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ull<span class="token punctuation">;</span>__global__ <span class="token keyword">void</span> <span class="token function">monte_carlo_kernel</span><span class="token punctuation">(</span>ull<span class="token operator">*</span> res<span class="token punctuation">,</span> ull cnt<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ull i <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> cnt<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  curandStatePhilox4_32_10_t state<span class="token punctuation">;</span>  <span class="token function">curand_init</span><span class="token punctuation">(</span>seed<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>  double2 rand <span class="token operator">=</span> <span class="token function">curand_uniform2_double</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> x <span class="token operator">=</span> rand<span class="token punctuation">.</span>x<span class="token punctuation">;</span>  <span class="token keyword">double</span> y <span class="token operator">=</span> rand<span class="token punctuation">.</span>y<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> y <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">atomicAdd</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">launch_monte_carlo</span><span class="token punctuation">(</span>ull<span class="token operator">*</span> res<span class="token punctuation">,</span> ull cnt<span class="token punctuation">,</span> cudaStream_t<span class="token operator">&amp;</span> stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ull grid_dim <span class="token operator">=</span> cnt <span class="token operator">>></span> <span class="token number">10</span><span class="token punctuation">;</span>  monte_carlo_kernel<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>grid_dim <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> stream<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>      res<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span>      std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>microseconds<span class="token operator">></span><span class="token punctuation">(</span>          std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ull<span class="token operator">*</span> res<span class="token punctuation">;</span>  <span class="token function">cudaMallocManaged</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>res<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ull<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  ull cnt <span class="token operator">=</span> <span class="token number">1e10</span><span class="token punctuation">;</span>  cudaStream_t stream<span class="token punctuation">;</span>  <span class="token function">cudaStreamCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">launch_monte_carlo</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">cudaDeviceSynchronize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">16.0</span> <span class="token operator">/</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">cudaFree</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h2><p>其实标准的小学生解法不需要建坐标系，只需要如下图所示，做4条辅助线就行。</p><p><img src="3.png" alt></p><p>很容易证明，辅助线将三角形ACD划分出来的5个小三角形是全等的。</p><p>那么阴影面积就等于正方形AOBD减去四分之一圆BOD，再减去最右侧的弧边三角形ADE。而弧边三角形ADE面积等于三角形ACD减去三角形BCE，再减去扇形BDE。</p><p>所以问题的关键就是求角DBE的大小，因为小三角形的边长可以轻易求出，所以最终答案很好算：<br>$$<br>\frac{32}{5}-4\pi+16 \arctan{\frac{1}{2}}<br>$$</p><p>可以发现和之前高等数学得到的结果形式并不同，其实数值是一样的，所以我们得到了一个等式：<br>$$<br>4\arctan{\frac{1}{2}}+2\arcsin{\frac{3}{5}}=\pi<br>$$</p><p>这个可能看起来不是那么直观，但确实是成立的，根据反三角函数恒等式$2\arctan x = \arctan \frac{2x}{1-x^2}$，可以推出等号左边等于$2(\arctan \frac{4}{3} + \arcsin \frac{3}{5})$。构造一个边长3、4、5的直角三角形，显然答案就是$\pi$。</p><h2 id="总结与拓展"><a href="#总结与拓展" class="headerlink" title="总结与拓展"></a>总结与拓展</h2><p>其实这道题小学生也没几个人能做出来，就算给我们做也得费老鼻子劲，还不一定算的对。</p><p>最近还看到了很多类似的趣图，这里分享给大家，闲暇时间可以做了玩玩。</p><p>可以在评论区说出你的答案哦。</p><p><img src="4.jpg" alt></p><p><img src="5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零二一年终总结</title>
      <link href="/2021/12/13/2021-conclusion/"/>
      <url>/2021/12/13/2021-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天是12.13，一晃二十六周岁了。从2017年开始，每年都会简单总结一下一年中经历的事情，不知不觉已经五年了。</p><p><a href="https://godweiyang.com/2018/01/22/2017-conclusion/">二零一七年终总结</a><br><a href="https://godweiyang.com/2018/12/31/2018-conclusion/">二零一八年终总结</a><br><a href="https://godweiyang.com/2019/12/13/2019-conclusion/">二零一九年终总结</a><br><a href="https://godweiyang.com/2020/12/13/2020-conclusion/">二零二零年终总结</a></p><p>回顾过去五年，从大三到今年毕业正式工作，好像干了很多事情，又好像什么都没干。也就混到硕士毕业，侥幸发了篇ACL，然后又侥幸进入字节从事新的研究方向。这五年来唯一不变的可能就是一直在打英雄联盟吧，还是当年的开黑队友，还是熟悉的味道。</p><p>2021年是正式成为社会人的一年，从校园老油条蜕变为了职场萌新。总结下来就是，上半年在忙着毕业，下半年在忙着开发LightSeq。</p><p>今年过年在上海度过了人生第一个不在家的春节，一是因为疫情回去要做核酸，二是因为毕业论文没多久要交了。连编带凑，花了将近一个月赶出了一篇像模像样的毕业论文。后面的毕业流程走的出乎意料的快，导师也没怎么修改，短短数周就答辩结束，仿佛学校盼着我们早日离校步入社会。拿完优秀毕业生、优秀毕业论文和国家奖学金，实验室最后聚了聚餐，接着就正式毕业了。</p><p><a href="https://godweiyang.com/2021/05/21/master-graduate/">七年师大，青春永不毕业</a></p><p><img src="1.jpg" alt="春节生怕饿死，囤的食物"></p><p><img src="2.jpg" alt="上海市优秀毕业生"></p><p>学校里的事就这么多了，主要精力还是在公司里。上半年进一步完善LightSeq推理引擎，写了很多文章对LightSeq进行了大量的介绍和宣传，也给很多想入门CUDA和模型加速的同学科普了基本的知识。</p><p><a href="https://godweiyang.com/2021/03/28/nn-cuda-example/">熬了几个通宵，我写了份CUDA新手入门代码</a></p><p><a href="https://godweiyang.com/2021/04/13/lightseq-python-usage/">只用两行代码，我让Transformer推理加速了10倍</a></p><p><img src="3.jpg" alt="LightSeq star数嗖嗖上涨"></p><p>还在NAACL 2021上发表了一篇关于LightSeq推理引擎相关技术的论文，进行了技术沉淀，推理引擎的开发也算是告一段落了。</p><p><a href="https://arxiv.org/abs/2010.13887" target="_blank" rel="noopener">论文地址：LightSeq: A High Performance Inference Library for Transformers</a></p><p>今年最重要的工作内容要数LightSeq训练引擎了，从4月份开始，到6月份结束，历时三个月和同事们一起开发出了业界首个Transformer全流程训练加速引擎。训练引擎从0到1的整个过程我都有参与，这期间为了快速融入到项目的开发中，不得不自学了CUDA和模型加速的相关知识，这些之前在学校都是没有接触过的。项目开源后也投递了论文，虽然没有中，但也积累了不少经验，懂了一些系统领域会议论文的写法。leader还安排我去QCon大会进行了分享，宣传了一波LightSeq技术。</p><p><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">LightSeq源码</a></p><p><a href="https://godweiyang.com/2021/06/21/lightseq2-introduction/">训练加速3倍！字节跳动推出业界首个NLP模型全流程加速引擎</a></p><p><a href="https://arxiv.org/abs/2110.05722" target="_blank" rel="noopener">论文地址：LightSeq2: Accelerated Training for Transformer-based Models on GPUs</a></p><p><img src="12.jpg" alt="QCon分享"></p><p>目前的话在开发LightSeq量化推理，在不久的将来就会和大家正式见面，模型推理速度也将迈上一个新的台阶。</p><p>生活方面，下半年重新开始做饭了，外卖一方面不卫生，一方面也吃腻了，不一定有自己做的好吃。不过租的房子厨房实在太小了，做一次饭都要收拾很久，经常也会不想做。限于篇幅，这里就只放几张图吧，更多的可以去我朋友圈围观。</p><p><img src="7.jpg" alt="炸薯条"><br><img src="8.jpg" alt="可乐鸡翅、玉米排骨汤"><br><img src="10.jpg" alt="糖醋排骨"></p><p>虽然房子小，10月底家里还是新增了一员，我从师兄家抱回了一只布偶猫。养猫给我的生活新增了不少乐趣，没事的时候可以撸一撸。但也带来了很多麻烦，猫经常乱拉，晚上睡觉吵人，每天要铲屎喂粮，就和带一个孩子一样。可能是我给他吃的太好了吧，才6个月左右就已经长到10斤了。</p><p><img src="11.jpg" alt="安静的美男子"></p><p>情感方面依旧维持原样，虽然有过小插曲，但都不合适。</p><p>今年给我最大的感觉就是，工作了之后时间变快了，生活变单调了。尤其是取消大小周之后，每周都过得好快，每次还没恍过神就又到下一个周末了。这可能也和我比较宅有关，每周末除了打游戏，就还是打游戏。睡眠时间也依旧很晚，不断摧残自己的身体。</p><p>对于2022年，最大的心愿还是把工作做好，先把模型量化做完善了，争取早日晋升，希望LightSeq的star早日能上3000。然后继续做好菜、养好猫，快乐游戏每一天。文章最近更新的也没有以前频繁了，得勤快一点了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【白话模型量化系列一】矩阵乘法量化</title>
      <link href="/2021/11/25/int8-gemm/"/>
      <url>/2021/11/25/int8-gemm/</url>
      
        <content type="html"><![CDATA[<p>模型量化是模型加速方向一个很重要的方法，主要思想就是用int8数据格式来存储和进行计算。这样做有两点好处：</p><ol><li>可以减小模型存储的体积。原本float32存储需要4个字节，现在int8存储只需要1个字节，体积是原来的1/4。</li><li>可以加快计算速度。这主要是因为int8数据的读写更快，并且int8矩阵乘法一般来说会更快一点。</li></ol><p>以现在最常用的Transformer模型来举例，在使用CUDA推理加速库（例如LightSeq）之后，矩阵乘法的占比高达将近90%。所以优化非矩阵乘法的速度意义不是很大了，占比不高，你算得再快对整体的提速也很小，因此可以尝试优化矩阵乘法。</p><p>那么我们考虑浮点数矩阵乘法$C = AB$，如何将它转化为整数矩阵乘法，并且得到几乎相同的乘法结果呢？</p><h2 id="用整数矩阵来表示浮点数矩阵"><a href="#用整数矩阵来表示浮点数矩阵" class="headerlink" title="用整数矩阵来表示浮点数矩阵"></a>用整数矩阵来表示浮点数矩阵</h2><p>首先我们需要将一个浮点数矩阵$A$用整数矩阵$A_I$来表示。我们假设$A$的数值范围在$[-c_1, c_1]$之间，其实这个假设是合理的，例如一般深度学习模型参数初始化都是正态分布，那么数值范围就在$[-1, 1]$之间。然后整数矩阵$A_I$的数值范围其实就是有符号整数的表示范围$[-128， 127]$，为了实现的简单，我们只量化到$[-127, 127]$，这样就和$A$一样关于零点左右对称了。我们令$s = 127$，用来表示int8的数值范围，如果$s = 15$，那就是int4的范围了。</p><p>接着整数矩阵$A_I$就可以表示为$A_I = int(\frac{s}{c_1}A)$，也就是将浮点数区间$[-c_1, c_1]$里的数字等比例映射到整数区间$[-s, s]$，然后向最近的整数取整。同理，整数矩阵$B_I$可以表示为$B_I = int(\frac{s}{c_2}B)$。</p><p>这样我们就可以得到两个浮点数矩阵的整数表示，接下来就可以利用他们来进行整数矩阵乘法的转换。</p><h2 id="转化为整数矩阵乘法"><a href="#转化为整数矩阵乘法" class="headerlink" title="转化为整数矩阵乘法"></a>转化为整数矩阵乘法</h2><p>整数矩阵$A_I$还原为浮点数很简单，只需要$A = \frac{c_1}{s}A_I$即可。但是注意$A_I$是取过整的，所以还原回去的$A$并不完全等于原始的$A$，是有误差的。举个通俗的例子，两个浮点数0.1和0.101经过量化都变成了整数13，但是还原回浮点数后全都变成了0.102，再也没法区分两个浮点数有什么不同了。</p><p>所以回到原始的问题，浮点数矩阵乘法$C = AB$可以改写为$C = \frac{c_1}{s}A_I \frac{c_2}{s}B_I$，也就是$C = \frac{c_1c_2}{s^2}A_I B_I$。</p><p>那么就可以先计算整数矩阵乘法$A_I B_I$，然后得到整数的输出矩阵之后，乘上系数$\frac{c_1c_2}{s^2}$，还原为浮点数矩阵。</p><p>注意输入矩阵$A_I$和$B_I$都是int8的，但是乘法结果$A_I B_I$一定是int32的。</p><h3 id="总结一下流程"><a href="#总结一下流程" class="headerlink" title="总结一下流程"></a>总结一下流程</h3><ol><li>输入两个浮点数矩阵$A$和$B$，先分别转化为各自的整数矩阵$A_I = int(\frac{s}{c_1}A)$和$B_I = int(\frac{s}{c_2}B)$。</li><li>然后计算整数矩阵乘法结果$A_I B_I$。</li><li>最后乘上系数还原为浮点数的乘法结果$C = \frac{c_1c_2}{s^2}A_I B_I$。</li></ol><h2 id="进阶（relu激活函数）"><a href="#进阶（relu激活函数）" class="headerlink" title="进阶（relu激活函数）"></a>进阶（relu激活函数）</h2><p>熟悉Transformer的同学应该知道，FFN第二层输入分别是relu的结果$A$和参数$B$。那么这里就存在一个问题，relu结果的数值范围是$[0, c_1]$，而不可能是$[-c_1, c_1]$。</p><p>如果我们强行还按照$[-c_1, c_1]$的范围来量化relu结果$A$的话会怎么样呢？这样会导致整数区间$[-127, 0)$永远不会有数字，因为根本没有负数浮点数的存在。这样就白白浪费了127个整数，就会导致量化的精度大大受损。</p><p>那按照$[0, c_1]$来量化的话，怎么计算整数矩阵乘法的结果呢？</p><p>稍稍推导一下就可以得出，$A$可以表示为$A = \frac{c_1}{2s}(A_I + s \textbf{1})$，其中$\textbf{1}$表示和$A$相同形状的全1矩阵。而$B$的话依然表示为$B = \frac{c_2}{s}B_I$。</p><p>这样矩阵乘法可以改写为$C = \frac{c_1c_2}{2s^2}A_I B_I + \frac{c_1c_2}{2s}\textbf{1}B_I$。其中第二项因子可以用$B = \frac{c_2}{s}B_I$来进一步简化，最终得到$C = \frac{c_1c_2}{2s^2}A_I B_I + \frac{c_1}{2}\textbf{1}B$。</p><p>第一项因子和之前一样，先算整数矩阵乘法$A_I B_I$，再乘上系数，只不过系数变成了$\frac{c_1c_2}{2s^2}$。</p><p>第二项因子$\textbf{1}B$的维度和$C$相同，并且它的矩阵元素等于$B$中同一列的元素之和。那么问题就很简单了，我们只需要提前计算出矩阵$B$每一列的元素和，再乘上系数$\frac{c_1}{2}$，结果存下来。最后在计算完$\frac{c_1c_2}{2s^2}A_I B_I$整数矩阵乘法结果之后，加上这个列元素之和就行了，你可以将其理解为残差项。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果矩阵乘法两个输入的范围都是关于零点对称的，那么计算公式为：<br><strong>量化：</strong><br>$$A_I = int(\frac{s}{c_1}A), B_I = int(\frac{s}{c_2}B)$$<br><strong>反量化：</strong><br>$$C = \frac{c_1c_2}{s^2}A_I B_I$$</p><p>如果矩阵乘法其中一个输入是relu的结果，那么计算公式为：<br><strong>量化：</strong><br>$$A_I = int(\frac{2s}{c_1}(A - s \textbf{1})), B_I = int(\frac{s}{c_2}B)$$<br><strong>反量化：</strong><br>$$C = \frac{c_1c_2}{2s^2}A_I B_I + \frac{c_1}{2}\textbf{1}B$$</p><p>当然还有很多其他情况，例如softmax的输出范围一定是$[0, 1]$，那么attention中的矩阵乘法公式还得改写。</p><p>此外为了减小量化的损失，还需要在模型结构中插入伪量化节点，然后进行量化感知训练（QAT）。接着还需要将finetune后的模型存储为int8格式。然后还需要开发加载int8模型的推理加速库代码。最后就是本文讲到的整数矩阵乘法了。整个流程比较繁琐，这部分内容今后我会慢慢给大家分享。网上关于量化的优秀教程非常多，我不会讲太多理论上的量化知识，只会从实践的角度来白话一下我们在Transformer模型量化过程中做的一些尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>昨晚学妹参加了B站秋招笔试，还想考考我？</title>
      <link href="/2021/08/26/bilibili-0/"/>
      <url>/2021/08/26/bilibili-0/</url>
      
        <content type="html"><![CDATA[<p>学妹昨晚参加了B站的2022届秋招算法笔试，做完给我发来了一道题，想考考我，说挺难的。<br><img src="2.jpg" alt></p><p>我看了两分钟，给她发去了我的思路。然后学妹一眼就看懂了，立马秒过。<br><img src="1.jpg" alt></p><p>那么这道题到底是怎么做的呢？</p><p>题目要求将$n$个数切分成$k$块，求每块的序号乘上该块内数字之和的最大值。</p><p>那么首先我们可以用$S_i$来表示前缀和，也就是$S_i = \sum_{j &lt; i}{a_j}$。</p><p>然后假设$k$个子序列中，第$i$个子序列的末尾元素为$a_{d_i}$，其中$1 \le i \le k$。那么第$i$个子序列的元素和就可以用前缀和来表示为$S_{d_i} - S_{d_{i-1}}$。</p><p>然后题目要求的最大值就可以表示为：<br>$$<br>\sum_{1 \le i \le k}{i \cdot (S_{d_i} - S_{d_{i-1}})}<br>$$</p><p>展开并化简就可以得到：<br>$$<br>-\sum_{0 \le i \le k-1}{S_{d_i}} + k \cdot S_{d_k}<br>$$</p><p>后面一项$k \cdot S_{d_k}$就是整个数组之和的$k$倍，是一个定值。所以要求这个式子的最大值，就是求$\sum_{0 \le i \le k-1}{S_{d_i}}$的最小值。</p><p>又因为$S_{d_0} = 0$，所以就是求$\sum_{1 \le i \le k-1}{S_{d_i}}$的最小值。</p><p>可以发现，这$k-1$个前缀和其实是互不干扰的，所以只需要对所有的前缀和进行排序，取最小的$k-1$个就行了。</p><p>C++代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">300010</span><span class="token punctuation">;</span>ll a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ll res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        res <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    res <span class="token operator">=</span> <span class="token operator">-</span>res <span class="token operator">+</span> k <span class="token operator">*</span> a<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python代码：</p><pre class="line-numbers language-python"><code class="language-python">n<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">]</span>S <span class="token operator">=</span> <span class="token punctuation">[</span>sum<span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>S<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token operator">-</span>sum<span class="token punctuation">(</span>S<span class="token punctuation">[</span><span class="token punctuation">:</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> k <span class="token operator">*</span> sum<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cuBLAS矩阵乘法性能分析（附代码示例）</title>
      <link href="/2021/08/24/gemm/"/>
      <url>/2021/08/24/gemm/</url>
      
        <content type="html"><![CDATA[<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p>矩阵乘法是神经网络中最基础、最重要的一个运算。在用CUDA实现矩阵乘法时，不需要我们手动写，<code>cuBLAS</code>库提供了现成的矩阵乘法算子，例如<code>cublasGemmEx</code>和<code>cublasLtMatmul</code>。其中后者是轻量级版本，API调用更灵活。例如对于整数乘法，<code>cublasLtMatmul</code>支持int8的输入输出，而<code>cublasGemmEx</code>只支持int8输入，int32输出。</p><p>今天我只给大家讲解<code>cublasGemmEx</code>，主要使用起来相对更简洁一点。</p><p>官方文档地址：<br><a href="https://docs.nvidia.com/cuda/cublas/index.html#cublas-GemmEx" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cublas/index.html#cublas-GemmEx</a></p><p>经过翻阅网上各种教程，我找到了一篇我认为写的最好的博客。例子举得非常好，写的很详细。地址如下：<br><a href="https://www.cnblogs.com/cuancuancuanhao/p/7763256.html" target="_blank" rel="noopener">https://www.cnblogs.com/cuancuancuanhao/p/7763256.html</a></p><p>具体的使用方法可以参见上面这篇博客，我这里就不再赘述了。</p><p>今天我主要给大家演示一下，不同数据类型的矩阵乘法，速度和结果上到底有多大的差异？</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>我写了一个简单的测试代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cuda_profiler_api.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cublas_v2.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cuda.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cuda_fp16.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cuda_runtime.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>int8_t <span class="token function">float2int8</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">,</span> <span class="token keyword">float</span> scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>    int8_t i <span class="token operator">=</span> <span class="token function">int8_t</span><span class="token punctuation">(</span>f <span class="token operator">*</span> scale<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">127</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> S<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">allocate_memory</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> T <span class="token operator">*</span><span class="token operator">*</span>A<span class="token punctuation">,</span> T <span class="token operator">*</span><span class="token operator">*</span>B<span class="token punctuation">,</span> S <span class="token operator">*</span><span class="token operator">*</span>C<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">cudaMallocManaged</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> m <span class="token operator">*</span> k <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cudaMallocManaged</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> k <span class="token operator">*</span> n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cudaMallocManaged</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> m <span class="token operator">*</span> n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> S<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">free_memory</span><span class="token punctuation">(</span>T <span class="token operator">*</span>A<span class="token punctuation">,</span> T <span class="token operator">*</span>B<span class="token punctuation">,</span> S <span class="token operator">*</span>C<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">cudaFree</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cudaFree</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cudaFree</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> S<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">cublas_gemm_ex</span><span class="token punctuation">(</span>cublasHandle_t handle<span class="token punctuation">,</span> cublasOperation_t transA<span class="token punctuation">,</span> cublasOperation_t transB<span class="token punctuation">,</span>                   <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> T <span class="token operator">*</span>A<span class="token punctuation">,</span> T <span class="token operator">*</span>B<span class="token punctuation">,</span> S <span class="token operator">*</span>C<span class="token punctuation">,</span> <span class="token keyword">int</span> lda<span class="token punctuation">,</span> <span class="token keyword">int</span> ldb<span class="token punctuation">,</span> <span class="token keyword">int</span> ldc<span class="token punctuation">,</span>                   S <span class="token operator">*</span>alpha<span class="token punctuation">,</span> S <span class="token operator">*</span>beta<span class="token punctuation">,</span> <span class="token keyword">int</span> algo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cudaDataType_t AType<span class="token punctuation">,</span> BType<span class="token punctuation">,</span> CType<span class="token punctuation">,</span> ComputeType<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AType <span class="token operator">=</span> BType <span class="token operator">=</span> CType <span class="token operator">=</span> ComputeType <span class="token operator">=</span> CUDA_R_32F<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> __half<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AType <span class="token operator">=</span> BType <span class="token operator">=</span> CType <span class="token operator">=</span> ComputeType <span class="token operator">=</span> CUDA_R_16F<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>is_same<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> int8_t<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AType <span class="token operator">=</span> BType <span class="token operator">=</span> CUDA_R_8I<span class="token punctuation">;</span>        CType <span class="token operator">=</span> ComputeType <span class="token operator">=</span> CUDA_R_32I<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Not supported data type."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cublasStatus_t status<span class="token punctuation">;</span>    status <span class="token operator">=</span> <span class="token function">cublasGemmEx</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span>                          transA<span class="token punctuation">,</span>                          transB<span class="token punctuation">,</span>                          m<span class="token punctuation">,</span>                          n<span class="token punctuation">,</span>                          k<span class="token punctuation">,</span>                          alpha<span class="token punctuation">,</span>                          A<span class="token punctuation">,</span>                          AType<span class="token punctuation">,</span>                          lda<span class="token punctuation">,</span>                          B<span class="token punctuation">,</span>                          BType<span class="token punctuation">,</span>                          ldb<span class="token punctuation">,</span>                          beta<span class="token punctuation">,</span>                          C<span class="token punctuation">,</span>                          CType<span class="token punctuation">,</span>                          ldc<span class="token punctuation">,</span>                          ComputeType<span class="token punctuation">,</span>                          <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>cublasGemmAlgo_t<span class="token operator">></span><span class="token punctuation">(</span>algo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> CUBLAS_STATUS_SUCCESS<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> S<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">test_gemm</span><span class="token punctuation">(</span>cublasHandle_t handle<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> T <span class="token operator">*</span>A<span class="token punctuation">,</span> T <span class="token operator">*</span>B<span class="token punctuation">,</span> S <span class="token operator">*</span>C<span class="token punctuation">,</span>               S <span class="token operator">*</span>alpha<span class="token punctuation">,</span> S <span class="token operator">*</span>beta<span class="token punctuation">,</span> <span class="token keyword">int</span> algo<span class="token punctuation">,</span> <span class="token keyword">int</span> iteration<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">float</span> total_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> iteration<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> timeval start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>        <span class="token function">cudaDeviceSynchronize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">cudaProfilerStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> success <span class="token operator">=</span> <span class="token function">cublas_gemm_ex</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span>                                     CUBLAS_OP_N<span class="token punctuation">,</span>                                     CUBLAS_OP_N<span class="token punctuation">,</span>                                     n<span class="token punctuation">,</span>                                     m<span class="token punctuation">,</span>                                     k<span class="token punctuation">,</span>                                     B<span class="token punctuation">,</span>                                     A<span class="token punctuation">,</span>                                     C<span class="token punctuation">,</span>                                     n<span class="token punctuation">,</span>                                     k<span class="token punctuation">,</span>                                     n<span class="token punctuation">,</span>                                     alpha<span class="token punctuation">,</span>                                     beta<span class="token punctuation">,</span>                                     <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>cublasGemmAlgo_t<span class="token operator">></span><span class="token punctuation">(</span>algo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">cudaDeviceSynchronize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>end<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">cudaProfilerStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>success <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            total_time <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>end<span class="token punctuation">.</span>tv_sec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_sec<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end<span class="token punctuation">.</span>tv_usec <span class="token operator">-</span> start<span class="token punctuation">.</span>tv_usec<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.001</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>total_time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"algo %d: %.3f ms\n"</span><span class="token punctuation">,</span> algo<span class="token punctuation">,</span> total_time <span class="token operator">/</span> <span class="token punctuation">(</span>iteration <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shape: (%d, %d) x (%d, %d)\n"</span><span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start_algo <span class="token operator">=</span> CUBLAS_GEMM_DEFAULT<span class="token punctuation">;</span>    <span class="token keyword">int</span> end_algo <span class="token operator">=</span> CUBLAS_GEMM_ALGO23<span class="token punctuation">;</span>    <span class="token keyword">int</span> start_algo_t_op <span class="token operator">=</span> CUBLAS_GEMM_DEFAULT_TENSOR_OP<span class="token punctuation">;</span>    <span class="token keyword">int</span> end_algo_t_op <span class="token operator">=</span> CUBLAS_GEMM_ALGO15_TENSOR_OP<span class="token punctuation">;</span>    <span class="token keyword">int</span> iteration <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> <span class="token operator">*</span>fA<span class="token punctuation">,</span> <span class="token operator">*</span>fB<span class="token punctuation">,</span> <span class="token operator">*</span>fC<span class="token punctuation">;</span>    __half <span class="token operator">*</span>hA<span class="token punctuation">,</span> <span class="token operator">*</span>hB<span class="token punctuation">,</span> <span class="token operator">*</span>hC<span class="token punctuation">;</span>    int8_t <span class="token operator">*</span>iA<span class="token punctuation">,</span> <span class="token operator">*</span>iB<span class="token punctuation">;</span> int32_t <span class="token operator">*</span>iC<span class="token punctuation">;</span>    <span class="token keyword">float</span> f_alpha <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> f_beta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    __half h_alpha <span class="token operator">=</span> <span class="token function">__float2half_rn</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> h_beta <span class="token operator">=</span> <span class="token function">__float2half_rn</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    int32_t i_alpha <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i_beta <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">allocate_memory</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">allocate_memory</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">allocate_memory</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>iA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>iB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>iC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">*</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        fA<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">255</span> <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">127</span><span class="token punctuation">;</span>        hA<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">__float2half_rn</span><span class="token punctuation">(</span>fA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iA<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">float2int8</span><span class="token punctuation">(</span>fA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k <span class="token operator">*</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        fB<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">255</span> <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">127</span><span class="token punctuation">;</span>        hB<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">__float2half_rn</span><span class="token punctuation">(</span>fB<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iB<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">float2int8</span><span class="token punctuation">(</span>fB<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cublasHandle_t handle<span class="token punctuation">;</span>    <span class="token function">cublasCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>>>>>>>> test fp32 >>>>>>>>>>>>>>>>>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> algo <span class="token operator">=</span> start_algo<span class="token punctuation">;</span> algo <span class="token operator">&lt;=</span> end_algo<span class="token punctuation">;</span> <span class="token operator">++</span>algo<span class="token punctuation">)</span>        <span class="token function">test_gemm</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> fA<span class="token punctuation">,</span> fB<span class="token punctuation">,</span> fC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f_alpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f_beta<span class="token punctuation">,</span> algo<span class="token punctuation">,</span> iteration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> algo <span class="token operator">=</span> start_algo_t_op<span class="token punctuation">;</span> algo <span class="token operator">&lt;=</span> end_algo_t_op<span class="token punctuation">;</span> <span class="token operator">++</span>algo<span class="token punctuation">)</span>        <span class="token function">test_gemm</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> fA<span class="token punctuation">,</span> fB<span class="token punctuation">,</span> fC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f_alpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>f_beta<span class="token punctuation">,</span> algo<span class="token punctuation">,</span> iteration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>>>>>>>> test fp16 >>>>>>>>>>>>>>>>>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> algo <span class="token operator">=</span> start_algo<span class="token punctuation">;</span> algo <span class="token operator">&lt;=</span> end_algo<span class="token punctuation">;</span> <span class="token operator">++</span>algo<span class="token punctuation">)</span>        <span class="token function">test_gemm</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> hA<span class="token punctuation">,</span> hB<span class="token punctuation">,</span> hC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>h_alpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>h_beta<span class="token punctuation">,</span> algo<span class="token punctuation">,</span> iteration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> algo <span class="token operator">=</span> start_algo_t_op<span class="token punctuation">;</span> algo <span class="token operator">&lt;=</span> end_algo_t_op<span class="token punctuation">;</span> <span class="token operator">++</span>algo<span class="token punctuation">)</span>        <span class="token function">test_gemm</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> hA<span class="token punctuation">,</span> hB<span class="token punctuation">,</span> hC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>h_alpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>h_beta<span class="token punctuation">,</span> algo<span class="token punctuation">,</span> iteration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>>>>>>>> test int8 >>>>>>>>>>>>>>>>>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> algo <span class="token operator">=</span> start_algo<span class="token punctuation">;</span> algo <span class="token operator">&lt;=</span> end_algo<span class="token punctuation">;</span> <span class="token operator">++</span>algo<span class="token punctuation">)</span>        <span class="token function">test_gemm</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> iA<span class="token punctuation">,</span> iB<span class="token punctuation">,</span> iC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i_alpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i_beta<span class="token punctuation">,</span> algo<span class="token punctuation">,</span> iteration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> algo <span class="token operator">=</span> start_algo_t_op<span class="token punctuation">;</span> algo <span class="token operator">&lt;=</span> end_algo_t_op<span class="token punctuation">;</span> <span class="token operator">++</span>algo<span class="token punctuation">)</span>        <span class="token function">test_gemm</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> iA<span class="token punctuation">,</span> iB<span class="token punctuation">,</span> iC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i_alpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>i_beta<span class="token punctuation">,</span> algo<span class="token punctuation">,</span> iteration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">">>>>>>>>>>>>>>>>> compare result >>>>>>>>>>>>>>>>>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fp32: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f%c"</span><span class="token punctuation">,</span> fC<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">" \n"</span><span class="token punctuation">[</span>i<span class="token operator">==</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fp16: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f%c"</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">(</span>hC<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" \n"</span><span class="token punctuation">[</span>i<span class="token operator">==</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"int8: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f%c"</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">(</span>iC<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">127</span><span class="token operator">/</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token string">" \n"</span><span class="token punctuation">[</span>i<span class="token operator">==</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free_memory</span><span class="token punctuation">(</span>iA<span class="token punctuation">,</span> iB<span class="token punctuation">,</span> iC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free_memory</span><span class="token punctuation">(</span>fA<span class="token punctuation">,</span> fB<span class="token punctuation">,</span> fC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free_memory</span><span class="token punctuation">(</span>hA<span class="token punctuation">,</span> hB<span class="token punctuation">,</span> hC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码保存为<code>test_gemm.cpp</code>，然后执行下面命令进行编译：</p><pre class="line-numbers language-shell"><code class="language-shell">nvcc test_gemm.cpp -o test_gemm -L/usr/local/cuda/lib64 -lcudart -lcuda -lcublas<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后执行<code>./test_gemm</code>运行就行了。</p><p>这里计算的是$C = A \cdot B$，其中$A$的维度是$(m, k)$，$B$的维度是$(k, n)$，$C$的维度是$(m, n)$。由于在C++和Python中新建的数组默认都是行优先存储，而cuBLAS计算矩阵乘法是默认是列优先存储。所以你新建的矩阵送到cuBLAS矩阵乘法算子后，它默认识别成了列优先存储。因此需要调整一下运算顺序，或者对矩阵进行转置。</p><p>你需要记住一点，<strong>行优先存储的矩阵送到cuBLAS后，相当于做了一次转置，同样计算得到的矩阵$C$也是列优先存储的，你需要转置后再用行优先存储来正常读取。</strong>而根据矩阵的运算法则，我们有：<br>$$<br>C^{\top} = (A \cdot B)^{\top} = B^{\top} \cdot A^{\top}<br>$$<br>所以三个转置后的矩阵就不需要经过任何处理了，直接送到cuBLAS里计算就行了。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>我对比了三种数据类型：<code>fp32</code>、<code>fp16</code>和<code>int8</code>，测试环境是V100显卡、CUDA 10.1。由于V100显卡没有int8的tensor core，所以速度并不能达到最快。要想全速进行int8的矩阵乘法，推荐使用<code>sm75</code>及以上的显卡，例如T4、A100等等。此外我还对比了不同的GEMM算法的效果。</p><p>执行上面的运行命令后，会输出如下的结果：</p><pre class="line-numbers language-text"><code class="language-text">shape: (4096, 1024) x (1024, 8192)>>>>>>>>>>>>>>>>> test fp32 >>>>>>>>>>>>>>>>>algo -1: 4.831 msalgo 2: 5.293 msalgo 3: 5.406 msalgo 4: 5.297 msalgo 5: 5.098 msalgo 6: 4.874 msalgo 11: 4.870 msalgo 18: 7.219 msalgo 19: 6.061 msalgo 20: 5.631 msalgo 99: 1.110 msalgo 100: 1.159 msalgo 101: 1.688 msalgo 102: 4.944 msalgo 103: 4.744 msalgo 104: 4.700 msalgo 105: 4.679 msalgo 106: 4.679 msalgo 107: 4.675 msalgo 108: 4.676 msalgo 109: 4.677 msalgo 110: 4.676 msalgo 111: 4.676 msalgo 112: 4.678 msalgo 113: 4.675 msalgo 114: 4.676 msalgo 115: 4.689 ms>>>>>>>>>>>>>>>>> test fp16 >>>>>>>>>>>>>>>>>algo -1: 2.423 msalgo 1: 2.460 msalgo 2: 2.565 msalgo 3: 2.518 msalgo 5: 2.398 msalgo 6: 2.416 msalgo 99: 0.737 msalgo 100: 1.581 msalgo 101: 1.032 msalgo 102: 0.978 msalgo 103: 0.767 msalgo 104: 0.790 msalgo 105: 0.803 msalgo 106: 0.774 msalgo 107: 2.656 msalgo 108: 2.577 msalgo 109: 2.518 msalgo 110: 0.925 msalgo 111: 0.951 msalgo 112: 0.935 msalgo 113: 0.909 msalgo 114: 2.549 msalgo 115: 2.532 ms>>>>>>>>>>>>>>>>> test int8 >>>>>>>>>>>>>>>>>algo -1: 1.232 msalgo 0: 7.544 msalgo 1: 1.217 msalgo 2: 1.294 msalgo 3: 2.362 msalgo 99: 1.243 msalgo 100: 1.244 msalgo 101: 1.237 msalgo 102: 1.232 msalgo 103: 1.230 msalgo 104: 1.224 msalgo 105: 1.222 msalgo 106: 1.224 msalgo 107: 1.225 msalgo 108: 1.224 msalgo 109: 1.218 msalgo 110: 1.217 msalgo 111: 1.217 msalgo 112: 1.218 msalgo 113: 1.218 msalgo 114: 1.216 msalgo 115: 1.217 ms>>>>>>>>>>>>>>>>> compare result >>>>>>>>>>>>>>>>>fp32: 52.38629 44.76633 37.65229 31.04420 24.94203 19.34578 14.25543 9.67102 5.59253 2.01996fp16: 52.46875 44.84375 37.40625 31.21875 24.95312 19.39062 14.28125 9.69531 5.61328 2.05078int8: 52.38626 44.76632 37.65230 31.04421 24.94203 19.34577 14.25544 9.67103 5.59254 2.01996<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里简单解释一下，algo -1到23表示不使用tensor core算法的结果，algo 99到115表示使用tensor core算法的结果。</p><p>可以看到图中缺失了一部分算法的结果，因为那些算法可能不适用于当前的矩阵乘法，因此报错了。</p><p>汇总一下各自最快的结果（不使用vs使用tensor core）：</p><ul><li>fp32: 4.83 1.11</li><li>fp16: 2.41 0.73</li><li>int8: 1.21 1.21</li></ul><p>由于V100显卡没有int8的tensor core，所以int8的两个结果是相同的。结果也符合我们的预期，速度上fp32慢于fp16慢于int8。所以在实际的深度学习应用中，流行使用混合精度，也就是用fp16来进行训练和推理。</p><p>而int8是速度最快的，所以如果训练和推理也都能使用int8的话，速度上将会迈上一个新的台阶。</p><p>那么一个浮点数的矩阵乘法怎么转变为整数的矩阵乘法呢？这里我不会详细讲，后续会出一个详细的量化教程。</p><p>简单来说，对于一个浮点数$f$，假设范围在$[-1, 1]$之间，那我们可以将它表示成一个$[-127, 127]$之间的8位整数$i$，转换关系为：<br>$$<br>f = i / 127<br>$$<br>那么浮点数矩阵乘法$f_3 = f_1 \cdot f_2$就可以表示为：<br>$$<br>f_3 = f_1 \cdot f_2 = i_1 \cdot i_2 / 127^2<br>$$<br>所以只需要计算int8矩阵乘法$i_1 \cdot i_2$，然后得到int32类型的输出结果之后，除以$127^2$就可以得到原始的浮点数结果了。</p><p>那么由于这里有个类型转换的操作，所以会产生误差。但是在我们的样例中，int8的误差竟然比fp16还要小很多，结果和fp32几乎一模一样。这主要由于是我构造的矩阵数据分布非常均匀有规律，因此计算误差会很小，实际深度网络中int8的误差会较大。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>int8甚至更低比特的量化的实际收益非常大，提速可以达到将近2倍。虽然现在有很多现成的自动量化工具，但是效果上或多或少都有一定的损失，速度上也没有达到极致。因此今后量化是一个不错的方向，值得一试。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最全攻略：利用LightSeq加速你的深度学习模型</title>
      <link href="/2021/08/24/volctrans/"/>
      <url>/2021/08/24/volctrans/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LightSeq是字节跳动火山翻译团队开源的一款Transformer系列模型加速引擎，分为训练和推理两个部分。其中推理加速引擎早在2019年12月就已经开源，而训练加速引擎也在2021年6月开源。<br><strong>项目地址：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p>LightSeq主要采用了CUDA算子融合、显存优化、参数连续化、层级式解码策略等技术，感兴趣的小伙伴可以阅读此前的文章：<br><strong>训练引擎：</strong><br><a href="https://zhuanlan.zhihu.com/p/383657837" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/383657837</a><br><strong>推理引擎：</strong><br><a href="https://zhuanlan.zhihu.com/p/269478459" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/269478459</a></p><p>本文详细讲解一下如何使用LightSeq来改造你的PyTorch模型，实现1.5-3倍的训练加速和5-10倍的推理加速。至于TensorFlow模型的加速，目前也已经支持，这里不会详细讲解，可以参考下面NeurST的代码：<br><a href="https://github.com/bytedance/neurst/tree/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/neurst/tree/lightseq</a></p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>使用LightSeq进行加速的整体流程依次为：</p><ol><li>接入训练引擎进行模型训练，并保存模型参数。</li><li>加载模型参数，使用训练引擎的前向传播部分进行模型推理。</li><li>为了更快的推理速度，还可以将模型参数导出为protobuf或者hdf5格式。</li><li>使用推理引擎解析第3步中导出的模型，并进行模型推理。</li></ol><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>LightSeq提供了封装好的embedding、encoder、decoder、cross entropy和adam类，可以接入到你自己的模型中替换原有的模型。</p><p>LightSeq还提供了现成的Fairseq、Hugging Face、DeepSpeed<br>DeepSpeed可以用于大规模训练Speed、NeurST等样例。如果你用这几个训练库的话，就可以直接使用。如果你是自己的模型，那也可以手动接入LightSeq。这几个样例代码都在<code>examples/training</code>目录下。</p><h3 id="自定义模型"><a href="#自定义模型" class="headerlink" title="自定义模型"></a>自定义模型</h3><p>首先引入所有可能用到的头文件：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training <span class="token keyword">import</span> <span class="token punctuation">(</span>    LSTransformer<span class="token punctuation">,</span>    LSTransformerEmbeddingLayer<span class="token punctuation">,</span>    LSTransformerEncoderLayer<span class="token punctuation">,</span>    LSTransformerDecoderLayer<span class="token punctuation">,</span>    LSCrossEntropyLayer<span class="token punctuation">,</span>    LSAdam<span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以新建encoder层为例，主要分为两个步骤：</p><ol><li>使用<code>LSTransformerEncoderLayer.get_config</code>函数新建config。</li><li>新建LightSeq的encoder层，即<code>LSTransformerEncoderLayer</code>类，使用config来初始化。</li></ol><p>一个典型的例子如下：</p><pre class="line-numbers language-python"><code class="language-python">config <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>    model<span class="token operator">=</span><span class="token string">"bert-base"</span><span class="token punctuation">,</span>    max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>    max_seq_len<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>    fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">)</span>layer <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>max_batch_tokens</code>指定了训练过程中一个batch最大可能的单词数，<code>max_seq_len</code>指定了句子的最长长度。<code>model</code>提供了四种现成的模型配置：<code>transformer-base</code>、<code>transformer-big</code>、<code>bert-base</code>和<code>bert-big</code>。</p><p>当然如果你想用自己的模型配置，也可以手动补全所有的参数：</p><pre class="line-numbers language-python"><code class="language-python">config <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>    max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>    max_seq_len<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>    hidden_size<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">,</span>    intermediate_size<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>    nhead<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span>    attn_prob_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>    activation_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>    hidden_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>    pre_layer_norm<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>    activation_fn<span class="token operator">=</span><span class="token string">"gelu"</span><span class="token punctuation">,</span>    fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">)</span>layer <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了encoder以外，embedding、decoder、cross entropy和adam也可以用同样的方法新建，最后和你自己写的模型一样进行训练即可。</p><p>此外LightSeq还提供了完整的Transformer类<code>LSTransformer</code>，可以直接新建一整个Transformer：</p><pre class="line-numbers language-python"><code class="language-python">config <span class="token operator">=</span> LSTransformer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>    model<span class="token operator">=</span><span class="token string">"transformer-base"</span><span class="token punctuation">,</span>    max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>    max_seq_len<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>    vocab_size<span class="token operator">=</span><span class="token number">32000</span><span class="token punctuation">,</span>    padding_idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    num_encoder_layer<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>    num_decoder_layer<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>    fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">)</span>model <span class="token operator">=</span> LSTransformer<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码在<code>examples/training/custom</code>中，可以直接运行<code>python run.py</code>查看效果。</p><h3 id="Hugging-Face"><a href="#Hugging-Face" class="headerlink" title="Hugging Face"></a>Hugging Face</h3><p>以Hugging Face官方提供的<code>run_glue.py</code>为例，一般首先都是用<code>AutoModel.from_pretrained</code>函数新建模型model，然后进行训练。</p><p>为了接入LightSeq，需要将model中的所有encoder层替换为LightSeq版本的encoder层。替换过程分为三个步骤：</p><ol><li>使用<code>LSTransformerEncoderLayer.get_config</code>函数新建config。</li><li>获取Hugging Face预训练好的BERT参数。</li><li>新建LightSeq的encoder层，即<code>LSTransformerEncoderLayer</code>类，使用config和预训练好的参数来初始化。</li></ol><p>新建encoder层代码参见上一小节。注意在Hugging Face这个例子里，额外给<code>LSTransformerEncoderLayer</code>封装了一层<code>LSHFTransformerEncoderLayer</code>，主要是为了兼容原来的encoder输入形状。</p><p>示例代码在<code>examples/training/huggingface</code>中，运行<code>sh run_glue.sh</code>和<code>sh run_ner.sh</code>分别可以查看LightSeq在GLUE和NER任务上的加速效果。</p><p>注意Hugging Face BERT的fine-tune任务很不稳定，经常会不收敛，这时候可以尝试修改运行脚本中的<code>--seed</code>参数。</p><h3 id="Fairseq"><a href="#Fairseq" class="headerlink" title="Fairseq"></a>Fairseq</h3><p>Fairseq主要用于一些生成任务，使用LightSeq加速的原理是一样的，都是需要将各自组件替换为LightSeq对应的组件。</p><p>LightSeq对Fairseq做了非常完整的替换，将embedding、encoder、decoder、cross entropy和adam全部替换为了LightSeq对应的部分，来达到极致的加速效果。</p><p>示例代码在<code>examples/training/fairseq</code>目录下，其中<code>fs_cli</code>目录存放着三个启动入口：<code>train</code>、<code>validate</code>和<code>generate</code>，<code>fs_modules</code>目录存放着用LightSeq封装好的几个Transformer组件。</p><p>直接运行<code>sh ls_fairseq_wmt14en2de.sh</code>即可自动下载数据并运行WMT14英德机器翻译任务。脚本中主要的运行命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">lightseq-train /tmp/wmt14_en_de/ \    --task translation \    --arch ls_transformer_wmt_en_de_big_t2t --share-decoder-input-output-embed \    --optimizer ls_adam --adam-betas '(0.9, 0.98)' --clip-norm 0.0 \    --lr 5e-4 --lr-scheduler inverse_sqrt --warmup-updates 4000 --weight-decay 0.0001 \    --criterion ls_label_smoothed_cross_entropy --label-smoothing 0.1 \    --max-tokens 8192 \    --eval-bleu --eval-bleu-args '{"beam": 5, "max_len_a": 1.2, "max_len_b": 10}' \    --eval-bleu-detok moses --eval-bleu-remove-bpe --eval-bleu-print-samples \    --best-checkpoint-metric bleu \    --maximize-best-checkpoint-metric --fp16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到和一般运行Fairseq的命令不同的地方有这么几个：</p><ol><li>启动入口从<code>fairseq-train</code>替换为了<code>lightseq-train</code>，这是因为在根目录<code>setup.py</code>里封装了<code>--user-dir</code>用户模块目录。如果还想继续用<code>fairseq-train</code>的话，就需要手动指定<code>--user-dir fs_modules</code>参数。</li><li>模型结构<code>--arch</code>需要在原来的基础上加上前缀<code>ls_</code>，用来指定使用LightSeq提供的Transformer模型。</li><li>优化器<code>--optimizer</code>和损失函数<code>--criterion</code>都需要在原来的基础上加上前缀<code>ls_</code>，指定使用LightSeq对应的组件。</li></ol><h3 id="DeepSpeed"><a href="#DeepSpeed" class="headerlink" title="DeepSpeed"></a>DeepSpeed</h3><p>DeepSpeed主要用于大规模训练，也提供了Transformer的encoder层CUDA实现，不过效率没有LightSeq高。</p><p>LightSeq提供了Fairseq+DeepSpeed分布式训练的使用样例，将启动器替换成了<code>deepspeed</code>，手动指定<code>--user-dir</code>目录，还需要指定DeepSpeed的配置文件<code>deepspeed_config</code>，其它参数和上一节Fairseq样例一模一样。</p><p>使用时运行<code>sh ds_fairseq_wmt14en2de.sh</code>即可，和上一小节一样都是用Fairseq运行WMT14英德机器翻译任务。</p><h2 id="模型导出"><a href="#模型导出" class="headerlink" title="模型导出"></a>模型导出</h2><p>在模型训练完之后，直接load保存的checkpoint就可以继续fine-tune或者推理。但是这样调用的是训练引擎的推理部分，也就是模型的前向传播。这部分代码需要频繁在python和c++之间切换，并且前向过程中计算了很多反向传播才需要用到的变量。因此速度不如纯粹的推理引擎快。</p><p>而要想使用LightSeq的推理引擎，就必须先将checkpoint转变为protobuf或者hdf5的格式。</p><p>LightSeq提供了每个组件的导出接口，如果你使用了LightSeq的模型组件，那么导出将变得非常容易。只需要引入下面的头文件即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training <span class="token keyword">import</span> <span class="token punctuation">(</span>    export_ls_config<span class="token punctuation">,</span>    export_ls_embedding<span class="token punctuation">,</span>    export_ls_encoder<span class="token punctuation">,</span>    export_ls_decoder<span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这四个函数分别可以导出推理引擎所需要的配置信息、embedding参数、encoder参数和decoder参数。而如果有其他部分的参数没包括在这里面（例如输出到词表的映射矩阵），则需要自己进行导出，详见下面的教程。</p><p>LightSeq对Hugging Face的BERT、BART、GPT2三种模型，以及Fairseq+LightSeq、LightSeq的Transformer模型都提供了模型导出的样例，代码在<code>examples/inference/python/export</code>目录下。其中Hugging Face的模型都是没有采用LightSeq加速训练的预训练模型参数，所以导出更为复杂一些。</p><p>模型导出的核心思想就是：</p><ol><li>首先创建一个protobuf对象<code>Transformer</code>或者hdf5的文件对象。</li><li>然后在checkpoint中提取出参数值，将其赋值给<code>Transformer</code>或者hdf5文件对象中对应的参数。</li></ol><p>这个过程麻烦的就是提取并且对应赋值的过程，LightSeq提供了一系列方便的操作函数。</p><h3 id="Fairseq-1"><a href="#Fairseq-1" class="headerlink" title="Fairseq"></a>Fairseq</h3><p>执行<code>python ls_fs_transformer_export.py</code>可以导出上一章节中Fairseq+LightSeq训练样例得到的模型。</p><p>以protobuf导出为例，观察代码可以看到主体部分如下（省略了部分参数）：</p><pre class="line-numbers language-python"><code class="language-python">file <span class="token operator">=</span> Transformer<span class="token punctuation">(</span><span class="token punctuation">)</span>encoder_state_dict<span class="token punctuation">,</span> decoder_state_dict <span class="token operator">=</span> _extract_weight<span class="token punctuation">(</span>state_dict<span class="token punctuation">)</span>export_ls_embedding<span class="token punctuation">(</span>file<span class="token punctuation">,</span> encoder_state_dict<span class="token punctuation">,</span> is_encoder<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>export_ls_embedding<span class="token punctuation">(</span>file<span class="token punctuation">,</span> decoder_state_dict<span class="token punctuation">,</span> is_encoder<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>export_ls_encoder<span class="token punctuation">(</span>file<span class="token punctuation">,</span> encoder_state_dict<span class="token punctuation">)</span>export_ls_decoder<span class="token punctuation">(</span>file<span class="token punctuation">,</span> decoder_state_dict<span class="token punctuation">)</span>export_fs_weights<span class="token punctuation">(</span>file<span class="token punctuation">,</span> state_dict<span class="token punctuation">)</span>export_ls_config<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要用户自己将state_dict拆分成encoder和decoder两部分，这主要是因为设计时考虑到有些用户只会用到encoder的导出（例如BERT）。并且LightSeq无法知道用户模型的最外层参数名叫啥，万一不叫encoder，而叫enc之类的呢？所以交给用户自己拆分更加合理。</p><p>然后分别导出encoder的embedding、decoder的embedding、encoder和decoder参数，这几部分都直接调用LightSeq提供的接口就行了。LightSeq会自动帮你把解析出来的参数导出到定义的<code>Transformer</code>类里。</p><p>接着需要处理一下Fairseq中与LightSeq无关的一些参数，例如encoder和decoder的layer norm参数等等。<code>export_fs_weights</code>函数需要用户自己实现，核心思想就是找到state_dict中的参数名，将其赋值给<code>Transformer</code>类里对应的变量就行了。</p><p>最后设置一下<code>Transformer</code>类里所有的配置参数就行了。</p><p>hdf5的用法类似，LightSeq都将其封装在同样的函数里了，只需要指定<code>save_pb=False</code>即可。</p><h3 id="Hugging-Face-1"><a href="#Hugging-Face-1" class="headerlink" title="Hugging Face"></a>Hugging Face</h3><p>执行<code>python hf_bert_export.py</code>、<code>python hf_bart_export.py</code>和<code>python hf_gpt2_export.py</code>三个文件分别可以导出BERT、BART和GPT2的预训练模型。</p><p>因为Hugging Face的模型参数都是预训练得到的，所以LightSeq无法识别参数名是什么样的，只能用户自己编写导出规则，具体参考上面三个导出样例即可。</p><h3 id="LightSeq-Transformer"><a href="#LightSeq-Transformer" class="headerlink" title="LightSeq Transformer"></a>LightSeq Transformer</h3><p>使用LightSeq提供的Transformer进行训练的话，参数名LightSeq都知道的一清二楚，因此可以直接使用LightSeq提供的导出接口进行转换。过程和上面的Fairseq+LightSeq类似。</p><p>具体样例可以执行<code>python ls_transformer_export.py</code>，同时得到protobuf和hdf5格式的模型导出文件，并且对比两者生成的结果。这里的checkpoint可以使用上一章节中<code>自定义模型</code>小节中训练得到的模型。</p><h3 id="自定义模型-1"><a href="#自定义模型-1" class="headerlink" title="自定义模型"></a>自定义模型</h3><p>因为自定义的模型参数LightSeq无法识别参数名，所以需要用户自己编写转换规则。</p><p>举一个简单的例子，假设用户模型中有个encoder的输出部分的layer norm参数，state_dict中的参数名叫做<code>encoder.layer_norm.weight</code>。那么可以按如下方式进行转换：</p><pre class="line-numbers language-python"><code class="language-python">transformer <span class="token operator">=</span> Transformer<span class="token punctuation">(</span><span class="token punctuation">)</span>enc_norm_w <span class="token operator">=</span> state_dict<span class="token punctuation">[</span><span class="token string">"encoder.layer_norm.weight"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>transformer<span class="token punctuation">.</span>src_embedding<span class="token punctuation">.</span>norm_scale<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> enc_norm_w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="模型推理"><a href="#模型推理" class="headerlink" title="模型推理"></a>模型推理</h2><p>得到导出的protobuf或者hdf5模型后，推理就变得十分简单，核心代码就三行：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lightseq<span class="token punctuation">.</span>inference <span class="token keyword">as</span> lsimodel <span class="token operator">=</span> lsi<span class="token punctuation">.</span>Transformer<span class="token punctuation">(</span><span class="token string">"transformer.pb"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>output <span class="token operator">=</span> model<span class="token punctuation">.</span>infer<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先定义一个<code>Transformer</code>类用来加载模型参数，指定load的protobuf文路径和batch_size大小。</p><p>然后调用<code>infer</code>函数进行推理，传入的输入参数必须是list或者numpy类型，且必须是二维。</p><p>LightSeq在<code>examples/inference/python/test</code>目录下提供了三个Hugging Face模型推理的样例，此外上一小节中<code>examples/inference/python/export</code>中的<code>ls_transformer_export.py</code>代码也包含了导出后推理的过程。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>总结一下，使用LightSeq加速你的深度学习模型，最佳方式无外乎三步：</p><ol><li>接入LightSeq训练引擎的模型组件，构建模型，进行训练，保存checkpoint。</li><li>将checkpoint转换为protobuf或者hdf5格式，LightSeq的组件可以调用现成的转换接口，其它的需要自己手写转换规则。</li><li>调用LightSeq推理引擎，加载上一步中导出的模型，进行快速推理。</li></ol><p>目前LightSeq已经被广泛应用在字节跳动公司内外各项业务和学术研究上，支持了标准的Transformer、BERT、BART、GPT2、ViT等多种Transformer系列模型。只要你的模型中包含有Transformer的部分组件，例如encoder层，就可以直接调用LightSeq进行加速。</p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p>如果在使用中遇到任何问题，或者有任何需求和建议，都可以在github issue中提出，或者加入LightSeq的飞书用户群：<br><a href="https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=936uf19e-966f-43f6-8401-269ab93ec38d" target="_blank" rel="noopener">https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=936uf19e-966f-43f6-8401-269ab93ec38d</a></p><p><img src="1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 模型加速 </tag>
            
            <tag> LightSeq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让大家久等了，BERT推理加速终于开源了</title>
      <link href="/2021/08/10/ls-bert-infer/"/>
      <url>/2021/08/10/ls-bert-infer/</url>
      
        <content type="html"><![CDATA[<p>前几个月一直有不少小伙伴问我要<strong>LightSeq的BERT推理加速代码</strong>，当时内部已经使用了，但是一直没空整理开源。</p><p>现在代码终于整理好了，写了一个简单的样例，大家有需要的可以使用起来了。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>这里我直接使用预训练好的BERT模型，用户只需要输入一个带有<code>[MASK]</code>标记的句子，就可以自动预测出完整的句子。</p><p>例如我输入“巴黎是[MASK]国的首都”，那么模型就会输出“巴黎是法国的首都。”。</p><p>LightSeq已经<strong>完美支持了BERT模型的快速推理</strong>，代码近期已经开源：<br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p>BERT推理使用样例可以参考<code>examples/inference/python</code>目录下的<code>ls_bert.py</code>文件。我们用LightSeq来加速BERT推理试试。</p><p>首先需要安装LightSeq和Hugging Face：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install lightseq transformers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后需要将Hugging Face的BERT模型导出为LightSeq支持的HDF5模型格式，运行<code>examples/inference/python</code>目录下的<code>hf_bert_export.py</code>文件即可，运行前将代码的第167-168两行修改为下面这样，指定使用中文版本的BERT预训练模型。</p><pre class="line-numbers language-python"><code class="language-python">output_lightseq_model_name <span class="token operator">=</span> <span class="token string">"lightseq-bert-base-chinese"</span>input_huggingface_bert_model <span class="token operator">=</span> <span class="token string">"bert-base-chinese"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后就会在运行目录下生成一个<code>lightseq-bert-base-chinese.hdf5</code>模型文件，导出就成功啦。</p><p>最后使用LightSeq进行推理即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> transformers <span class="token keyword">import</span> AutoTokenizer<span class="token punctuation">,</span> AutoModelForMaskedLM<span class="token keyword">import</span> lightseq<span class="token punctuation">.</span>inference <span class="token keyword">as</span> lsitokenizer <span class="token operator">=</span> AutoTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"bert-base-chinese"</span><span class="token punctuation">)</span>hf_model <span class="token operator">=</span> AutoModelForMaskedLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"bert-base-chinese"</span><span class="token punctuation">)</span>hf_model<span class="token punctuation">.</span>to<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>ls_model <span class="token operator">=</span> lsi<span class="token punctuation">.</span>Bert<span class="token punctuation">(</span><span class="token string">"lightseq-bert-base-chinese.hdf5"</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    raw_text <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入中文句子，要预测的字符用#代替：\n> "</span><span class="token punctuation">)</span>    input_text <span class="token operator">=</span> raw_text<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">,</span> <span class="token string">"[MASK]"</span><span class="token punctuation">)</span>    inputs <span class="token operator">=</span> tokenizer<span class="token punctuation">(</span>input_text<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">)</span>    input_ids <span class="token operator">=</span> inputs<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span>    mask <span class="token operator">=</span> inputs<span class="token punctuation">[</span><span class="token string">"attention_mask"</span><span class="token punctuation">]</span>    outputs <span class="token operator">=</span> ls_model<span class="token punctuation">.</span>infer<span class="token punctuation">(</span>input_ids<span class="token punctuation">,</span> mask<span class="token punctuation">)</span>    logits <span class="token operator">=</span> hf_model<span class="token punctuation">.</span>cls<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    output_ids <span class="token operator">=</span> logits<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    res_text <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>output_ids<span class="token punctuation">)</span>    res_text <span class="token operator">=</span> res_text<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    output_text <span class="token operator">=</span> list<span class="token punctuation">(</span>raw_text<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>raw_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> raw_text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">:</span>            output_text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res_text<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"> "</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>output_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>给大家看看效果，运行我写好的代码，我们来看看会输出什么结果：</p><pre class="line-numbers language-text"><code class="language-text">请输入中文句子，要预测的字符用#代替：> 巴黎是#国的首都。> 巴黎是法国的首都。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p>就在上周，首位外部贡献者出现了，修复了LightSeq的词嵌入表示的bug。<br><img src="2.png" alt></p><blockquote><p>在这里我们非常欢迎感兴趣的同学来贡献自己的代码，包括但不局限于：修复bug、提供训练和推理样例、支持更多模型结构。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 模型加速 </tag>
            
            <tag> LightSeq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据分析，带你认识一个你从未见过的周杰伦</title>
      <link href="/2021/08/03/jay-chou/"/>
      <url>/2021/08/03/jay-chou/</url>
      
        <content type="html"><![CDATA[<p>周杰伦可以说是大多数90后的青春了，连我妈这种从来不咋看新闻的人也知道他。</p><p>你是否曾在初中时抄过他的歌词？你又是否曾经将他的歌词写进作文？</p><p>今天我就用大数据来分析一波他的所有歌词，带你认识一个你从未见过的周杰伦。<br><img src="2.png" alt></p><h2 id="获取周杰伦的所有歌词"><a href="#获取周杰伦的所有歌词" class="headerlink" title="获取周杰伦的所有歌词"></a>获取周杰伦的所有歌词</h2><p>这件事其实不难，我们写个代码从QQ音乐上自动收集就行了。说来也是心酸，以前一直用网易云音乐的，后来周杰伦版权没了，就只能投身了QQ音乐。</p><p>代码我都开源出来了，也不用大家自己运行，歌词文件我都放在下面了：<br><a href="https://github.com/godweiyang/lyric-crawler/tree/master/output" target="_blank" rel="noopener">https://github.com/godweiyang/lyric-crawler/tree/master/output</a></p><p>里面有两个歌词文件是关于周杰伦的：<code>周杰伦_歌词.txt</code>和<code>周杰伦_歌名.txt</code>，分别保存了他出道以来唱过的所有歌曲的歌词和按照专辑分类的歌曲名称，当然不包括演唱会和Live版本。</p><p>一共整整<strong>174</strong>首！这个数量已经是相当多了，当然这里面还包括了蔡依林和他合唱的两首歌：《骑士精神》和《布拉格广场》，还有李玟的《刀马旦》等等，我也都算进去了。</p><h2 id="谁作曲最多？"><a href="#谁作曲最多？" class="headerlink" title="谁作曲最多？"></a>谁作曲最多？</h2><p>经过简单统计可以惊人地发现，在174首歌曲中，周杰伦亲自作曲的歌曲竟然高达171首！</p><p>那三首非本人作曲的分别是袁咏琳作曲的《画沙》、派伟俊作曲的《Try》和Funky Monkey Babys作曲的《你是我的OK绷》。</p><p>老杰迷应该都知道杰伦的作曲是有多么的牛批。《夜曲》一响，上台领奖，颁奖词都说的词穷了。时至今日这首歌还是我的手机铃声。<br><img src="1.jpeg" alt></p><h2 id="谁作词最多？"><a href="#谁作词最多？" class="headerlink" title="谁作词最多？"></a>谁作词最多？</h2><p>统计下来可以发现作曲量排名前五位的分别是：</p><ul><li>方文山：96首</li><li>周杰伦：42首</li><li>黄俊郎：15首</li><li>徐若瑄：6首</li><li>宋健彰：4首</li></ul><p>大家应该都知道，周杰伦最好的搭档就是方文山。可以说方文山和周杰伦相互成就了对方，方文山的中国风配上周杰伦的曲简直就是天造地和。<br><img src="3.jpeg" alt></p><p>而杰伦自己作词的歌也不在少数，虽然很多人都吐槽他的《等你下课》和《不爱我就拉倒》歌词简单土味，但不可否认的是他也能写出《晴天》、《稻香》这样的神级歌曲。</p><h2 id="周杰伦最常用的词语"><a href="#周杰伦最常用的词语" class="headerlink" title="周杰伦最常用的词语"></a>周杰伦最常用的词语</h2><p>我对周杰伦所有的歌词统计了一下词频，生成了一个词云：<br><img src="4.png" alt></p><p>可以看到杰伦最常用的五个词语是：</p><ul><li>离开</li><li>回忆</li><li>微笑</li><li>世界</li><li>爱情</li></ul><p>周杰伦前期基本都是苦情歌，常使用这些词也不足为奇。比如《退后》中的“天空灰得像哭过，离开你以后，并没有，更自由”，《晴天》中的“好想再问一遍，你会等待还是离开”，《花海》中的“不要你离开，距离隔不开，思念变成海，在窗外进不来”，等等等等。</p><p>而到了后期，特别是结婚后，这种歌曲基本就销声匿迹了，更多的是《告白气球》这种甜歌：“花店玫瑰，名字写错谁，告白气球，风吹到对街，微笑在天上飞”。</p><h2 id="周杰伦最爱的季节"><a href="#周杰伦最爱的季节" class="headerlink" title="周杰伦最爱的季节"></a>周杰伦最爱的季节</h2><p>杰伦最爱什么季节呢？从他所有歌词中可以统计出，春夏秋冬四个季节分别出现的次数是：</p><ul><li>春天：7次</li><li>夏天：17次</li><li>秋天：33次</li><li>冬天：18次</li></ul><p>可以看出，周杰伦最爱写的季节其实还是秋天和冬天，这也符合他大多数歌曲都是苦情歌的实际情况。一首《枫》里的“缓缓飘落的枫叶像思念，为何挽回要赶在冬天来之前”，非常伤感。这首歌也成为了周杰伦唱的难度最高的歌之一，他本人几乎都没有在演唱会上唱过。</p><h2 id="周杰伦最爱的天气"><a href="#周杰伦最爱的天气" class="headerlink" title="周杰伦最爱的天气"></a>周杰伦最爱的天气</h2><p>粗略统计了一下，周杰伦最爱的三种天气是：</p><ul><li>雨天：150次</li><li>雪天：31次</li><li>晴天：12次</li></ul><p>其中雨天更是常客，《晴天》中的“刮风这天，我试过握着你手，但偏偏，雨渐渐，大到我看你不见”，《给我一首歌的时间》中的“雨淋湿了天空，毁得很讲究，你说你不懂，为何在这时牵手”。雨是最能寄托思念的物品，因此也成为了杰伦的最爱。</p><h2 id="周杰伦最爱的心情"><a href="#周杰伦最爱的心情" class="headerlink" title="周杰伦最爱的心情"></a>周杰伦最爱的心情</h2><p>人有四种心情，喜怒哀乐，分析周杰伦歌词中出现的心情词语，常用的有这么几个：</p><ul><li>喜（开心）：17次</li><li>怒（生气、怒火）：10次</li><li>哀（难过、忧伤）：41次</li><li>乐（快乐）：32次</li></ul><p>可以看出周杰伦表达最多的情感是哀，其次是乐，其实这也是前期苦情歌太多导致的。比如《黑色幽默》的第一句“难过是因为闷了很久，是因为想了太多，是心理起了作用”，作为第一张专辑中的主打歌曲，当时就已经走上了苦情歌的路了。</p><h2 id="2010年前后周杰伦歌曲对比"><a href="#2010年前后周杰伦歌曲对比" class="headerlink" title="2010年前后周杰伦歌曲对比"></a>2010年前后周杰伦歌曲对比</h2><p>网上很多人都持有一个观点，那就是从2010年周杰伦的《跨时代》专辑开始，他的专辑质量就出现了明显下滑。很多人还因此嘲讽，说什么江郎才尽之类的话。那么事实真的如此吗？我们还是用数据来说话。</p><h3 id="常用词语变化"><a href="#常用词语变化" class="headerlink" title="常用词语变化"></a>常用词语变化</h3><p>首先来看看2010年前后的最常用词语有哪些变化：<br><img src="5.png" alt><br><img src="6.png" alt></p><p>可以看到2010年以前最常用的词语是：离开、回忆、微笑、时间，而2010年之后最常用的词语变成了：hey、公公、世界、我会、微笑、靠靠。可以看出确实用词上2010年之后明显变得不如2010年之前了，这也正常，后期方文山为周杰伦作词也不如以前多了。</p><h3 id="作词变化"><a href="#作词变化" class="headerlink" title="作词变化"></a>作词变化</h3><p>那么方文山后期到底还为周杰伦作了多少词呢？我统计了2010年前后方文山和周杰伦各自作词的数量：</p><ul><li>2010年之前：方文山52首，周杰伦20首，总共93首</li><li>2010年之后：方文山29首，周杰伦16首，总共56首</li></ul><p>可以看到，周杰伦2010年之后作品数量减少很多，这几年甚至都不出专辑了。这也没办法，杰伦也不小了，但是他的神专已经足够多的让人难以超越了。</p><p>而2010年之后方文山虽然作词总数大幅减少，但是占比依然是很高的，同时周杰伦自己作词的占比提升不少。这也抨击了那些说周杰伦成名后就和方文山关系不好了之类的言论，最后一个专辑《周杰伦的床边故事》，方文山都还为周杰伦作词整整6首！</p><h2 id="做最好的自己"><a href="#做最好的自己" class="headerlink" title="做最好的自己"></a>做最好的自己</h2><p>周杰伦引领了2000年后中国的流行乐坛，开创了中国风歌曲的先河，很多歌曲现在听依然感觉领先整个时代。</p><p>他一直坚持自己的风格，很多歌都具有教育意义。《稻香》诉说了对家乡的思念，《止战之殇》诉说了对和平的渴望、《听妈妈的话》诉说了对妈妈的感恩，等等等等。《千山万水》更是被国家博物馆收藏，他也成为了北京奥运会唯一一位独唱的歌手，排面十足。</p><p>就像周杰伦在《土耳其冰淇淋》中唱的那样，炫技、牛批就完事了，要做就做不一样的自己：</p><blockquote><p>谁说拍中国风 一定要配灯笼<br>谁说写中国风 一定要商角徵羽宫<br>我干脆自己下车 指挥乐坛的交通<br>管他管他什么曲风</p></blockquote><p>这首也是《周杰伦的床边故事》专辑中周杰伦一手包办了作词、作曲、编曲的炫技歌曲。不像《告白气球》那样为了迎合大众而写的口水歌，这首歌表达出了周杰伦自己的个性，编曲也非常的厉害。</p><p><strong>感谢周杰伦，感谢你出现在了我的青春里。如果给我一次机会，我一定要去看一场你的演唱会！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 周杰伦 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析完吴亦凡的所有歌曲，我震惊了</title>
      <link href="/2021/08/01/lyric-crawler/"/>
      <url>/2021/08/01/lyric-crawler/</url>
      
        <content type="html"><![CDATA[<p>最近吴亦凡的事件闹的沸沸扬扬，相信不少吃瓜群众也都有所耳闻。</p><p>但咱们今天不谈他的事件到底怎么样，咱们来谈谈他的歌到底如何。</p><h2 id="收集歌词"><a href="#收集歌词" class="headerlink" title="收集歌词"></a>收集歌词</h2><p>我写了一个代码，从QQ音乐上收集了吴亦凡所有的歌词信息，自动汇总整理成一个txt文件，代码在下面：<br><a href="https://github.com/godweiyang/lyric-crawler" target="_blank" rel="noopener">https://github.com/godweiyang/lyric-crawler</a></p><p>使用方法非常简单，直接运行<code>python run.py</code>，然后输入你要收集的歌手名字即可，比如<code>吴亦凡</code>。</p><p>然后就会在<code>output</code>文件夹下自动生成两个文件<code>吴亦凡_歌词.txt</code>和<code>吴亦凡_歌名.txt</code>，里面分别是他的所有歌词和按专辑分类的所有歌名。</p><p>我们来看看歌词文件具体内容：<br><img src="1.png" alt></p><p>可以看到Kris Wu的《大碗宽面》和《bad girl》等经典作品都在其中。</p><h2 id="分析歌词"><a href="#分析歌词" class="headerlink" title="分析歌词"></a>分析歌词</h2><p>那么有了这些歌词可以干嘛呢？咱们可以做很多有趣的分析，比如今天就来分析一下吴亦凡的歌里面出现最多的词是什么？</p><p>我们可以用jieba对歌词文件进行分词，然后生成词云，相关代码我也都开源在了下面：<br><a href="https://github.com/godweiyang/wordcloud" target="_blank" rel="noopener">https://github.com/godweiyang/wordcloud</a></p><p>只需要运行<code>python create_word_cloud.py 吴亦凡_歌词.txt</code>即可，会自动生成两张词云的图片。</p><p>咱们打开看看效果：<br><img src="2.png" alt></p><p>可以看到，吴亦凡歌曲里出现最多的词竟然是<strong>girl</strong>！其次是一些语气词“yeah”之类的，果然是符合他的rapper身份啊。</p><p>这也就不难想象了，Kris Wu先生对girl如此的痴迷，做出现在的事情也在情理之中。</p><p>而且高频词里面大多都是英文，也表明了Kris Wu成为国际顶流的决心。</p><p>这次事件也为各大顶流和众多粉丝们敲响了警钟。顶流要洁身自好，树立良好的榜样形象。而粉丝们更应该去追求那些正能量、能够激励我们前进的顶流。</p><p>分析完了吴亦凡，我们再来看看我最爱的几位歌手都喜欢用什么词语。</p><p>首先就是我最爱的歌手<strong>周杰伦</strong>：<br><img src="3.png" alt></p><p>可以看到杰伦最爱用的词语是“离开、回忆、微笑、世界、爱情”。杰伦早期的作品主要以苦情歌为主，这也是我最爱的风格，比如“你要离开我知道很简单，你说依赖是我们的阻碍”。而结婚后杰伦就几乎再也没唱过苦情歌了，基本都是甜甜的情歌。</p><p>再来看看我最爱的女歌手<strong>邓紫棋</strong>：<br><img src="4.png" alt></p><p>紫棋最爱用的是“世界、快乐、再见、离开”，可以看到和杰伦有两个词是相同的，大家都喜欢用“世界、离开”等词语。</p><p>更多的歌手我就不在这里分析了，大家可以自己用我的代码收集歌词，然后进行分析。</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><strong>收集歌词：</strong><br><a href="https://github.com/godweiyang/lyric-crawler" target="_blank" rel="noopener">https://github.com/godweiyang/lyric-crawler</a></p><p><strong>生成词云：</strong><br><a href="https://github.com/godweiyang/wordcloud" target="_blank" rel="noopener">https://github.com/godweiyang/wordcloud</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>养成女友？我训练出了一个“杨超越”聊天机器人</title>
      <link href="/2021/07/24/chatbot/"/>
      <url>/2021/07/24/chatbot/</url>
      
        <content type="html"><![CDATA[<p>在上一期教程中，我演示了如何从零开始训练一个比较智障的聊天机器人。</p><p><a href="https://zhuanlan.zhihu.com/p/392175369" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/392175369</a></p><p>但是当时数据量太少，模型简单，完全没法用，只能回复训练集中出现过的句子。</p><p>而现在，完全体的聊天机器人终于诞生了，我把它命名为“杨超越”。这次可以随你提问什么了，她都能对答如流！</p><p>首先来看看回复的效果怎么样：</p><pre class="line-numbers language-text"><code class="language-text">聊天开始！（按q退出）我：很高兴认识你杨超越：我也很开心哦我：我喜欢你杨超越：我也喜欢你我：做我女朋友好不好？杨超越：哈哈,可以呢!我：我会一直支持超越妹妹的！杨超越：谢谢我们会一直努力的我：我什么时候有女朋友？杨超越：女朋友。。我：我什么时候脱单？杨超越：脱你妹啊!!我：q聊天结束！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到超越妹妹的回复还是非常流畅的，那她究竟是怎么诞生的呢？</p><p>完整的项目我都放在了下面，欢迎大家点个star，支持一波：<br><a href="https://github.com/godweiyang/chatbot" target="_blank" rel="noopener">https://github.com/godweiyang/chatbot</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这里我才用的是网上公开的小黄鸡聊天语料，大概有100万条左右，但是质量不是很高，都放在了<code>data</code>目录下。</p><p>模型采用标准的Transformer-big模型，输入你的提问句子，预测超越妹妹回复的句子，<code>config</code>目录下是训练和预测的配置文件。</p><p>模型训练采用NeurST训练库，主要基于TensorFlow，也支持PyTorch训练。模型快速推理采用LightSeq，可加速推理10倍以上，同时还能加速NeurST的训练，最高加速3倍。两者都是字节跳动AI Lab自研的，都已开源。</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>我们需要安装三样东西：</p><ul><li>SentencePiece的命令行版本和python版本，用来对句子进行分词。</li><li>NeurST深度学习训练库，用来训练Transformer模型。</li><li>LightSeq，用来加速模型推理。</li></ul><p>安装命令都很简单：</p><pre class="line-numbers language-shell"><code class="language-shell">git clone https://github.com/google/sentencepiece.git & cd sentencepiecemkdir build & cd buildcmake ..make -j $(nproc)sudo make installsudo ldconfig -vpip3 install lightseq neurst sentencepiece<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开始养成"><a href="#开始养成" class="headerlink" title="开始养成"></a>开始养成</h2><h3 id="生成词表"><a href="#生成词表" class="headerlink" title="生成词表"></a>生成词表</h3><p>首先我们需要从训练语料库中抽取出词表，为了方便，直接用SentencePiece来分词，生成大小为32k的词表。</p><pre class="line-numbers language-shell"><code class="language-shell">spm_train --input=./data/train/train.src,./data/train/train.trg \    --model_prefix=./data/spm \    --vocab_size=32000 \    --character_coverage=0.9995<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要指定训练语料路径<code>--input</code>、词表保存的路径前缀<code>--model_prefix</code>和词表大小<code>--vocab_size</code>。运行结束后会在<code>data</code>目录下生成<code>spm.model</code>和<code>spm.vocab</code>两个词表文件。一个是训练好的分词模型，一个是词表。</p><p>不过我也上传了生成好的TFRecord，大家也可以直接使用，跳过这一步。</p><p><strong>我上传了生成好的词表文件，大家可以直接使用，跳过这一步。</strong></p><h3 id="生成TFRecord"><a href="#生成TFRecord" class="headerlink" title="生成TFRecord"></a>生成TFRecord</h3><p>为了加快TensorFlow的训练速度，可以预先将训练语料用上面的词表处理成id，然后保存为TFRecord格式。这样模型训练时就可以直接读取id进行训练了，不需要做前面的分词操作。能大大加快训练速度，提升显卡利用率。</p><pre class="line-numbers language-shell"><code class="language-shell">python3 -m neurst.cli.create_tfrecords \    --config_paths configs/task_args.yml \    --dataset ParallelTextDataset \    --src_file ./data/train/train.src \    --trg_file ./data/train/train.trg \    --processor_id 0 \    --num_processors 1 \    --num_output_shards 32 \    --output_range_begin 0 \    --output_range_end 32 \    --output_template ./data/tfrecords/train.tfrecords-%5.5d-of-%5.5d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里主要需要指定训练集的路径<code>--src_file</code>和<code>--trg_file</code>，其它参数保持默认即可。生成完毕后会在<code>data/tfrecords</code>下面生成32个二进制文件，这就是处理好的训练数据了。</p><p><strong>我上传了生成好的TFRecord，大家可以直接使用，跳过这一步。</strong></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>有了词表，有了处理好的训练数据，接下来就是训练模型了。这里开启了XLA优化，使用Horovod分布式训练，加快训练速度。如果报错，可以去掉最后两行。</p><pre class="line-numbers language-shell"><code class="language-shell">python3 -m neurst.cli.run_exp \    --entry trainer \    --task translation \    --hparams_set transformer_big \    --model_dir ./models/transformer_big \    --config_paths ./configs/task_args.yml,./configs/train_args.yml,./configs/valid_args.yml \    --distribution_strategy horovod \    --enable_xla<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要指定的参数就是模型保存路径<code>model_dir</code>，其他都保持默认。训练好的模型会保存在<code>models/transformer_big</code>下，里面还细分为了<code>best</code>、<code>best_avg</code>等文件夹，用来存最好的模型、模型的平均值等等。</p><p>我在8张V100 32G显卡上训练了8个小时左右，如果你们自己训练的话还是比较耗时的。</p><p><strong>由于模型文件过大，之后我会找地方上传我训练好的模型文件，省去大家训练的时间。</strong></p><h3 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h3><p>训练好的模型会保存在<code>models/transformer_big</code>目录下，然后我们就可以开始预测啦。</p><pre class="line-numbers language-shell"><code class="language-shell">python3 -m neurst.cli.run_exp \    --entry predict \    --model_dir ./models/transformer_big \    --config_paths ./configs/predict_args.yml \    --output output.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这时候还没有交互功能，只能指定一个测试集文件，写在了模型预测的配置文件里<code>configs/predict_args.yml</code>。还可以指定<code>--output</code>，将回复结果输出到文件中。</p><p><strong>如果想直接体验交互式的对话聊天，可以跳过这一步。</strong></p><h3 id="模型导出为PB格式"><a href="#模型导出为PB格式" class="headerlink" title="模型导出为PB格式"></a>模型导出为PB格式</h3><p>如果直接用TensorFlow进行推理的话，速度非常慢，你就会感觉你和超越妹妹之间存在延时。所以可以将训练得到的ckpt模型导出为PB格式，然后就可以用LightSeq训练加速引擎进行快速推理了。</p><pre class="line-numbers language-shell"><code class="language-shell">python3 export/export.py \    --model_dir ./models/transformer_big \    --output_file ./models/transformer_big/model.pb \    --beam_size 4 \    --length_penalty 0.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要指定模型路径<code>--model_dir</code>和导出PB文件的路径<code>--output_file</code>，其它参数保持默认。最后会得到<code>models/transformer_big/model.pb</code>这个PB文件。</p><p><strong>由于模型文件过大，之后我会找地方上传我导出好的PB模型文件，这样大家就可以直接跳到最后一步了。</strong></p><h3 id="开始交互式聊天！"><a href="#开始交互式聊天！" class="headerlink" title="开始交互式聊天！"></a>开始交互式聊天！</h3><p>有了PB模型文件，就可以和超越妹妹开始聊天啦！</p><pre class="line-numbers language-shell"><code class="language-shell">python3 chat.py \    --spm_model ./data/spm.model \    --model_file ./models/transformer_big/model.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里需要指定两个路径。一是最开始训练好的分词模型<code>--spm_model</code>，用来将你输入的句子变成整数id。二是<code>--model_file</code>，也就是上一步中的PB格式模型文件。</p><p>聊天过程中随时可以按q退出聊天，你每说一句话，超越妹妹就会回复你一句。</p><h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>这次用到的NeurST训练库和LightSeq加速库都非常好用，从上面使用教程中也可以看出，几乎不需要你写什么代码就能使用起来。</p><p><strong>聊天机器人：</strong><br><a href="https://github.com/godweiyang/chatbot" target="_blank" rel="noopener">https://github.com/godweiyang/chatbot</a></p><p><strong>NeurST训练库：</strong><br><a href="https://github.com/bytedance/neurst" target="_blank" rel="noopener">https://github.com/bytedance/neurst</a></p><p><strong>LightSeq加速库：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> 模型训练 </tag>
            
            <tag> 模型加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始训练一个人工智障女友</title>
      <link href="/2021/07/21/transformer-code/"/>
      <url>/2021/07/21/transformer-code/</url>
      
        <content type="html"><![CDATA[<p>很多人工智能小白可能不知道那些高大上的语音助理、机器翻译或者聊天机器人都是怎么被创造出来的，也不知道一个深度学习模型是怎么从零开始搭建并运行起来的。</p><p>今天我就简单教大家如何从零开始搭建一个Transformer模型，并在自己的数据上训练起来。这个教程非常基础，所以训练出来的模型也很傻瓜，适合零基础小白长知识用。</p><p>首先整个训练流程可以分为下面几步，我们在后面章节依次介绍：</p><ol><li>处理数据</li><li>创建模型</li><li>创建损失函数</li><li>创建参数优化器</li><li>进行训练</li><li>进行预测</li></ol><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>这里我们需要使用到的有三样东西：</p><ul><li>训练深度学习模型需要用PyTorch。</li><li>对句子进行分词处理需要用Hugging Face的分词器。</li><li>搭建Transformer模型需要用LightSeq的快速模型、损失函数以及参数优化器。</li></ul><p>所以运行下面安装命令即可：</p><pre class="line-numbers language-shell"><code class="language-shell">pip3 install torch transformersgit clone https://github.com/bytedance/lightseq.gitcd lightseqpip3 install -e .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后导入必要的一些文件：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> transformers <span class="token keyword">import</span> BertTokenizer<span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training <span class="token keyword">import</span> LSTransformer<span class="token punctuation">,</span> LSCrossEntropyLayer<span class="token punctuation">,</span> LSAdam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><p>因为深度学习模型擅长和数字打交道，所以你需要将你说的话或者写的句子变成一串整数id，用来表示每个单词在词表中的序号。</p><p>这里我们使用到的是Hugging Face的分词器，它能帮你把输入的句子直接变成一串整数id，非常便捷。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 创建Hugging Face分词器</span>    tokenizer <span class="token operator">=</span> BertTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"bert-base-cased"</span><span class="token punctuation">)</span>    vocab_size <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>vocab_size    sep_id <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>        tokenizer<span class="token punctuation">.</span>special_tokens_map<span class="token punctuation">[</span><span class="token string">"sep_token"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> add_special_tokens<span class="token operator">=</span><span class="token boolean">False</span>    <span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 将源文本映射成整数id</span>    src_text <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">"What is the fastest library in the world?"</span><span class="token punctuation">,</span>        <span class="token string">"You are so pretty!"</span><span class="token punctuation">,</span>        <span class="token string">"What do you love me for?"</span><span class="token punctuation">,</span>        <span class="token string">"The sparrow outside the window hovering on the telephone pole."</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>    src_tokens <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_encode_plus<span class="token punctuation">(</span>        src_text<span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span>    <span class="token punctuation">)</span>    src_tokens <span class="token operator">=</span> src_tokens<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    batch_size<span class="token punctuation">,</span> src_seq_len <span class="token operator">=</span> src_tokens<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> src_tokens<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将目标文本映射成整数id</span>    trg_text <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">"I guess it must be LightSeq, because ByteDance is the fastest."</span><span class="token punctuation">,</span>        <span class="token string">"Thanks very much and you are pretty too."</span><span class="token punctuation">,</span>        <span class="token string">"Love your beauty, smart, virtuous and kind."</span><span class="token punctuation">,</span>        <span class="token string">"You said all this is very summery."</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>    trg_tokens <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_encode_plus<span class="token punctuation">(</span>        trg_text<span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span>    <span class="token punctuation">)</span>    trg_tokens <span class="token operator">=</span> trg_tokens<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    trg_seq_len <span class="token operator">=</span> trg_tokens<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将目标文本左移1个单词位置，用来作为解码端输出</span>    target <span class="token operator">=</span> trg_tokens<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    trg_tokens <span class="token operator">=</span> trg_tokens<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        tokenizer<span class="token punctuation">,</span>        src_text<span class="token punctuation">,</span>        src_tokens<span class="token punctuation">,</span>        trg_text<span class="token punctuation">,</span>        trg_tokens<span class="token punctuation">,</span>        target<span class="token punctuation">,</span>        sep_id<span class="token punctuation">,</span>        vocab_size<span class="token punctuation">,</span>        batch_size<span class="token punctuation">,</span>        src_seq_len<span class="token punctuation">,</span>        trg_seq_len<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中注释写的非常清楚了，只需要创建输入文本和输出文本即可，而标准的解码端输出就是输出文本左移一个单词，也就是每个单词输入后预测下一个单词是什么。</p><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>这里我们使用Transformer-base模型进行训练，使用LightSeq来创建Transformer模型非常简单，只需要创建一个配置，然后用它就能创建Transformer模型了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_model</span><span class="token punctuation">(</span>vocab_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    transformer_config <span class="token operator">=</span> LSTransformer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        model<span class="token operator">=</span><span class="token string">"transformer-base"</span><span class="token punctuation">,</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">2048</span><span class="token punctuation">,</span>        max_seq_len<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>        vocab_size<span class="token operator">=</span>vocab_size<span class="token punctuation">,</span>        padding_idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        num_encoder_layer<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>        num_decoder_layer<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    model <span class="token operator">=</span> LSTransformer<span class="token punctuation">(</span>transformer_config<span class="token punctuation">)</span>    model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>half<span class="token punctuation">,</span> device<span class="token operator">=</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> model<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建损失函数"><a href="#创建损失函数" class="headerlink" title="创建损失函数"></a>创建损失函数</h2><p>这里我们使用交叉熵损失函数，使用LightSeq来创建同样非常简单，只需要创建一个配置。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_criterion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ce_config <span class="token operator">=</span> LSCrossEntropyLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">2048</span><span class="token punctuation">,</span>        padding_idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        epsilon<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> LSCrossEntropyLayer<span class="token punctuation">(</span>ce_config<span class="token punctuation">)</span>    loss_fn<span class="token punctuation">.</span>to<span class="token punctuation">(</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>half<span class="token punctuation">,</span> device<span class="token operator">=</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> loss_fn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建参数优化器"><a href="#创建参数优化器" class="headerlink" title="创建参数优化器"></a>创建参数优化器</h2><p>使用LightSeq来创建参数优化器的过程和平常使用PyTorch创建一模一样，只要一行代码就行了。</p><pre class="line-numbers language-python"><code class="language-python">opt <span class="token operator">=</span> LSAdam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="进行训练"><a href="#进行训练" class="headerlink" title="进行训练"></a>进行训练</h2><p>模型训练过程也和平常一模一样，这里我们训练2000轮。因为训练过程中需要知道目标端的文本是什么，所以需要输入源端和目标端两个文本。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"========================TRAIN========================"</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    output <span class="token operator">=</span> model<span class="token punctuation">(</span>src_tokens<span class="token punctuation">,</span> trg_tokens<span class="token punctuation">)</span>    loss<span class="token punctuation">,</span> _ <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token keyword">if</span> epoch <span class="token operator">%</span> <span class="token number">200</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"epoch {:03d}: {:.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    opt<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h2><p>在模型训练好之后，我们用它进行预测。这时候你就不知道目标端的文本是什么了，你只能输入源端文本，然后目标端输入一个句子开始标记，后面的目标端文本都得通过模型预测得到。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"========================TEST========================"</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获得编码器的输出和掩码表示</span>encoder_out<span class="token punctuation">,</span> encoder_padding_mask <span class="token operator">=</span> model<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>src_tokens<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用目标端文本的第一个单词作为解码器的初始输入，预测后面单词</span>predict_tokens <span class="token operator">=</span> trg_tokens<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>trg_seq_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 使用缓存来加速解码速度</span>    output <span class="token operator">=</span> model<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>        predict_tokens<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> encoder_out<span class="token punctuation">,</span> encoder_padding_mask<span class="token punctuation">,</span> cache    <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 预测下一个单词</span>    output <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>output<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将预测得到的单词和历史预测拼接，作为最终预测结果</span>    predict_tokens <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>predict_tokens<span class="token punctuation">,</span> output<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将结束符后的单词都标记为结束符</span>mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>predict_tokens<span class="token punctuation">,</span> sep_id<span class="token punctuation">)</span><span class="token punctuation">.</span>int<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>predict_tokens <span class="token operator">=</span> predict_tokens<span class="token punctuation">.</span>masked_fill<span class="token punctuation">(</span>mask <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> sep_id<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将预测结果的id还原为文本</span>predict_text <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>predict_tokens<span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>>> source text"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>src_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>>> target text"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>trg_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>>> predict text"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>predict_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码如下，保存在<code>run.py</code>里面，然后运行下面命令就行了：</p><pre class="line-numbers language-shell"><code class="language-shell">python3 run.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> transformers <span class="token keyword">import</span> BertTokenizer<span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training <span class="token keyword">import</span> LSTransformer<span class="token punctuation">,</span> LSCrossEntropyLayer<span class="token punctuation">,</span> LSAdam<span class="token keyword">def</span> <span class="token function">create_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 创建Hugging Face分词器</span>    tokenizer <span class="token operator">=</span> BertTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"bert-base-cased"</span><span class="token punctuation">)</span>    vocab_size <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>vocab_size    sep_id <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>        tokenizer<span class="token punctuation">.</span>special_tokens_map<span class="token punctuation">[</span><span class="token string">"sep_token"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> add_special_tokens<span class="token operator">=</span><span class="token boolean">False</span>    <span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 将源文本映射成整数id</span>    src_text <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">"What is the fastest library in the world?"</span><span class="token punctuation">,</span>        <span class="token string">"You are so pretty!"</span><span class="token punctuation">,</span>        <span class="token string">"What do you love me for?"</span><span class="token punctuation">,</span>        <span class="token string">"The sparrow outside the window hovering on the telephone pole."</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>    src_tokens <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_encode_plus<span class="token punctuation">(</span>        src_text<span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span>    <span class="token punctuation">)</span>    src_tokens <span class="token operator">=</span> src_tokens<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    batch_size<span class="token punctuation">,</span> src_seq_len <span class="token operator">=</span> src_tokens<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> src_tokens<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将目标文本映射成整数id</span>    trg_text <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">"I guess it must be LightSeq, because ByteDance is the fastest."</span><span class="token punctuation">,</span>        <span class="token string">"Thanks very much and you are pretty too."</span><span class="token punctuation">,</span>        <span class="token string">"Love your beauty, smart, virtuous and kind."</span><span class="token punctuation">,</span>        <span class="token string">"You said all this is very summery."</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>    trg_tokens <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_encode_plus<span class="token punctuation">(</span>        trg_text<span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span>    <span class="token punctuation">)</span>    trg_tokens <span class="token operator">=</span> trg_tokens<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    trg_seq_len <span class="token operator">=</span> trg_tokens<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将目标文本左移1个单词位置，用来作为解码端输出</span>    target <span class="token operator">=</span> trg_tokens<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    trg_tokens <span class="token operator">=</span> trg_tokens<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        tokenizer<span class="token punctuation">,</span>        src_text<span class="token punctuation">,</span>        src_tokens<span class="token punctuation">,</span>        trg_text<span class="token punctuation">,</span>        trg_tokens<span class="token punctuation">,</span>        target<span class="token punctuation">,</span>        sep_id<span class="token punctuation">,</span>        vocab_size<span class="token punctuation">,</span>        batch_size<span class="token punctuation">,</span>        src_seq_len<span class="token punctuation">,</span>        trg_seq_len<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">create_model</span><span class="token punctuation">(</span>vocab_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    transformer_config <span class="token operator">=</span> LSTransformer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        model<span class="token operator">=</span><span class="token string">"transformer-base"</span><span class="token punctuation">,</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">2048</span><span class="token punctuation">,</span>        max_seq_len<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>        vocab_size<span class="token operator">=</span>vocab_size<span class="token punctuation">,</span>        padding_idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        num_encoder_layer<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>        num_decoder_layer<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    model <span class="token operator">=</span> LSTransformer<span class="token punctuation">(</span>transformer_config<span class="token punctuation">)</span>    model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>half<span class="token punctuation">,</span> device<span class="token operator">=</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> model<span class="token keyword">def</span> <span class="token function">create_criterion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    ce_config <span class="token operator">=</span> LSCrossEntropyLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">2048</span><span class="token punctuation">,</span>        padding_idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>        epsilon<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> LSCrossEntropyLayer<span class="token punctuation">(</span>ce_config<span class="token punctuation">)</span>    loss_fn<span class="token punctuation">.</span>to<span class="token punctuation">(</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>half<span class="token punctuation">,</span> device<span class="token operator">=</span>torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> loss_fn<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token punctuation">(</span>        tokenizer<span class="token punctuation">,</span>        src_text<span class="token punctuation">,</span>        src_tokens<span class="token punctuation">,</span>        trg_text<span class="token punctuation">,</span>        trg_tokens<span class="token punctuation">,</span>        target<span class="token punctuation">,</span>        sep_id<span class="token punctuation">,</span>        vocab_size<span class="token punctuation">,</span>        batch_size<span class="token punctuation">,</span>        src_seq_len<span class="token punctuation">,</span>        trg_seq_len<span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token operator">=</span> create_data<span class="token punctuation">(</span><span class="token punctuation">)</span>    model <span class="token operator">=</span> create_model<span class="token punctuation">(</span>vocab_size<span class="token punctuation">)</span>    loss_fn <span class="token operator">=</span> create_criterion<span class="token punctuation">(</span><span class="token punctuation">)</span>    opt <span class="token operator">=</span> LSAdam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"========================TRAIN========================"</span><span class="token punctuation">)</span>    model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        output <span class="token operator">=</span> model<span class="token punctuation">(</span>src_tokens<span class="token punctuation">,</span> trg_tokens<span class="token punctuation">)</span>        loss<span class="token punctuation">,</span> _ <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        <span class="token keyword">if</span> epoch <span class="token operator">%</span> <span class="token number">200</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"epoch {:03d}: {:.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        opt<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"========================TEST========================"</span><span class="token punctuation">)</span>    model<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获得编码器的输出和掩码表示</span>    encoder_out<span class="token punctuation">,</span> encoder_padding_mask <span class="token operator">=</span> model<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>src_tokens<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 使用目标端文本的第一个单词作为解码器的初始输入，预测后面单词</span>    predict_tokens <span class="token operator">=</span> trg_tokens<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>    cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>trg_seq_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 使用缓存来加速解码速度</span>        output <span class="token operator">=</span> model<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>            predict_tokens<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> encoder_out<span class="token punctuation">,</span> encoder_padding_mask<span class="token punctuation">,</span> cache        <span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 预测下一个单词</span>        output <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>output<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 将预测得到的单词和历史预测拼接，作为最终预测结果</span>        predict_tokens <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>predict_tokens<span class="token punctuation">,</span> output<span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将结束符后的单词都标记为结束符</span>    mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>cumsum<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>predict_tokens<span class="token punctuation">,</span> sep_id<span class="token punctuation">)</span><span class="token punctuation">.</span>int<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    predict_tokens <span class="token operator">=</span> predict_tokens<span class="token punctuation">.</span>masked_fill<span class="token punctuation">(</span>mask <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> sep_id<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将预测结果的id还原为文本</span>    predict_text <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>predict_tokens<span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>>> source text"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>src_text<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>>> target text"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>trg_text<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>>>> predict text"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>predict_text<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果运行顺利的话，你会看到下面的输出信息：</p><pre class="line-numbers language-text"><code class="language-text">========================TRAIN========================TransformerEmbeddingLayer #0 bind weights and grads.TransformerEncoderLayer #0 bind weights and grads.TransformerEncoderLayer #1 bind weights and grads.TransformerEncoderLayer #2 bind weights and grads.TransformerEncoderLayer #3 bind weights and grads.TransformerEncoderLayer #4 bind weights and grads.TransformerEncoderLayer #5 bind weights and grads.TransformerEmbeddingLayer #1 bind weights and grads.TransformerDecoderLayer #0 bind weights and grads.Decoder layer #0 allocate encdec_kv memoryTransformerDecoderLayer #1 bind weights and grads.TransformerDecoderLayer #2 bind weights and grads.TransformerDecoderLayer #3 bind weights and grads.TransformerDecoderLayer #4 bind weights and grads.TransformerDecoderLayer #5 bind weights and grads.epoch 000: 725.560epoch 200: 96.252epoch 400: 15.151epoch 600: 5.770epoch 800: 3.212epoch 1000: 1.748epoch 1200: 0.930epoch 1400: 0.457epoch 1600: 0.366epoch 1800: 0.299========================TEST========================>>>>> source textWhat is the fastest library in the world?You are so pretty!What do you love me for?The sparrow outside the window hovering on the telephone pole.>>>>> target textI guess it must be LightSeq, because ByteDance is the fastest.Thanks very much and you are pretty too.Love your beauty, smart, virtuous and kind.You said all this is very summery.>>>>> predict textI guess it must be LightSeq, because ByteDance is the fastest.Thanks very much and you are pretty too.Love your beauty, smart, virtuous and kind.You said all this is very summery.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，最后的预测文本和真实的目标端文本完全一致。</p><p>当然这里的例子非常简单，输入输出只有4句话。如果你有大量的对话数据集的话，你就可以训练出一个非常完美的聊天机器人啦，还愁啥没有女朋友呢？</p><p>如果觉得LightSeq比较好用，别忘了给个star，是给我们最大的支持。</p><p><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Transformer </tag>
            
            <tag> 模型训练 </tag>
            
            <tag> 模型加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练BERT，我只花了一半的时间</title>
      <link href="/2021/07/13/huggingface-speedup/"/>
      <url>/2021/07/13/huggingface-speedup/</url>
      
        <content type="html"><![CDATA[<p>相信很多人都知道Hugging Face，也都用过它的Transformers预训练语言模型，但你们有没有觉得它训练的有点太慢了呢？</p><p>这时候，字节第二快的男人要站出来了（第一快是我mentor），手把手教你怎么让训练时间缩短一半。</p><h2 id="训练BERT"><a href="#训练BERT" class="headerlink" title="训练BERT"></a>训练BERT</h2><p>首先我们要安装Transformers库，这很简单：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install transformers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们直接把官方的例子拷贝下来，这里我们用的是GLUE任务，地址是<a href="https://github.com/huggingface/transformers/blob/master/examples/pytorch/text-classification/run_glue.py" target="_blank" rel="noopener">https://github.com/huggingface/transformers/blob/master/examples/pytorch/text-classification/run_glue.py</a>。因为代码太长了，这里就不放了，拷贝下来后文件名是<code>run_glue.py</code>。</p><p>接着我们就可以直接运行这个代码了，我们采用mrpc数据集，开启FP16训练，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">python run_glue.py \  --model_name_or_path bert-base-cased \  --task_name mrpc \  --do_train \  --do_eval \  --max_seq_length 128 \  --per_device_train_batch_size 32 \  --num_train_epochs 3 \  --output_dir /tmp/mrpc/ \  --overwrite_output_dir \  --fp16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我这里是单卡训练的，训练完后输出如下：</p><pre class="line-numbers language-txt"><code class="language-txt">***** train metrics *****  epoch                    =        3.0  train_loss               =     0.3921  train_runtime            = 0:00:45.06  train_samples            =       3668  train_samples_per_second =    244.166  train_steps_per_second   =      7.655<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，训练总共耗时<strong>45秒</strong>，是不是有点等不及了呢？</p><h2 id="加速训练"><a href="#加速训练" class="headerlink" title="加速训练"></a>加速训练</h2><p>首先我们需要安装训练加速库，这里我们用到的是LightSeq，项目地址是<a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a>。不过我们还是直接<code>pip</code>安装：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install lightseq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们需要做的就是将Hugging Face的BERT替换成LightSeq的BERT，代码如下，放在文件<code>replace_module.py</code>中。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>pytorch<span class="token punctuation">.</span>transformer_encoder_layer <span class="token keyword">import</span> <span class="token punctuation">(</span>    LSTransformerEncoderLayer<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">LSHFTransformerEncoderLayer</span><span class="token punctuation">(</span>LSTransformerEncoderLayer<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>LSHFTransformerEncoderLayer<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> hidden_states<span class="token punctuation">,</span> encoder_padding_mask<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        encoder_padding_mask <span class="token operator">/=</span> <span class="token operator">-</span><span class="token number">10000.0</span>        output <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>forward<span class="token punctuation">(</span>hidden_states<span class="token punctuation">,</span> encoder_padding_mask<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>output<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">gen_ls_bert_config</span><span class="token punctuation">(</span>training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">:</span>    bert_config <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>        max_seq_len<span class="token operator">=</span>config<span class="token punctuation">.</span>max_position_embeddings<span class="token punctuation">,</span>        hidden_size<span class="token operator">=</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span>        intermediate_size<span class="token operator">=</span>config<span class="token punctuation">.</span>intermediate_size<span class="token punctuation">,</span>        nhead<span class="token operator">=</span>config<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">,</span>        attn_prob_dropout_ratio<span class="token operator">=</span>config<span class="token punctuation">.</span>attention_probs_dropout_prob<span class="token punctuation">,</span>        activation_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        hidden_dropout_ratio<span class="token operator">=</span>config<span class="token punctuation">.</span>hidden_dropout_prob<span class="token punctuation">,</span>        pre_layer_norm<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span>training_args<span class="token punctuation">.</span>fp16<span class="token punctuation">,</span>        local_rank<span class="token operator">=</span>training_args<span class="token punctuation">.</span>local_rank<span class="token punctuation">,</span>    <span class="token punctuation">)</span>    <span class="token keyword">return</span> bert_config<span class="token keyword">def</span> <span class="token function">inject_ls_enc_layer</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>config<span class="token punctuation">.</span>num_hidden_layers<span class="token punctuation">)</span><span class="token punctuation">:</span>        bert_config <span class="token operator">=</span> gen_ls_bert_config<span class="token punctuation">(</span>training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span>        model<span class="token punctuation">.</span>bert<span class="token punctuation">.</span>encoder<span class="token punctuation">.</span>layer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> LSHFTransformerEncoderLayer<span class="token punctuation">(</span>bert_config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里<code>LSHFTransformerEncoderLayer</code>是继承的LightSeq中的<code>LSTransformerEncoderLayer</code>类，然后重写了<code>forward</code>函数。原因是Hugging Face的输入格式和LightSeq略有不同，需要在<code>forward</code>之前转换一下。</p><p><code>gen_ls_bert_config</code>函数是用来定义LightSeq的encoder参数配置，这里直接从Hugging Face的主函数入口获取即可。</p><p><code>inject_ls_enc_layer</code>函数就是用来替换BERT中的每一层encoder的，首先定义每一层的参数配置，然后用<code>LSHFTransformerEncoderLayer</code>类去替换原始的encoder层即可。</p><p>然后我们打开<code>run_glue.py</code>，在头文件处加上<code>inject_ls_enc_layer</code>的引用：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> replace_module <span class="token keyword">import</span> inject_ls_enc_layer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后在定义完model后，将model中的encoder替换即可，利用上面引用的替换函数：</p><pre class="line-numbers language-python"><code class="language-python">model <span class="token operator">=</span> AutoModelForSequenceClassification<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>    model_args<span class="token punctuation">.</span>model_name_or_path<span class="token punctuation">,</span>    from_tf<span class="token operator">=</span>bool<span class="token punctuation">(</span><span class="token string">".ckpt"</span> <span class="token keyword">in</span> model_args<span class="token punctuation">.</span>model_name_or_path<span class="token punctuation">)</span><span class="token punctuation">,</span>    config<span class="token operator">=</span>config<span class="token punctuation">,</span>    cache_dir<span class="token operator">=</span>model_args<span class="token punctuation">.</span>cache_dir<span class="token punctuation">,</span>    revision<span class="token operator">=</span>model_args<span class="token punctuation">.</span>model_revision<span class="token punctuation">,</span>    use_auth_token<span class="token operator">=</span><span class="token boolean">True</span> <span class="token keyword">if</span> model_args<span class="token punctuation">.</span>use_auth_token <span class="token keyword">else</span> None<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 在model定义后立刻替换</span>inject_ls_enc_layer<span class="token punctuation">(</span>model<span class="token punctuation">,</span> training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们重新运行上一次运行的命令：</p><pre class="line-numbers language-shell"><code class="language-shell">python run_glue.py \  --model_name_or_path bert-base-cased \  --task_name mrpc \  --do_train \  --do_eval \  --max_seq_length 128 \  --per_device_train_batch_size 32 \  --num_train_epochs 3 \  --output_dir /tmp/mrpc/ \  --overwrite_output_dir \  --fp16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终输出如下：</p><pre class="line-numbers language-txt"><code class="language-txt">***** train metrics *****  epoch                    =        3.0  train_loss               =     0.6077  train_runtime            = 0:00:25.08  train_samples            =       3668  train_samples_per_second =    438.603  train_steps_per_second   =     13.751<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次运行时间只有<strong>25秒</strong>！不愧是字节最快的男人。</p><h2 id="加载预训练参数"><a href="#加载预训练参数" class="headerlink" title="加载预训练参数"></a>加载预训练参数</h2><p>有眼尖的小伙伴可能发现了，上面加速后效果变差了呀。没错，因为新建了encoder类之后，参数都是随机初始化的了，所以要重新加载一下预训练参数。</p><p>LightSeq的encoder类初始化的时候提供了预训练参数初始化的选项，我们只需要将预训练参数从Hugging Face的BERT中提取出来即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_hf_bert_enc_layer_params</span><span class="token punctuation">(</span>layer<span class="token punctuation">)</span><span class="token punctuation">:</span>    init_ws <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    init_bs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>self<span class="token punctuation">.</span>query<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>self<span class="token punctuation">.</span>query<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>self<span class="token punctuation">.</span>key<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>self<span class="token punctuation">.</span>key<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>self<span class="token punctuation">.</span>value<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>self<span class="token punctuation">.</span>value<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>output<span class="token punctuation">.</span>dense<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>output<span class="token punctuation">.</span>dense<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>output<span class="token punctuation">.</span>LayerNorm<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>attention<span class="token punctuation">.</span>output<span class="token punctuation">.</span>LayerNorm<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>intermediate<span class="token punctuation">.</span>dense<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>intermediate<span class="token punctuation">.</span>dense<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>output<span class="token punctuation">.</span>dense<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>output<span class="token punctuation">.</span>dense<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_ws<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>output<span class="token punctuation">.</span>LayerNorm<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    init_bs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer<span class="token punctuation">.</span>output<span class="token punctuation">.</span>LayerNorm<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> init_ws<span class="token punctuation">,</span> init_bs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意参数在列表中的顺序不能错了，然后将这两个列表加入到<code>LSHFTransformerEncoderLayer</code>类的初始化参数中去：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">inject_ls_enc_layer</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>config<span class="token punctuation">.</span>num_hidden_layers<span class="token punctuation">)</span><span class="token punctuation">:</span>        bert_config <span class="token operator">=</span> gen_ls_bert_config<span class="token punctuation">(</span>training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 提取预训练参数</span>        init_ws<span class="token punctuation">,</span> init_bs <span class="token operator">=</span> get_hf_bert_enc_layer_params<span class="token punctuation">(</span>model<span class="token punctuation">.</span>bert<span class="token punctuation">.</span>encoder<span class="token punctuation">.</span>layer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 利用预训练参数进行初始化</span>        model<span class="token punctuation">.</span>bert<span class="token punctuation">.</span>encoder<span class="token punctuation">.</span>layer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> LSHFTransformerEncoderLayer<span class="token punctuation">(</span>            bert_config<span class="token punctuation">,</span> init_ws<span class="token punctuation">,</span> init_bs        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着运行命令不变，效果就上来啦。</p><h2 id="和竞品比如何？"><a href="#和竞品比如何？" class="headerlink" title="和竞品比如何？"></a>和竞品比如何？</h2><p>另一款知名的训练加速库DeepSpeed你们可能也听过，那和它比速度怎么样呢？</p><p>Hugging Face已经内置了DeepSpeed，可以直接开启。不过它并没有替换掉encoder，所以模型还是用PyTorch写的，速度依然很慢。因此我们需要手动替换一下encoder。</p><p>代码和上面类似，也是定义参数配置和encoder类：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> deepspeed<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>transformer <span class="token keyword">import</span> <span class="token punctuation">(</span>    DeepSpeedTransformerConfig<span class="token punctuation">,</span>    DeepSpeedTransformerLayer<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">gen_ds_bert_config</span><span class="token punctuation">(</span>training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">:</span>    bert_config <span class="token operator">=</span> DeepSpeedTransformerConfig<span class="token punctuation">(</span>        batch_size<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>        hidden_size<span class="token operator">=</span>config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span>        intermediate_size<span class="token operator">=</span>config<span class="token punctuation">.</span>intermediate_size<span class="token punctuation">,</span>        heads<span class="token operator">=</span>config<span class="token punctuation">.</span>num_attention_heads<span class="token punctuation">,</span>        attn_dropout_ratio<span class="token operator">=</span>config<span class="token punctuation">.</span>attention_probs_dropout_prob<span class="token punctuation">,</span>        hidden_dropout_ratio<span class="token operator">=</span>config<span class="token punctuation">.</span>hidden_dropout_prob<span class="token punctuation">,</span>        num_hidden_layers<span class="token operator">=</span>config<span class="token punctuation">.</span>num_hidden_layers<span class="token punctuation">,</span>        initializer_range<span class="token operator">=</span><span class="token number">0.02</span><span class="token punctuation">,</span>        layer_norm_eps<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span>training_args<span class="token punctuation">.</span>local_rank<span class="token punctuation">,</span>        fp16<span class="token operator">=</span>training_args<span class="token punctuation">.</span>fp16<span class="token punctuation">,</span>        pre_layer_norm<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>        huggingface<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        training<span class="token operator">=</span><span class="token boolean">True</span>    <span class="token punctuation">)</span>    <span class="token keyword">return</span> bert_config<span class="token keyword">def</span> <span class="token function">inject_ds_enc_layer</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>config<span class="token punctuation">.</span>num_hidden_layers<span class="token punctuation">)</span><span class="token punctuation">:</span>        bert_config <span class="token operator">=</span> gen_ds_bert_config<span class="token punctuation">(</span>training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span>        model<span class="token punctuation">.</span>bert<span class="token punctuation">.</span>encoder<span class="token punctuation">.</span>layer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> DeepSpeedTransformerLayer<span class="token punctuation">(</span>bert_config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>run_glue.py</code>里引用<code>inject_ds_enc_layer</code>替换函数，并对model进行替换：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> replace_module <span class="token keyword">import</span> inject_ds_enc_layermodel <span class="token operator">=</span> AutoModelForSequenceClassification<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>    model_args<span class="token punctuation">.</span>model_name_or_path<span class="token punctuation">,</span>    from_tf<span class="token operator">=</span>bool<span class="token punctuation">(</span><span class="token string">".ckpt"</span> <span class="token keyword">in</span> model_args<span class="token punctuation">.</span>model_name_or_path<span class="token punctuation">)</span><span class="token punctuation">,</span>    config<span class="token operator">=</span>config<span class="token punctuation">,</span>    cache_dir<span class="token operator">=</span>model_args<span class="token punctuation">.</span>cache_dir<span class="token punctuation">,</span>    revision<span class="token operator">=</span>model_args<span class="token punctuation">.</span>model_revision<span class="token punctuation">,</span>    use_auth_token<span class="token operator">=</span><span class="token boolean">True</span> <span class="token keyword">if</span> model_args<span class="token punctuation">.</span>use_auth_token <span class="token keyword">else</span> None<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 在model定义后立刻替换</span>inject_ds_enc_layer<span class="token punctuation">(</span>model<span class="token punctuation">,</span> training_args<span class="token punctuation">,</span> config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们还需要定义一个DeepSpeed需要用到的运行参数配置<code>ds_config.json</code>：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"train_micro_batch_size_per_gpu"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>  <span class="token property">"optimizer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"AdamW"</span><span class="token punctuation">,</span>    <span class="token property">"params"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"lr"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>      <span class="token property">"betas"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token number">0.9</span><span class="token punctuation">,</span>        <span class="token number">0.999</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"eps"</span><span class="token operator">:</span> <span class="token number">1e-8</span><span class="token punctuation">,</span>      <span class="token property">"weight_decay"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>      <span class="token property">"torch_adam"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"scheduler"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"WarmupDecayLR"</span><span class="token punctuation">,</span>    <span class="token property">"params"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"warmup_num_steps"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>      <span class="token property">"warmup_min_lr"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>      <span class="token property">"warmup_max_lr"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>      <span class="token property">"total_num_steps"</span><span class="token operator">:</span> <span class="token string">"auto"</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"gradient_clipping"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>  <span class="token property">"fp16"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"enabled"</span><span class="token operator">:</span> <span class="token string">"auto"</span><span class="token punctuation">,</span>    <span class="token property">"loss_scale"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token property">"initial_scale_power"</span><span class="token operator">:</span> <span class="token number">7</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行命令需要稍稍修改，采用DeepSpeed的启动器：</p><pre class="line-numbers language-shell"><code class="language-shell">deepspeed --num_gpus=1 run_glue.py \  --model_name_or_path bert-base-cased \  --task_name mrpc \  --do_train \  --do_eval \  --max_seq_length 128 \  --per_device_train_batch_size 32 \  --num_train_epochs 3 \  --output_dir /tmp/mrpc/ \  --overwrite_output_dir \  --fp16 \  --deepspeed ds_config.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果如下：</p><pre class="line-numbers language-txt"><code class="language-txt">***** train metrics *****  epoch                    =        3.0  train_loss               =     0.5865  train_runtime            = 0:00:37.17  train_samples            =       3668  train_samples_per_second =    296.032  train_steps_per_second   =      9.281<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现DeepSpeed用了整整<strong>37秒</strong>才训练完，和LightSeq的<strong>25秒</strong>相比还是有差距的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最终对比下来，Hugging Face花了<strong>45秒</strong>训练完成，DeepSpeed花了<strong>37秒</strong>，而LightSeq只花了<strong>25秒</strong>。</p><p><strong>项目地址：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p><strong>技术原理：</strong><br><a href="https://zhuanlan.zhihu.com/p/383657837" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/383657837</a></p><p><strong>其它使用例子：</strong><br><a href="https://zhuanlan.zhihu.com/p/382961951" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/382961951</a></p><p>如果你对字节的技术比较感兴趣，欢迎加入我们，一起开发牛X的项目，做最快的男人。 </p><p><strong>我的内推码：</strong><br>A7FSJMK<br><strong>内推链接：</strong><br><a href="https://jobs.toutiao.com/s/egpham5" target="_blank" rel="noopener">https://jobs.toutiao.com/s/egpham5</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
            <tag> BERT </tag>
            
            <tag> 训练加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动秋招提前批开始，不用笔试，只剩一个月！</title>
      <link href="/2021/07/08/bytedance-hire-2022/"/>
      <url>/2021/07/08/bytedance-hire-2022/</url>
      
        <content type="html"><![CDATA[<blockquote><p>盼星星盼月亮，字节跳动2022届秋招提前批终于开始啦！</p></blockquote><h2 id="提前批优势"><a href="#提前批优势" class="headerlink" title="提前批优势"></a>提前批优势</h2><ul><li><strong>所有岗位无笔试，直接面试！</strong>  </li><li><strong>提前批投递结果不影响秋招，相当于多一次投递机会！</strong>  </li></ul><h2 id="内推时间："><a href="#内推时间：" class="headerlink" title="内推时间："></a>内推时间：</h2><p>2021年 7月8日 - 8月1日（<strong>只有一个月不到！</strong>）</p><h2 id="招聘对象："><a href="#招聘对象：" class="headerlink" title="招聘对象："></a>招聘对象：</h2><p>2021年9月-2022年8月期间毕业，且最高学历毕业后无全职工作经验的学生。</p><h2 id="职位类别："><a href="#职位类别：" class="headerlink" title="职位类别："></a>职位类别：</h2><p><strong>研发</strong>类校招岗位</p><h2 id="投递方式"><a href="#投递方式" class="headerlink" title="投递方式"></a>投递方式</h2><p>所以抓紧这一个月不到的时间，赶紧来投递吧。不用给我简历，直接官网投递！</p><h3 id="扫描二维码"><a href="#扫描二维码" class="headerlink" title="扫描二维码"></a>扫描二维码</h3><p>可以直接扫描下面的二维码（注意扫描<strong>校招</strong>那一个！！！）：<br><img src="hire.jpeg" alt></p><h3 id="点击链接"><a href="#点击链接" class="headerlink" title="点击链接"></a>点击链接</h3><p>我的内推码:<br><strong>A7FSJMK</strong>  </p><p>投递链接:<br><a href="https://jobs.toutiao.com/s/egpham5" target="_blank" rel="noopener">https://jobs.toutiao.com/s/egpham5</a></p><p>最后一定要注意：<br><strong>要用我的内推码！！！</strong><br><strong>要用我的内推码！！！</strong><br><strong>要用我的内推码！！！</strong>  </p><p>不然我没法帮你查进度、催进度！</p><h2 id="面试算法题福利"><a href="#面试算法题福利" class="headerlink" title="面试算法题福利"></a>面试算法题福利</h2><p>去年我找实习的时候，连续刷了110天的leetcode，最后才得以进入字节。我把当时刷的题目都写了详细的题解，一题多解，汇总在下面的文章里了：<br><a href="http://localhost:4000/2020/04/24/leetcode-conclusions-110/" target="_blank" rel="noopener">https://godweiyang.com/2020/04/24/leetcode-conclusions-110/</a></p><p>有不懂的加我微信（<strong>godweiyang</strong>）问我！</p><blockquote><p>最后祝大家都能顺利进入字节！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恕我直言，你们的模型训练都还不够快</title>
      <link href="/2021/06/26/params-cont/"/>
      <url>/2021/06/26/params-cont/</url>
      
        <content type="html"><![CDATA[<p>周末在家没事干，也没人约了打游戏，于是打开了gayhub闲逛，哦不，是github。</p><p><img src="1.jpeg" alt></p><p>然后发现了一个挺有意思的项目:<br><img src="2.png" alt></p><p><strong>也就是将你模型中的参数全部存储为一个连续的内存块，加速你的模型训练。</strong></p><p>于是我抱着试试看的心态，基于Fairseq和LightSeq分别实现了两个单层的Transformer编码层模型，简单写了一个例子试了一下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先为了运行我这个例子，你需要安装上面提到的<code>contiguous-params</code>库。然后还需要安装<code>fairseq</code>和<code>lightseq</code>库。</p><pre class="line-numbers language-shell"><code class="language-shell">pip install contiguous-params fairseq lightseq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>我这里创建了一个模型，就是单层的Transformer编码层，然后随机输入一个向量，损失函数就是输出向量的所有元素的平方均值。</p><p>然后测试了采用参数连续化前后，前向传播、反向传播、梯度更新三部分的时间消耗。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass<span class="token keyword">import</span> copy<span class="token keyword">import</span> torch<span class="token keyword">from</span> fairseq<span class="token punctuation">.</span>modules<span class="token punctuation">.</span>transformer_layer <span class="token keyword">import</span> TransformerEncoderLayer<span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>pytorch<span class="token punctuation">.</span>transformer_encoder_layer <span class="token keyword">import</span> LSTransformerEncoderLayer<span class="token keyword">from</span> contiguous_params <span class="token keyword">import</span> ContiguousParams<span class="token keyword">def</span> <span class="token function">get_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''CUDA同步并获取当前时间'''</span>    torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">ls_config_to_fs_args</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''将LightSeq的config转换为Fairseq的args'''</span>    @dataclass    <span class="token keyword">class</span> <span class="token class-name">Args</span><span class="token punctuation">:</span>        encoder_embed_dim<span class="token punctuation">:</span> int        encoder_ffn_embed_dim<span class="token punctuation">:</span> int        encoder_attention_heads<span class="token punctuation">:</span> int        dropout<span class="token punctuation">:</span> float        attention_dropout<span class="token punctuation">:</span> float        activation_dropout<span class="token punctuation">:</span> float        encoder_normalize_before<span class="token punctuation">:</span> bool    args <span class="token operator">=</span> Args<span class="token punctuation">(</span>        config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>intermediate_size<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>nhead<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>hidden_dropout_ratio<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>attn_prob_dropout_ratio<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>activation_dropout_ratio<span class="token punctuation">,</span>        config<span class="token punctuation">.</span>pre_layer_norm    <span class="token punctuation">)</span>    <span class="token keyword">return</span> args<span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">,</span> contiguous<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''训练过程'''</span>    model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> contiguous<span class="token punctuation">:</span>        parameters <span class="token operator">=</span> ContiguousParams<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        opt <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>parameters<span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        opt <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>    fw_time<span class="token punctuation">,</span> bw_time<span class="token punctuation">,</span> step_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        opt<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        start_time <span class="token operator">=</span> get_time<span class="token punctuation">(</span><span class="token punctuation">)</span>        outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>        loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>square<span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>        fw_time <span class="token operator">+=</span> get_time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time        start_time <span class="token operator">=</span> get_time<span class="token punctuation">(</span><span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        bw_time <span class="token operator">+=</span> get_time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time        start_time <span class="token operator">=</span> get_time<span class="token punctuation">(</span><span class="token punctuation">)</span>        opt<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        step_time <span class="token operator">+=</span> get_time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start_time        <span class="token keyword">if</span> epoch <span class="token operator">%</span> <span class="token number">200</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"epoch {:>3d}: loss = {:>5.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> fw_time<span class="token punctuation">,</span> bw_time<span class="token punctuation">,</span> step_time<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 定义LightSeq的config</span>    config <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>        max_seq_len<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>        hidden_size<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span>        intermediate_size<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>        nhead<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span>        attn_prob_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        activation_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        hidden_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        pre_layer_norm<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span><span class="token number">0</span>    <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将LightSeq的config转换为Fairseq的args</span>    args <span class="token operator">=</span> ls_config_to_fs_args<span class="token punctuation">(</span>config<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 随机生成输入</span>    bsz<span class="token punctuation">,</span> sl <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">80</span>    inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>bsz<span class="token punctuation">,</span> sl<span class="token punctuation">,</span> config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    masks <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>bsz<span class="token punctuation">,</span> sl<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 定义LightSeq模型并训练</span>    ls_model <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">(</span>config<span class="token punctuation">)</span>    ls_fw_time<span class="token punctuation">,</span> ls_bw_time<span class="token punctuation">,</span> ls_step_time <span class="token operator">=</span> train<span class="token punctuation">(</span>ls_model<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 定义连续化参数的LightSeq模型并训练</span>    config_cont <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>config<span class="token punctuation">)</span>    ls_model_cont <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">(</span>config_cont<span class="token punctuation">)</span>    ls_c_fw_time<span class="token punctuation">,</span> ls_c_bw_time<span class="token punctuation">,</span> ls_c_step_time <span class="token operator">=</span> train<span class="token punctuation">(</span>ls_model_cont<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">,</span> contiguous<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    inputs <span class="token operator">=</span> inputs<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    masks <span class="token operator">=</span> masks <span class="token operator">></span> <span class="token number">0.5</span>    <span class="token comment" spellcheck="true"># 定义Fairseq模型并训练</span>    fs_model <span class="token operator">=</span> TransformerEncoderLayer<span class="token punctuation">(</span>args<span class="token punctuation">)</span>    fs_fw_time<span class="token punctuation">,</span> fs_bw_time<span class="token punctuation">,</span> fs_step_time <span class="token operator">=</span> train<span class="token punctuation">(</span>fs_model<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 定义连续化参数的Fairseq模型并训练</span>    fs_model_cont <span class="token operator">=</span> TransformerEncoderLayer<span class="token punctuation">(</span>args<span class="token punctuation">)</span>    fs_c_fw_time<span class="token punctuation">,</span> fs_c_bw_time<span class="token punctuation">,</span> fs_c_step_time <span class="token operator">=</span> train<span class="token punctuation">(</span>fs_model_cont<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">,</span> contiguous<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"LightSeq time:         {:.3f}s, {:.3f}s, {:.3f}s"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>ls_fw_time<span class="token punctuation">,</span> ls_bw_time<span class="token punctuation">,</span> ls_step_time<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"LightSeq (cont) time:  {:.3f}s, {:.3f}s, {:.3f}s"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>ls_c_fw_time<span class="token punctuation">,</span> ls_c_bw_time<span class="token punctuation">,</span> ls_c_step_time<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Fairseq time:          {:.3f}s, {:.3f}s, {:.3f}s"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>fs_fw_time<span class="token punctuation">,</span> fs_bw_time<span class="token punctuation">,</span> fs_step_time<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Fairseq (cont) time:   {:.3f}s, {:.3f}s, {:.3f}s"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>fs_c_fw_time<span class="token punctuation">,</span> fs_c_bw_time<span class="token punctuation">,</span> fs_c_step_time<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a>详细讲解</h2><p>这里最主要的地方就两行：</p><pre class="line-numbers language-python"><code class="language-python">parameters <span class="token operator">=</span> ContiguousParams<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>opt <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>parameters<span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先用<code>ContiguousParams</code>类封装<code>model.parameters()</code>，然后将封装后的<code>parameters.contiguous()</code>送进优化器中，这里送进去的就已经是连续存储的一整块参数了。</p><p>我们详细阅读<code>ContiguousParams</code>的源码，可以发现实现很简单：<br><a href="https://github.com/PhilJd/contiguous_pytorch_params/blob/master/contiguous_params/params.py" target="_blank" rel="noopener">https://github.com/PhilJd/contiguous_pytorch_params/blob/master/contiguous_params/params.py</a></p><p>核心代码就是下面这个函数，注释中我都详细解释了每一步在干嘛：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">make_params_contiguous</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    index <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 遍历所有的参数</span>    <span class="token keyword">for</span> p <span class="token keyword">in</span> self<span class="token punctuation">.</span>_parameters<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 计算参数p的大小</span>        size <span class="token operator">=</span> p<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 在连续参数块中的对应位置赋值参数p</span>        self<span class="token punctuation">.</span>_param_buffer<span class="token punctuation">[</span>index<span class="token punctuation">:</span>index <span class="token operator">+</span> size<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span>data<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 将参数p的数值和梯度都重新指向连续参数块和连续梯度块的对应位置</span>        p<span class="token punctuation">.</span>data <span class="token operator">=</span> self<span class="token punctuation">.</span>_param_buffer<span class="token punctuation">[</span>index<span class="token punctuation">:</span>index <span class="token operator">+</span> size<span class="token punctuation">]</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>p<span class="token punctuation">.</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>        p<span class="token punctuation">.</span>grad <span class="token operator">=</span> self<span class="token punctuation">.</span>_grad_buffer<span class="token punctuation">[</span>index<span class="token punctuation">:</span>index <span class="token operator">+</span> size<span class="token punctuation">]</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>p<span class="token punctuation">.</span>data<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 连续内存块位置偏移到下一个参数</span>        index <span class="token operator">+=</span> size    <span class="token comment" spellcheck="true"># 连续参数块的梯度设置为连续梯度块</span>    self<span class="token punctuation">.</span>_param_buffer<span class="token punctuation">.</span>grad <span class="token operator">=</span> self<span class="token punctuation">.</span>_grad_buffer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在封装了原始参数之后，之后模型计算就会从连续内存块中对应位置取出数值，然后进行计算。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>我在V100显卡上运行了一下上面的例子，结果如下：<br><img src="3.png" alt></p><p>可以看出，LightSeq在采用参数连续化前后，三部分运行时间几乎没有任何变化，这主要是由于LightSeq已经在模型内部做过参数连续化了，因此速度已经很快了。</p><p>而Fairseq前后的第三部分，也就是参数更新部分时间缩减非常多，从1.5秒缩短到了0.1秒，总的训练时间几乎缩短了将近一半。</p><p>最后对比LightSeq和Fairseq可以明显发现，LightSeq的训练时间比Fairseq快非常多。主要是因为LightSeq采用了算子融合等各种技术，加速了Transformer模型的训练。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以在你的<strong>任意</strong>PyTorch模型中，都可以用上面的参数连续化技术大大加快训练速度。</p><p>而如果你的模型是Transformer类模型，那还可以直接用字节跳动开源的LightSeq训练加速引擎，更加方便。</p><p>如果你是TensorFlow爱好者，还可以直接用字节跳动开源的NeurST序列生成库进行训练，里面直接集成了LightSeq，所以训练很快。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="参数连续化"><a href="#参数连续化" class="headerlink" title="参数连续化"></a>参数连续化</h3><p><a href="https://github.com/PhilJd/contiguous_pytorch_params" target="_blank" rel="noopener">https://github.com/PhilJd/contiguous_pytorch_params</a></p><h3 id="LightSeq"><a href="#LightSeq" class="headerlink" title="LightSeq"></a>LightSeq</h3><p><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><h3 id="NeurST"><a href="#NeurST" class="headerlink" title="NeurST"></a>NeurST</h3><p><a href="https://github.com/bytedance/neurst" target="_blank" rel="noopener">https://github.com/bytedance/neurst</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> LightSeq </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网传字节跳动实习生删除所有轻量级模型，还有救吗？</title>
      <link href="/2021/06/25/bytedance-news-0/"/>
      <url>/2021/06/25/bytedance-news-0/</url>
      
        <content type="html"><![CDATA[<p>这两天字节跳动的一个新闻上了热搜，相信大多数人应该都已经听说了：<br><img src="1.png" alt></p><p>事情大致经过就是字节跳动一个新实习生想删除HDFS下一个目录，可能是存储空间不够了吧。然后经过多方求证，确定了这个目录已经没用了，接着删除了，还使用了无法恢复的命令删除的。</p><p>这下公司很多轻量级模型全被删没了，受到了一定程度上的影响，也被认定为P0级事故。但因为实习生也是误删，还多方求证过的，所以对他的影响应该没那么大。</p><p>在知乎上还看到了个有趣的评论：</p><blockquote><p>张一鸣：要Always Day 1。<br>实习生：懂了。</p></blockquote><p>当然这只是调侃，虽然实习生权限给这么大，也反映了字节跳动一视同仁，人人平等的文化理念，但也暴露出了一些权限管理上的漏洞，这次事件也能给他们敲响警钟。</p><h2 id="还有救吗？"><a href="#还有救吗？" class="headerlink" title="还有救吗？"></a>还有救吗？</h2><p>我相信字节跳动应该有能力恢复被删除的模型的。那要是真的无法恢复了，就得全部重新训练了。虽然模型也不大，但架不住数量多啊，真要全部重新训练，还是得耗费不少时间的。</p><p>这时候有什么办法可以挽救呢？可以试试字节跳动人工智能实验室最近开源的LightSeq新版训练引擎啊！</p><p><img src="logo.png" alt></p><p>目前主流的NLP模型和部分CV模型都是基于Transformer的。用LightSeq进行训练加速，<strong>本来要3天训练完的，现在最快只需要1天！</strong></p><p>技术原理和使用教程也在最近发布了，亲测非常好用，只需要几行代码。</p><p><strong>技术原理：</strong><br><a href="https://zhuanlan.zhihu.com/p/383657837" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/383657837</a></p><p><strong>使用教程：</strong><br><a href="https://zhuanlan.zhihu.com/p/382961951" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/382961951</a></p><p><strong>项目地址：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p>如果觉得好用，还请帮忙转发，点个star，让更多的人体会到极速训练的快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节跳动 </tag>
            
            <tag> CUDA </tag>
            
            <tag> LightSeq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只用几行代码，我让模型『训练』加速了3倍以上！</title>
      <link href="/2021/06/21/lightseq2-usage/"/>
      <url>/2021/06/21/lightseq2-usage/</url>
      
        <content type="html"><![CDATA[<p>最近总有学妹问我，论文要截稿了，模型来不及跑怎么办？</p><p>还有学妹问我，有好多idea，验证一个就要跑一周怎么办？</p><p>这时候我想起了下面这张图，我想这句话反映了大多数从事人工智能的科研工作者们目前的状态。</p><p><img src="1.png" alt></p><p>于是我告诉学妹，想要快，找我就对了，我教你怎样让你的模型训练加速3倍以上！</p><p>这里我们需要用到的就是字节跳动AI Lab最近开源的训练加速引擎——LightSeq。</p><p><img src="2.png" alt></p><p>具体的原理这里就不做过多介绍了，另一篇文章里写的很详细：<a href="https://bytedance.feishu.cn/docs/doccn9w7UdOYcEOD99FjFVpdFzf#" target="_blank" rel="noopener">训练加速3倍！字节跳动推出业界首个NLP模型全流程加速引擎</a>。今天我来教大家如何使用LightSeq。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>LightSeq依赖第三方库Ninja对CUDA进行编译，所以先装它：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install ninja<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>你可以从源码进行安装，使用如下命令：</p><pre class="line-numbers language-shell"><code class="language-shell">git clone https://github.com/bytedance/lightseq.gitcd lightseqpip install -e .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你想执行LightSeq提供的现成样例，或者使用它的单元测试工具，那最好从源码安装。</p><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>当然如果你想直接调用LightSeq的接口，不需要它的样例或者单元测试工具，我更推荐你用下面pip的方式安装，更加方便：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install lightseq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p>这次讲解的所有样例都放在了<code>lightseq/training/examples</code>目录下，推荐大家采用上面源码安装的方式安装LightSeq，这样可以直接运行样例。</p><h3 id="Hugging-Face"><a href="#Hugging-Face" class="headerlink" title="Hugging Face"></a>Hugging Face</h3><p>Hugging Face是目前用的最多的预训练模型库了吧，主要是用起来太方便了，模型也很全。直接<code>pip install transformers</code>安装即可。</p><p>以BERT在NER任务上微调为例，直接运行LightSeq提供的脚本就行：</p><pre class="line-numbers language-shell"><code class="language-shell">sh lightseq/training/examples/huggingface/run_ner.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Fairseq"><a href="#Fairseq" class="headerlink" title="Fairseq"></a>Fairseq</h3><p>Fairseq是目前最主流的序列生成库之一，用来做机器翻译、文本生成等任务都是非常方便的。安装的话也很简单，直接<code>pip install fairseq</code>即可。</p><p>LightSeq同样提供了现成的运行脚本，如果想运行LightSeq加速后的模型，执行如下命令：</p><pre class="line-numbers language-shell"><code class="language-shell">sh lightseq/training/examples/fairseq/ls_fairseq_wmt14en2de.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来看看细节，一般如果我们想用Fairseq来训练一个机器翻译模型，通常首先会准备好数据集，然后执行如下命令：</p><pre class="line-numbers language-shell"><code class="language-shell">fairseq-train DATA_DIR \    --arch transformer_wmt_en_de_big_t2t \    --optimizer adam \    --criterion label_smoothed_cross_entropy \    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里我们只列出了同LightSeq有关的三个参数：<code>--arch</code>、<code>--optimizer</code>和<code>--criterion</code>，分别指定了模型结构、参数优化器和损失函数。</p><p>如果想用LightSeq进行加速，直接将上面的运行命令改为下面这样：</p><pre class="line-numbers language-shell"><code class="language-shell">lightseq-train DATA_DIR \    --arch ls_transformer_wmt_en_de_big_t2t \    --optimizer ls_adam \    --criterion ls_label_smoothed_cross_entropy \    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意改动的地方有4个。<code>fairseq-train</code>改成<code>lightseq-train</code>，这是为了导入LightSeq的目录。<code>--arch</code>、<code>--optimizer</code>和<code>--criterion</code>都加上了<code>ls_</code>前缀，这样就快速替换为了LightSeq的组件。</p><h3 id="自定义模型"><a href="#自定义模型" class="headerlink" title="自定义模型"></a>自定义模型</h3><p>当然绝大多数时候你可能只是想自己搭建一个Transformer模型，然后用来做自己的事情。</p><p>以编码层为例，你只需要为每一层创建一个配置对象，然后用它创建LightSeq的编码层即可。</p><p>我写了一份完整的训练代码，非常浅显易懂，看注释就行了：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>pytorch<span class="token punctuation">.</span>transformer_encoder_layer <span class="token keyword">import</span> LSTransformerEncoderLayer<span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">)</span><span class="token punctuation">:</span>    inputs <span class="token operator">=</span> inputs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    masks <span class="token operator">=</span> masks<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>    model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    opt <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        opt<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> masks<span class="token punctuation">)</span>        loss <span class="token operator">=</span> torch<span class="token punctuation">.</span>square<span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        opt<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> epoch <span class="token operator">%</span> <span class="token number">200</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"epoch {:>3d}: loss = {:>5.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 定义LightSeq配置</span>    config <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>        max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>        max_seq_len<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>        hidden_size<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">,</span>        intermediate_size<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>        nhead<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span>        attn_prob_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        activation_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        hidden_dropout_ratio<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>        pre_layer_norm<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>        fp16<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>        local_rank<span class="token operator">=</span><span class="token number">0</span>    <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 随机生成输入</span>    bsz<span class="token punctuation">,</span> sl <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">80</span>    inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>bsz<span class="token punctuation">,</span> sl<span class="token punctuation">,</span> config<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>    masks <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>bsz<span class="token punctuation">,</span> sl<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 定义LightSeq编码层并进行训练</span>    model <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">(</span>config<span class="token punctuation">)</span>    train<span class="token punctuation">(</span>model<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> masks<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="训练速度"><a href="#训练速度" class="headerlink" title="训练速度"></a>训练速度</h2><p>说了这么多，实际速度到底怎么样？我用Fairseq测了一下训练的总耗时：</p><p><img src="4.png" alt></p><p>不同模型大小、不同批处理大小、不同显卡上加速效果都是有区别的，但总体上都能缩短一半左右的训练时间。</p><p>如果你的显卡比较老旧（我相信大多数学校实验室都是这样的），显存又比较小，那么批处理大小只能设置的很小，那加速比甚至能达到3倍以上。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>学妹试了直叫好，让我下次别再这么快了。</p><p><img src="6.png" alt></p><p>你也别忘了点个star，让更多的人享受到极速的快乐。</p><p><img src="7.png" alt></p><p><strong>LightSeq地址：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p><img src="5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> LightSeq </tag>
            
            <tag> PyTorch </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练加速3倍！字节跳动推出业界首个NLP模型全流程加速引擎</title>
      <link href="/2021/06/21/lightseq2-introduction/"/>
      <url>/2021/06/21/lightseq2-introduction/</url>
      
        <content type="html"><![CDATA[<p><img src="ls.png" alt></p><p>如今NLP和CV领域的大部分任务都将Transformer作为基础模型。而早在2019年12月，字节跳动曾经开源过一款Transformer类模型推理加速引擎——LightSeq。作为业界第一款支持多种模型和解码方法的推理加速引擎，LightSeq的推理速度快于其它同类软件，更是远远超过了TensorFlow和PyTorch。</p><p>最近，LightSeq发布了最新版本，引入了引擎方面的重大更新——支持了Transformer全流程训练加速，在不同的批处理大小下相比主流训练库最高可加速3倍多！至此从训练到推理部署的整个过程都已被LightSeq打通。</p><p>那么它到底采用了哪些技术呢？下面笔者根据LightSeq公布的资料为你逐个揭晓。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><img src="1.png" alt="图1：Transformer模型结构图（以机器翻译为例）"></p><p>Transformer模型 [1]自从2017年被谷歌提出之后，成为了众多NLP任务以及部分CV任务的主流模型，尤其是机器翻译、文本生成、文本摘要、时间序列预测等任务。图1是机器翻译任务使用Transformer进行训练的一个例子。但由于硬件资源的匮乏，很多高校实验室或者公司都无法训练很大的模型，而降低批处理大小等措施又会导致训练时间成倍增加。因此如何利用有限的资源最快训练出模型成为了亟待解决的问题。</p><p>针对这一痛点，字节跳动推出了LightSeq训练加速引擎，对Transformer训练的整个计算过程进行了优化。从词嵌入层、编码层、解码层，到最后的损失函数层，从前向传播、反向传播、梯度同步，到最后的参数更新，LightSeq都进行了细致的性能分析和优化。以机器翻译任务为例，仅需要修改几行代码开启LightSeq训练加速，就可以加速最多3倍以上。</p><p>总的来说，LightSeq具有如下几个优点：</p><ol><li>支持Transformer的完整加速。<br>LightSeq是业界第一款完整支持整个Transformer模型加速的训练引擎，包括了词嵌入层、编码层、解码层、损失函数层等高效自定义层。相比之下，另一款知名的深度学习优化引擎DeepSpeed [2]仅支持编码层的加速，因此只能用在BERT等模型上，局限性较大。</li><li>训练速度快。<br>LightSeq训练速度非常快。例如在WMT14 [3]英德机器翻译任务上，利用英伟达最新的训练显卡A100，相比于主流序列生成库，LightSeq最快仅需要三分之一的训练时间。</li><li>功能全面，简单易用。<br>LightSeq提供了高效的TensorFlow和PyTorch自定义层供用户灵活使用，可以自由插入到Hugging Face等主流训练库中。除此之外，还和当前流行的训练库如Fairseq [4]、NeurST [5]等做了深度集成，用户在安装LightSeq后，只需要修改几个命令行参数，就能在这些训练库上使用LightSeq。</li><li>提供丰富的二次开发工具。<br>LightSeq提供了完整的CUDA kernel和Transformer自定义层的单元测试功能，可以测试自定义算子的正确性，同时分析出运行时间和加速比，帮助开发者更快地验证功能的正确性和有效性。</li></ol><p>表1列举了不同训练加速引擎之间支持的功能对比：</p><p><img src="t1.png" alt="表1：不同训练加速引擎支持功能对比"></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>LightSeq提供了多种便捷的运行方式，点击文末链接可以快速体验。这里简单讲解一下快速接入LightSeq进行训练的两种方式。</p><h3 id="使用自定义层"><a href="#使用自定义层" class="headerlink" title="使用自定义层"></a>使用自定义层</h3><p>LightSeq提供了许多自定义层供用户灵活使用。</p><p>例如想要将Transformer模型中的编码层替换为LightSeq的编码层，只需要提供一个编码层参数，用来初始化LightSeq编码层。然后就可以用它来替换原始的编码层，加速模型训练。详细代码如下（这里省略了部分配置参数）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> lightseq<span class="token punctuation">.</span>training<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>pytorch<span class="token punctuation">.</span>transformer_encoder_layer <span class="token keyword">import</span> LSTransformerEncoderLayerconfig <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">.</span>get_config<span class="token punctuation">(</span>    max_batch_tokens<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span>    max_seq_len<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>enc_layer <span class="token operator">=</span> LSTransformerEncoderLayer<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一键启动"><a href="#一键启动" class="headerlink" title="一键启动"></a>一键启动</h3><p>LightSeq还和几个当前流行的训练库（例如Fairseq和NeurST）做了深度集成，仅需修改很少的代码就能开启LightSeq加速。</p><p><strong>Fairseq</strong><br>LightSeq为Fairseq提供了一套完整便捷的Transformer训练样例。</p><p>首先需要安装Fairseq，以及必要的第三方库。</p><p>然后用如下命令安装LightSeq加速库：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install lightseq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着就可以通过LightSeq提供的启动器，灵活地指定使用LightSeq优化版本的Transformer模型、参数优化器和损失函数，下面是启动参数样例（这里省略了和LightSeq无关的参数）：</p><pre class="line-numbers language-shell"><code class="language-shell">lightseq-train DATA_PATH \    --arch ls_transformer_wmt_en_de_big_t2t \    --optimizer ls_adam \    --criterion ls_label_smoothed_cross_entropy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NeurST</strong><br>NeurST是一款同时支持TensorFlow和PyTorch的开源序列生成库，可以用来做文本生成、机器翻译和语音翻译。LightSeq已经与其进行了深度融合，无需用户修改代码和启动参数即可直接进行加速训练。</p><p>首先需要安装NeurST，官方提供了详细的安装教程 [6]。</p><p>然后安装TensorFlow版本的LightSeq，命令如下：</p><pre class="line-numbers language-shell"><code class="language-shell">pip install http://sf3-ttcdn-tos.pstatp.com/obj/nlp-opensource/lightseq/tensorflow/lightseq_tf-2.0.1-cp37-cp37m-linux_x86_64.whl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样NeurST就会自动识别LightSeq已经安装成功，调用<code>lightseq</code>库进行模型构建来加速训练，无需修改启动参数。运行命令详见NeurST提供的机器翻译样例 [6]。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>在WMT14标准的英德翻译任务上，LightSeq做了评测实验。以当前流行的Fairseq训练库（基于PyTorch）和被广泛使用Apex工具库 [7]为基准，测试了LightSeq的训练性能。实验在NVIDIA Tesla V100 和 NVIDIA Ampere A100上进行，采用单机八卡数据并行训练和16位浮点数混合精度。</p><p>在不同模型大小和批处理大小下，LightSeq对单步训练速度的提升结果如图2所示：</p><p><img src="2.png" alt="图2：A100和V100显卡下不同层数模型加速比"></p><p>这里所有模型的词表大小为40k，编码层和解码层隐层维度是1024，注意力头数为16。e和d分别表示编码器和解码器的层数。加速比的计算采用了每秒训练有效单词数（real word per second）这一常见指标。</p><p>可以发现：</p><ol><li>使用了LightSeq后，单步训练速度有45%-250%的提升，作为对比，Apex仅有5%-30%的提升。LightSeq能取得这种大幅度的性能提升，源自于其对模型进行了全流程的细致优化。</li><li>Apex显存使用量对比原生Fairseq略有提升，例如V100上，Apex导致6e6d的模型在15000批处理大小上出现了显存溢出，而LightSeq仍然可以正常训练。这证明了LightSeq在保证高效计算的同时，也做到了高效使用显存，这个特征在显存有限或者训练大模型时非常关键。</li><li>随着批处理大小的增加，LightSeq加速比逐渐降低。其原因是，经过LightSeq优化后，单步训练中矩阵乘法占比提高，显卡的计算吞吐成为训练速度的瓶颈。这表明LightSeq已经对计算资源做到了充分利用。也解释了为什么计算吞吐更高的A100，平均会取得比V100高15%左右的加速比。</li></ol><p>最后在WMT14英德翻译数据集上测试了图1中Transformer模型训练至收敛的时间，结果如图3所示：</p><p><img src="3.png" alt="图3：A100和V100显卡下不同模型训练总时间"></p><p>由于LightSeq的计算优化是无损的，不会影响模型训练至收敛的训练步数，所以收敛时间的提升和单步训练时间的提升趋于一致。观察可以发现，LightSeq最多可将模型训练时间由8.5小时降低到3.8小时。</p><h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><p>为了更清楚地展示LightSeq优化前后模型的运算情况，用Nsight Systems [8]可视化模型训练过程中单步的算子调用情况。</p><p>首先是Fairseq+Apex的可视化，结果如图4所示。总耗时在288ms左右，三个红色框分别表示前向传播、反向传播、梯度同步与参数更新。可以看出前向传播的算子排列比较稀疏，存在很大的优化空间。</p><p><img src="4.png" alt="图4：Fairseq+Apex单步训练过程可视化"></p><p>然后是Fairseq+LightSeq的可视化，结果如图5所示，总耗时降到了185ms左右。而且LightSeq的算子排列更加紧密，大大增加了显卡的利用率。</p><p><img src="5.png" alt="图5：Fairseq+LightSeq单步训练过程可视化"></p><h3 id="CUDA-kernel性能"><a href="#CUDA-kernel性能" class="headerlink" title="CUDA kernel性能"></a>CUDA kernel性能</h3><p>此外还测试了LightSeq单卡情况下所有CUDA kernel的性能，对比了PyTorch、TensorFlow（XLA编译优化）、DeepSpeed和LightSeq四种实现方式。由于kernel太多，这里只列举了部分实验结果。</p><p>首先对比了最常用的dropout，图6是V100显卡上16位和32位浮点数dropout不同实现的加速对比结果：</p><p><img src="6.png" alt="图6：dropout加速对比"></p><p>从图6中可以看出，LightSeq的实现要远远快于PyTorch和DeepSpeed。DeepSpeed在元素数量过百万之后逐渐不如PyTorch，而LightSeq始终比PyTorch快。随着元素数量的增加，LightSeq和DeepSpeed的速度都会有明显下降。TensorFlow在开启了XLA之后速度依然落后于PyTorch，且随着元素数量的增加差距逐渐缩小。</p><p>然后对比了注意力机制中的softmax函数，测试了实际训练场景中批处理大小为8192情况下的加速比。图7是V100显卡上16位和32位浮点数softmax不同实现的加速对比结果，因为DeepSpeed只支持句子长度为8的整数倍，所以这里只测试了长度为32的整数倍的句子计算速度：</p><p><img src="7.png" alt="图7：softmax加速对比"></p><p>可以看出，LightSeq几乎在所有情况下远远快于DeepSpeed。且随着序列长度增加，LightSeq加速比逐渐增大。而DeepSpeed在16位浮点数情况下加速比会逐渐减小，在32位浮点数情况下甚至会出现比PyTorch还要慢的情况。TensorFlow即便使用XLA融合算子，运算速度也远远落后于其它三种实现。</p><p>在其它多数kernel测试中，LightSeq都要快于其它三种实现。</p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p><img src="8.png" alt="图8：模型训练过程"></p><p>如图8所示，以2卡为例，一个完整的Transformer模型训练过程主要包括四个步骤：前向传播、后向传播、梯度同步和参数更新。其中前向传播和后向传播占模型训练总时间的70%多，包含了众多计算密集型和I/O密集型操作，因此是优化的重点。而梯度同步虽然耗时相对较少，但是也可以通过和反向传播并行化等方法隐藏掉大部分延时。最后优化器更新参数方面也大有文章可做，可以从计算和I/O两个方面减小延时。</p><p>下面详细介绍优化这四个步骤的几种技术：算子多运算融合、输入输出层融合、动态显存复用和参数连续化，最后介绍一下LightSeq提供的单元测试功能。</p><h3 id="算子多运算融合"><a href="#算子多运算融合" class="headerlink" title="算子多运算融合"></a>算子多运算融合</h3><p>在大多数深度学习框架（例如TensorFlow和PyTorch）中，一个简单的运算通常都需要很多细粒度的核函数来实现。例如在TensorFlow中，一次层归一化（Layer Normalization）操作需要调用三次核函数以及两次中间显存读写，非常耗时。而基于CUDA，LightSeq定制化了一个层归一化专用的核函数，将两次中间结果的写入寄存器。从而实现一次核函数调用，同时没有中间结果显存读写，因此大大节省了计算开销。</p><p>基于这个思路，LightSeq利用CUDA矩阵运算库cuBLAS [9]提供的矩阵乘法和自定义核函数实现了Transformer的编码器和解码器。以编码层为例，具体结构如图9所示：</p><p><img src="9.png" alt="图9：编码层计算过程"><br>蓝色部分是自定义核函数，黄色部分是矩阵乘法。可以发现，矩阵乘法之间的运算全部都用一个定制化核函数实现了，因此大大减少了核函数调用和显存读写，最终提升了运算速度。</p><p>LightSeq还优化了核函数的实现，采用float4数据类型来进行数据读写，大大增加了数据的吞吐量，减小了核函数执行的延时。LightSeq支持任意长度的序列输入，根据不同的序列长度选择最合适的核函数来调用执行。相比之下，DeepSpeed多数核函数只支持句子长度为8的整数倍，因此速度较慢，局限性较大。</p><h3 id="输入输出层融合"><a href="#输入输出层融合" class="headerlink" title="输入输出层融合"></a>输入输出层融合</h3><p>此外LightSeq还实现了词嵌入层和损失函数层的算子融合。对于词嵌入层，LightSeq将词表查找与放缩、位置向量融合以及dropout操作都写成了一个核函数。对于损失函数层，将交叉熵损失融合成一个核函数。通过输入输出层的融合，进一步减小了模型训练的时间，增加了显卡利用率。</p><p>以词嵌入层为例，图10展示了输入句子中单词id之后，词嵌入层进行的计算过程：</p><p><img src="10.png" alt="图10：词嵌入层计算过程"></p><p>可以看出，在融合之前一个词嵌入层需要经过词向量查找与放缩、位置向量查找、两者相加、dropout五种运算，因此需要频繁调用核函数，非常耗时。而将这五个操作融合成一个核函数可以大大加快获取最终词表示的速度。</p><h3 id="动态显存复用"><a href="#动态显存复用" class="headerlink" title="动态显存复用"></a>动态显存复用</h3><p>为了避免计算过程中的显存申请释放并节省显存占用，LightSeq首先对模型中所有动态的矩阵大小都定义了最大值（例如最大序列长度）。接着在模型初始化的时候，为计算过程中的每个中间计算结果按最大值分配显存，并对没有依赖的中间结果共用显存。</p><h3 id="参数连续化"><a href="#参数连续化" class="headerlink" title="参数连续化"></a>参数连续化</h3><p>LightSeq将Transformer每一层中所有的参数都绑定在一起，做连续化处理。初始化模型某一层的时候只需要定义一个参数，参数量为原始模型该层总的参数量。在后续计算时，只需要从这个参数的对应位置处取出原始参数值即可。</p><p>以编码层为例，自注意力层和前馈层共有16个参数，假设总参数量为S。于是可以定义一个大小为S的参数，按照原始各个参数的参数量来划分出16个块，连续存储16个参数，在计算时只需要取出对应的参数块即可。</p><p>参数连续化能显著降低参数更新期间拷贝、同步、计算的次数。实验分析发现，进行了这项优化后，优化器性能提升了40%-50%。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>LightSeq提供了丰富的单元测试功能，不仅可以测试所有的自定义核函数和自定义层的正确性，还可以对比测试不同实现之间的速度。用户可以自由指定测试的组数、每组重复运行次数、容差和数据类型。</p><p>具体步骤上，首先用户需要构造随机数据，然后根据数据类型选择不同的CUDA核函数，最后分别实现自定义和基准的计算函数即可。这样就保证了用户可以基于自身场景进行更进一步的二次定制开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LightSeq新版训练加速引擎全方面提升了Transformer模型的训练速度，打通了训练和推理部署全流程，使用灵活方便。大大缩减了科研工作者们训练模型的成本。可以期待未来像机器翻译、文本生成、摘要、对话生成、情感分析等大量NLP应用场景可以使用LightSeq来训练和推理。</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><strong>LightSeq地址：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p><img src="lightseq.png" alt></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Transformer: “Attention is all you need”, NIPS (2017)<br>[2] DeepSpeed: <a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener">https://github.com/microsoft/DeepSpeed</a><br>[3] WMT14: <a href="http://www.statmt.org/wmt14/" target="_blank" rel="noopener">http://www.statmt.org/wmt14/</a><br>[4] Fairseq: <a href="https://github.com/pytorch/fairseq" target="_blank" rel="noopener">https://github.com/pytorch/fairseq</a><br>[5] NeurST: <a href="https://github.com/bytedance/neurst/tree/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/neurst/tree/lightseq</a><br>[6] NeurST机器翻译样例: <a href="https://github.com/bytedance/neurst/tree/lightseq/examples/translation" target="_blank" rel="noopener">https://github.com/bytedance/neurst/tree/lightseq/examples/translation</a><br>[7] Apex: <a href="https://github.com/NVIDIA/apex" target="_blank" rel="noopener">https://github.com/NVIDIA/apex</a><br>[8] Nsight Systems: <a href="https://developer.nvidia.com/nsight-systems" target="_blank" rel="noopener">https://developer.nvidia.com/nsight-systems</a><br>[9] cuBLAS: <a href="https://docs.nvidia.com/cuda/cublas/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cublas/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> LightSeq </tag>
            
            <tag> PyTorch </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七年师大，青春永不毕业</title>
      <link href="/2021/05/21/master-graduate/"/>
      <url>/2021/05/21/master-graduate/</url>
      
        <content type="html"><![CDATA[<p>2021年5月19日，我答辩顺利结束了。</p><p>22年的学生时代终于要走到了尽头，在学校的日子过一天少一天。想到校园卡即将刷不进校门了，难免有些失落。</p><p>七年师大，从两年的东川路500号，到五年的中山北路3663号。我见证了计算机系的三次变迁，也发展的越来越好。谈到当年为何选择学计算机，也是因为巧合。高考没考好，来到了师大，一心想学个工科，也就只能选择计算机了。没曾想到，一如计科深似海，这才是我感兴趣的专业。恰逢大一大二那会儿人工智能崛起，计算机毕业生工资也水涨船高。现在竞争越来越激烈了，已经从当年的冷门专业变成香饽饽了，还是很庆幸当年误打误撞来了这里的，也许高考考好一点，就没有今天的我了。</p><p>回顾七年的师大生活，简单而充实，虽有遗憾，但也很知足了。</p><p>本科四年，单调的不能再单调，竞赛、上课、恋爱，再无其它。两年半的初恋虽然没有善终，但也教会了我很多吧。大多数时间都花在了ACM训练和专业课程上，其它时间花的确实太少了。各种奖拿了一堆，看起来光鲜亮丽很充实，却也多了很多遗憾。</p><p>硕士三年，理科大楼、教室、宿舍三点一线，就这样过了两年。平平无奇的研一，每天除了几小时的摸鱼，剩下的时间都用来打游戏了。研二运气好了点，发了论文，赶上疫情，直接就来到字节实习了。没曾想，这一实习，竟然就成了永别，退了宿舍，租了房子，彻底离开了熟悉的B906。</p><p>七年时光，遇见了很多的人，几年后还能联系的不知道还剩多少，也可能只能在召唤师峡谷天天见了。今天打印论文巧遇了许久不见的酸菜鱼，说起今后不知何时能再见，莫名伤感。晚上AntNLP再聚撸串儿，不知道今后还能不能聚的这么齐了。都要各奔四方了，虽然基本都在上海，但聚一次也不容易。</p><p>学业结束了，工作找到了，只剩下最后一件心头事了吧。晚上聚餐不经意间又被问起五二零怎么不带人来，我只能微微一笑，懂我的人早就了解真相了，不知道的我也不想再提。就当作今年什么事都没有发生过，仅仅是少上了三天班而已。</p><p>睡得越来越晚，头发越来越少，心事越来越多。谈到未来，我想最重要的还是工作，先提升自己，做到出色。然后是副业，公众号和知乎很久没更新了，以后可以专心运营，写出更多更好的文章了。联盟永远不会再见，每天还是会上线看看那几个熟悉的id，这么多年一直都未曾改变。周末多出去转转，上海虽小，却也没怎么逛过，世界很大，也想多去看看。其他的随缘，爸妈催，亲戚介绍，以后过年少不了的话题，不管就好。五二零扫了遍朋友圈，三五十对还是有的，感慨确实年纪大了，不是当年的qq空间了。</p><p><strong>致谢：</strong><br>qq, lcz, wyy, yxj, hzy, mx, zm, fzc, zqm, qjy, scy, jt, scz, dyp, zgp, lyf, gsy, etc.<br>人太多，不一一列举了，都是这么多年还时常联系的。</p><p>特别感谢我的父母和导师。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节还有打游戏、听音乐这种神仙工作？</title>
      <link href="/2021/04/16/bytedance-hire-2021/"/>
      <url>/2021/04/16/bytedance-hire-2021/</url>
      
        <content type="html"><![CDATA[<p>有很多同（xue）学（mei）想来字节，但是也不知道投什么岗位，于是就乱投一通，最后大多数都倒在了简历筛选阶段。</p><p><img src="1.jpeg" alt></p><p>那么怎么增大过简历关的概率，拿到面试机会呢？</p><p>首先这个岗位hc得充足，也就是有足够的招人名额，或者说很缺人；其次就是和你的方向契合度要高。</p><p>从字节情况来看，热门的部门竞争一定很激烈，很多同学可能投了简历就石沉大海。</p><p>但是很多新兴的部门，其实处在上升期，非常缺人；我们内部也在积极组织内推，寻找合适的同学。</p><p>目前字节比较缺人的业务部门有<strong>教育、游戏、客户端</strong>等等，我这里挑了几个非常非常缺人的部门，给大家内推一下。</p><p><img src="2.jpeg" alt></p><h2 id="朝夕光年（游戏）"><a href="#朝夕光年（游戏）" class="headerlink" title="朝夕光年（游戏）"></a>朝夕光年（游戏）</h2><p>朝夕光年，是字节跳动旗下游戏业务集团品牌，面向全球用户与开发者开展游戏研发与发行业务。通过提供顶级游戏和打造玩家社群，朝夕光年致力于服务全球玩家，为每位玩家带来有趣和激励人心的体验。</p><h3 id="在招岗位"><a href="#在招岗位" class="headerlink" title="在招岗位"></a>在招岗位</h3><p>美术（原画/技术美术/ UE/UI/动作/特效/3D）<br>技术（前端/后端/服务端/测试/引擎）<br>运营（运营管理/市场用户/评测）<br>策划 （系统/剧情/数值）<br>数据分析<br>音频设计<br>市场营销</p><h3 id="投递地址"><a href="#投递地址" class="headerlink" title="投递地址"></a>投递地址</h3><p><a href="http://nxw.so/54Ouo" target="_blank" rel="noopener">http://nxw.so/54Ouo</a></p><h2 id="美术专属岗位（游戏）"><a href="#美术专属岗位（游戏）" class="headerlink" title="美术专属岗位（游戏）"></a>美术专属岗位（游戏）</h2><h3 id="在招岗位-1"><a href="#在招岗位-1" class="headerlink" title="在招岗位"></a>在招岗位</h3><p><strong>正式岗位</strong><br>游戏场景原画，游戏角色原画，游戏技术美术（美术向），游戏动作设计师，游戏交互设计师， 游戏特效设计师，游戏3D美术设计师，游戏UE设计师， 游戏UI设计师，游戏GUI设计师<br><strong>实习岗位</strong><br>游戏动作设计，游戏交互设计， 游戏特效设计，游戏3D美术设计，游戏UE设计， 游戏UI设计，GUI设计，平面设计，视频设计</p><h3 id="投递地址-1"><a href="#投递地址-1" class="headerlink" title="投递地址"></a>投递地址</h3><p><a href="http://nxw.so/59qWf" target="_blank" rel="noopener">http://nxw.so/59qWf</a></p><h2 id="抖音音乐客户端"><a href="#抖音音乐客户端" class="headerlink" title="抖音音乐客户端"></a>抖音音乐客户端</h2><p><strong>详细介绍：</strong><br><a href="https://bytedance.feishu.cn/docs/doccnnMwOVoO09kXAt1ONmofL9i" target="_blank" rel="noopener">https://bytedance.feishu.cn/docs/doccnnMwOVoO09kXAt1ONmofL9i</a></p><h3 id="在招岗位-2"><a href="#在招岗位-2" class="headerlink" title="在招岗位"></a>在招岗位</h3><p>iOS开发（高级）工程师 - 抖音音乐（上海）<br>iOS开发（高级）工程师 - 抖音音乐（深圳）<br>Android开发（高级）工程师 - 抖音音乐（上海）<br>Android开发（高级）工程师 - 抖音音乐（深圳）<br>等等</p><h3 id="投递地址-2"><a href="#投递地址-2" class="headerlink" title="投递地址"></a>投递地址</h3><p><a href="http://nxw.so/5e5Zo" target="_blank" rel="noopener">http://nxw.so/5e5Zo</a></p><h2 id="一定要记得填上我的内推码！！！"><a href="#一定要记得填上我的内推码！！！" class="headerlink" title="一定要记得填上我的内推码！！！"></a>一定要记得填上我的内推码！！！</h2><blockquote><p>一定要记得填上我的内推码！！！<br>一定要记得填上我的内推码！！！<br>一定要记得填上我的内推码！！！</p></blockquote><p>重要的事情说三遍，还是有很多同学网上随便找个内推码，或者干脆不填。然后跑来让我查进度，这样我是没有办法知道进度的，也没办法帮你联系hr！</p><p><strong>我的内推码是：</strong><br><strong>A7FSJMK</strong></p><p>在我的公众号【算法码上来】后台回复【内推】，还可以进内推群，加我联系方式，随时咨询进度！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只用两行代码，我让Transformer推理加速了10倍</title>
      <link href="/2021/04/13/lightseq-python-usage/"/>
      <url>/2021/04/13/lightseq-python-usage/</url>
      
        <content type="html"><![CDATA[<p>最近有学妹问我，我训了一个Transformer模型，但是预测好慢啊，有啥解决方案吗？</p><p>我心想，你又想好，又想快，咋不上天🚀呢？</p><p><img src="1.png" alt></p><p>于是我跟她说，你可以试试lightseq啊，跟闪电⚡️一样快，用了你就可以上天了。</p><p>她一脸懵比，lightseq是啥玩意儿啊？咋就能让我的模型起飞🛫️了呢？</p><p>我跟她说，你不需要知道太多细节，你只需要知道它是一个Transformer系列模型推理加速库就行了。</p><p>她还是一脸疑惑，那用起来能有huggingface方便吗？你看人家就两行代码。</p><p>我不屑一笑，就这？lightseq也只要两行代码就够了！</p><p><img src="2.jpeg" alt></p><p>为了方便，我用了一个bart模型预测句子中mask单词的例子来给她吹了一波。</p><p>不懂什么是bart？建议先去看看huggingface的文档：<br><a href="https://huggingface.co/transformers/model_doc/bart.html" target="_blank" rel="noopener">https://huggingface.co/transformers/model_doc/bart.html</a></p><h2 id="huggingface-bart"><a href="#huggingface-bart" class="headerlink" title="huggingface bart"></a>huggingface bart</h2><p>我们平时想用huggingface的bart来预测句子中的mask单词，大体上都会像下面这样写代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> transformers <span class="token keyword">import</span> BartTokenizer<span class="token punctuation">,</span> BartForConditionalGenerationtokenizer <span class="token operator">=</span> BartTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"facebook/bart-base"</span><span class="token punctuation">)</span>model <span class="token operator">=</span> BartForConditionalGeneration<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"facebook/bart-base"</span><span class="token punctuation">)</span>sentences <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"I love that girl, but &lt;mask> does not &lt;mask> me."</span><span class="token punctuation">]</span>inputs <span class="token operator">=</span> tokenizer<span class="token punctuation">(</span>sentences<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>generated_ids <span class="token operator">=</span> model<span class="token punctuation">.</span>generate<span class="token punctuation">(</span>inputs<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> max_length<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span>res <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>generated_ids<span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然运行前要先安装一下<code>transformers</code>包：  </p><pre class="line-numbers language-shell"><code class="language-shell">pip3 install transformers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后会输出句子“I love that girl, but she does not love me.”，句子中的两个“mask”被预测成了“she”和“love”。</p><p>看起来预测的很nice，但是预测的也太慢了，这要是有一堆句子要去预测，不得等到🐒年🐎月？</p><p><img src="3.jpeg" alt></p><p>接下来我们来看看lightseq是怎么加速预测的。</p><h2 id="lightseq-bart"><a href="#lightseq-bart" class="headerlink" title="lightseq bart"></a>lightseq bart</h2><p>代码我都放在下面地址了，只要两分钟就能跑出结果了：<br><a href="https://github.com/bytedance/lightseq/tree/master/examples/inference/python" target="_blank" rel="noopener">https://github.com/bytedance/lightseq/tree/master/examples/inference/python</a></p><p>运行前要先安装一下<code>lightseq</code>包：  </p><pre class="line-numbers language-shell"><code class="language-shell">pip3 install lightseq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先lightseq只能接收HDF5或者PB格式的模型文件，我们帮你写好了模型转换的脚本，就是<code>hf_bart_export.py</code>，它会将huggingface预训练的bart模型转换为HDF5格式。</p><p>所以直接运行<code>python3 hf_bart_export.py</code>就行了，这里我们用的是bart-base模型。</p><p>运行完了会发现执行目录下多出一个<code>lightseq_bart_base.hdf5</code>文件，这就是转换后的模型文件。</p><p>最后直接跟huggingface一样，两行代码就能搞定啦：  </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lightseq<span class="token punctuation">.</span>inference <span class="token keyword">as</span> lsi<span class="token keyword">from</span> transformers <span class="token keyword">import</span> BartTokenizertokenizer <span class="token operator">=</span> BartTokenizer<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span><span class="token string">"facebook/bart-base"</span><span class="token punctuation">)</span>model <span class="token operator">=</span> lsi<span class="token punctuation">.</span>Transformer<span class="token punctuation">(</span><span class="token string">"lightseq_bart_base.hdf5"</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span>sentences <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"I love that girl, but &lt;mask> does not &lt;mask> me."</span><span class="token punctuation">]</span>inputs <span class="token operator">=</span> tokenizer<span class="token punctuation">(</span>sentences<span class="token punctuation">,</span> return_tensors<span class="token operator">=</span><span class="token string">"pt"</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>generated_ids <span class="token operator">=</span> model<span class="token punctuation">.</span>infer<span class="token punctuation">(</span>inputs<span class="token punctuation">[</span><span class="token string">"input_ids"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>generated_ids <span class="token operator">=</span> <span class="token punctuation">[</span>ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> ids <span class="token keyword">in</span> generated_ids<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>res <span class="token operator">=</span> tokenizer<span class="token punctuation">.</span>batch_decode<span class="token punctuation">(</span>generated_ids<span class="token punctuation">,</span> skip_special_tokens<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看得出来仅仅替换了模型定义和模型推理那两行代码而已，是不是非常简单快速？</p><p><img src="4.jpeg" alt></p><p>这时候她又问了，那我换一个模型，比如bert，要怎么导出pb模型呢？</p><p>也很简单，只需要为bert也单独写一个<code>hf_bert_export.py</code>就行了。不过目前还在开发中，之后会慢慢完善常见的一些模型的。</p><h2 id="速度到底怎么样？"><a href="#速度到底怎么样？" class="headerlink" title="速度到底怎么样？"></a>速度到底怎么样？</h2><p>我写好了一个例子，就在<code>ls_bart.py</code>里，直接运行就行了，当然你也可以加上<code>--user_input</code>参数来手动输入句子。</p><p>输入的句子是：  </p><pre class="line-numbers language-text"><code class="language-text">I love that girl, but <mask> does not <mask> me.She is so <mask> that I can not help glance at <mask>.Nothing's gonna <mask> my love for you.Drop everything now. Meet me in the pouring <mask>. Kiss me on the sidewalk.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：  </p><pre class="line-numbers language-text"><code class="language-text">=========lightseq=========lightseq generating...lightseq time: 0.03332779789343476slightseq results:I love that girl, but she does not love me.She is so beautiful that I can not help glance at her.Nothing's gonna change my love for you.Drop everything now. Meet me in the pouring rain. Kiss me on the sidewalk.=========huggingface=========huggingface generating...huggingface time: 0.3208070669788867shuggingface results:I love that girl, but she does not love me.She is so beautiful that I can not help glance at her.Nothing's gonna change my love for you.Drop everything now. Meet me in the pouring rain. Kiss me on the sidewalk.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出预测的是真的🐂🍺，最后两句歌词都预测的很完美，能看出是啥歌吗？</p><p>再看预测时间，lightseq是huggingface的10倍左右，真是一个天上一个地下啊。</p><p><img src="6.jpeg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，想要使用lightseq加速你的模型，只需要两步就行了：</p><ul><li>将你的模型转换为hdf5格式的模型。（lightseq为你写好了转换脚本，不断更新中）</li><li>调用<code>lightseq.inference.Transformer</code>和<code>model.infer</code>进行快速推理。</li></ul><p>学妹赶紧打住了我，好了好了，我知道很🐂🍺了。还给你装起来了，我这就去用。</p><p>但是源码哪里有？我想学一学。</p><p>我又甩给她一串地址：<br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p><img src="5.png" alt></p><p>好好看，好好学，都是CUDA写的，要是看得迷糊，建议先去看看我之前的入门教程嗷：<br><a href="https://godweiyang.com/2021/03/28/nn-cuda-example/">https://godweiyang.com/2021/03/28/nn-cuda-example/</a></p><p>从此，世上又多了一位快如⚡️的👨。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> LightSeq </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熬了几个通宵，我写了份CUDA新手入门代码</title>
      <link href="/2021/03/28/nn-cuda-example/"/>
      <url>/2021/03/28/nn-cuda-example/</url>
      
        <content type="html"><![CDATA[<p>在用PyTorch或者TensorFlow搭积木的时候，你是不是也遇到过下面这些情况：</p><ul><li>自带的算子及其组合都无法满足你超（bian）常（tai）的计算需求。</li><li>自带的算子不可导，需要自己定义反向传播的梯度，例如<code>argmax</code>。</li><li>自带的算子太慢了，严重影响了你发paper的速度。</li></ul><p><img src="1.jpeg" alt></p><hr><p>这时候你就会想，要是能自己实现一个速度又快、又能满足需求的算子就好了。</p><p>你想到了CUDA，自己写一个CUDA算子不就完事了嘛！</p><p>然后问题又来了，写是写完了，怎么用python代码调用它呢？</p><p>还有一个问题，这个算子它没梯度啊，自动求导机制不顶用了！</p><p>你去网上各种搜索，方法倒是全有，但是源码都好复杂，你一个新手怎么可能有心思看完那么复杂的教程？</p><p><img src="2.jpeg" alt></p><hr><p>这时候，你突然看到了这篇文章，看完后你惊呼：“怎么会有这么简洁的示例代码，这就是我想要的！”</p><p>没错，这就是我熬了好几个通宵，查了无数bug后，写出来的一份示例代码。</p><p>话不多说，先上源码好吧：<br><a href="https://github.com/godweiyang/NN-CUDA-Example" target="_blank" rel="noopener">https://github.com/godweiyang/NN-CUDA-Example</a></p><p>我给它命名为“Neural Network CUDA Example”，简称“NN CUDA Example”，意思就是神经网络调用CUDA的示例。</p><p><img src="logo.png" alt></p><p>那么这玩意到底有啥用呢？目前为止，它可以让你学到下面这些东西：</p><ul><li>最简单的CUDA算子的写法。</li><li>最简洁的PyTorch和TensorFlow封装CUDA算子的方法。</li><li>几种编译CUDA算子的方法。</li><li>python调用CUDA算子的几种方式。</li><li>python中统计CUDA算子运行时间的正确方法。</li><li>PyTorch和TensorFlow自定义算子梯度的方法。</li></ul><p><img src="3.jpeg" alt></p><hr><p>你直呼内行，要是早点能看到这篇文章，能多发好几篇论文啊。</p><p>看完代码，有些细节你还是懵逼了，这这这都是啥意思啊，为啥这么写啊？</p><p>这时候你又看到了几篇教程，哦原来都有讲解，那没事了。</p><ul><li><a href="https://godweiyang.com/2021/03/18/torch-cpp-cuda/">PyTorch自定义CUDA算子教程与运行时间分析</a></li><li><a href="https://godweiyang.com/2021/03/18/torch-cpp-cuda-2/">详解PyTorch编译并调用自定义CUDA算子的三种方式</a></li><li><a href="https://godweiyang.com/2021/03/18/torch-cpp-cuda-3/">三分钟教你如何PyTorch自定义反向传播</a></li></ul><p><img src="4.jpeg" alt></p><hr><p>从那以后，你代码能力飞速提升，一连发了好几篇顶会。</p><p>然后你顺手一键三连，把这篇文章转给了身边有需要的人，个个都夸你发现了宝藏。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> C++ </tag>
            
            <tag> PyTorch </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三分钟教你如何PyTorch自定义反向传播</title>
      <link href="/2021/03/24/torch-cpp-cuda-3/"/>
      <url>/2021/03/24/torch-cpp-cuda-3/</url>
      
        <content type="html"><![CDATA[<p>在前面两篇教程中，我们详细讲解了如何编写cuda算子，并用PyTorch进行调用，并且详细讲述了三种编译cuda算子的方式，具体可以看前面两篇：</p><p><a href="https://godweiyang.com/2021/03/18/torch-cpp-cuda/">https://godweiyang.com/2021/03/18/torch-cpp-cuda/</a><br><a href="https://godweiyang.com/2021/03/21/torch-cpp-cuda-2/">https://godweiyang.com/2021/03/21/torch-cpp-cuda-2/</a></p><p>本文我们将讲解如何用自定义cuda算子搭建一个简单的神经网络，并实现反向传播，进行模型训练。</p><p>完整的代码还是放在了github仓库，欢迎大家star并fork：<br><a href="https://github.com/godweiyang/torch-cuda-example" target="_blank" rel="noopener">https://github.com/godweiyang/torch-cuda-example</a></p><p>本文主要涉及到的是<code>train.py</code>这个代码，功能是搭建了一个PyTorch模型，并且调用了自定义的cuda算子，实现了自定义的反向传播函数，最终完成训练。</p><h2 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h2><p>之前我们实现了一个$a + b$的tensor求和cuda算子，于是我们可以利用它来实现$\mathcal{L} = a^2 + b^2$。</p><p>最终训练收敛后$a$和$b$都会趋近于0，模型没有输入，只有两个可训练的参数$a$和$b$。</p><h2 id="搭建模型"><a href="#搭建模型" class="headerlink" title="搭建模型"></a>搭建模型</h2><p>首先我们还是像正常写PyTorch模型那样搭建一个模型，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AddModel</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>AddModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># tensor长度</span>        self<span class="token punctuation">.</span>n <span class="token operator">=</span> n        <span class="token comment" spellcheck="true"># 定义可训练参数a和b</span>        self<span class="token punctuation">.</span>a <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>b <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 正态分布初始化参数a和b</span>        self<span class="token punctuation">.</span>a<span class="token punctuation">.</span>data<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>mean<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>b<span class="token punctuation">.</span>data<span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>mean<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 求a^2与b^2</span>        a2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>square<span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span>        b2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>square<span class="token punctuation">(</span>self<span class="token punctuation">.</span>b<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 调用自定义cuda算子对两个平方数求和</span>        c <span class="token operator">=</span> AddModelFunction<span class="token punctuation">.</span>apply<span class="token punctuation">(</span>a2<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> self<span class="token punctuation">.</span>n<span class="token punctuation">)</span>        <span class="token keyword">return</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点就在调用自定义cuda算子那一行<code>AddModelFunction.apply()</code>，你也可以写成<code>c = a2 + b2</code>。不过这里我们为了演示如何使用自定义cuda算子，所以不这么干了。</p><h2 id="实现自定义cuda算子前向和反向传播"><a href="#实现自定义cuda算子前向和反向传播" class="headerlink" title="实现自定义cuda算子前向和反向传播"></a>实现自定义cuda算子前向和反向传播</h2><p>下面就是如何实现<code>AddModelFunction.apply()</code>函数了，我们先来看一下具体代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AddModelFunction</span><span class="token punctuation">(</span>Function<span class="token punctuation">)</span><span class="token punctuation">:</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> args<span class="token punctuation">.</span>compiler <span class="token operator">==</span> <span class="token string">'jit'</span><span class="token punctuation">:</span>            cuda_module<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span>        <span class="token keyword">elif</span> args<span class="token punctuation">.</span>compiler <span class="token operator">==</span> <span class="token string">'setup'</span><span class="token punctuation">:</span>            add2<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span>        <span class="token keyword">elif</span> args<span class="token punctuation">.</span>compiler <span class="token operator">==</span> <span class="token string">'cmake'</span><span class="token punctuation">:</span>            torch<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>add2<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"Type of cuda compiler must be one of jit/setup/cmake."</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> c    @staticmethod    <span class="token keyword">def</span> <span class="token function">backward</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> grad_output<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>grad_output<span class="token punctuation">,</span> grad_output<span class="token punctuation">,</span> None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个类继承的是<code>torch.autograd.Function</code>类，我们可以用它来实现一下无法自动求导的操作，比如<code>argmax</code>这种不可导的函数。</p><p>我们需要实现两个函数，<code>forward</code>和<code>backward</code>，分别用来前向和反向传播，注意都得声明成静态函数。</p><p>前向传播接收多个参数，第一个固定为<code>ctx</code>，用来存储反向传播中可能会用到的一些上下文，比如<code>input</code>和一些前向过程中的中间变量等等，其他参数随你定。然后我们根据上一教程中调用cuda算子的方法计算得到求和结果，进行返回。</p><p>反向传播接收两个参数，第一个同样是<code>ctx</code>，里面存着前向过程中保存的一些上下文变量信息。第二个是<code>grad_output</code>，也就是最终的损失函数对前向传播的返回值求导的结果。在我们这里的模型中，令<br>$$a2 = a^2, b2 = b^2, s = a2 + b2, \mathcal{L} = s$$<br>那么自定义cuda算子实现的就是$s = a2 + b2$这一步，而<code>grad_output</code>就是$\frac{\partial \mathcal{L}}{\partial s}$。我们自定义的cuda算子反向传播的导数就是$\frac{\partial s}{\partial a2}$和$\frac{\partial s}{\partial b2}$，然后根据链式求导法则就可以得到损失函数对每个参数的导数了。</p><p>反向传播返回值表示损失函数对前向传播每一个参数的梯度，所以个数必须等于前向传播除了<code>ctx</code>以外的其他参数个数，并且顺序也要一一对应。因为$\frac{\partial s}{\partial a2} = \frac{\partial s}{\partial b2} = 1$，所以返回值就是<code>grad_output</code>，<code>grad_output</code>和<code>None</code>，因为对常数$n$不需要求导，所以直接返回空即可。</p><h2 id="训练流程"><a href="#训练流程" class="headerlink" title="训练流程"></a>训练流程</h2><p>最终训练流程和平常一样：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义模型</span>model <span class="token operator">=</span> AddModel<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将模型中所有参数拷贝到GPU端</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义优化器</span>opt <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 清空优化器缓存</span>    opt<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 前向传播</span>    output <span class="token operator">=</span> model<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 求loss</span>    loss <span class="token operator">=</span> output<span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 反向传播</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 更新参数</span>    opt<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> epoch <span class="token operator">%</span> <span class="token number">25</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"epoch {:>3d}: loss = {:>8.3f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终损失函数降到了0，log信息如下：</p><pre class="line-numbers language-shell"><code class="language-shell">Loading extension module add2...Initializing model...Initializing optimizer...Begin training...epoch   0: loss = 1996.658epoch  25: loss =  727.122epoch  50: loss =  264.796epoch  75: loss =   96.431epoch 100: loss =   35.117epoch 125: loss =   12.789epoch 150: loss =    4.657epoch 175: loss =    1.696epoch 200: loss =    0.618epoch 225: loss =    0.225epoch 250: loss =    0.082epoch 275: loss =    0.030epoch 300: loss =    0.011epoch 325: loss =    0.004epoch 350: loss =    0.001epoch 375: loss =    0.001epoch 400: loss =    0.000epoch 425: loss =    0.000epoch 450: loss =    0.000epoch 475: loss =    0.000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这三个教程暂时告一段落了，通过这些简单的例子，应该大致能学会如何自己写cuda算子，并且用PyTorch调用，完成模型训练了。</p><p>更复杂的模型其实基本的原理都是类似的，我不喜欢上来就讲解很复杂的大项目源码，我喜欢抽象出一个最简的example，这样更容易理解底层的原理，而不会被很多冗余的代码干扰。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> C++ </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解PyTorch编译并调用自定义CUDA算子的三种方式</title>
      <link href="/2021/03/21/torch-cpp-cuda-2/"/>
      <url>/2021/03/21/torch-cpp-cuda-2/</url>
      
        <content type="html"><![CDATA[<p>在上一篇教程中，我们实现了一个自定义的CUDA算子<code>add2</code>，用来实现两个Tensor的相加。然后用PyTorch调用这个算子，分析对比了一下和PyTorch原生加法的速度差异，并且详细解释了线程同步给统计时间带来的影响。</p><p><strong>上一篇教程：</strong><br><a href="https://godweiyang.com/2021/03/18/torch-cpp-cuda">https://godweiyang.com/2021/03/18/torch-cpp-cuda</a></p><p>本篇教程我们主要讲解如何<strong>编译并调用</strong>之前我们写好的CUDA算子，完整的代码还是放在了github仓库，欢迎大家star并fork：<br><a href="https://github.com/godweiyang/torch-cuda-example" target="_blank" rel="noopener">https://github.com/godweiyang/torch-cuda-example</a></p><p>我保证，这是你网上简单<strong>最为精简、最容易看懂</strong>的一套代码了，因为我自己也是刚入门，复杂的我也看得累。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>NVIDIA Driver: 418.116.00</li><li>CUDA: 11.0</li><li>Python: 3.7.3</li><li>PyTorch: 1.7.0+cu110</li><li>CMake: 3.16.3</li><li>Ninja: 1.10.0</li><li>GCC: 8.3.0</li></ul><p>这是我自己的运行环境，显卡是V100，其他环境不保证可以运行，但是大概率没问题，可能要做轻微修改。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><pre class="line-numbers language-shell"><code class="language-shell">├── include│   └── add2.h # cuda算子的头文件├── kernel│   ├── add2_kernel.cu # cuda算子的具体实现│   └── add2.cpp # cuda算子的cpp torch封装├── CMakeLists.txt├── LICENSE├── README.md├── setup.py├── time.py # 比较cuda算子和torch实现的时间差异└── train.py # 使用cuda算子来训练模型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码结构还是很清晰的。<code>include</code>文件夹用来放cuda算子的头文件（<code>.h</code>文件），里面是cuda算子的定义。<code>kernel</code>文件夹放cuda算子的具体实现（<code>.cu</code>文件）和cpp torch的接口封装（<code>.cpp</code>文件）。</p><p>最后是python端调用，我实现了两个功能。一是比较运行时间，上一篇教程详细讲过了；二是训练一个PyTorch模型，这个下一篇教程再来详细讲述。</p><h2 id="编译cpp和cuda文件"><a href="#编译cpp和cuda文件" class="headerlink" title="编译cpp和cuda文件"></a>编译cpp和cuda文件</h2><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>JIT就是just-in-time，也就是即时编译，或者说动态编译，就是说在python代码运行的时候再去编译cpp和cuda文件。</p><p>JIT编译的方法上一篇教程已经演示过了，只需要在python端添加<code>load</code>代码即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>cpp_extension <span class="token keyword">import</span> loadcuda_module <span class="token operator">=</span> load<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"add2"</span><span class="token punctuation">,</span>                   extra_include_paths<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"include"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   sources<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"kernel/add2.cpp"</span><span class="token punctuation">,</span> <span class="token string">"kernel/add2_kernel.cu"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>cuda_module<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的就是两个参数，<code>extra_include_paths</code>表示包含的头文件目录，<code>sources</code>表示需要编译的代码，一般就是<code>.cpp</code>和<code>.cu</code>文件。</p><p>cpp端用的是pybind11进行封装：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">PYBIND11_MODULE</span><span class="token punctuation">(</span>TORCH_EXTENSION_NAME<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">def</span><span class="token punctuation">(</span><span class="token string">"torch_launch_add2"</span><span class="token punctuation">,</span>          <span class="token operator">&amp;</span>torch_launch_add2<span class="token punctuation">,</span>          <span class="token string">"add2 kernel warpper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JIT编译看起来非常的简单，运行过程中也基本没有碰到坑，非常顺利。</p><p>运行成功的话可以看到Ninja调用了三条命令来编译：</p><pre class="line-numbers language-shell"><code class="language-shell">[1/2] nvcc -c add2_kernel.cu -o add2_kernel.cuda.o[2/3] c++ -c add2.cpp -o add2.o[3/3] c++ add2.o add2_kernel.cuda.o -shared -o add2.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由于输出太长，我省略了多数的参数信息，并精简了指令。可以看出先是调用<code>nvcc</code>编译了<code>.cu</code>，生成了<code>add2_kernel.cuda.o</code>；然后调用<code>c++</code>编译<code>add2.cpp</code>，生成了<code>add2.o</code>；最后调用<code>c++</code>生成动态链接库<code>add2.so</code>。</p><h3 id="Setuptools"><a href="#Setuptools" class="headerlink" title="Setuptools"></a>Setuptools</h3><p>第二种编译的方式是通过Setuptools，也就是编写<code>setup.py</code>，具体代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> setuptools <span class="token keyword">import</span> setup<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>cpp_extension <span class="token keyword">import</span> BuildExtension<span class="token punctuation">,</span> CUDAExtensionsetup<span class="token punctuation">(</span>    name<span class="token operator">=</span><span class="token string">"add2"</span><span class="token punctuation">,</span>    include_dirs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"include"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    ext_modules<span class="token operator">=</span><span class="token punctuation">[</span>        CUDAExtension<span class="token punctuation">(</span>            <span class="token string">"add2"</span><span class="token punctuation">,</span>            <span class="token punctuation">[</span><span class="token string">"kernel/add2.cpp"</span><span class="token punctuation">,</span> <span class="token string">"kernel/add2_kernel.cu"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    cmdclass<span class="token operator">=</span><span class="token punctuation">{</span>        <span class="token string">"build_ext"</span><span class="token punctuation">:</span> BuildExtension    <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写方法也非常的常规，调用的是<code>CUDAExtension</code>。需要在<code>include_dirs</code>里加上头文件目录，不然会找不到头文件。</p><p>cpp端用的是pybind11进行封装：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">PYBIND11_MODULE</span><span class="token punctuation">(</span>TORCH_EXTENSION_NAME<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">def</span><span class="token punctuation">(</span><span class="token string">"torch_launch_add2"</span><span class="token punctuation">,</span>          <span class="token operator">&amp;</span>torch_launch_add2<span class="token punctuation">,</span>          <span class="token string">"add2 kernel warpper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着执行：</p><pre class="line-numbers language-shell"><code class="language-shell">python3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就能生成动态链接库，同时将<code>add2</code>添加为python的模块了，可以直接<code>import add2</code>来调用。</p><p>如果执行正常的话，也是可以看到两条编译命令的：</p><pre class="line-numbers language-shell"><code class="language-shell">[1/2] nvcc -c add2_kernel.cu -o add2_kernel.o[2/2] c++ -c add2.cpp -o add2.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后会执行第三条：</p><pre class="line-numbers language-shell"><code class="language-shell">x86_64-linux-gnu-g++ -shared add2.o add2_kernel.o -o add2.cpython-37m-x86_64-linux-gnu.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后同样生成了一个动态链接库，不过python端我们不需要加载这个动态链接库，因为setuptools已经帮我们把cuda算子调用的接口注册到python模块里了，直接import即可：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> add2add2<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这里我踩了一个坑，<strong><code>.cpp</code>和<code>.cu</code>文件名不要相同，也最好不要取容易与python自带库重复的名字</strong>。此外要先<code>import torch</code>，然后再<code>import add2</code>，不然也会报错。</p><h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><p>最后就是cmake编译的方式了，要编写一个<code>CMakeLists.txt</code>文件，代码如下：</p><pre class="line-numbers language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.1 FATAL_ERROR)# 修改为你自己的nvcc路径，或者删掉这行，如果能运行的话。set(CMAKE_CUDA_COMPILER "/usr/local/cuda/bin/nvcc")project(add2 LANGUAGES CXX CUDA)find_package(Torch REQUIRED)find_package(CUDA REQUIRED)find_library(TORCH_PYTHON_LIBRARY torch_python PATHS "${TORCH_INSTALL_PREFIX}/lib")# 修改为你自己的python路径，或者删掉这行，如果能运行的话。include_directories(/usr/include/python3.7)include_directories(include)set(SRCS kernel/add2.cpp kernel/add2_kernel.cu)add_library(add2 SHARED ${SRCS})target_link_libraries(add2 "${TORCH_LIBRARIES}" "${TORCH_PYTHON_LIBRARY}")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里踩了好几个大坑。首先是找不到nvcc的路径，于是第3行先设置了一下，当然如果你删了也能跑那就更好。然后是找不到python的几个头文件，于是加上了第11行，同样如果你删了也能跑那就更好。最后是一个巨坑，没有链接<code>TORCH_PYTHON_LIBRARY</code>，导致动态链接库生成成功了，但是调用执行一直报错，所以加上了第8行和第17行。</p><p>cpp端用的是<code>TORCH_LIBRARY</code>进行封装：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">TORCH_LIBRARY</span><span class="token punctuation">(</span>add2<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">def</span><span class="token punctuation">(</span><span class="token string">"torch_launch_add2"</span><span class="token punctuation">,</span> torch_launch_add2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里不再使用pybind11，因为我的pybind11没有使用conda安装，会出现一些编译问题，详见：<a href="https://github.com/pybind/pybind11/issues/1379#issuecomment-489815562" target="_blank" rel="noopener">https://github.com/pybind/pybind11/issues/1379#issuecomment-489815562</a>。</p><p>编写完后执行下面编译命令：</p><pre class="line-numbers language-shell"><code class="language-shell">mkdir buildcd buildcmake -DCMAKE_PREFIX_PATH="$(python3 -c 'import torch.utils; print(torch.utils.cmake_prefix_path)')" ../make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后会在<code>build</code>目录下生成一个<code>libadd2.so</code>，通过如下方式在python端调用：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> torchtorch<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>load_library<span class="token punctuation">(</span><span class="token string">"build/libadd2.so"</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>ops<span class="token punctuation">.</span>add2<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果编译成功的话，可以看到如下输出信息：</p><pre class="line-numbers language-shell"><code class="language-shell">Building CXX object CMakeFiles/add2.dir/kernel/add2.cpp.o[ 66%] Building CUDA object CMakeFiles/add2.dir/kernel/add2_kernel.cu.o[100%] Linking CXX shared library libadd2.so[100%] Built target add2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行python"><a href="#执行python" class="headerlink" title="执行python"></a>执行python</h2><p>这里我实现了两个功能，代码都很简单，一个是测试时间，一个是训练模型。都可以通过参数<code>--compiler</code>来指定编译方式，可供选择的就是上面提到的三种：jit、setup和cmake。</p><h3 id="比较运行时间"><a href="#比较运行时间" class="headerlink" title="比较运行时间"></a>比较运行时间</h3><pre class="line-numbers language-shell"><code class="language-shell">python3 time.py --compiler jitpython3 time.py --compiler setuppython3 time.py --compiler cmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><pre class="line-numbers language-shell"><code class="language-shell">python3 train.py --compiler jitpython3 train.py --compiler setuppython3 train.py --compiler cmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此三种编译cuda算子并python调用的方式基本都囊括了，下一篇教程将讲讲PyTorch如何将自定义cuda算子加入到计算图中，并实现前向和反向传播，最终训练模型。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> C++ </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch自定义CUDA算子教程与运行时间分析</title>
      <link href="/2021/03/18/torch-cpp-cuda/"/>
      <url>/2021/03/18/torch-cpp-cuda/</url>
      
        <content type="html"><![CDATA[<p>最近因为工作需要，学习了一波CUDA。这里简单记录一下PyTorch自定义CUDA算子的方法，写了一个非常简单的example，再介绍一下正确的PyTorch中CUDA运行时间分析方法。</p><p>所有的代码都放在了github上，地址是：<br><a href="https://github.com/godweiyang/torch-cuda-example" target="_blank" rel="noopener">https://github.com/godweiyang/torch-cuda-example</a></p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>下面我们就来详细了解一下PyTorch是如何调用自定义的CUDA算子的。</p><p>首先我们可以看到有四个代码文件：</p><ul><li><code>main.py</code>，这是python入口，也就是你平时写模型的地方。</li><li><code>add2.cpp</code>，这是torch和CUDA连接的地方，将CUDA程序封装成了python可以调用的库。</li><li><code>add2.h</code>，CUDA函数声明。</li><li><code>add2.cu</code>，CUDA函数实现。</li></ul><p>然后逐个文件看一下是怎么调用的。</p><h3 id="CUDA算子实现"><a href="#CUDA算子实现" class="headerlink" title="CUDA算子实现"></a>CUDA算子实现</h3><p>首先最简单的当属<code>add2.h</code>和<code>add2.cu</code>，这就是普通的CUDA实现。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">launch_add2</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>c<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">*</span>a<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">*</span>b<span class="token punctuation">,</span>                 <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">__global__ <span class="token keyword">void</span> <span class="token function">add2_kernel</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> c<span class="token punctuation">,</span>                            <span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> a<span class="token punctuation">,</span>                            <span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> b<span class="token punctuation">,</span>                            <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span> \            i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> gridDim<span class="token punctuation">.</span>x <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">launch_add2</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> c<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> a<span class="token punctuation">,</span>                 <span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> b<span class="token punctuation">,</span>                 <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    dim3 <span class="token function">grid</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1023</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dim3 <span class="token function">block</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    add2_kernel<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>grid<span class="token punctuation">,</span> block<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里实现的功能是两个长度为$n$的tensor相加，每个block有1024个线程，一共有$n/1024$个block。具体CUDA细节就不讲了，本文重点不在于这个。</p><p><code>add2_kernel</code>是kernel函数，运行在GPU端的。而<code>launch_add2</code>是CPU端的执行函数，调用kernel。注意它是异步的，调用完之后控制权立刻返回给CPU，所以之后计算时间的时候要格外小心，很容易只统计到调用的时间。</p><h3 id="Torch-C-封装"><a href="#Torch-C-封装" class="headerlink" title="Torch C++封装"></a>Torch C++封装</h3><p>这里涉及到的是<code>add2.cpp</code>，这个文件主要功能是提供一个PyTorch可以调用的接口。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;torch/extension.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"add2.h"</span></span><span class="token keyword">void</span> <span class="token function">torch_launch_add2</span><span class="token punctuation">(</span>torch<span class="token operator">::</span>Tensor <span class="token operator">&amp;</span>c<span class="token punctuation">,</span>                       <span class="token keyword">const</span> torch<span class="token operator">::</span>Tensor <span class="token operator">&amp;</span>a<span class="token punctuation">,</span>                       <span class="token keyword">const</span> torch<span class="token operator">::</span>Tensor <span class="token operator">&amp;</span>b<span class="token punctuation">,</span>                       <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">launch_add2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">data_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">data_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span><span class="token function">data_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">PYBIND11_MODULE</span><span class="token punctuation">(</span>TORCH_EXTENSION_NAME<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    m<span class="token punctuation">.</span><span class="token function">def</span><span class="token punctuation">(</span><span class="token string">"torch_launch_add2"</span><span class="token punctuation">,</span>          <span class="token operator">&amp;</span>torch_launch_add2<span class="token punctuation">,</span>          <span class="token string">"add2 kernel warpper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>torch_launch_add2</code>函数传入的是C++版本的torch tensor，然后转换成C++指针数组，调用CUDA函数<code>launch_add2</code>来执行核函数。</p><p>这里用pybind11来对<code>torch_launch_add2</code>函数进行封装，然后用cmake编译就可以产生python可以调用的.so库。但是我们这里不直接手动cmake编译，具体方法看下面的章节。</p><h3 id="Python调用"><a href="#Python调用" class="headerlink" title="Python调用"></a>Python调用</h3><p>最后就是python层面，也就是我们用户编写代码去调用上面生成的库了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>cpp_extension <span class="token keyword">import</span> loadcuda_module <span class="token operator">=</span> load<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"add2"</span><span class="token punctuation">,</span>                   sources<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"add2.cpp"</span><span class="token punctuation">,</span> <span class="token string">"add2.cu"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># c = a + b (shape: [n])</span>n <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span>a <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>b <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>cuda_c <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>n<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>ntest <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">def</span> <span class="token function">show_time</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    times <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># GPU warm up</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        func<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>ntest<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># sync the threads to get accurate cuda running time</span>        torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>        start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>        torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span>device<span class="token operator">=</span><span class="token string">"cuda:0"</span><span class="token punctuation">)</span>        end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        times<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>end_time<span class="token operator">-</span>start_time<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1e6</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r<span class="token punctuation">)</span>    <span class="token keyword">return</span> times<span class="token punctuation">,</span> res<span class="token keyword">def</span> <span class="token function">run_cuda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cuda_module<span class="token punctuation">.</span>torch_launch_add2<span class="token punctuation">(</span>cuda_c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span>    <span class="token keyword">return</span> cuda_c<span class="token keyword">def</span> <span class="token function">run_torch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># return None to avoid intermediate GPU memory application</span>    <span class="token comment" spellcheck="true"># for accurate time statistics</span>    a <span class="token operator">+</span> b    <span class="token keyword">return</span> None<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Running cuda..."</span><span class="token punctuation">)</span>cuda_time<span class="token punctuation">,</span> _ <span class="token operator">=</span> show_time<span class="token punctuation">(</span>run_cuda<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Cuda time:  {:.3f}us"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>cuda_time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Running torch..."</span><span class="token punctuation">)</span>torch_time<span class="token punctuation">,</span> _ <span class="token operator">=</span> show_time<span class="token punctuation">(</span>run_torch<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Torch time:  {:.3f}us"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>torch_time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里6-8行的<code>torch.utils.cpp_extension.load</code>函数就是用来自动编译上面的几个cpp和cu文件的。最主要的就是<code>sources</code>参数，指定了需要编译的文件列表。然后就可以通过<code>cuda_module.torch_launch_add2</code>，也就是我们封装好的接口来进行调用。</p><p>接下来的代码就随心所欲了，这里简单写了一个测量运行时间，对比和torch速度的代码，这部分留着下一章节讲解。</p><p>总结一下，主要分为三个模块：</p><ul><li>先编写CUDA算子和对应的调用函数。</li><li>然后编写torch cpp函数建立PyTorch和CUDA之间的联系，用pybind11封装。</li><li>最后用PyTorch的cpp扩展库进行编译和调用。</li></ul><h2 id="运行时间分析"><a href="#运行时间分析" class="headerlink" title="运行时间分析"></a>运行时间分析</h2><p>我们知道，CUDA kernel函数是异步的，所以不能直接在CUDA函数两端加上<code>time.time()</code>测试时间，这样测出来的只是调用CUDA api的时间，不包括GPU端运行的时间。</p><p>所以我们要加上线程同步函数，等待kernel中所有线程全部执行完毕再执行CPU端后续指令。这里我们将同步指令加在了python端，用的是<code>torch.cuda.synchronize</code>函数。</p><p>具体来说就是形如下面代码：</p><pre class="line-numbers language-python"><code class="language-python">torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span><span class="token punctuation">)</span>start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span><span class="token punctuation">)</span>end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中第一次同步是为了防止前面的代码中有未同步还在GPU端运行的指令，第二次同步就是为了等<code>fun()</code>所有线程执行完毕后再统计时间。</p><p>这里我们torch和cuda分别执行10次看看平均时间，此外执行前需要先执行10次做一下warm up，让GPU达到正常状态。</p><p>我们分别测试四种情况，分别是：</p><ul><li>两次同步</li><li>第一次同步，第二次不同步</li><li>第一次不同步，第二次同步</li><li>两次不同步</li></ul><p>这里我们采用英伟达的Nsight Systems来可视化运行的每个时刻指令执行的情况。</p><p>安装命令为：</p><pre class="line-numbers language-shell"><code class="language-shell">sudo apt install nsight-systems<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在运行python代码时，在命令前面加上<code>nsys profile</code>就行了：</p><pre class="line-numbers language-shell"><code class="language-shell">nsys profile python3 main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就会生成<code>report1.qdstrm</code>和<code>report1.sqlite</code>两个文件，将<code>report1.qdstrm</code>转换为<code>report1.qdrep</code>文件：</p><pre class="line-numbers language-shell"><code class="language-shell">QdstrmImporter -i report1.qdstrm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后将生成的<code>report1.qdrep</code>文件用Nsight Systems软件打开，我这里是mac系统。</p><h3 id="两次同步"><a href="#两次同步" class="headerlink" title="两次同步"></a>两次同步</h3><p>这是正确的统计时间的方法，我们打开Nsight Systems，放大kernel运行那一段可以看到下图：<br><img src="1.png" alt></p><p>其中第1和第3个框分别是cuda和torch的GPU warm up过程，这部分没有进行线程同步（上面的黄色块）。</p><p>而第2和第4个框就分别是cuda和torch的加法执行过程了，我们可以放大来看看。<br><img src="2.png" alt></p><p>可以看出，每执行一次（一个框）都经过了三个步骤：先是调用api（左上角蓝色框），然后执行kernel（下方蓝色框），最后线程同步（右上角黄色框）。</p><p>所以最后算出来的时间就是这三个步骤的耗时，也就是下图选中的范围：<br><img src="3.png" alt></p><p>时间大概在29us左右，和我们实际代码测出来的也是比较接近的：<br><img src="4.png" alt></p><p>其实我们实际想要知道的耗时并不包括api调用和线程同步的时间，但是这部分时间在python端不好去掉，所以就加上了。</p><h3 id="第一次同步，第二次不同步"><a href="#第一次同步，第二次不同步" class="headerlink" title="第一次同步，第二次不同步"></a>第一次同步，第二次不同步</h3><p>放大每次执行的过程：<br><img src="5.png" alt></p><p>可以看出，虽然长的和上一种情况几乎一模一样，但是在api调用完之后，立刻就进行计时了，所以耗时只有8us左右，实际测出来情况也是这样的：<br><img src="6.png" alt></p><h3 id="第一次不同步，第二次同步"><a href="#第一次不同步，第二次同步" class="headerlink" title="第一次不同步，第二次同步"></a>第一次不同步，第二次同步</h3><p>我们先来看一下实际统计的时间：<br><img src="7.png" alt></p><p>很奇怪是不是，第一次运行耗时非常久，那我们可视化看看到底怎么回事：<br><img src="8.png" alt></p><p>可以看出，因为第一次开始计时前没有同步线程，所以在GPU warm up调用api完毕后，第一次cuda kernel调用就开始了。然后一直等到warm up执行完毕，才开始执行第一次cuda kernel，然后是线程同步，结束后才结束计时。这个过程非常长，差不多有130us左右。然后第二次开始执行就很正常了，因为kernel结束的同步相当于是下一次执行之前的同步。</p><h3 id="两次不同步"><a href="#两次不同步" class="headerlink" title="两次不同步"></a>两次不同步</h3><p>先来看看执行情况：<br><img src="9.png" alt></p><p>可以看出因为没有任何同步，所有GPU warm up和cuda kernel的api调用全接在一起了，执行也是。所以计时只计算到了每个api调用的时间，差不多在7us左右。</p><p>上面四种情况，torch指令情形几乎一样，因此不再赘述。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这篇文章，应该可以大致了解PyTorch实现自定义CUDA算子并调用的方法，也能知道怎么正确的测量CUDA程序的耗时。</p><p>当然还有一些内容留作今后讲解，比如如何实现PyTorch神经网络的自定义前向和反向传播CUDA算子、如何用TensorFlow调用CUDA算子等等。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> C++ </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信电脑版重大更新，可以上班刷朋友圈摸鱼了</title>
      <link href="/2021/03/13/wechat-3-0-0/"/>
      <url>/2021/03/13/wechat-3-0-0/</url>
      
        <content type="html"><![CDATA[<p>微信刚刚更新了3.0.0内测版本，不过暂时只有mac os版本。</p><p>主要有这么几大更新：</p><ul><li>图标变了。</li><li>能刷朋友圈了。</li><li>能看聊天分享的视频号了。</li><li>支持深色模式了。</li></ul><p>首先是图标，从原来的圆润的图标变成了手机端的方形图标：</p><p><img src="1.png" alt></p><p>然后是可以刷朋友圈了，这是最重磅的一大更新了，上班再也不用担心刷手机摸鱼被发现了！</p><p><img src="2.png" alt></p><p>接着是可以点开朋友分享的视频号观看了，不过只能看分享的，不能任意查看。</p><p><img src="3.png" alt></p><p>最后是支持深色模式了，不过对系统版本有要求。</p><p><img src="4.png" alt></p><blockquote><p>因为是内测版，所以自己下安装包安装。在我公众号“算法码上来”的后台回复“微信”，下载最新安装包。</p></blockquote><p>但是安装完后，如果你的系统是最新的big sur，那么可能会打不开，显示“没有权限”。那么两条简单的命令教你怎么解决。</p><pre class="line-numbers language-shell"><code class="language-shell">sudo chmod -R 777 /Applications/WeChat.app/xattr -c -r /Applications/WeChat.app/Contents/MacOS/WeChat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先第一条命令是给微信app文件夹下所有文件赋予可执行权限，第二条命令则是去除mac系统特有的管理权限，然后就能运行啦。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 朋友圈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节跳动2021春招正式启动！欢迎找我内推~</title>
      <link href="/2021/02/25/bytedance2021-hire/"/>
      <url>/2021/02/25/bytedance2021-hire/</url>
      
        <content type="html"><![CDATA[<p><img src="1.png" alt></p><blockquote><p>字节跳动2021春季校园招聘正式启动！<strong>持续扩招，7000+ offer来袭，2次投递机会，70%超高实习转正率</strong>，大量暑期实习及全职补录岗位欢迎大家踊跃投递！</p></blockquote><h2 id="招聘对象"><a href="#招聘对象" class="headerlink" title="招聘对象"></a>招聘对象</h2><p>👩‍🎓暑期实习：2022届应届生（2021 年 9 月至 2022 年 8 月期间毕业）<br>👨‍🎓全职补录：2021届应届生（2020 年 9 月至 2021 年 8 月期间毕业）</p><p><em>上述毕业时间中国大陆以毕业证为准，非中国大陆地区以学位证为准，全职补录岗位需最高学历毕业后无全职工作经验</em></p><h2 id="职位类别"><a href="#职位类别" class="headerlink" title="职位类别"></a>职位类别</h2><p>研发、运营、职能/支持、产品、设计、销售、市场、教研教学、游戏策划。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>每位候选人最多可以投递<strong>两个</strong>职位。</li><li>两个职位可以同时投递、彼此独立，<strong>较早投递</strong>的职位默认优先处理。</li><li>内推码的优势是可以帮助候选人的简历被<strong>优先筛选</strong>，并且可以随时<strong>查进度</strong>，<strong>联系HR</strong>。</li><li>候选人可以同时投递校招实习岗位和日常实习岗位，但注意候选人当次只能在<strong>一个岗位</strong>上进入后续招聘流程。</li><li>内推码<strong>不支持补填</strong>，记得一定要第一时间填上我的内推码哦。</li></ul><h2 id="我的内推码："><a href="#我的内推码：" class="headerlink" title="我的内推码："></a>我的内推码：</h2><p><strong>A7FSJMK</strong></p><h2 id="投递链接"><a href="#投递链接" class="headerlink" title="投递链接"></a>投递链接</h2><p><a href="https://jobs.toutiao.com/s/e1tMuhb" target="_blank" rel="noopener">https://jobs.toutiao.com/s/e1tMuhb</a></p><h2 id="投递二维码"><a href="#投递二维码" class="headerlink" title="投递二维码"></a>投递二维码</h2><p><img src="2.png" alt></p><h2 id="日常实习生以及社招"><a href="#日常实习生以及社招" class="headerlink" title="日常实习生以及社招"></a>日常实习生以及社招</h2><p><strong>日常实习生</strong>以及<strong>社招</strong>长期开启，欢迎<strong>加入内推群</strong>了解最新消息，也欢迎<strong>加我微信</strong>给我简历，向我咨询进度。</p><p><em>注意：<strong>暑期实习</strong>以及<strong>全职补录</strong>请从上文链接投递，下图二维码适合任意时刻投递。</em><br><img src="3.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内推 </tag>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情人节，情人结，情人劫</title>
      <link href="/2021/02/14/valentine-day/"/>
      <url>/2021/02/14/valentine-day/</url>
      
        <content type="html"><![CDATA[<p>首先还是祝各位有情人的、没情人的都节日快乐~</p><p>为什么突然挑这个时间写文章呢，一是好几天没发了再水水，二是太闷了唠唠嗑，三是抒发一下近来的情感。</p><p>先说说我的择偶标准的变化历程吧。刚上大学时，我还是投身学习的小屁孩，那时候只想找一个系，一个班的，天天腻在一起，一起上课吃饭自习，有时间呢就出去玩玩，典型的校园青春剧咯。当然因为很多事做的不到位，后来就结束了。一直到现在，都没有经历过下一段。这期间，我的择偶观不断发生着变化，准确来说，是越来越宽松。从一个系扩大到了一个学校，扩大到了一个上海，当然仍然无法接受异地，腻在一起的心依旧没有磨灭。颜值上我也没有很高标准，我对我自己也有自知之明。开始越来越看中未来的计划了，考虑很多现实因素。以后不在上海工作？pass。门不当户不对？对不起我怂了。圈子差太多？咱们聊不来。等等等等。考虑的越多，越怂，以至于没有一个可以进入我的考虑范围之内了。我室友曾经跟我说过，考虑那么多干嘛，先谈着不就行了。再小几岁也许我会这么想吧，现在不小了，到了谈婚论嫁的年龄了，太现实了，我会想到以后很远很远的日子，不想随随便便了，最好下一次就是最后一次。可能28岁以前找不到的话，就要接受相亲的事实了吧，直奔目的，也挺好，就跟做买卖一样。其实择偶标准这方面都是活的，我最最最看重的就是跟我能聊得来，性格相合，有差距无所谓，我的可塑性还是不错的，都好调节。如果上来就聊不来，那就基本gg了，我这么擅长聊天的人都能聊死，我只能说确实不适合。</p><p>再说说我是个什么样的人吧，很多人可能对我有很大的误解。我是一个经历非常简单的人，26年来应该除了学习、一段恋爱、实习工作、游戏，再无他物。我也是一个恋爱或人生理论家、鸡汤大师，我说过，我很擅长开导人，我也很少不回别人的消息。所以可能在我单身的时候，会经常看到我的聊天列表里面的人不停的换，公司来了两个学妹实习吃个饭也能被人逮到把柄，所以自然而然会把我往海王那里引导。实际上寡王差不多吧，不聊感情不聊骚，只是出于学长之类的身份给予一些必要的帮助吧。而且我是一个很有原则的人，只要我有了目标，不管是将来进行时还是现在进行时，我都不会再和其他异性闲聊了，对自己负责，对她也是负责。我的判断能力也挺强的吧，很难被他人的观点左右，我只会根据自己的判断，去决定网上的观点是对还是错，对的我吸收了，错的我一笑了之，不会当真。这也导致了我一定程度上的独立性，看到网上的恋爱教学、人生教学、成功学、营销大师这种，我基本上都当段子看，不全信，不茫然跟从，甚至有些会在心里骂讲的什么玩意。我也很擅长开导人，失恋了、考验了、找工作了、发论文了等等等等，都有人找我问过，理论我都能说一大堆，鸡汤我也能编的停不下来。我很擅长从我的实际情况和我身边人的实际情况出发，用讲故事的形式告诉那些人人生的道理，而不是网上的教学那样张口就来大道理。我一直觉得，身边人都有那么多好的范例了，为什么还要去相信那些虚无的，没有见过的事物。当然身边的人也不能全部借鉴，还是靠我自己的判断力，哪些人的经历我觉得适合我，哪些人我觉得三观不正，有问题，我要远离。我都有自己的判断方式，近朱者赤，近墨者黑，从小到大我都是这样。生活上，我也很简单，现在每天上班，下班就回来打游戏，说白了还是比较懒。但是生活情调还是要有的，香薰啥的小物件我喜欢摆摆，起泡酒这种提高生活幸福感的东西还是要有的。我的抗压能力应该说还可以，虽然我很容易被压力困扰，学业压力、工作压力、情感压力。但是我还是比较能自我排解的吧，喝起泡酒微醺、写写文章就像现在这样、和室友聊聊、出去透透气，都能想开不少。没有什么大不了的，这个没成，大不了继续努力工作嘛，没有谁离不开谁。</p><p>其实恋爱观这方面我也改变了很多想法了，以前的我很喜欢网聊，主要还是因为宅，刚开始肯定都是网上聊聊。那么就会有一个问题，有些不喜欢网聊的女生就会长时间不回你。当然可能原因很多，可能你是鱼，那你就也晾着就行了。也可能她是真的喜欢线下，那就要学会习惯，在她不回你消息的时候，不要再去想想想了，想她为什么还是不回我啊，她到底在干嘛呀，她到底是不是故意晾着我啊。大可不必，做好你自己的事就行了，发完你自己的消息，然后就去认真工作，提升自己，变得更好，吸引才是最重要的。当然这方面我还是没有完全适应呢，正在努力习惯。</p><p>关于未来，我的计划其实是和绝大多数人一样的，很普通很平常。几年之内攒够首付的钱，在近郊附近买一套不大不小的房，距离在我和她公司的中间，看情况可以更靠近她一点，当然近地铁优先。若干年之后卖掉再换大的，定型。然后就是带小孩了，996的工作可能下班晚了点，谁有空谁接送，如果是两个程序员，那我真没想过该怎么办。双方父母肯定也会来带，一带一个月那种，然后带回老家带带之类的。这些话题都太远了，而且问题都不大，都不是什么难点，不多说了。</p><p>放平心态，淡化得失，无论成功与否，都不要太放心上，对人要用心，对自己更要上心。</p><p>还有好多没想得起来的，没写在文字里，以后慢慢聊吧。</p><p>祝好。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恋爱观 </tag>
            
            <tag> 人生观 </tag>
            
            <tag> 价值观 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鼠年最后一篇随笔</title>
      <link href="/2021/02/10/2021-guonian/"/>
      <url>/2021/02/10/2021-guonian/</url>
      
        <content type="html"><![CDATA[<p>明天就是除夕了，这应该也是鼠年最后一篇文章了，也达成了第一次在外过年的成就。</p><p>今年没有选择回家过年🧨，虽然家在江苏盐城，2小时的🚄就到了，原因很多。</p><p>一是懒得做好几次核酸，虽然家里农村管的可能并不严，也不需要啥隔离，但还是嫌麻烦。</p><p>二是要写毕业论文，在公司写🈶️4k显示器，🈶️我的机械键盘，租房还🈶️我的🖥️可以打打🎮。</p><p>三是在公司还能拿个💰，补贴补贴家用，毕竟6天就顶爸妈两人一个月了。</p><p>毕业论文已经写了大半了，过年申请了加班，认真熟悉一下之后的工作，想尽快融入。</p><p>还是有太多东西不会，和学校里学的都不一样，cuda、DL编译等等太多太多，希望早日能熟悉这块领域。</p><p>过年准备了很多吃的喝的，防止点不到外卖或者店不开门，饿是饿不死，论文也不会写的。</p><p>第一次在外过年，心情倒也没那么失落，也没那么想家，和爸妈也经常视频，也不反对我留下。</p><p>开始学着买🐔金，做一波韭菜，吃一波人口红利了。</p><p>好好攒钱，早日买房，平时吃喝也都在公司食堂，除了房租可能一个月也就花几百，把💰花在对的人和事身上。</p><p>好好❤️自己，❤️👩。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 过年 </tag>
            
            <tag> 爱情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于内推、简历、面试，我有一些想说的</title>
      <link href="/2021/02/05/about-find-work/"/>
      <url>/2021/02/05/about-find-work/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近我司内推活动又开始了，宣传了一波，帮很多人内推了一下，这过程中也发现了不少问题。虽然我也没太多经验，但还是想拿出来说一说。</p></blockquote><h2 id="关于内推"><a href="#关于内推" class="headerlink" title="关于内推"></a>关于内推</h2><p>其实如果你只是随便在网上找了个内推码，然后自己投了投，那和不内推基本没有任何区别。所以还是得找靠谱的人内推，能随时联系得上，内推的一大好处就是<strong>能随时找他查查进度咋样了，能让他帮忙联系hr处理一些事情</strong>。当然这还是普通内推的情况，如果你投的是内推人自己的部门，并且你也很强，那他可以在面试官面前给你吹吹牛，至少<strong>简历关基本上可以直接过了吧，面试或许也能增加好感</strong>，当然个人能力还是最重要的。</p><p>然后就是针对我司内推的一些注意事项，<strong>尽量不要海投</strong>。有些人以为一下子投几十个，总能有一个被捞起来吧。其实我们后台系统看到的情况是，简历评估是串行的，遵循队列先进先出的规律，你的投递顺序决定了你的简历评估顺序。所以<strong>投你最中意、最有把握的岗位</strong>就行，然后可以投一两个次优的，或者干脆别再投了。因为你投再多，流程也不会进行下去的。</p><p>也有人会好奇内推对我有啥好处，其实绝大多数情况下，你们在我这投一个简历我可能也就几毛钱或者几块钱，只有入职了才会有大额奖金。</p><h2 id="关于简历"><a href="#关于简历" class="headerlink" title="关于简历"></a>关于简历</h2><p>简历说白了其实还是需要硬实力，但是我相信大多数人跟我一样也没啥拿得出手的干货，这时候就要包装一下了。</p><p>先放一下我的辣鸡简历吧：</p><p><strong>中文简历：</strong><br><a href="https://godweiyang.com/medias/files/cv-zh.pdf">https://godweiyang.com/medias/files/cv-zh.pdf</a></p><p><strong>英文简历：</strong><br><a href="https://godweiyang.com/medias/files/cv-en.pdf">https://godweiyang.com/medias/files/cv-en.pdf</a></p><p>也没啥好参考的，我这方面经验不是很足，推荐一个我感觉不错的经验贴：</p><p><a href="https://www.zhihu.com/question/25002833/answer/158108028" target="_blank" rel="noopener">https://www.zhihu.com/question/25002833/answer/158108028</a></p><p>我个人感觉，少一些主观评价（没有特色的），比如踏实好学、不怕吃苦这种（还真看到很多人喜欢写这些）。然后突出自己的特长，精简一些，如果你是面试官，第一眼看到你的简历如果是密密麻麻的，那你可能都没耐心找重点了。</p><p>简历模板也是不少人想要的，我比较推崇用LaTeX模板写，排版比较工整，也不会很花里胡哨，当然你喜欢用word也行。分享一个LaTeX模板网站吧：</p><p><a href="https://www.latexstudio.net/index/lists/barSearch/text/%E7%AE%80%E5%8E%86" target="_blank" rel="noopener">https://www.latexstudio.net/index/lists/barSearch/text/%E7%AE%80%E5%8E%86</a></p><p>简历页数最好控制在一页以内，还是以精简为主，当然如果你是大佬几十页的论文就当我没说，不过大佬也不会来看我写的这些。</p><h2 id="关于面试"><a href="#关于面试" class="headerlink" title="关于面试"></a>关于面试</h2><p>面试我也没啥好说的，主要就算法题和专业知识，我的经历说实话也基本没任何参考价值。</p><p>算法题去刷leetcode就行了。如果你有基础，那就随机刷，找手感就行了。如果你基础不是很好，那就刷重点专题，比如贪心、动态规划之类的，先培养题感。大多数题目官网都有不错的题解，如果你还是看不懂，可以试试看我写的题解：</p><p><a href="https://godweiyang.com/2020/04/24/leetcode-conclusions-110/">https://godweiyang.com/2020/04/24/leetcode-conclusions-110/</a></p><p>专业知识没啥特别说的，网上找面经复习去吧，当然这就靠你搜索能力了，鱼龙混杂，不一定找得到靠谱的面经。就拿我NLP方向举例，我当时就在知乎找到几篇不错的总结文章，例如下面的：</p><p><strong>nlp中的预训练语言模型总结（单向模型、BERT系列模型、XLNet）：</strong><br><a href="https://zhuanlan.zhihu.com/p/76912493" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76912493</a></p><p><strong>NLP算法面试必备！史上最全！PTMs：NLP预训练模型的全面总结：</strong><br><a href="https://zhuanlan.zhihu.com/p/115014536" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/115014536</a></p><p>我觉得很多人搜索能力还是挺欠缺的，特别是在各种群里看到过的各种问题都能轻易搜到，所以锻炼锻炼搜索能力吧。</p><p>如果你有很牛的论文或者项目，那大可不必复习得这么累，好好温习一下你的论文或项目，问起细节来对答如流就行。</p><h2 id="找我内推"><a href="#找我内推" class="headerlink" title="找我内推"></a>找我内推</h2><p><strong>NLP同学想来我们组的：</strong><br>有NLP基础，想找实习的同学，可以【直接把简历给我】。我们组（字节AI Lab NLP，北京和上海）急缺做文本生成和机器翻译相关工作的实习生，不要求有顶会或竞赛，面试能过就行，看能力。实习转正率很高。有兴趣的私聊我【微信godweiyang】直接发简历，会直接送到leader手上，帮转给有需要的同学也行。</p><p><strong>想投其他岗位的：</strong><br>我的内推码：<strong>A7FSJMK</strong></p><p>投递地址：<br><a href="https://job.toutiao.com/referral/mobile/position?token=MzsxNjExOTkzMjA4NDg4OzY4MjMzNTY3NzIyMzg0MTEyNzc7MA" target="_blank" rel="noopener">https://job.toutiao.com/referral/mobile/position?token=MzsxNjExOTkzMjA4NDg4OzY4MjMzNTY3NzIyMzg0MTEyNzc7MA</a></p><p>或者直接加我微信godweiyang，拉你进内推群，找我问进度，有啥疑问也能直接问我。</p><p><img src="1.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内推 </tag>
            
            <tag> 简历 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想来字节跳动和我做同事吗？抓紧这次机会吧~</title>
      <link href="/2021/01/28/bytedance-offer/"/>
      <url>/2021/01/28/bytedance-offer/</url>
      
        <content type="html"><![CDATA[<h2 id="想来字节吗？"><a href="#想来字节吗？" class="headerlink" title="想来字节吗？"></a>想来字节吗？</h2><blockquote><p>想来字节体会一下字节范吗？想来和我面基一起吃个饭吗？那就先来投个简历实习一下吧。文末有<strong>投递方式</strong>和<strong>内推群</strong>链接。</p></blockquote><p><strong>投递时间</strong>：2020.1.28 - 2020.7.31<br><strong>投递岗位</strong>：中国大陆所有<strong>研发类实习生</strong></p><h2 id="我的亲身实习经历"><a href="#我的亲身实习经历" class="headerlink" title="我的亲身实习经历"></a>我的亲身实习经历</h2><p>我在2020年5月通过暑期实习进来的，在字节跳动实习也有大半年了，也顺利转正了，体验可以说是非常nice。</p><p>我也写过几篇随笔，记录了一下实习体验之类的：  </p><ul><li><a href="https://godweiyang.com/2020/04/26/summer-interview-experience/" title="【NLP算法岗】提前批暑期实习面经">【NLP算法岗】提前批暑期实习面经</a></li><li><a href="https://godweiyang.com/2020/12/05/school-conclusion/" title="物来顺应，未来不迎，当时不杂，既过不恋">物来顺应，未来不迎，当时不杂，既过不恋</a></li></ul><p>每天的美食肯定是体会最深的了，<strong>不要钱，不要钱，不要钱</strong>，重要的事情要说三遍。你以为不要钱肯定没好吃的？那就错了，我经常会把我吃的拍给我妈看，随便挑一些拍过的吧（我饭量小，拍的也不大行，所以看起来肯定没有官方摆拍好看，但是很实在）：<br><img src="1.jpeg" alt></p><p>上面还能看到有<strong>乐乐茶</strong>，没错这就是几天前我们的下午茶！</p><p>多的我不说了，不同部门的工作强度和体验也不一样，我不好评价。我只能说，来了字节可能确实也有些部门会很累，但是<strong>综合体验不会差</strong>。</p><h2 id="福利待遇"><a href="#福利待遇" class="headerlink" title="福利待遇"></a>福利待遇</h2><p>下面都是基础性的福利了，大家都是知道的，不多说了：</p><ul><li>就近住房补贴。</li><li>免费三餐自助，节省时间可选择盒饭，减肥健身可选择健康餐。</li><li>免费健身房和康体娱乐中心。</li><li>下午茶，零食水果、咖啡牛奶统统不限量。</li></ul><h2 id="投递方式"><a href="#投递方式" class="headerlink" title="投递方式"></a>投递方式</h2><p>可以直接点击下方<strong>链接</strong>选择你心仪的岗位投递：<br><a href="https://job.toutiao.com/referral/mobile/lightning-referral?token=MzsxNjExODMyOTIzNzg1OzY4MjMzNTY3NzIyMzg0MTEyNzc7MA" target="_blank" rel="noopener">https://job.toutiao.com/referral/mobile/lightning-referral?token=MzsxNjExODMyOTIzNzg1OzY4MjMzNTY3NzIyMzg0MTEyNzc7MA</a></p><p>也可以扫描下面的<strong>二维码</strong>投递：<br><img src="2.png" alt></p><h2 id="字节跳动内推群"><a href="#字节跳动内推群" class="headerlink" title="字节跳动内推群"></a>字节跳动内推群</h2><p>欢迎加入<strong>字节跳动内推群</strong>，有任何问题都可以在群里提问（如果二维码失效，加我微信直接拉你进群）：<br><img src="3.png" alt><br><strong>我的微信</strong>：<br><img src="4.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你如何用代码自动群发邮件（邮件轰炸机）</title>
      <link href="/2021/01/26/python-mail/"/>
      <url>/2021/01/26/python-mail/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近碰到个脑子可能不大正常的人，整天给一堆人群发乱七八糟的邮件，各种喷人、编造谣言和绯闻，看的很是心烦。</p></blockquote><p><img src="1.png" alt="一个上午就发了这么多"><br><img src="2.png" alt="都是编造的我老家各种老师、官员的绯闻"></p><p>于是乎我找了段python代码，给她自动发邮件轰炸一下。</p><p>代码很简单，如下所示：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding: utf-8</span><span class="token keyword">import</span> time<span class="token keyword">import</span> smtplib<span class="token keyword">from</span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>multipart <span class="token keyword">import</span> MIMEMultipart<span class="token keyword">from</span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>text <span class="token keyword">import</span> MIMEText<span class="token keyword">from</span> email<span class="token punctuation">.</span>header <span class="token keyword">import</span> Headersmtpserver <span class="token operator">=</span> <span class="token string">'smtp.163.com'</span>username <span class="token operator">=</span> <span class="token string">'username@163.com'</span>password <span class="token operator">=</span> <span class="token string">'password'</span>sender <span class="token operator">=</span> <span class="token string">'username@163.com'</span>receiver <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'username@qq.com'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># receiver = ['username1@qq.com', 'username2@163.com']</span>msg <span class="token operator">=</span> MIMEMultipart<span class="token punctuation">(</span><span class="token string">'mixed'</span><span class="token punctuation">)</span>subject <span class="token operator">=</span> <span class="token string">'发送主题'</span>subject <span class="token operator">=</span> Header<span class="token punctuation">(</span>subject<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span>msg<span class="token punctuation">[</span><span class="token string">'Subject'</span><span class="token punctuation">]</span> <span class="token operator">=</span> subjectmsg<span class="token punctuation">[</span><span class="token string">'From'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'username &lt;username@163.com>'</span>msg<span class="token punctuation">[</span><span class="token string">'To'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'username &lt;username@163.com>'</span><span class="token comment" spellcheck="true"># msg['To'] = 'username1 &lt;username1@163.com>; username2 &lt;username2@163.com>'</span>msg<span class="token punctuation">[</span><span class="token string">'Date'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'2021-1-26'</span>text <span class="token operator">=</span> <span class="token string">"邮件正文"</span>text_plain <span class="token operator">=</span> MIMEText<span class="token punctuation">(</span>text<span class="token punctuation">,</span> <span class="token string">'plain'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span>msg<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>text_plain<span class="token punctuation">)</span>total <span class="token operator">=</span> <span class="token number">1000</span>send <span class="token operator">=</span> <span class="token number">0</span>error <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> error <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">and</span> send <span class="token operator">&lt;</span> total<span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        smtp <span class="token operator">=</span> smtplib<span class="token punctuation">.</span>SMTP<span class="token punctuation">(</span><span class="token punctuation">)</span>        smtp<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'smtp.163.com'</span><span class="token punctuation">)</span>        smtp<span class="token punctuation">.</span>login<span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span>        <span class="token keyword">while</span> send <span class="token operator">&lt;</span> total<span class="token punctuation">:</span>            smtp<span class="token punctuation">.</span>sendmail<span class="token punctuation">(</span>sender<span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>as_string<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第{}封邮件发送成功！"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>send<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            send <span class="token operator">+=</span> <span class="token number">1</span>            error <span class="token operator">=</span> <span class="token number">0</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span>        smtp<span class="token punctuation">.</span>sendmail<span class="token punctuation">(</span>sender<span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>as_string<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        smtp<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"发生错误，重新发送"</span><span class="token punctuation">)</span>        error <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先你需要开启你的邮箱的<strong>POP3/SMTP</strong>和<strong>IMAP/SMTP</strong>服务，一般在邮箱设置的账户里，找找都能找到，注意开启后会获得一段<strong>授权码</strong>，牢记它！之后的操作用它来替换你原本的邮箱密码。</p><p>上面代码详细含义如下：</p><ul><li><code>smtpserver</code>替换成你自己邮箱的服务器地址，百度可以搜到。</li><li><code>username</code>替换成你的邮箱账号，也就是登陆的时候的账号名。</li><li><code>password</code>替换成你的<strong>授权码</strong>，而不是原本的邮箱密码！</li><li><code>sender</code>是你的发件人，替换成你的邮箱账号。</li><li><code>receiver</code>是你的收件人，注释部分可以发送给多个人。注意<strong>很多邮箱有最大收件人个数的限制</strong>。</li><li><code>subject</code>是你的邮件主题。</li><li><code>msg[&#39;From&#39;]</code>是发邮件时显示的发件人信息。</li><li><code>msg[&#39;To&#39;]</code>是发邮件时显示的收件人信息，注释部分也可以显示多个人信息，用分号隔开。</li><li><code>msg[&#39;Date&#39;]</code>是发邮件日期。</li><li><code>text</code>是邮件正文，这里我省略了图片、附件等发送方法，可以参考文末链接。</li><li><code>total</code>是我设置的邮件轰炸次数，这里发送1000次，如果你是正常群发目的，设置成1次就行了。</li><li><code>error</code>是允许报错次数，如果连续超过10次依然发送失败，那么就停止发送了。</li><li>注意我这里设置了<code>time.sleep(60)</code>，也就是60秒发送一次。这个时间不能太短，不然发送过于频繁，会被判断成垃圾邮件！</li></ul><p>如果运行提示缺少库，那就用<code>pip install xxx</code>安装一下就行了。</p><p>像大家平时如果有群发邮件的正当需求，都可以用这个代码试试。不建议用它来轰炸其他人哦，这是不好的行为。</p><p><strong>参考文献：</strong><br><a href="https://www.cnblogs.com/yufeihlf/p/5726619.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeihlf/p/5726619.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 发邮件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐几个不错的CUDA入门教程（非广告）</title>
      <link href="/2021/01/25/cuda-reading/"/>
      <url>/2021/01/25/cuda-reading/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近因为项目需要，入坑了CUDA，又要开始写很久没碰的C++了。对于CUDA编程以及它所需要的GPU、计算机组成、操作系统等基础知识，我基本上都忘光了，因此也翻了不少教程。这里简单整理一下，给同样有入门需求的同学们参考一下。</p></blockquote><h1 id="官方文档及书籍"><a href="#官方文档及书籍" class="headerlink" title="官方文档及书籍"></a>官方文档及书籍</h1><p>英文好、时间充裕的同学可以精读官方文档或者著作。</p><h2 id="NVIDIA-CUDA-C-Programming-Guide"><a href="#NVIDIA-CUDA-C-Programming-Guide" class="headerlink" title="NVIDIA CUDA C++ Programming Guide"></a>NVIDIA CUDA C++ Programming Guide</h2><p><strong>地址：</strong><br><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html</a></p><p>这是英伟达官方的CUDA编程教程，但是我英文一般，简单过了一遍之后感觉很多细节没讲，有一定的跳跃性，所以我看完还是很朦胧。</p><h2 id="CUDA-C-Best-Practices-Guide"><a href="#CUDA-C-Best-Practices-Guide" class="headerlink" title="CUDA C++ Best Practices Guide"></a>CUDA C++ Best Practices Guide</h2><p><strong>地址：</strong><br><a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html</a></p><p>这也是英伟达官方的CUDA编程教程，不过侧重点在实践方面，比如如何编程才能最大化利用GPU特性提升性能，建议基础打好之后再来看这个。</p><h2 id="CUDA-C编程权威指南"><a href="#CUDA-C编程权威指南" class="headerlink" title="CUDA C编程权威指南"></a>CUDA C编程权威指南</h2><p>这么经典的书就不用我多说了，英文原版叫《Professional CUDA C Programming》，pdf地址在下面，如果打开比较慢的可以后台回复【cuda】获取pdf文件：<br><a href="http://www.hds.bme.hu/~fhegedus/C++/Professional%20CUDA%20C%20Programming.pdf" target="_blank" rel="noopener">http://www.hds.bme.hu/~fhegedus/C++/Professional%20CUDA%20C%20Programming.pdf</a></p><h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><p>像我这种英文差、想快速入门的只能找找中文博客看看了，还是找到不少非常奈斯的教程的。</p><h2 id="谭升的博客（强推！！！）"><a href="#谭升的博客（强推！！！）" class="headerlink" title="谭升的博客（强推！！！）"></a>谭升的博客（强推！！！）</h2><p><strong>地址：</strong><br><a href="https://face2ai.com/program-blog/#GPU编程（CUDA）" target="_blank" rel="noopener">https://face2ai.com/program-blog/#GPU编程（CUDA）</a></p><p>这是我最近发现的又一个宝藏博主，看完他的GPU编程系列教程后感觉豁然开朗，很多底层的原理和细节都通彻了，<strong>强烈安利！</strong></p><p>他在github还开源了教程对应的示例代码：<br><a href="https://github.com/Tony-Tan/CUDA_Freshman" target="_blank" rel="noopener">https://github.com/Tony-Tan/CUDA_Freshman</a></p><h2 id="CUDA编程入门极简教程"><a href="#CUDA编程入门极简教程" class="headerlink" title="CUDA编程入门极简教程"></a>CUDA编程入门极简教程</h2><p><strong>地址：</strong><br><a href="https://zhuanlan.zhihu.com/p/34587739" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34587739</a></p><p>速览即可，看完就会写最简单的CUDA代码了。</p><h2 id="《CUDA-C-Programming-Guide》-《CUDA-C-编程指南》-导读"><a href="#《CUDA-C-Programming-Guide》-《CUDA-C-编程指南》-导读" class="headerlink" title="《CUDA C Programming Guide》(《CUDA C 编程指南》)导读"></a>《CUDA C Programming Guide》(《CUDA C 编程指南》)导读</h2><p><strong>地址：</strong><br><a href="https://zhuanlan.zhihu.com/p/53773183" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53773183</a></p><p>这是NVIDIA CUDA C++ Programming Guide和《CUDA C编程权威指南》两者的中文解读，加入了很多作者自己的理解，对于快速入门还是很有帮助的。但还是感觉细节欠缺了一点，建议不懂的地方还是去看原著。</p><h2 id="CUDA编程入门系列"><a href="#CUDA编程入门系列" class="headerlink" title="CUDA编程入门系列"></a>CUDA编程入门系列</h2><p><strong>地址：</strong><br><a href="https://zhuanlan.zhihu.com/p/97044592" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/97044592</a></p><p>这位大佬写了六篇，主要是通过一个简单的加法的例子，一步步讲了CUDA优化的若干种方法，拿来上手实践一下还是很棒的。</p><h2 id="CUDA编程系列"><a href="#CUDA编程系列" class="headerlink" title="CUDA编程系列"></a>CUDA编程系列</h2><p><strong>地址：</strong><br><a href="https://blog.csdn.net/sunmc1204953974/article/details/51000970" target="_blank" rel="noopener">https://blog.csdn.net/sunmc1204953974/article/details/51000970</a></p><p>这个系列写的也是很全了，十几篇，建议快速通读一下。</p><h1 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h1><p>有很多的CUDA源码可以供我们慢慢学习，我这就简单给几个典型的Transformer系列的加速代码了。</p><h2 id="LightSeq"><a href="#LightSeq" class="headerlink" title="LightSeq"></a>LightSeq</h2><p><strong>地址：</strong><br><a href="https://github.com/bytedance/lightseq" target="_blank" rel="noopener">https://github.com/bytedance/lightseq</a></p><p>这是字节跳动开源的生成模型推理加速引擎，BERT、GPT、VAE等等全都支持，速度也是目前业界最快的之一。</p><h2 id="FasterTransformer"><a href="#FasterTransformer" class="headerlink" title="FasterTransformer"></a>FasterTransformer</h2><p><strong>地址：</strong><br><a href="https://github.com/NVIDIA/DeepLearningExamples/tree/master/FasterTransformer" target="_blank" rel="noopener">https://github.com/NVIDIA/DeepLearningExamples/tree/master/FasterTransformer</a></p><p>这是英伟达开源的Transformer推理加速引擎。</p><h2 id="TurboTransformers"><a href="#TurboTransformers" class="headerlink" title="TurboTransformers"></a>TurboTransformers</h2><p><strong>地址：</strong><br><a href="https://github.com/Tencent/TurboTransformers" target="_blank" rel="noopener">https://github.com/Tencent/TurboTransformers</a></p><p>这是腾讯开源的Transformer推理加速引擎。</p><h2 id="DeepSpeed"><a href="#DeepSpeed" class="headerlink" title="DeepSpeed"></a>DeepSpeed</h2><p><strong>地址：</strong><br><a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener">https://github.com/microsoft/DeepSpeed</a></p><p>这是微软开源的深度学习分布式训练加速引擎。</p><blockquote><p>我mentor说，不需要看这些，然后甩给了我20行代码，说看懂了就行了。结果我看懂了，门还是没开QAQ，所以建议还是看看底层一些的原理，加深自己的理解，特别是我强推的那篇博客。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cuda </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用画图代码（折线图、柱状图、饼图）</title>
      <link href="/2021/01/20/python-figure/"/>
      <url>/2021/01/20/python-figure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单记录一下最简单常用的三种论文插图的python画图代码，以作备忘。</p></blockquote><p>有很多很牛b的作图教程，我也学不来，就扔给大家自己学吧：</p><ul><li><a href="https://www.zhihu.com/question/21664179" title="如何在论文中画出漂亮的插图？" target="_blank" rel="noopener">如何在论文中画出漂亮的插图？</a></li></ul><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># x轴刻度标签</span>x_ticks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># x轴范围（0, 1, ..., len(x_ticks)-1）</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x_ticks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 第1条折线数据</span>y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 第2条折线数据</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置画布大小</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画第1条折线，参数看名字就懂，还可以自定义数据点样式等等。</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#FF0000'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'label1'</span><span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">3.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画第2条折线</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#00FF00'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'label2'</span><span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">3.0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 给第1条折线数据点加上数值，前两个参数是坐标，第三个是数值，ha和va分别是水平和垂直位置（数据点相对数值）。</span><span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">'%d'</span><span class="token operator">%</span>b<span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span> <span class="token string">'bottom'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 给第2条折线数据点加上数值</span><span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">'%d'</span><span class="token operator">%</span>b<span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span> <span class="token string">'bottom'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画水平横线，参数分别表示在y=3，x=0~len(x)-1处画直线。</span>plt<span class="token punctuation">.</span>hlines<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> colors <span class="token operator">=</span> <span class="token string">"#000000"</span><span class="token punctuation">,</span> linestyles <span class="token operator">=</span> <span class="token string">"dashed"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加x轴和y轴刻度标签</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span>r <span class="token keyword">for</span> r <span class="token keyword">in</span> x<span class="token punctuation">]</span><span class="token punctuation">,</span> x_ticks<span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">,</span> rotation<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加x轴和y轴标签</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span>u<span class="token string">'x_label'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>u<span class="token string">'y_label'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>u<span class="token string">'Title'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存图片</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'./figure.pdf'</span><span class="token punctuation">,</span> bbox_inches<span class="token operator">=</span><span class="token string">'tight'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图片</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="1.png" alt></p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># x轴刻度标签</span>x_ticks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 柱的宽度</span>barWidth <span class="token operator">=</span> <span class="token number">0.25</span><span class="token comment" spellcheck="true"># 第1个柱的x轴范围（每个柱子的中点）（0, 1, ..., len(x_ticks)-1）</span>x1 <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x_ticks<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 第2个柱的x轴范围（每个柱子的中点）</span>x2 <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">+</span> barWidth <span class="token keyword">for</span> x <span class="token keyword">in</span> x1<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 第1个柱数据</span>y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 第2个柱数据</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置画布大小</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画第1个柱</span>plt<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#FF0000'</span><span class="token punctuation">,</span> width<span class="token operator">=</span>barWidth<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'label1'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画第2个柱</span>plt<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#00FF00'</span><span class="token punctuation">,</span> width<span class="token operator">=</span>barWidth<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'label2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 给第1个柱数据点加上数值，前两个参数是坐标，第三个是数值，ha和va分别是水平和垂直位置（数据点相对数值）。</span><span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">'%d'</span><span class="token operator">%</span>b<span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span> <span class="token string">'bottom'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 给第2个柱数据点加上数值</span><span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>text<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token string">'%d'</span><span class="token operator">%</span>b<span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span> <span class="token string">'bottom'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 画水平横线</span>plt<span class="token punctuation">.</span>hlines<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>x_ticks<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span>barWidth<span class="token punctuation">,</span> colors <span class="token operator">=</span> <span class="token string">"#000000"</span><span class="token punctuation">,</span> linestyles <span class="token operator">=</span> <span class="token string">"dashed"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加x轴和y轴刻度标签</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span>r <span class="token operator">+</span> barWidth<span class="token operator">/</span><span class="token number">2</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> x1<span class="token punctuation">]</span><span class="token punctuation">,</span> x_ticks<span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加x轴和y轴标签</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span>u<span class="token string">'x_label'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>u<span class="token string">'y_label'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>u<span class="token string">'Title'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存图片</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'./figure.pdf'</span><span class="token punctuation">,</span> bbox_inches<span class="token operator">=</span><span class="token string">'tight'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图片</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="2.png" alt></p><h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 设置画布大小</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置每块区域的标签</span>labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置每块区域离圆心的距离，这里a区域凸出一点点</span>explode <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.05</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置每块区域的值</span>values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置每块区域的颜色</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'#F5DEB3'</span><span class="token punctuation">,</span> <span class="token string">'#87CEFA'</span><span class="token punctuation">,</span> <span class="token string">'#FFB6C1'</span><span class="token punctuation">,</span> <span class="token string">'#90EE90'</span><span class="token punctuation">,</span> <span class="token string">'#D3D3D3'</span><span class="token punctuation">]</span>_<span class="token punctuation">,</span> l_text<span class="token punctuation">,</span> p_text <span class="token operator">=</span> plt<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>values<span class="token punctuation">,</span> explode<span class="token operator">=</span>explode<span class="token punctuation">,</span> labels<span class="token operator">=</span>labels<span class="token punctuation">,</span> autopct<span class="token operator">=</span><span class="token string">'%1.1f%%'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span>colors<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置标签字体大小</span><span class="token keyword">for</span> t <span class="token keyword">in</span> l_text<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>set_size<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置数值字体大小</span><span class="token keyword">for</span> t <span class="token keyword">in</span> p_text<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>set_size<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>u<span class="token string">'Title'</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>fontsize<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存图片</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'./figure.pdf'</span><span class="token punctuation">,</span> bbox_inches<span class="token operator">=</span><span class="token string">'tight'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图片</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><p><img src="3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何自动搜出更好、更小、更快的NLP模型？</title>
      <link href="/2020/12/24/nas-transformer/"/>
      <url>/2020/12/24/nas-transformer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近读了不少神经架构搜索（NAS）的论文，把NAS的整体脉络大致摸清了。</p><p>但是也发现了NAS目前还是用在CV领域居多，NLP领域和移动端优化寥寥无几。因此这里分享几篇NLP或者移动端上的NAS论文。</p><p>刚入门，很多不懂，理解有误或者有更多推荐的相关论文都可以评论区留言。</p><h2 id="AMC"><a href="#AMC" class="headerlink" title="AMC"></a>AMC</h2><p><strong>[ECCV 18] AMC: AutoML for Model Compression and Acceleration on Mobile Devices</strong></p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>以往的压缩策略或者说剪枝率都是人工调的，而本文提出了一直基于强化学习的剪枝方法，每层剪枝率可以单独调。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="1.png" alt><br>从最下面一层开始，编码整个网络的状态。然后用强化学习生成下一层的剪枝率，更新状态。最后的reward可以是压缩率、延时、FLOPs等等。actor用的是DDPG，action定义为(0, 1]之间的稀疏率。<br><img src="2.png" alt><br>上面是剪枝和状态更新过程。</p><p>应用场景分为两种，一种是资源受限条件下寻找效果最高的模型，这种情况reward就直接定义为效果就行了，而资源的限制设定在了action空间里，就是上图伪代码做的事情。另一种是效果不变的情况下，压缩的尽量小，这种情况就要改reward，本文设定为了$R = -L \cdot \log(\text{Params})$，这里改成FLOPs也是可以的，因为参数量前面加了$\log$，所以参数量的下降产生的奖励非常小，这就能一定程度上防止效果下降过多。延时的话本文认为和FLOPs基本正相关，因此直接优化FLOPs就行了（其实很多地方不是这样，比如考虑到并行等）。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="3.png" alt><br>相同稀疏率情况下，效果更好。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>可以针对不同设备，自动搜出最佳的压缩策略，对于平衡效果和压缩率/加速比非常友好。</p><h2 id="TextNAS"><a href="#TextNAS" class="headerlink" title="TextNAS"></a>TextNAS</h2><p><strong>[AAAI 20] TextNAS: A Neural Architecture Search Space Tailored for Text Representation</strong></p><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>大多数NAS方法集中在搜索策略的设计上，但是本文重点在定义了一个很好的搜索空间，包含了文本处理里面常用的一些操作符。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>本文发现NLP领域cell搜索不如直接搜整个网络效果好。搜索空间定义为了卷积层、池化层、双向循环结构（GRU）、注意力层。搜索算法就是用的ENAS，并且每个layer只能选择前面k=5个layer作为输入，这样可以减小搜索空间，但其实这样也丢失了长距离的残差连接。</p><h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><p><img src="4.png" alt><br>这篇是做效果提升的，因此可以看到在很多数据集上效果都超过了之前的模型。</p><h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p>感觉上和ENAS差别不是很大，就是搜索空间针对NLP任务做了一些扩展。此外搜索目标只是效果，并没有考虑到延时等条件。</p><h2 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h2><p><strong>[ICML 19] The Evolved Transformer</strong></p><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>这篇是想搜出一个效果更好的Transformer结构。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p><img src="5.png" alt><br>搜索空间也是cell堆叠，每个cell里面encoder有6个block，decoder有8个，这样是为了初始化的时候能重现Transformer结构。</p><p>演化算法初始个体就用的是Transformer结构，这样收敛的更快一点。为了加快搜索速度，采用了Progressive Dynamic Hurdles的方法，过程是这样的：初始种群全部训练到一定步数后early stop，算出平均适应度。接下来后代训练到相同步数后，适应度高于平均值的继续训练一定步数后early stop，其余的直接early stop。然后更新这个early stop的步数和对应的适应度平均值，继续演化出后代。</p><h3 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h3><p><img src="6.png" alt><br>可以看出，在多个不同模型大小设置下，ET效果都要高于Transformer，而且越小效果越好。</p><h3 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h3><p>大力出奇迹，效果也不错，但是缺点就是搜索时间太长了。</p><h2 id="OFA"><a href="#OFA" class="headerlink" title="OFA"></a>OFA</h2><p><strong>[ICLR 20] Once for All: Train One Network and Specialize it for Efficient Deployment</strong></p><h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>NAS能减小目标设备上的延时，但是对于每个设备都得retrain，甚至得重新搜索结构。所以本文只需要训练一次，对于每个设备只需要几分钟就能搜出最优结构，并且不需要retrain。</p><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><p>首先train一个超网络，然后采用progressive shrinking进行子网络的采样和finetune，progressive shrinking会同时训练各个大小的网络，这样不同子网络之间性能都能达到比较好。</p><p>最后训练一个（模型结构，准确率）的预测器，再维护一个（模型结构，目标设备，延时/FLOPs）的loopup table，用演化算法直接搜一个目标设备上最优的模型。因为是帕累托最优，所以寻找的是小于限定延时/FLOPs情况下最佳效果的模型。<br><img src="7.png" alt></p><h3 id="实验-3"><a href="#实验-3" class="headerlink" title="实验"></a>实验</h3><p><img src="8.png" alt><br><img src="9.png" alt><br><img src="10.png" alt><br>相同延时的情况下效果会好很多。搜出结构之后再finetune会更好。搜出结构后从头train效果很差，说明pretrain的weight是有用的。</p><h3 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h3><p>移动端部署很好用，只需要train一次，速度非常快，progressive shrinking解决了多个子网络互相影响的问题。</p><h2 id="HAT"><a href="#HAT" class="headerlink" title="HAT"></a>HAT</h2><p><strong>[ACL 20] HAT: Hardware Aware Transformers for Efficient Natural Language Processing</strong></p><h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>Transfomer部署到不同终端，NAS费时费钱。</p><h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><p>其实就是把OFA照搬到Transformer上，这里连progressive shrinking都没用，直接uniform采样，貌似也没有用不同size的模型联合训练。</p><h3 id="实验-4"><a href="#实验-4" class="headerlink" title="实验"></a>实验</h3><p><img src="11.png" alt></p><h3 id="评价-4"><a href="#评价-4" class="headerlink" title="评价"></a>评价</h3><p>我感觉相比于OFA创新很小，就是设计了一下Transformer的搜索空间，其他基本差不多。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前看来，AMC、OFA和HAT是之后可以尝试的工作。</p><p>如果想不改变结构，单纯通过剪枝压缩的话，可以尝试用AMC在相同压缩率或延时的情况下达到更好的效果。</p><p>而如果想要更深一步优化延时和压缩率，可以尝试OFA的方法，这种方法只需要train一次超网络，训练过程中采用技巧防止子网络性能互相影响即可。最后针对不同设备直接搜出最优结构就行了，不需要在评估过程中重新训练。因此速度非常快，也很方便。</p><p>OFA和HAT的代码也都开源了，可以按照教程试一试，我试了在ImageNet上搜出一个比较好的模型还是非常快的。不考虑pretrain的时间，对于每个设备只需要几十秒就搜出来了。</p><p><strong>OFA：</strong><br><a href="https://github.com/mit-han-lab/once-for-all" target="_blank" rel="noopener">https://github.com/mit-han-lab/once-for-all</a></p><p><strong>HAT：</strong><br><a href="https://github.com/mit-han-lab/hardware-aware-transformers" target="_blank" rel="noopener">https://github.com/mit-han-lab/hardware-aware-transformers</a></p><p>此外AMC也有两个很nice的工具包都集成进去了：<br><strong>Intel：</strong><br><a href="https://github.com/IntelLabs/distiller/tree/master/examples/auto_compression/amc" target="_blank" rel="noopener">https://github.com/IntelLabs/distiller/tree/master/examples/auto_compression/amc</a><br><strong>MicroSoft：</strong><br><a href="https://github.com/microsoft/nni/tree/master/examples/model_compress/amc" target="_blank" rel="noopener">https://github.com/microsoft/nni/tree/master/examples/model_compress/amc</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
            <tag> NAS </tag>
            
            <tag> 神经架构搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文看懂AutoML</title>
      <link href="/2020/12/18/automl-survey/"/>
      <url>/2020/12/18/automl-survey/</url>
      
        <content type="html"><![CDATA[<p><strong>论文地址：</strong><br><a href="https://arxiv.org/abs/1908.00709" title="AutoML: A survey of the state-of-the-art" target="_blank" rel="noopener">AutoML: A survey of the state-of-the-art</a></p><blockquote><p>最近看了些NAS的论文，发现上面这篇综述写的很不错，非常全面，详细拜读了一下。有很多细节不是很懂，也没空去精读原论文，但是能够对大致的脉络有个初步的了解。因此简单写一下这篇综述讲了些啥，第一次接触NAS，可能有理解有误，望指正批评。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先这篇综述是讲AutoML的，不单单是NAS，但是因为NAS是AutoML中最最重要的一部分，所以主要篇章还是用来讲NAS了。据作者所说，应该是第一篇完整讲述AutoML整个流程的综述。</p><p>首先，本文将AutoML划分成了如下几个流程：</p><p><img src="1.png" alt></p><p>先是数据准备，然后是特征工程，接着是模型生成，最后就是模型评估了。其中模型生成又可以分为搜索空间和优化方法，搜索空间有传统的ML模型或者DL模型，优化方法又分为超参数优化和结构优化。NAS的话主要就涉及到DL模型的搜索空间定义、结构优化和模型评估策略这三块。</p><p>因为我主要关注NAS这块，所以其他部分就只简单介绍一下，不做过多解读。</p><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p><img src="2.png" alt></p><p>看上面这个图应该很清楚了，数据准备主要分为数据收集、数据清洗和数据增强三个部分。</p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>有开源的就去下开源的，没开源的就去互联网上爬，要是什么都没有呢，那就通过GAN之类的技术来生成伪数据，有总比没有好嘛。</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>就是清洗数据中的噪声、脏数据，这一过程可能需要一些知识去判断什么是噪声。还有一个研究主题就是如何清洗每天更新的源源不断的新数据。</p><h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h3><p><img src="3.png" alt></p><p>数据增强某种程度上也可以被视为数据收集的一种工具，因为效果都是一样的，增加了新数据。但是它的目的有所不同，主要是为了防止模型过拟合。上图针对不同数据有很多增强方法，这里就不介绍了。</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>有句话叫：数据和特征决定了机器学习的上界，而模型和算法只是为了去近似这个上界。主要可以分成三块，特征选择、特征构建和特征提取。这里也不多介绍了，因为在DL里特征工程用得很少，DL模型可以自己从数据中学出特征，很少需要自己手动构造特征了。</p><h2 id="模型生成"><a href="#模型生成" class="headerlink" title="模型生成"></a>模型生成</h2><p>从这块开始进入到了NAS的领域。之前说了，搜索空间分为ML和DL两块，本文只关注DL，而优化方法又分为超参优化和网络架构优化，本文也主要只关注网络架构优化，因为超参优化是挑选出最优网络架构之后的事情了，不过也有工作将NAS用在超参优化上的，这个就不在讨论范围内了。</p><p><img src="4.png" alt></p><p><img src="5.png" alt></p><p>上面两张图是NAS的一般流程：</p><ul><li>首先针对不同的任务定义一个搜索空间，这个搜索空间就决定了你搜出来的网络架构可能长什么样子，也决定了你搜出来的架构可能性有多少，当然是越大越好，但是带来的后果就是搜索速度太慢。 </li><li>然后在这个搜索空间里进行搜索，采样出一个比较好的模型架构，这里方法就非常多了，最简单的就是随机搜索，随机采样一个网络架构。 </li><li>最后就是在训练集上评估你采样出的架构效果，反馈给架构优化，让它优化，然后继续采样，循环下去。评估方法也有很多，最简单的就是像正常训练模型那样完整训练一遍，得到效果，但是这样太慢了，因此需要其他方法来加速训练或者估计效果。 </li></ul><h3 id="搜索空间"><a href="#搜索空间" class="headerlink" title="搜索空间"></a>搜索空间</h3><p>神经网络可以看作是一个DAG，而如何定义这个DAG，其实你可以用生成图的方式做加法生成它，也可以做减法，从大图中抽取出子图等等，有很多方法。</p><p>定义搜索空间需要人类知识，这一步目前还不够Auto，定义的好，生成出来的架构才可能好。而有些工作发现只要你搜索空间定义的足够好，随机搜索都能达到和各种架构优化方法相似的效果，那么NAS将变得毫无意义，所以这一块还是挺玄学的。</p><h4 id="整体结构搜索"><a href="#整体结构搜索" class="headerlink" title="整体结构搜索"></a>整体结构搜索</h4><p>就是按照DAG的拓扑序，依次生成出模型架构出来。一般来说，用一个RNN来生成，每生成一个node，都要预测出它的输入是哪些node（残差）、作用在它上面的op有哪些。</p><p>但是这种方法太慢了，搜索的复杂度是指数级别的，因此在最初的几篇RL论文里，都用了几百个GPU训练了几十天才搜出来，穷苦人家可搜不起。</p><h4 id="cell搜索"><a href="#cell搜索" class="headerlink" title="cell搜索"></a>cell搜索</h4><p>这种方式也是借鉴了人类设计神经网络的经验，像ResNet系列都是将一个个cell层层堆叠得到的，因此如果只搜一个cell，然后将相同的cell堆叠起来岂不是大大减小了搜索空间。后面的很多工作都是基于cell来搜索的，比如NASNet。</p><p><img src="6.png" alt></p><p>在NASNet中，cell被分成了两种，一种是normal cell，它的输入输出维度保持相同，另一种是reduction cell，它的结构和normal cell相似，但是输出的宽度和高度减半，通道数加倍。</p><p>最后搜索出最优cell之后，根据需要堆叠不同层数的cell就行了，这个层数也是人为定义的。但是这里就会存在一个训练和评估不一致的问题，一般来说，在搜索的时候，为了减小显存占用，会堆叠比较少的层数去评估。但是在得到最优cell之后，用来retrain时会堆叠比较多的层数，这里就不一定是最优解了。也有工作做这方面的优化，比如P-DARTS，在搜索阶段逐渐增加堆叠的层数。</p><p><img src="7.png" alt></p><h4 id="分层搜索"><a href="#分层搜索" class="headerlink" title="分层搜索"></a>分层搜索</h4><p>当然搜索cell也是存在问题的，忽视了整体结构的优化，而且每一层的cell相同也不一定最好啊。因此后来的工作又提出了分层搜索的方法。</p><p>比如Auto-deeplab在搜索cell的同时，还搜索了不同层的分辨率，下一层的分辨率可以是一半、不变或两倍，这一步限制一是为了减小搜索空间，二是为了增加稳定性，防止分辨率变化太大。</p><p><img src="8.png" alt></p><p>再如HierNAS，按照层次结构来搜索网络架构，第一层是一些原子操作，第二层用这些原子操作生成一些比较小的网络，第三层用第二层的小网络再搭建出一个更大的网络，依次下去。</p><p><img src="9.png" alt></p><p>再如progressive NAS，为了减小一个cell里面的搜索空间大小，从一个cell里面只有一个block开始搜索，每次挑出top-k个cell，在基础上衍生出两个block，依次下去。评估性能用的是代理模型直接预测，不需要真的训练一遍。</p><p>再如MnasNet，它将整个网络分为了若干个cell，每个cell串行了若干个block，每个cell的block数量可能不同，而单个cell里面的block结构是相同的，这样就考虑到了整体的网络搜索空间。和堆叠cell不同的是，每个block的结构比较简单，不然的话整体上搜索复杂度还是太大了。当然这篇主要还是为了做移动端部署，因此做了多目标NAS，将延时也考虑到了目标函数中去。</p><p><img src="10.png" alt></p><p>之前的方法还存在一个问题，就是基本都是在小数据集上做的搜索评估，最后将最优结构运用到大数据集上，这就存在不一致性。因此例如ProxylessNAS就直接在大数据集上搜索评估，为了减小显存消耗，采用BinaryConnect，每次只激活两个结点之间的一条边。</p><h4 id="网络态射"><a href="#网络态射" class="headerlink" title="网络态射"></a>网络态射</h4><p>这类方法主要思想就是在已经训练好的成熟网络基础上增加宽度、深度等等，继承父网络的参数，加速子网络的训练。</p><p>首先是Net2Net，扩展分为两个方向，一种是宽度上的，一种是深度上的，不能同时进行。</p><p><img src="11.png" alt></p><p>因此后来就有了网络态射，可以处理任意线性层和非线性层，并且深度和宽度上可以同时扩展。</p><h3 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h3><p>定义好搜索空间后，就要采用架构优化算法来搜索出最优的架构了。</p><h4 id="演化算法"><a href="#演化算法" class="headerlink" title="演化算法"></a>演化算法</h4><p><img src="12.png" alt></p><p>演化算法就是模仿的生物进化过程。首先要对网络架构进行编码，方便之后的操作。可以将图结构编码为二进制串，但是这样固定长度不灵活。于是就有了Cartesian genetic programming、Neuro evolution of augmenting topologies、Cellular encoding等各种编码方法，详细就不介绍了。</p><p>一般演化算法分为四步：选择、交叉、变异、替换。</p><ul><li>选择。就是从候选的网络架构中挑选出适应度最高的，一种可以直接挑绝对值最高的，另一种可以挑相对值最高的，第三种比较有名的是锦标赛选择算法，也就是放回抽样，每次等概率随机选k个，挑出最好的那一个，进入下一代，其余放回，重复上述操作。 </li><li>交叉。交叉方式和编码方式有很大关系， </li><li>变异。上面两步做完后，有很多方式可以对个体进行变异，比如随机翻转某一位，随机增加或者删除两层之间的连接等等。 </li><li>替换。新的个体加入种群后，旧的个体要被删除掉。可以删除最久之前的，也可以删除效果最差的，也有工作一个都不删除，只要你内存和时间顶得住。 </li></ul><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><p><img src="13.png" alt></p><p>强化学习主要思想就是用一个控制器（一般是RNN）来生成网络架构，然后评估得到得分作为反馈更新控制器参数。有用策略梯度的，也有用Q-learning的，还有用PPO算法的等等。第一篇NAS论文就是用的RL，但是这一类方法普遍很费卡，一般人玩不起。</p><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p><img src="14.png" alt></p><p>前两种都是在离散空间搜结构，梯度下降方法是将离散空间变为了连续空间。第一个提出的是DARTS，在两个结点之间定义了若干种操作，然后做softmax，最后在评估的时候取argmax。</p><p>这种方法也有不好，比如成倍增加了显存，本来一条边现在需要成倍的计算量，此外用了代理任务，在小数据集上训的层数比较少，迁移到大数据集上层数又很多。也有解决方法，比如P-DARTS，随着训练进行逐渐加层数，为了减小计算量，还逐渐减少了每条边上的操作数。而GDAS每次只选概率最大的那个操作边做前向，反向传播用gumbel softmax。</p><p>两套参数联合优化也是很困难的，DARTS用的是交替优化，一次优化结构参数，一次优化模型权重。</p><p>最后还有个问题，就是搜索后期会倾向于搜索残差连接之类的操作，这不好。于是DARTS+发现一个cell里出现两个或以上残差连接后就直接停止。P-DARTS则是给残差加了正则化，减小出现的次数。</p><h4 id="代理模型"><a href="#代理模型" class="headerlink" title="代理模型"></a>代理模型</h4><p>这一类方法（SMBO）使用一个代理模型来指导最优模型的生成。传统的方法有贝叶斯优化（高斯过程、随机森林、TPE等等），就不详细介绍传统方法了。</p><p>也有用神经网络当作代理模型的，比如PNAS、EPNAS、NAO都用一个LSTM或者MLP将离散的结构编码成连续的表示，然后预测性能，接着找出性能最高的最优表示，用解码器还原出离散的结构。</p><h4 id="网格和随机搜索"><a href="#网格和随机搜索" class="headerlink" title="网格和随机搜索"></a>网格和随机搜索</h4><p>这就是最原始最普通的优化方法，比如直接在搜索空间随机搜索结构，然后评估，最后取最优的就行了。虽说随机搜索听起来不大行，但实际出来的效果，能和大多数NAS方法达到相似效果，还很简单。</p><h4 id="混合优化方法"><a href="#混合优化方法" class="headerlink" title="混合优化方法"></a>混合优化方法</h4><p>上面这么多方法混合在一起，可能效果会更好。演化算法是全局优化的，鲁棒性很强，但是随机性有点大，不稳定，计算消耗也大。强化学习也是的，训练很不稳定。梯度下降方法训练快，但是需要提前定义好超网络结构，限制了结构的多样性。</p><p>演化算法可以结合强化学习、梯度下降、SMBO，梯度下降也可以结合SMBO等等，这里就不详细介绍了，典型的例子有Evo-NAS、NAO等等。</p><h3 id="超参优化"><a href="#超参优化" class="headerlink" title="超参优化"></a>超参优化</h3><p>这一步其实是脱离了NAS的，就和一般的超参优化一样，网络搜索、随机搜索、贝叶斯优化、梯度优化等等方法，这里不做过多介绍了。</p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>在模型生成之后，需要对模型进行评估，然后指导架构优化模块生成更好的架构。最一般的方法就是从头开始训练到收敛，但是这样太慢了，一般都要生成个几百万以上的架构的，训练时间太久了。</p><h3 id="低保真度"><a href="#低保真度" class="headerlink" title="低保真度"></a>低保真度</h3><p>可以在评估时降低数据集的分辨率，降低cell堆叠的层数，使用小数据集等等，这样可以快速得到架构的大致效果，但是最后得到的架构可能在目标数据集上不是全局最优的。</p><h3 id="权重共享"><a href="#权重共享" class="headerlink" title="权重共享"></a>权重共享</h3><p>比如ENAS，可以在多次评估模型性能时，继承之前相同node的参数，可以加快收敛速度。网络态射也是用到了权重共享。</p><h3 id="代理模型-1"><a href="#代理模型-1" class="headerlink" title="代理模型"></a>代理模型</h3><p>直接学习一个预测器，输入是网络架构，输出是它的性能，当然这需要提前先训练一些模型，得到（架构，性能）的若干数据，然后才能学习出这个预测器，PNAS就是这么干的。当然预测器的学习数据肯定不会多，所以SemiNAS就用半监督的方法，利用大量无标注的结构去预测出性能，加入到训练集中继续优化预测器。</p><h3 id="early-stop"><a href="#early-stop" class="headerlink" title="early stop"></a>early stop</h3><p>可以只训练几轮，然后根据前期的学习曲线预测出最终的性能。</p><h2 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h2><h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><p><img src="15.png" alt><br><img src="16.png" alt></p><p>可以看出，演化算法和强化学习搜索时间都非常长，除了个别几个用了权重共享之类技巧的。梯度下降方法全部都挺快的，但是整体效果都不如其他几类方法。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>从整体流程上来看，NAS方法还可以分为一阶段和两阶段。两阶段是一般做法，第一个阶段就是搜索评估阶段，选出最好的架构，第二个阶段就是retrain这个最优架构，在验证集上评估。而一阶段就是只需要训练一次超网络，联合优化架构参数和模型权重，之后不需要再retrain了。比如比较有名的Once-for-all，采用了progressive shrinking算法来使得子网络之间的性能相互不受到影响。</p><p>NAS还可以分为one-shot和non-one-shot，one-shot意思就是搜索空间重合的，可以重复利用之前的参数，比如ENAS、网络态射、ProxylessNAS等都是的。</p><p>大多数NAS都只是把最终的效果当作目标，其实在移动端部署上还要考虑延时、模型大小、计算量等目标，一般都是解帕累托最优，比如MnasNet考虑到了延时。</p><h2 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h2><h3 id="搜索空间的灵活性"><a href="#搜索空间的灵活性" class="headerlink" title="搜索空间的灵活性"></a>搜索空间的灵活性</h3><p>现在的搜索空间基本都还是人为定义的，参考了很多人类设计神经网络的经验，比如原子操作定义成conv、pooling之类的，结构上cell堆叠等等，但是真正的auto应该是模型自动设计网络架构和原子操作，比如AutoML-Zero就用最基本的原子操作（sin、cos、mean、std等）设计出了两层的神经网络。这一块应该是今后的一大方向，例如目前工作主要在CV上，而对于NLP的Transformer模型，搜索空间如何定义的很好？目前工作还寥寥无几，看了几篇也都是堆叠conv，分支结构之类的。</p><h3 id="探索更多的领域"><a href="#探索更多的领域" class="headerlink" title="探索更多的领域"></a>探索更多的领域</h3><p>如上所说，目前大多数工作都是在CV上，搜的是conv结构，而像NLP、语音等领域探索甚少，像多目标领域也只有很少的工作（韩松老师组工作很多），即使是在CV，任务也大多数局限在CIFAR-10和ImageNet上。</p><h3 id="可解释性"><a href="#可解释性" class="headerlink" title="可解释性"></a>可解释性</h3><p>搜出来的网络为什么好？现在人类设计的网络大多数都能强行解释一下好处，即使它仍然是个黑盒。但是NAS搜出来的基本看不出设计的逻辑。</p><h3 id="可复现"><a href="#可复现" class="headerlink" title="可复现"></a>可复现</h3><p>之前也说了，例如演化算法和强化学习这一类方法训练很不稳定，很难复现出结果。很多论文也都只是公开了最好的模型，都不放出源码的（当然我并没有质疑他们），超参数之类的也有些没有公布，这导致我们平民玩家没法复现，没法用啊。而且大家评测的环境都不相同，众说纷纭，没法公平比较，因此也有一些工作提出了NAS统一的数据集来评测。</p><h3 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h3><p>如果目标领域数据添加了噪声，可能会对搜出来的模型产生很大影响。所以如何搜出更加鲁棒、能适应不同领域或者有噪声数据的结构可能是未来的一个研究方向。</p><h3 id="联合超参优化和架构优化"><a href="#联合超参优化和架构优化" class="headerlink" title="联合超参优化和架构优化"></a>联合超参优化和架构优化</h3><p>目前大多数NAS方法都是先搜出最优架构，再调整超参在目标领域上retrain，如何同时学好这两块也是一个方向。</p><h3 id="完全的AutoML的pipeline"><a href="#完全的AutoML的pipeline" class="headerlink" title="完全的AutoML的pipeline"></a>完全的AutoML的pipeline</h3><p>做到从数据收集开始一直到最后的模型生成训练全部流程化，不需要人为参与，那样才是真正的智能。目前的话有一些比较好的开源工具了，AutoKeras、NNI等等。</p><h3 id="终身学习"><a href="#终身学习" class="headerlink" title="终身学习"></a>终身学习</h3><p>当新的数据源源不断进来时，当只有少量有标签数据或者有大量无标签数据时，如何做NAS，有几个不错的工作，比如UnNAS是做无监督NAS的，MetaNAS是结合meta-learning的。</p><h2 id="经典论文简析"><a href="#经典论文简析" class="headerlink" title="经典论文简析"></a>经典论文简析</h2><h3 id="（NAS）-ICLR-17-Neural-Architecture-Search-with-Reinforcement-Learning"><a href="#（NAS）-ICLR-17-Neural-Architecture-Search-with-Reinforcement-Learning" class="headerlink" title="（NAS）[ICLR 17] Neural Architecture Search with Reinforcement Learning"></a>（NAS）[ICLR 17] Neural Architecture Search with Reinforcement Learning</h3><p><strong>动机</strong><br>用强化学习来采样网络，生成出最优网络结构，避免人工设计。</p><p><strong>方法</strong><br>用RNN来预测CNN或者RNN的结构，采样结构，下游任务效果作为强化学习得分，策略梯度更新参数。</p><p>CNN预定义好层数，LSTM每5层预测CNN一层的5个参数。</p><p><img src="17.png" alt></p><p>RNN预定义好cell的计算拓扑图，LSTM预测每个node的计算逻辑。</p><p><img src="18.png" alt></p><p><strong>实验</strong><br><img src="19.png" alt></p><p>接近人类设计网络的最好水平。速度超慢，800 K40，28天，只适用于小数据集例如CIFAR-10。</p><p><strong>评价</strong><br>强化学习应用到NAS的第一篇论文。</p><h3 id="（NASNet）-CVPR-18-Learning-Transferable-Architectures-for-Scalable-Image-Recognition"><a href="#（NASNet）-CVPR-18-Learning-Transferable-Architectures-for-Scalable-Image-Recognition" class="headerlink" title="（NASNet）[CVPR 18] Learning Transferable Architectures for Scalable Image Recognition"></a>（NASNet）[CVPR 18] Learning Transferable Architectures for Scalable Image Recognition</h3><p><strong>动机</strong><br>RL直接搜太慢了，只能用在小数据集，ImageNet之类的大数据集没法用。</p><p><strong>方法</strong><br>提出了NASNet，用堆叠相同cell的方式减小搜索空间。在CIFAR-10上面学习cell结构，通过增加堆叠层数的方式迁移到ImageNet上去。用PPO替代策略梯度。</p><p><img src="20.png" alt></p><p>选择之前的两个node，分别预测对应op，然后预测合并op。</p><p><img src="21.png" alt></p><p><strong>实验</strong><br><img src="22.png" alt><br><img src="23.png" alt></p><p>效果和参数量都好于前作，达到了SOTA水平。速度加快很多，500 P100，4天，相比于前作加速7倍。</p><p><strong>评价</strong><br>NASNet，通过cell堆叠加快了结构搜索的速度，同时效果达到了SOTA，并且容易迁移到其他任务上去。</p><h3 id="（ENAS）-ICML-18-Efficient-Neural-Architecture-Search-via-Parameter-Sharing"><a href="#（ENAS）-ICML-18-Efficient-Neural-Architecture-Search-via-Parameter-Sharing" class="headerlink" title="（ENAS）[ICML 18] Efficient Neural Architecture Search via Parameter Sharing"></a>（ENAS）[ICML 18] Efficient Neural Architecture Search via Parameter Sharing</h3><p><strong>动机</strong><br>之前的方法采样出一个结构，在dev上得到acc，然后就会抛弃权重，重新采样训练，非常耗时。</p><p><strong>方法</strong><br>定义一个超图，每次搜出的子图共享权重。</p><p>对于RNN cell，LSTM的每两个step预测之前某个node作为输入，再预测op，最后出度0的node拼接作为输出。</p><p><img src="24.png" alt></p><p>对于CNN，一种策略是直接生成整个网络，每个node先预测之前哪些作为输入，然后预测op。</p><p><img src="25.png" alt></p><p>另一种策略和NASNet类似，堆叠cell，搜索空间缩小到一个cell。</p><p><strong>实验</strong><br><img src="26.png" alt></p><p>优于NAS和NASNet，1 1080Ti，16小时，相比NAS加速1000倍。</p><p><strong>评价</strong><br>训练速度很快，AutoKeras背后就采用了ENAS。</p><h3 id="（DARTS）-ICLR-19-DARTS-Differentiable-Architecture-Search"><a href="#（DARTS）-ICLR-19-DARTS-Differentiable-Architecture-Search" class="headerlink" title="（DARTS）[ICLR 19] DARTS: Differentiable Architecture Search"></a>（DARTS）[ICLR 19] DARTS: Differentiable Architecture Search</h3><p><strong>动机</strong><br>离散结构搜索太慢了，采样+验证+反馈的循环很耗时。</p><p><strong>方法</strong><br>连续域结构搜索代替离散域结构搜索，用微分来优化结构。</p><p>两套参数：模型参数$w$（训练集优化）、结构参数$\alpha$（验证集优化）。</p><p>交替优化两套参数，softmax+relax学习最终结构。</p><p><img src="27.png" alt></p><p><strong>实验</strong><br><img src="28.png" alt></p><p>效果达到或接近了SOTA，速度上比ENAS慢，比其他的方法快。</p><p><strong>评价</strong><br>第一个用可微分方法做NAS的，第一个连续空间搜索代替离散空间搜索。</p><h3 id="ICLR-19-Rethinking-the-Value-of-Network-Pruning"><a href="#ICLR-19-Rethinking-the-Value-of-Network-Pruning" class="headerlink" title="[ICLR 19] Rethinking the Value of Network Pruning"></a>[ICLR 19] Rethinking the Value of Network Pruning</h3><p><strong>动机</strong><br>现有的剪枝方法存在问题，很多操作不合理，没有必要。</p><p><strong>方法</strong><br>传统剪枝方法基于两个假设：</p><ul><li>过参数化很重要，训练大模型再剪枝优于直接训练剪枝后的模型。 </li><li>继承大模型参数，再finetune很重要，优于随机初始化剪枝后模型再重新训练。 </li></ul><p>本文认为都不一定对：</p><ul><li>对于预定义好的模型，直接训练可以达到和训练-剪枝-finetune相同甚至更好的效果。 </li><li>大模型剪枝后，随机初始化重新训练，效果和继承参数finetune差不多。</li></ul><p>所以本文认为剪枝后的结构重要，而参数不是那么重要。</p><p><strong>实验</strong><br><img src="29.png" alt></p><p>一系列实验结果验证了猜想，此外本文还否定了彩票假设，认为剪枝后随机初始化即可，没必要和原始初始化相同。</p><p><strong>评价</strong><br>仍然有一些局限性，比如数据分布均衡、模型比较大，估计在其他设置下不一定work。而且不如finetune速度快。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h3 id="不错的综述或讨论"><a href="#不错的综述或讨论" class="headerlink" title="不错的综述或讨论"></a>不错的综述或讨论</h3><p><a href="https://lilianweng.github.io/lil-log/2020/08/06/neural-architecture-search.html" target="_blank" rel="noopener">https://lilianweng.github.io/lil-log/2020/08/06/neural-architecture-search.html</a><br><a href="https://jinzhuojun.blog.csdn.net/article/details/84698471" target="_blank" rel="noopener">https://jinzhuojun.blog.csdn.net/article/details/84698471</a><br><a href="http://www.tensorinfinity.com/paper_136.html" target="_blank" rel="noopener">http://www.tensorinfinity.com/paper_136.html</a><br><a href="https://zhuanlan.zhihu.com/p/73785074" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73785074</a><br><a href="https://www.zhihu.com/question/359162202" target="_blank" rel="noopener">https://www.zhihu.com/question/359162202</a><br><a href="https://github.com/pzhren/Awesome-NAS" target="_blank" rel="noopener">https://github.com/pzhren/Awesome-NAS</a><br>Neural Architecture Search: A Survey<br>A Comprehensive Survey of Neural Architecture Search: Challenges and Solutions<br>AutoML: A Survey of the State-of-the-Art<br>A Comprehensive Survey of Neural Architecture Search: Challenges and Solutions</p><h3 id="一些经典论文"><a href="#一些经典论文" class="headerlink" title="一些经典论文"></a>一些经典论文</h3><p>Neural Architecture Search with Reinforcement Learning<br>Designing Neural Network Architectures using Reinforcement Learning<br>Efficient Neural Architecture Search via Parameter Sharing<br>Learning Transferable Architectures for Scalable Image Recognition<br>DARTS: Differentiable Architecture Search<br>Neural Architecture Optimization<br>FP-NAS: Fast Probabilistic Neural Architecture Search<br>SNAS: Stochastic Neural Architecture Search<br>EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks<br>Once for All: Train One Network and Specialize it for Efficient Deployment<br>Rethinking the Value of Network Pruning<br>TextNAS: A Neural Architecture Search Space Tailored for Text Representation<br>The Evolved Transformer<br>HAT: Hardware-Aware Transformers for Efficient Natural Language Processing<br>Searching Better Architectures for Neural Machine Translation</p><h3 id="一些经典源码或工具"><a href="#一些经典源码或工具" class="headerlink" title="一些经典源码或工具"></a>一些经典源码或工具</h3><p><a href="https://github.com/quark0/darts" target="_blank" rel="noopener">https://github.com/quark0/darts</a><br><a href="https://github.com/melodyguan/enas" target="_blank" rel="noopener">https://github.com/melodyguan/enas</a><br><a href="https://github.com/mit-han-lab/once-for-all" target="_blank" rel="noopener">https://github.com/mit-han-lab/once-for-all</a><br><a href="https://github.com/mit-han-lab/hardware-aware-transformers" target="_blank" rel="noopener">https://github.com/mit-han-lab/hardware-aware-transformers</a><br><a href="https://github.com/microsoft/nni" target="_blank" rel="noopener">https://github.com/microsoft/nni</a><br><a href="https://github.com/IntelLabs/distiller" target="_blank" rel="noopener">https://github.com/IntelLabs/distiller</a><br><a href="https://autokeras.com/" target="_blank" rel="noopener">https://autokeras.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
            <tag> NAS </tag>
            
            <tag> 神经架构搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零二零年终总结</title>
      <link href="/2020/12/13/2020-conclusion/"/>
      <url>/2020/12/13/2020-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>今天是我的阳历生日，今年是不平凡的一年，有许多事情值得回顾。</p></blockquote><h2 id="新冠"><a href="#新冠" class="headerlink" title="新冠"></a>新冠</h2><p>年初突如其来的疫情，谁也想不到，影响一直持续到现在。</p><p>因为疫情，大学六年来头一次呆家里这么久，足足四个月，人养胖了，和父母也更多交流了。</p><p>还记得当初在家苦口婆心劝家人过年别出去打牌了，最后还是没用，各种出去玩，好在得益于国家控制的好，最后也无大碍。</p><p>时至今日，还依然有源源不断的境外流入和极少数的本地病例，走在大街上依然需要戴口罩，这场战斗还要打很久。</p><p>希望这场战斗早点结束，因为它错过了很多，人生唯一一次出国开会也泡汤了。</p><h2 id="装潢"><a href="#装潢" class="headerlink" title="装潢"></a>装潢</h2><p>过年家里把老房子装潢了一下，长这么大第一次住上了自己的房间，不用和父母一起睡了。</p><p>为什么要装潢呢？其实就是为了以后我能带个女朋友回家，不过到现在还是孤身一人呢，房间自然也是空荡荡的。</p><p>说来也是，他们也着急了，有机会就安排介绍对象了，不过基本都不是很感兴趣。</p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>疫情在家第一件喜事就是ACL中了吧，也是运气好，想想也挺后怕的，不中的话现在的生活又是另一番模样。</p><p>论文搞得时间不是很久，精力倒是费了不少，导师很上心，从头到尾各种修改，非常感恩。</p><p>也给之后的实习面试铺平了道路吧，轻松了许多。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>刚中了论文其实也没想过立刻找实习，还不知道之后要干嘛，挺未知迷茫的，直到导师提醒我去找个实习。</p><p>最后有幸来了字节，也圆了我留上海大厂的愿望。</p><p>实习半年，做机器翻译，和学校里完全不一样，不过都是相通的。</p><p>转正也挺顺利的，有幸留下，继续和优秀的人做有挑战的事。</p><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><p>也是因为疫情在家，闲着没事干吧，刷起了leetcode，没曾想之后正好要面试。</p><p>重拾了公众号，每日题解也写了110多天，也算是坚持比较久的一件事了吧。</p><p>粉丝涨的慢慢悠悠，我不急，它也不急。</p><p>什么时候写文章副业赚的钱能抵得上工资，也许就能35岁退休了吧。</p><h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><p>毕业正式工作后估计也没啥时间了，趁着这段时间没啥事，和兄弟去北京游玩了几天。</p><p>几天体验下来，说实在的，更喜欢上海一点，夜晚更亮，更热闹一点。</p><p>这次时间比较短，等论文搞完，去南方再多玩会儿吧，希望到时候一起的不是兄弟。</p><h2 id="缘分"><a href="#缘分" class="headerlink" title="缘分"></a>缘分</h2><p>缘分这事，说来就来，说走就走；实习来了，实习又走了。</p><p>有时候不会去想合不合适，有时候又会觉得确实不合适。</p><p>也许进一步会有个结果，也许再也没有也许了。</p><p>有时候会想是不是单身久了会让人变怂，有时候发现也许这就是自卑吧。</p><p>也许这就是进一步舔狗，退一步一无所有吧。</p><p>等一个有缘人，一个合适的人，一个对上眼的人。</p><p>要求不多，懂事就好。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>我不知道以后的我会是什么样子，也许两点一线，租房，公司，除了工作就是睡觉和游戏。</p><p>关于未来，我只要一个大房子，一只猫，一个她，足矣。</p><blockquote><p>二十五了，不小了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北京五日游记</title>
      <link href="/2020/12/09/travel-to-beijing/"/>
      <url>/2020/12/09/travel-to-beijing/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>临近毕业了，趁着室友强哥正好也有空，一起约了去北京玩一玩。从12.6到12.10，一共5天，每天平均3万步，走了很多地方，也算是挺充实的了。</p><p><strong>足迹：</strong><br>首都国际机场、大栅栏、圆明园、四季民福（和平里店）、后海美食街、南锣鼓巷、天安门广场、王府井、三里屯、鸟巢、水立方、蓝色港湾、故宫、天坛、德云社（新街口剧场）、八达岭长城、五道口、北京字节（泰鹏大厦）、中科院计算所。</p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>早上8点的飞机，早早起了床就赶到了虹桥机场，两小时就到了。出了<strong>首都国际机场</strong>，直奔宾馆，因为天安门店和天安门广场店看错了，还跑错了地方。我们住的地方在杨梅竹斜街，胡同里老北京味很浓厚，就是房子看起来老破不堪，但是架不住地价贵啊，酸了。</p><p><img src="1.jpeg" alt="首都机场线"></p><p><img src="2.jpeg" alt="正阳门"></p><p>到了宾馆后，直奔<strong>大栅栏</strong>，吃了顿<strong>新成炸酱面</strong>，味道还不错，据宣传历史挺悠久的，建国初期就开了。</p><p>然后就去了<strong>圆明园</strong>，现场买票即可。见到了近三年不见的老同学：微笑直到夕阳尽头，强哥也见到了他的女同学。圆明园有三个园，太大了只逛了一小部分，不过见到了只在教科书里见到的废墟。北京的冬天真冷啊，还是在郊外的园子里，差点没被冻死，手机还开了直播，手都要被冻坏了。</p><p><img src="3.jpeg" alt="圆明园"></p><p><img src="4.jpeg" alt="爷孙满堂"></p><p>这天正好是我的农历生日，晚上我们四个人订了蛋糕，去吃了<strong>四季民福（和平里店）</strong>，因为故宫店人太多了所以没去。 不得不说，第一次吃正宗的北京烤鸭，味道还真不错，价格也还好，人均才150。有一说一，这是长这么大第一次在外面过这么正式的生日吧，昶臻还给我唱了生日歌，感动了，上一次有人给我过生日应该还是前女友吧。</p><p><img src="5.jpeg" alt="切烤鸭的师傅"></p><p><img src="6.jpeg" alt="片皮烤鸭"></p><p><img src="7.jpeg" alt="生日蛋糕"></p><p>后来去逛了<strong>后海</strong>，晚上黑漆漆的，确实没啥意思。美食街，也就是酒吧街了，基本都是清吧。门口都是拉客的，最好不要进去，要去就去大众点评上评价最高的那几家。</p><p><img src="8.jpeg" alt="后海酒吧"></p><p>顺道去了<strong>南锣鼓巷</strong>，建议白天去，晚上黑漆漆的，就中间一条胡同能逛。店的话还可以吧，吃了杯双皮奶，一般。有很多老北京风味的老店，不过都不是很感兴趣，没有什么特别想买的东西。</p><p><img src="9.jpeg" alt="双皮奶"></p><p><img src="10.jpeg" alt="文宇奶酪店"></p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p><strong>大栅栏</strong>找了家包子店吃了早餐，挺贵的，不过味道尚可，最重要的是量挺大，管饱。</p><p><img src="11.jpeg" alt="早餐店"></p><p>然后顺路去了趟<strong>天安门广场</strong>，安检特别严格，排队就排了很久。第一次见到从小只在电视上见过的天安门，心里还是非常激动的。</p><p><img src="12.jpeg" alt="天安门广场"></p><p><img src="13.jpeg" alt="人民英雄纪念碑"></p><p>然后去了<strong>王府井</strong>，这条街不是很长，没有想象中的那么热闹，可能是因为工作日，人比较稀少。但是和南京东路比的话，也感觉差了点热闹和繁华。</p><p><img src="14.jpeg" alt="王府井"></p><p><img src="15.jpeg" alt="北京饭店"></p><p>接着去了据说美女很多的<strong>三里屯</strong>，结果还是大失所望，工作日白天都没啥人，让我感觉像是冷清的商场。所以建议还是周末的晚上来，据说还会有好戏看（未成年人莫入），不过我这次是没有机会见到了，下次一定。</p><p><img src="16.jpeg" alt="三里屯"></p><p>午饭在三里屯吃了一家<strong>潇湘阁</strong>，真的非常下饭，强烈推荐，人均70左右。</p><p><img src="17.jpeg" alt="潇湘阁"></p><p>下午就去了<strong>鸟巢、水立方</strong>，现场买票就行了。当然如果你不需要进水立方里面看，就不需要买票，外面拍拍照就行了。水立方里面也没啥好看的，所以建议别买票进去了。</p><p><img src="18.jpeg" alt="鸟巢"></p><p><img src="19.jpeg" alt="水立方"></p><p><img src="20.jpeg" alt="水立方比赛泳池"></p><p>晚上去了传说中夜景很好看的<strong>蓝色港湾</strong>，不得不说，真的很好看。但是强哥要和他女同学约去吃饭了，我就自己吃了<strong>麦当劳</strong>。</p><p><img src="21.jpeg" alt="蓝色港湾"></p><p><img src="22.jpeg" alt="蓝色港湾"></p><p><img src="23.jpeg" alt="蓝色港湾"></p><p>晚上的杨梅竹斜街别有一番风味，人很少，很安静。</p><p><img src="24.jpeg" alt="杨梅竹斜街"></p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>早饭试了试大栅栏的<strong>狗不理包子</strong>，如网上流传那样，差评，又贵又一般。</p><p><img src="25.jpeg" alt="狗不理包子"></p><p>然后就去了<strong>故宫</strong>，需要提前一天在网上预约，同样需要过严格的安检。故宫很大，所有宫逛下来需要小半天时间。这次唯一的购物也是在故宫里产生的，买了三个香囊，太喜欢这外观了，我真是少女心爆棚。</p><p><img src="26.jpeg" alt="天安门"></p><p><img src="27.jpeg" alt="太和殿"></p><p><img src="28.jpeg" alt="可可爱爱的香囊"></p><p>接着就直奔<strong>天坛</strong>，在附近吃了顿肯德基，还冲了200块会员卡，送了一堆券，回去一定要记得用！白嫖了一顿半价生日套餐，还没吃过这么便宜的一顿KFC。天坛同样需要提前一天网上预约，里面也非常大，逛了整整一下午。还是非常壮观的，其实就是一个公园，散步养心非常不错。</p><p><img src="29.jpeg" alt="天坛"></p><p><img src="30.jpeg" alt="天坛上拍的夕阳"></p><p>晚上去听了德云社（新街口剧场），附近吃了顿川湘菜。德云社不允许自带酒水，但是里面的酒水超级超级贵，最便宜的30块一杯，建议别买。我们买的位置还很垃圾，价格还是最贵的。相声的话，大咖你是别想见到了，都是小辈，不过效果还行吧，除了一两个相声笑点比较多以外，其他的一般般。</p><p><img src="31.jpeg" alt="德云社"></p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>这一天全部用来去爬<strong>八达岭长城</strong>了，需要提前网上预约。前门站坐旅游公交1线，来回40元。记得带点吃的喝的，长城那边很贵。长城分为南北两线，南线7阁楼，没啥意思，走个几十米看个好汉碑就完事了，北线8个楼，建议走到底。如果爬不动可以直接坐缆车，直接到北线6楼。我们先去了南线3楼，然后折返，一路走到北线8楼，差点没累死。最后还是乖乖坐缆车下来了，单程100，往返便宜一点。</p><p><img src="32.jpeg" alt="爷孙登顶"></p><p><img src="33.jpeg" alt="强哥个人秀"></p><p><img src="34.jpeg" alt="强哥个人秀"></p><p><img src="35.jpeg" alt="下山缆车"></p><p>太累了，这一天就没去其他地方了，晚上在杨梅竹斜街随便逛了逛，吃了顿<strong>铃木食堂</strong>，点评评价很高，人均八九十吧。</p><p><img src="36.jpeg" alt="杨梅竹斜街的杂货铺"></p><p><img src="37.jpeg" alt="铃木食堂"></p><p><img src="38.jpeg" alt="铃木食堂"></p><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>直奔<strong>五道口</strong>，见到了快7年没见的高中老同学：昌老师和奕哥，吃了顿<strong>日昌餐馆</strong>。然后去<strong>北京字节（泰鹏大厦）</strong>工区转了转，最后去中科院计算所转了转，还瞻仰了部门leader求学时的真迹。</p><p><img src="43.jpeg" alt="日昌餐馆"></p><p><img src="41.jpeg" alt="多年未见的老朋友"></p><p><img src="39.jpeg" alt="北大东门"></p><p><img src="40.jpeg" alt="中科院计算所"></p><p><img src="42.jpeg" alt="爷孙离别"></p><p>最后大兴机场回了浦东机场，一路上是真的累。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>五天的时间过得很快，其实大部分地方也都逛完了，其他还有例如北海公园、景山公园、CBD等等地方还没有去，下次有机会出差再去玩玩吧。</p><p>这几天对北京的感受呢，可能是因为工作日加上旅游淡季，游人非常稀少，去哪里都不需要排队，感觉冷冷清清。晚上的话到处黑漆漆的，很安静，挺舒服的，想让人早睡。不过整体上来看，我还是更喜欢上海，喜欢这里的夜生活，喜欢热闹。</p><p>下一次和老朋友们再见又不知道是什么时候了，下一次应该就是工作了之后了。当然游戏中还是经常会遇见的，该喷还是得喷。</p><p>这次总共算下来一人花了2500左右，还是挺实惠的，每天走的都很累，但是都很充实。下周开始又要上班了，继续做一个快乐的打工人，加油！毕业论文也要着手开始写了，希望能顺利毕业。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北京 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物来顺应，未来不迎，当时不杂，既过不恋</title>
      <link href="/2020/12/05/school-conclusion/"/>
      <url>/2020/12/05/school-conclusion/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉来字节实习也有半年多了，前一阵子也终于通过了转正，正式成为了一名new ByteDancer。刚开始来的时候，原以为会和校园生活有很大的差别，也许很久都没法适应成为社会人的生活。但是现实打破了我的顾虑，字节这个大家庭给了我太多的惊喜。回首两年的研究生校园生活，以及字节的半年实习经历，感触良多。</p><p>我非常喜欢曾国藩的一句十六字箴言：</p><blockquote><p>物来顺应，未来不迎，当时不杂，既过不恋。</p></blockquote><p>这句话意思是说，<strong>凡事要顺其自然，坦然面对，活在当下，不过度担忧未来还未发生的事，要心无杂念地做好眼前的事，不要去留恋和纠结发生过的事</strong>。这是曾国藩的处世哲学，也是我一直以来努力追求的处世方式。</p><h2 id="未来不迎"><a href="#未来不迎" class="headerlink" title="未来不迎"></a>未来不迎</h2><p>遥想两年前刚刚保研成功，接下来头等大事便是选择学校和导师了。都说人往高处爬，许多人可能都会选择更好的学校，名声更大的导师。然而我没有，我毅然决然地选择了本校的一位青年教师。很多人不理解，问我是怎么考虑的。其实我的想法也很简单，未来不迎，我并不会过多考虑未来的我会是怎么样的，我并不在乎老师名气有多大，我也不在乎名校会给我贴多少金，我只看重老师能力强不强，对学生好不好。事实证明，我的选择没有错。能够早早进实验室开始科研也是对自己能力的一大提升，况且老师真正做到了亲力亲为，手把手带我进入了自然语言处理的领域。其实这也是一种懒人心态，我比较乐于<strong>活在当下，努力做好目前能做到的事，而不去过多想象以后的我会成为什么样的人，现在的选择对我的未来有多大的影响</strong>。</p><p>刚上研究生，我便开始运营起了我的博客、知乎、公众号等各大自媒体平台。初衷呢是想记录一下我的科研生涯中的点点滴滴，记录学习过程中遇到的各种问题和各种知识。但是后来看的人越来越多，也认识了全国各地非常多和我一样对算法和自然语言处理感兴趣的小伙伴。行走江湖，多认识一个人就是多一个靠山。和他们的交流中我也学到了很多，也发现了自己平时学习过程中一些很难发现的错误。其实当时完全没有想过我的博客未来会发展成什么样，会有多少人来看，更没想过godweiyang这么名字会有多少人会知道。但是不用去过度担忧未来，即使没有一个人去看你总结的经验和知识，即使没有一个人欣赏你认同你，你也要坚持写下去。总有一天，你会拨开云雾见光明。</p><h2 id="既过不恋"><a href="#既过不恋" class="headerlink" title="既过不恋"></a>既过不恋</h2><p>其实我的硕士生涯前两年科研并不顺利。因为悟性差，论文看得少，同时做的方向又非常的小众，所以并没有想出非常有创新的idea。拍脑袋想了个现在看起来非常无聊的点子，做了些不那么充分的实验，然后就冲击ACL顶会了。结果当然不出意料，评审们的观点也都很犀利，指出了我创新不足的缺点。然而创新不足是一个致命伤，这几乎没有办法修改，于是我只能转投了自以为更加简单一点的会议，最后依然被拒。就这样大半年快过去了，我的科研还是零进展。导师安慰我说，不要气馁，评审们提出这么详细的意见，说明这个方向并没有死掉，还是有很多人关注的。这也给了我很大的信心，<strong>不能想这么多乱七八糟的，也不要去留恋过往的得失，既过不恋，专心做好自己手头的事就行了</strong>。</p><p>但是不留恋不等于不反思。从失败的投稿经历中还是可以学到很多经验的，motivation要充分，idea要有创新，实验要做的充分等等。后来一个偶然的机会，我从师兄以往的论文中联想到了能否可以把他的idea迁移到我的领域。然而迁移过程中还是遇到了棘手的问题，由于短语结构的句法树和成分结构的句法树表示上存在差异，因此我需要一种全新的表示方法，然后才能继续下面的工作。但是一直没有想法，那段时间特别迷茫，不知道这个领域还能不能走得下去。每天跟导师聊天都会抱怨，有监督句法分析确实做不下去了，这次会议投完我一定要转无监督了。又是一个偶然的机会，在洗澡的时候突然想出了一种全新表示，歪打正着，成为了后来论文中最主要的创新点。</p><h2 id="当时不杂"><a href="#当时不杂" class="headerlink" title="当时不杂"></a>当时不杂</h2><p>那之后的一个多月，我再也没有打过游戏，当时不杂，专心完成我的论文初稿，同时完善各种实验。实验也遇到了很多困难，但在实验室师兄们的帮助下最终都顺利解决了。不得不说的是，导师对我的帮助实在是太大了。尽管刚开始他并不能完全理解我的idea，但是每天都会坚持和我讨论细节，并给出我修改的建议。等论文初稿完成，给我反反复复修改了很多遍，许多公式和证明都被精简浓缩。后来疫情在家的rebuttal环节，依旧远程帮我修改回复意见，最终侥幸中了今年的ACL。从这段经历中也可以看出，一个良师非常的重要。古语有云，三人行必有我师，能称作你老师的不一定是比你年长很多的人，你身边的任何人，都可能会给你人生中的某个阶段带来很大的启示，也会成为助力你前进的助推剂。英雄联盟中的易大师说过，<strong>真正的大师永远怀着一颗学徒的心，不管你以后做到了多高的位置，做出了多高的成就，都要永远怀着一颗谦逊求学的心</strong>。</p><p>在两年的硕士生涯里，我总结了下面几点经验，不管是在学术中，还是在工作中，我觉得都是通用的：</p><ul><li>一定要多积累领域相关知识，只有看的多了，才能知道下一步往哪里走。</li><li>但是不要拘泥于你自己的领域，也许别人的领域知识会对你有启发式的影响。</li><li>灵感来源于生活，阿基米德在洗澡时想出了浮力定律，也许你也能在洗澡时想出一个新的idea呢。</li><li>学会谦逊，每个人的意见都可能会对你的前进方向产生影响，多去聆听，这会让你少走很多弯路。</li><li>站在巨人的肩膀上，不要埋头造轮子，这会节省你很多时间，当然并不意味着你不懂底层的原理。</li><li>学会总结，就像这篇博客一样，总结可以让你回顾过去的得失，及时纠正前进中的错误。</li></ul><h2 id="余生很长，未来可期"><a href="#余生很长，未来可期" class="headerlink" title="余生很长，未来可期"></a>余生很长，未来可期</h2><p>接下来就是找实习了，当时也找了很多公司，但是由于懒人心态，只想留在上海，并没有去外面的世界看看的想法。实习面试也很顺利，成功进入了字节。但是由于在学校做的方向太小众了，来了这以后就开始做一个全新的方向了，也就是机器翻译。但我认为自然语言处理很多领域知识都是相通的，同时在学校组会我也学到了很多其他领域的知识，因此来了字节以后入门也没有那么的困难。AI Lab的工作体验和学校实验室其实非常接近，区别可能就是将学术和工程结合起来了，需要更多的考虑线上的需求，数据量和模型也大了很多。但是这里的氛围是非常相近的，也有非常多的大佬可以给你针对性的指导意见，这里的每个人都可以成为我的老师，教会了我很多在学校从来没接触过的知识。另一方面，公司的工作强度比学校更大，每天学到的东西是学校的很多倍，在这里你可以过得更加充实。</p><p>来了这半年多了，过程中也遇到了很多瓶颈，但是很感谢能力很强的mentor和其他同事们给我带来的各种帮助。虽然半年时间里做出的成果很有限，不算突出，但是我努力过了，自然就能坦然接受，并立志在接下来的工作中继续完善，最终争取做到最好。</p><p>最后再来说说刚刚结束的秋招。还是和三年前一样，我依然选择留在上海，因此最终在上海的几家公司中选择了字节。说说字节的哪些方面吸引了我吧。一是平台，也就是工作内容。机器翻译还是和我所学的自然语言处理非常相关的，而且实习了半年也是逐渐熟悉了，因此不需要时间成本再去换新的方向了。二是工作氛围。组内的气氛我还是非常喜欢的，大家都很年轻，都很有干劲。这让我联想到了我的导师，也是很年轻，每天有精力指导我们实验室每一个人。同时气氛又非常的活泼，不会让我感到那么紧张，那么的有压力。三是工作环境。字节上海的园区非常的干净整洁，设施也都很丰富。四是公司福利。自从来了公司，我爱上了去食堂吃饭，免费又好吃的三餐让我再也不用纠结点什么外卖了。同时各种节假日也会有活动和礼品，营造出各种节日氛围，这才是我理想中的工作环境，是我曾经幻想中大厂应该有的模样。可能有许多人忍受不了大小周的工作作息，但我暂时并没有感觉到有太大影响，毕竟也有加班费嘛，况且周末在家也是打游戏。为什么说是暂时呢？因为我现在单身，一个人的周末自然略显无聊，当然要用工作来让自己更加充实啦。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>很感谢能够加入字节，能够拥有这么好的平台、人脉，能够让我在这里做我喜欢做的事情。还是那句至理箴言，<strong>物来顺应，未来不迎，当时不杂，既过不恋</strong>。今后的工作中不管出现什么困难，都要坦然面对，一个bug修一周不是什么稀奇事，就看你有没有那种毅力。余生很长，不用去想太过久远的空洞目标，朝着一个正确的方向前进就行了。立足当下，做好你手头的活，不以物喜，不以己悲，心无旁骛才能做出优秀的成果。最后不要太过留恋过去，过往如烟，从中总结出得失，悟出经验，带着它继续前行就好了。</p><p>godweiyang<br>撰于 2020.12.04</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节跳动 </tag>
            
            <tag> 学术 </tag>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020国际机器翻译大赛：火山翻译力夺五项冠军</title>
      <link href="/2020/12/02/volctrans-wmt20/"/>
      <url>/2020/12/02/volctrans-wmt20/</url>
      
        <content type="html"><![CDATA[<p>马上体验<strong>火山翻译</strong>：<br><a href="https://translate.volcengine.cn" target="_blank" rel="noopener">https://translate.volcengine.cn</a></p><p>在11月下旬结束的自然语言处理顶级学术会议EMNLP2020上，国际机器翻译大赛（WMT20）公布了赛事最终结果，来自字节跳动火山引擎旗下的火山翻译（Volctrans）在39支参赛队伍中杀出重围，以显著优势在「中文-英语」语向翻译项目上拿下了冠军。</p><p>此外，火山翻译团队还拿下了「德语 -英语」和「德语-法语」语向机器翻译项目的冠军，更斩获了平行语料过滤对齐项目普什图语和高棉语的两项第一。</p><p><img src="1.jpeg" alt></p><h2 id="39支队伍角逐国际顶级机器翻译大赛WMT"><a href="#39支队伍角逐国际顶级机器翻译大赛WMT" class="headerlink" title="39支队伍角逐国际顶级机器翻译大赛WMT"></a>39支队伍角逐国际顶级机器翻译大赛WMT</h2><p>国际机器翻译大赛（WMT）由国际计算语言学协会（ACL）举办，是全球学术界公认的国际顶级机器翻译比赛，也是各大科技公司、顶尖院校与学术机构展示自身机器翻译实力的较量舞台。</p><p>自2006年至今，国际机器翻译大赛（WMT）已经成功举办15届，本届比赛共有39支队伍参赛，包括微软、Facebook、Google DeepMind、腾讯、小牛翻译、华为、滴滴等实力雄厚的参赛团队。</p><p>组委会根据中英、英中、英德等22个不同翻译任务提供测试数据集，并引入科学的语言专家人工评估流程。每个参赛系统首先由多名经验丰富的语言学家进行评估，然后对最终分数进行标准化加权，最后进行排名。整个评估过程历时四个月，评价结果有非常高的置信度。</p><h2 id="语言专家评估得分第一-火山翻译拿下「中文-英语」语向冠军"><a href="#语言专家评估得分第一-火山翻译拿下「中文-英语」语向冠军" class="headerlink" title="语言专家评估得分第一 火山翻译拿下「中文-英语」语向冠军"></a>语言专家评估得分第一 火山翻译拿下「中文-英语」语向冠军</h2><p>历年比赛中，「中文-英语」语向的翻译任务都是参赛队伍最多、竞争最为激烈的机器翻译任务之一，今年更胜往年。</p><p>火山翻译团队参加了非受限场景的比赛，也就是在给定测试集的情况下，可以使用任何数据和方法探索翻译效果极限的比赛方式，组织方也引入了四个权威的在线机器翻译商业系统（Online-A、G、Z、B）作为对比，这也是最能体现翻译团队数据和算法综合能力的场景。在人工评估中，火山翻译团队（Volctrans) 力压群雄，以明显的优势夺得了冠军。</p><p><img src="2.jpeg" alt="WMT2020 中英翻译前几名系统得分。Ave.z代表人工评估标准化分数，也是目前机器翻译最受认可的指标。"></p><p>相比「中文-英语」，「德语-英语」在 WMT 比赛上是传统项目，也是欧洲国家最关注的语向。在最后的人工评价中，火山翻译依然表现出色，取得了第一名的成绩。国际机器翻译大赛组委会给出了很高的评价，“作为新的参与者，火山翻译表现尤为出色（particularly well），超越了很多传统队伍”。</p><p>复旦大学计算机学院教授、EMNLP2021大会程序主席黄萱菁表示：“WMT是非常硬核的比赛，火山翻译取得了出色成绩。火山翻译的LightSeq、mRASP等技术让人眼前一亮，机器翻译有广阔的发展空间，非常期待火山翻译为机器翻译的技术研究和产品应用探索更多可能性。”</p><h2 id="领先的背后：火山翻译致力于打造前沿研究、产品研发和用户反馈的闭环"><a href="#领先的背后：火山翻译致力于打造前沿研究、产品研发和用户反馈的闭环" class="headerlink" title="领先的背后：火山翻译致力于打造前沿研究、产品研发和用户反馈的闭环"></a>领先的背后：火山翻译致力于打造前沿研究、产品研发和用户反馈的闭环</h2><p>火山翻译（Volctrans）是由字节跳动计算机研究科学家、工程师、产品经理、产品运营和语言专家组成的专业团队研发，其基于自主研发的机器学习技术，积累了百亿多种语言语料，已支持超过50个语种、2500个语对之间的互译，翻译效果和速度业界领先。</p><p><img src="3.jpeg" alt="火山翻译官网。可以通过 https://translate.volcengine.cn 体验火山翻译，并了解更多产品能力。"></p><p>目前，火山翻译具备文本翻译、语音翻译、图像翻译、语种识别四种能力，在办公、娱乐、新闻等场景表现优异。</p><p>基于这些能力，火山翻译推出了一系列形态多样的产品与服务，包括机器翻译云服务、智能视频翻译、智能同传、翻译浏览器插件等。此外，火山翻译支持API、SDK、私有部署等多种接入方式，且支持垂直领域的快速模型定制，能够满足不同群体和不同行业的翻译需求。</p><p>在视频翻译场景，火山翻译提供简单高效的视频“转写-打轴-翻译”全流程服务，轻松听译、智能打轴、高效编辑、专业审校，集四大能力于一身，帮助创作者轻松高效地应对跨语言视频创作。</p><p>在语音翻译领域，火山翻译的智能同传技术也表现卓越，能够根据现场发言提供高品质、低延时的实时语音识别字幕结果，同时提供人工字幕保障方案，让会议现场以及直播字幕更精准流畅。</p><p>火山翻译的技术来源于字节跳动团队多年机器学习和自然语言处理领域的深耕。团队拥有百余项技术发明专利，在人工智能顶级国际学术会议发表50余篇学术论文。在机器翻译技术上更是独创了mRASP多语言预训练算法，把几十种语言语料融合在一起训练，获得的模型在具体语对上微调取得了44个语对的业界最佳性能，整体效果力压Facebook研发的mBART方法。同时，火山翻译研发的LUT和COSTT语音到文本翻译算法，从语音输入（例如英语）可以直接输出目标语言文字（例如中文），减少了错误累积，在效果上取得了业界领先。</p><p>字节跳动杰出科学家、人工智能实验室总监李磊称：“火山翻译核心优势在打造前沿研究、产品研发和用户反馈的闭环，研发团队分布全世界多个国家，工作中也在使用自己打造的产品来跨语言沟通，在迭代中快速进步。”</p><p>火山翻译团队还研发了多项机器翻译前沿技术，目前已经集成到火山翻译系列产品中，例如镜像式生成模型MGNMT、CTNMT算法、交互式翻译算法CAMIT、胶囊翻译网络、并行翻译算法PNAT和GLAT等。火山翻译还采用了自研的高性能序列推理引擎LightSeq，推理速度业界最快，比原生系统提高10倍，可以达到每秒两万词的翻译速度。</p><p>李磊表示：“火山翻译已经为飞书、今日头条等多款海内外产品提供稳定和高质量的翻译服务，每天处理数亿次翻译请求，为来自全球的过亿用户群体提供优质的翻译体验。未来，火山翻译希望为更多用户提供服务，帮助用户更高效地实现国际信息无障碍交流。”</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节跳动 </tag>
            
            <tag> 火山翻译 </tag>
            
            <tag> 机器翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文速览EMNLP 2020中的Transformer量化论文</title>
      <link href="/2020/11/26/emnlp20-quantization/"/>
      <url>/2020/11/26/emnlp20-quantization/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>花了几天看了三篇EMNLP 2020中关于Transformer模型量化的相关论文，快速记一下要点。</p></blockquote><h2 id="Fully-Quantized-Transformer-for-Machine-Translation"><a href="#Fully-Quantized-Transformer-for-Machine-Translation" class="headerlink" title="Fully Quantized Transformer for Machine Translation"></a>Fully Quantized Transformer for Machine Translation</h2><p>这篇是华为诺亚方舟实验室和蒙特利尔大学合作的，发表在findings上面。</p><p><strong>论文地址：</strong><br><a href="https://www.aclweb.org/anthology/2020.findings-emnlp.1.pdf" target="_blank" rel="noopener">https://www.aclweb.org/anthology/2020.findings-emnlp.1.pdf</a></p><p><img src="1.png" alt></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>针对Transformer结构的计算密集型算子进行了activation量化，除了bias以外的所有weight进行了量化，这一点其实我们组也都做过了。</p><p>采用的是量化感知训练（QAT），反向传播采用的是straight-through estimator。</p><p>考虑到每个channel的分布有差异，因此针对每个channel单独学习量化的scale参数。</p><p>零值的处理：padding无需考虑，反正会被mask掉。ReLU和attention softmax之后的量化强制定义量化下界为0。量化全部加在dropout之前。</p><p>剪枝采用结构化剪枝，因为稀疏性剪枝需要硬件或库支持，比较麻烦。这里只对FFN参数进行剪枝，而且不是采用传统的百分比阈值，而是根据ReLU之后值计算出第一层FFN输出的每一列的max值，根据max值是否超过一定阈值来剪枝，这个阈值设定为所有列max值的方差乘上一个常数。这里好处就是剪枝的百分比不固定了，每一层动态剪，可多可少。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="2.png" alt><br>可以看出训练后量化（PTQ）降得还是略多的，而QAT的8位或6位基本没怎么降，4位的话影响就很大了。结果也是符合我们组实践效果的。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>自我感觉这篇没啥创新，不过最后也只是findings，没有中主会。量化位置和一些trick也都是很容易想到的，而每个channel单独量化其实实践下来意义也不大，不加这个trick效果也很好了已经。FFN最后也并没有剪去多少参数。</p><h2 id="Extremely-Low-Bit-Transformer-Quantization-for-On-Device-Neural-Machine-Translation"><a href="#Extremely-Low-Bit-Transformer-Quantization-for-On-Device-Neural-Machine-Translation" class="headerlink" title="Extremely Low Bit Transformer Quantization for On-Device Neural Machine Translation"></a>Extremely Low Bit Transformer Quantization for On-Device Neural Machine Translation</h2><p>这篇是三星做的，也发表在findings上面。</p><p><strong>论文地址：</strong><br><a href="https://www.aclweb.org/anthology/2020.findings-emnlp.433.pdf" target="_blank" rel="noopener">https://www.aclweb.org/anthology/2020.findings-emnlp.433.pdf</a></p><p><img src="3.png" alt></p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>这篇没有采用比较常用的uniform量化方式（也就是将浮点数区间等比例映射到整数区间），而是采用binary-code，也就是将参数$w$表示成$q$（量化位数）个相同维度的二值向量$b$的线性组合，最后矩阵和向量相乘可以变为：$y = \sum_{i=1}^{q}{(\alpha_i \circ (B_i \cdot x))}$，具体这里可以怎么加速可以参看三星之前的论文：BiQGEMM: Matrix Multiplication with Lookup Table For Binary-Coding-based Quantized DNNs。</p><p>这篇针对embedding的不同词频采用了不同的量化位数，具体方案可以看下面的伪代码：<br><img src="4.png" alt><br>总之就是词频越高，量化位数越多。而大多数单词词频都很低，1%的单词占据了95%的词频，所以他们位数高一点影响不大。针对每个词向量，采用的是不同的量化参数，这也是考虑到每个词向量的空间分布有差异。</p><p>针对encoder和decoder中的不同类型attention，论文也是采用了不同的量化位数。</p><p>训练策略上，这里finetune阶段每2000步开启一次量化，为了节约训练时间。</p><h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="5.png" alt><br>可以看出embedding量化影响还是比较大的，特别是量化到2位以下时。而全部采用2位量化效果很差。如果用本文的量化方法，可以看出大部分配置下，损失都在1个点以内，效果还是不错的。</p><h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p>这篇采用non-uniform量化方式，实现起来还是更复杂一点的，而且在矩阵相乘的加速优化方面，并没有过多阐述怎么实现。此外没有对比uniform量化和non-uniform量化方式的差距，不清楚性能的提升是non-uniform量化占主导，还是根据词频和不同attention类型采用不同量化位数占了主导。最后人工设计因素过多，比如attention的量化位数都得人来定好，应用起来不是很灵活。</p><h2 id="TernaryBERT-Distillation-aware-Ultra-low-Bit-BERT"><a href="#TernaryBERT-Distillation-aware-Ultra-low-Bit-BERT" class="headerlink" title="TernaryBERT: Distillation-aware Ultra-low Bit BERT"></a>TernaryBERT: Distillation-aware Ultra-low Bit BERT</h2><p>这篇还是华为诺亚方舟实验室做的，发表在EMNLP主会上面。</p><p><strong>论文地址：</strong><br><a href="https://www.aclweb.org/anthology/2020.emnlp-main.37.pdf" target="_blank" rel="noopener">https://www.aclweb.org/anthology/2020.emnlp-main.37.pdf</a></p><p><img src="6.png" alt></p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p><img src="7.png" alt><br>如上图所示，这篇在量化基础上还加上了蒸馏。</p><p>首先对于weight量化，采用三值量化，训练方法用的是TWN或者LAT，具体原理可以去看侯璐的论文：<a href="https://houlu369.github.io/，而activation还是采用一般的min-max量化。" target="_blank" rel="noopener">https://houlu369.github.io/，而activation还是采用一般的min-max量化。</a></p><p>量化参数的话，embedding每一行采用一套参数，而其他所有weight都是一整个采用一套参数。</p><p>蒸馏采用三个loss：hidden state、attention和logits。teacher是全精度的，student有两个，第一个是全精度的，模型和teacher一模一样。然后采用TWN或LAT量化得到三值网络，计算loss，最后反向传播更新全精度student的参数。</p><p>此外还有两个trick，一是用了数据增强，二是全精度的student模型初始化是用的finetune后的teacher。</p><h3 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="8.png" alt><br>在GLUE上做的实验，最大压缩率可以达到23倍，看起来效果比普通的Q-BERT、Q8-BERT还是好了不少的，比BERT也只差了1个点左右。这里所有的activation都只量化到了8位，估计再低试了效果也不好。</p><h3 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h3><p>GLUE和SQUAD上看起来效果很不错，压缩率也很高，但是融合的手段有点多：蒸馏、数据增强、模型初始化等，消融实验也可以看出来去掉蒸馏和数据增强后效果降了非常多，因此TWN和LAT相比于一般的min-max量化实际中到底有多大优势不得而知。最后这篇论文没有做机器翻译任务，都是做的分类任务，如果在更困难的生成任务上效果也很好，才真的有说服力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合看下来，这三篇论文采用了三种完全不同的量化方法。第一篇最好实现，TensorFlow自带的量化也是采用这种方式，8比特效果也近乎无损，但是更低的话就不大行了。后两篇都是超低比特量化，一个用的是binary-code，一个是TWN或LAT，压缩率都很高。第二篇根据词频或重要性区分不同参数的量化位数，在超低比特情况下还能保持很好的效果。第三篇直接超低比特量化，但是用了蒸馏等一系列操作把性能提升了上去，遗憾的是没有做机器翻译任务，让人产生怀疑。</p><p>不过最后只有第三篇中了主会，不管怎么样，还是有很多值得借鉴的地方的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 量化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一段平平无奇的秋招经历</title>
      <link href="/2020/11/24/find-work/"/>
      <url>/2020/11/24/find-work/</url>
      
        <content type="html"><![CDATA[<blockquote><p>秋招也正式结束了，三方寄出去了，最终选择留在了实习的字节跳动。这里简单聊聊这大半年以来的实习和秋招经历。</p></blockquote><p><img src="2.jpg" alt="字节跳动上海总部"></p><p>四月份的时候投的实习，当时面了阿里、腾讯、美团和字节，最终选择来了字节实习，主要想留在上海。</p><p>字节实习主要做的是机器翻译模型的压缩，剪枝量化蒸馏之类的，因为之前没有做过，所以到现在都还有很多东西需要去探索学习。</p><p>实习了有半年左右，然后就开始秋招了，虽然本来就想留在字节，但是为了保底，还是得投一投其他公司嘛。</p><p>最后面了百度、阿里、腾讯、美团、拼多多，还投过京东、携程之类的图个乐呵，最秀的是京东简历都没过，果然太菜了。</p><p>先说说我的情况吧，只有一篇方向冷门的水文，还有一些过去很多年的ACM经历，其他项目和竞赛经历为零，所以很庆幸当时字节实习要了我吧。</p><p>面试的话，百度、阿里是北京的部门，腾讯是深圳的，美团、拼多多是上海的，当然我最想留上海，所以bat就没怎么想面。最后的话bat挂了两家，一家没催没消息，上海的话三个色色批，也算圆了我留上海的愿望吧。</p><p>百度面我的是百度贴吧推荐部门，我当时就震惊了，百度贴吧还活着？这部门怎么样我不知道，也不做评价，当时心理上就不想面了。然后还是为数不多的上午面的，那天头还昏昏沉沉的，一面上来三道算法题，第一题最弱智的摩尔投票我都没想起来怎么做，后两题也不怎么会。面完就感觉糟糕的很，后面二面效果也是差不多。最后很长一段时间都没有任何消息，感觉上应该是凉了。大概一个月后，hr突然给我打电话，问有没有空聊聊，我当时在回家路上，就说换个时间吧，她也答应了。然后，就没有然后了，官网显示gg。百度的面试体验上来说是最糟糕的，算法题和问的面试知识都不在我的领域内，感觉很差，当然还是因为我太菜了。</p><p>阿里是内推的北京的达摩院云小蜜团队，面的还可以吧，三面都挺不错，但是到现在都没有接到过hr面通知。我自然也是懒得问，反正也不会去。刚刚内推的学长问我怎么样了，我人都傻了，这才想起来嘛。当然也没有然后了，我三方都寄走了。阿里面试体验有一说一还是不错的，二面云小蜜负责人就和我聊人生，谈中国互联网发展了，交叉面又是隔壁实验室老师的师弟，所以几分钟就结束了，很轻松。</p><p>腾讯也是很离谱，都说wxg今年很难进，果然我被pcg捞起来了，然后还是完全不会的后台开发。打电话问我面不面？说pcg的nlp算法岗名额很少了。我说我不会，他说没事，我是ACM的没问题，然后特么就给我约了面试，我人都傻了。结果第一面还是算法面，1小时5道算法题，我一眼就看出来是打过ACM的人出的题，第一题就很难。最后只做了两道，还错了一道。他来了句，好久没刷题了吧，做的不大行啊。wdnmd，是你捞我，搞个后台开发，还恶心我出这么难的题目，现在还嘲讽我。最后结果当然是挂了，然后就没消息了，也没人捞我。</p><p>然后就是上海的三家公司了，体验都是一级棒。</p><p>美团的话内推了点评搜索部门，北斗面了两面被转到普通校招了，也没办法，今年北斗入门要求两篇A，我太菜了。最后三面面试官竟然是我的老学长、老校友，所以聊得很开心，轻松过了。最后的话美团也是第一个开奖，价格当时看起来也是很香的。我也是直接签了offer，当然三方不急，其他两家都没定呢。</p><p>拼多多就很简单了，安全风控部门，其实也和NLP有很大关系的，算法竞赛也很有用。一面普普通通很正常，二面面试官很喜欢我，商业互吹，最后走了个过场吧。我当时还惊讶拼多多只有两面，也太轻松了吧。没想到hr面后又给我加了一面，不过难度也不大，轻松就过了。最后的话，拼多多也是给我开了很有诚意的价格，不得不说，真香。算上总包比美团高了足足有将近三十万。但是想到拼多多传闻的工作强度、工作环境之类的，我就很纠结选择钱还是生活了。最后还是放弃了，一周六天我还是撑不住，每天23点下班，我就没办法坐在电脑前直播游戏了，就不能写文章给你们看了。</p><p>字节我实习的部门万万没想到几乎是整个公司最后转正的部门，其他部门都开奖了很多了，我们却还没转正。因此搞得也是很焦虑，也一度想过溜了吧，美团拼多多挺好的。半年来做的东西虽然看起来也不solid，方法也很简单。现在看了些更加深入的论文后，愈发觉得做的挺弱智的。但是很感谢leader们对我的欣赏吧，说起来在公司我依旧和在学校一样活跃，喜欢水群，啥都喜欢搞搞。现在还成为了组里的logo设计师，推广营销组里的技术，前端也能搞了娱乐娱乐，还能训训模型，当然主业还是钻研算法，啥事情都能插上一手。最后开的奖也很不错吧，算上补贴之类的比美团略高，比拼多多低了二十万多吧。不过经过多次考虑后，我还是选择了留下。</p><p>总的来说，我的面试过程没有什么参考价值，不像网上说的那些SVM、xgboost、决策树之类的考一堆。我也看过，最后什么都没考，都问的是论文和实习经历。所以大家伙努力搞有意义的竞赛、论文、项目吧。</p><p>最后说说我为什么选择字节吧。当时有三个选择，美团、字节、拼多多。价格的话，杂七杂八全算在一起的话，可以认为x、x+6、x+27这种水平吧，大差不差。工作时间美团995、字节1095.5，这两家都很自由，其实差别不大，早走都行，美团优点是双休。拼多多11116，这个嘛，基本可以认为没有时间玩了，中午和晚上只能休息一小时，顶不住的。工作内容的话，美团点评搜索，核心部门，研究和工程并存，字节机器翻译、模型压缩吧，目前是偏研究，兼顾线上需求，拼多多安全风控，听说是不出事轻松，出了事或者节假日（各种购物节）就加班加点，看起来还是比较累的。工作环境氛围和福利的话，美团周边看起来一般，地理位置离学校更近，内部的话我也不清楚，开水团出了名的，除了开水没有福利了。字节体验了半年很舒服，三餐不仅免费，还很好吃（强烈推荐），不过我还是没吃胖，环境也很不错，在科技绿洲园区，有自己的一整栋楼，呆着很舒服，每逢节日各种福利，氛围营造的也很好。拼多多不了解，看起来很神秘的样子，全靠网上传闻和热搜了解（那几件事，你懂的），不过拼多多离学校真的好近好近。美团点评搜索的leader也很早就和我聊了，详细介绍了他们部门情况，这个leader感觉就非常的nice，看朋友圈生活也很丰富，想必共事起来也会很舒服。拼多多的leader之前也说过了，也很nice，都很想我去。当然字节这边也不用谈了，个个都是大佬，没什么可说的，一级棒。最后也是跟他们解释了很久为什么我选择留下吧，江湖很小，都是做技术的，还会再相遇的。</p><p>既然选择了留下，就更要好好干活了，当然也快写毕业论文了，准备过段时间出去玩个半个月的样子，长这么大还没出去旅游过。然后就回来写毕业论文，还是得稳一手，万一延毕了呢？然后就得继续看论文，研究我的模型压缩了，还有很长的路需要走。至于女朋友嘛，随缘吧，时间有了，对的人没了，很多人都是太多顾虑，而最中意的人，emmm，随缘吧，后会有期。</p><p>最后，还是很感谢能有机会留在字节吧，自从读了研就感觉自己是个很菜的人，跟一手论文的大佬们差距太大了，能有今天的结果是我最满意的了，我的秋招之旅就这样正式结束了。</p><p><img src="1.jpg" alt="最后感谢面试期间一直陪伴我的超越妹妹头像"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秋招 </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode 327】区间和的个数</title>
      <link href="/2020/11/07/leetcode-327/"/>
      <url>/2020/11/07/leetcode-327/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 $nums$，返回区间和在 $[lower, upper]$ 之间的个数，包含 $lower$ 和 $upper$。<br>区间和 $S(i, j)$ 表示在 $nums$ 中，位置从 $i$ 到 $j$ 的元素之和，包含 $i$ 和 $j$ $(i \le j)$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [-2,5,-1], lower = -2, upper = 2,输出：3解释：3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最暴力的解法就是 $O(n^2)$ 枚举所有区间，然后判断，显然会超时。</p><p>对于区间 $[i, j]$ 来说，它的和可以表示为 $pre[j] - pre[i]$ ，其中 $pre[i]$ 是前缀和，表示第 $0$ 个到第 $i$ 个元素之和。</p><p>如果这个区间满足条件，那就有 $lower \le pre[j] - pre[i] \le upper$。如果我们遍历每个 $j$ 的话，只要求出满足 $pre[j] - upper \le pre[i] \le pre[j] - lower$ 的左端点 $i$ 的数量即可。</p><p>如果将 $pre$ 数组排好序，那就能直接用二分法找出满足条件的数量了。但是这里需要在遍历右端点 $j$ 的时候动态插入 $pre[j]$ ，然后只对 $pre[0]$ 到 $pre[j]$ 进行排序。而目前应该没有什么数据结构能很快的同时支持动态有序插入和二分查找。</p><p>因此这里可以采用树状数组（或线段树），来求取一段区间的和是多少。而树状数组的值表示这个数有没有出现过（0或1）。</p><p>对于注意到这里有负数出现，因此需要先做离散化，对于每个前缀和 $pre[i]$，只需要离散化三个值：$pre[i]$、$pre[i]-lower$、$pre[i]-upper$ 即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">BIT</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">BIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ID</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>    set<span class="token operator">&lt;</span>ll<span class="token operator">></span> st<span class="token punctuation">;</span>    <span class="token keyword">int</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">addNum</span><span class="token punctuation">(</span>ll x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">proj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ll x<span class="token operator">:</span> st<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getID</span><span class="token punctuation">(</span>ll x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countRangeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> lower<span class="token punctuation">,</span> <span class="token keyword">int</span> upper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ID id <span class="token operator">=</span> <span class="token function">ID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BIT bit <span class="token operator">=</span> <span class="token function">BIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        id<span class="token punctuation">.</span><span class="token function">addNum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            id<span class="token punctuation">.</span><span class="token function">addNum</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>            id<span class="token punctuation">.</span><span class="token function">addNum</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>lower<span class="token punctuation">)</span><span class="token punctuation">;</span>            id<span class="token punctuation">.</span><span class="token function">addNum</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>upper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        id<span class="token punctuation">.</span><span class="token function">proj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bit<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">getID</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> lb <span class="token operator">=</span> id<span class="token punctuation">.</span><span class="token function">getID</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>upper<span class="token punctuation">)</span><span class="token punctuation">,</span> rb <span class="token operator">=</span> id<span class="token punctuation">.</span><span class="token function">getID</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>lower<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span> <span class="token operator">-</span> bit<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>lb<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bit<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">getID</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日心情（2020.10.19）</title>
      <link href="/2020/10/20/mood-20-10-19/"/>
      <url>/2020/10/20/mood-20-10-19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没有别的意思，只是又到了网抑云时间了。</p></blockquote><p>每天的生活还是那么重复而又单调。</p><p>早上九点半起床，10点多到公司。</p><p>工作两小时不到吃午饭，中午看看直播，两点又开始下午的工作。</p><p>7点开始吃晚饭，吃完要么回去打游戏，要么有事继续工作到九点十点回去，回去依旧是看直播。</p><p>这么看起来每天确实挺无聊的，每天晚上都盼望着早点回去，但是回去又不知道干什么。</p><p>有时候能约上几个同学打两把游戏，但也总感觉是在虚度光阴，挺无趣的。</p><p>有时候吧干脆就没人打游戏，只能听听歌，看看直播，对着电脑傻傻的发呆，没错，就像现在我这样。</p><p>以前在宿舍吧，还能有人说说话，聊聊八卦扯扯淡，不知不觉也就到了睡觉的时间了。</p><p>现在一个人在外，说话的人也没一个，几千的手机响都不响。</p><p>最近可能要转正答辩了，这两天在忙活做ppt，还得审两篇论文。</p><p>如果要我自己评价一下这五个多月以来自己的工作表现，我只能说问心无愧，学到了很多，虽然还有很多缺憾，但我尽力了。</p><p>其实挺想转正了之后找个女朋友的，但我知道，现实是不会有太大改变的，懒还是懒，现实还是现实。</p><p>工作了圈子小了很多，以后估计找起来难度比在学校大了不少。</p><p>都说很多男生嘴上嚷嚷着要脱单，实际上一点行动都没有，确实。</p><p>年纪大了，很多择偶要求都变了，好看，高学历，体贴，善解人意，不矫情，不异地，现实，都满足是不可能的。</p><p>但归根到底还是想找个能对上眼的，现实，不矫情，不异地，这些还是最重要的，越来越务实了吧。</p><p>又凌晨一点了，每天都想早点睡，每天都忍不住熬夜，不知道怎样才能改变。</p><p>明天依旧是社畜的一天，后面还有毕业论文，还有好多好多。</p><p>写的没有一点逻辑，是我边看直播边写的，想到哪写到哪，心情表达出来了，孤寂，无聊，抑郁。</p><p>很多人开玩笑说我是海王，通讯录里妹子多的是，确实挺多的。</p><p>但谁知道实则却是个寡王，没有置顶，首页都是群消息，偶尔来消息，一看是来请教问题的。</p><p>几年的写博客，搞营销，确实加了不少人，实际作用寥寥无几，名声有了，仅此而已。</p><p>也想过通讯录找个看上眼的，但又太现实，最后都会想到不合适，于我，于她。</p><p>认识新的人不难，了解新的人太累，还是幻想着熟人里成一个多省事，做梦。</p><p>也挺怪的，感情这方面，挺敏锐的，但也只是观察别人，谁谁谁又分分合合了，适合去做狗仔队。</p><p>理论看了一堆，段子听了无数，动起手来唯唯诺诺。</p><p>算了该睡了，最后一把直播，看完一定睡，一定不。</p><p>说是看直播，实际上什么技术都没学到，看的还是一个寂寞。</p><p>晚安。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆碎碎念</title>
      <link href="/2020/10/08/mood-20-10-08/"/>
      <url>/2020/10/08/mood-20-10-08/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>很久没有写东西了。一是实习确实没啥时间，下了班也只想打开游戏或者打开直播看看开火车。二是确实也不知道写啥，总是分享论文挺累的，刷题也没啥必要了。最舒服的还是闲扯，聊聊划水经验之类的。</p><p>这个国庆回了趟家，本来想着以后很少回去了，趁机周围转转。最后还是懒，还是呆家里窝了七天，每天LOL和直播为伴。想当年本科毕业也啥事没有，天天呆实验室打游戏，空度了一年。以后工作了时间就更少了，最久的假期可能就只剩明年毕业了，不知道到时候有没有人一起出去玩呢。<br><img src="1.jpg" alt><br>这么多年过去了，心态啥的可能改变了很多，唯一没改的就是懒。有多懒呢，就像这篇文章一样，我都懒得找好看的模板。</p><p>想当初保了研选学校导师，懒得出去夏令营，正好本校又有奈斯的导师，就直接留下了。大四啥事也没有，在实验室打了一年的游戏，白白浪费了一年时间。从下面我练的三个LOL号就能看出我打的有多勤快了，这么些年打了总共有7500把左右了。段位还是很低，水平还是很菜，但打个游戏就是为了开心，为了下班后能够放松放松，自然就不用受排位那些气了。<br><img src="2.jpg" alt><br><img src="3.jpg" alt><br><img src="4.jpg" alt><br>其实在科研上，我也是一个懒。讲道理这两年看论文写代码的时间应该比打游戏少得多。每天睡到中午才起来，吃完午饭可能都一两点了，然后去实验室看看论文想想idea，五六点老板来交流交流，吃完晚饭一直到深夜都是游戏时间了，偶尔晚上会写博客分享论文比较上头，回宿舍后凌晨又是抖音或者网抑云时间。这样时差混乱的日子过了有两三年，轻松是轻松，但是也挺无趣的，也想像别人那样过得充实，就还是懒，呆在实验室多舒服。其实我不是非常投入做科研的，不然我就转博了，还是想简简单单毕业找个工作了。我相信大多数人也是这个想法，真正喜欢科研的人少数。所以我一直用一种轻松愉悦的状态做科研，而不是应付任务，也许这样更容易产生出idea吧。<br><img src="5.jpg" alt><br>这种颓废的状态在今年实习后有了很大改变，公司毕竟不是学校，每天朝九晚五的生活节奏还是很快的。不过在这里还是做的偏research一点的东西，和学校区别不是很大，只是白天不划水了，学到的东西更多了。我也想过，这是不是我要的生活？看到许多人投了银行之类的，955轻轻松松，每天下班老婆孩子热炕头多舒服，我也想这样，就是钱可能少了点，家境贫寒的我还是想多挣点钱。再者自身技术还是不过关，也想做点有意义的工作，提升自己技术，同时为公司挣到了钱，这才是双赢。马上也面临转正了，虽然有其他几家保底了，但还是挺慌的，工作做的感觉零零散散，一直想总结总结沉淀一下，希望十月能给我带来好运吧。<br><img src="6.jpg" alt><br>感情上也是突出一个懒，单身久了看谁都眉清目秀，但也看谁都觉得不靠谱。越来越现实，考虑的不再是学校里简简单单的东西了，而是想着以后会怎样，这样一来很多都没法进行下去了。常说自信是最重要的，奖学金答辩时可自信了，吹牛一套一套的，但这时候却丧失了自信，逐渐卑微。很多道理都懂，也看过很多故事，但在自己身上，却不舍得花功夫。这一点这么些年还是没变，可能还是得等到工作安定了才能有心思冲一发吧，屡教不改，当年也是沉迷学习才落得如此下场。闲聊也越来越少了，事情过去没有人会记得你，他还是他，你还是你。<br><img src="7.jpg" alt><br>博客更新也越来越少了，粉丝涨得太慢了，进入了瓶颈期，主要还是自己懒，懒得营销。偶尔还是会挑些有意思的论文分享分享，但更多的是省点脑细胞，写写碎碎念多轻松。</p><p>2020最后一个假期结束了，明天又要开始社畜生活了，希望代码少点bug，运行顺利。其他的东西，我知道干等是等不到了，以后再说吧，有精力再冲。<br><img src="8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ACL2020】一种新颖的成分句法树序列化方法</title>
      <link href="/2020/08/30/acl20-yangwei-parsing/"/>
      <url>/2020/08/30/acl20-yangwei-parsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>论文作者：godweiyang，末流985研三，ACM退役蒻苣，爱好算法，目前在字节跳动AI Lab实习，业余喜欢PUBG和LOL。</p></blockquote><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/2020.acl-main.299/" title="论文地址" target="_blank" rel="noopener">A Span-based Linearization for Constituent Trees</a><br><strong>代码地址：</strong><a href="https://github.com/AntNLP/span-linearization-parser" title="代码地址" target="_blank" rel="noopener">https://github.com/AntNLP/span-linearization-parser</a><br><strong>PPT地址：</strong><a href="https://godweiyang.com/2020/08/30/acl20-yangwei-parsing/ACL2020.pdf" title="PPT地址">https://godweiyang.com/2020/08/30/acl20-yangwei-parsing/ACL2020.pdf</a>  </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉在字节跳动实习也快四个月了，在这高强度快节奏的工作生活中，也是收获颇多。然而博客也很久很久没更新过了，论文阅读了那么多，却一直没空写写自己中的这篇。今天趁周末分享一下自己发在今年ACL上的这篇工作，主要贡献就是提出了一种新颖的成分句法树的序列表示方法。建议配合我的PPT阅读，里面有很多例子。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>成分句法分析任务的目的就是解析出一个句子的短语结构树，详细的介绍都可以在我写的综述里找到：<a href="https://godweiyang.com/2019/08/15/con-parsing-summary-v2/" title="成分句法分析综述（第二版）">成分句法分析综述（第二版）</a>。</p><p>当前主流的成分句法分析方法我按照归一化目标主要分为两类：</p><ul><li>一是基于CKY的<strong>全局归一化</strong>方法，优化整棵句法树得分之和。也就是采用动态规划算法解析，时间复杂度较高（$O(n^3)$），但同时效果是目前SOTA的。</li><li>二是各种<strong>局部归一化</strong>方法，优化目标是单个目标得分（例如span、action、syntactic distance等等）。这一类方法具体包括基于shift-reduce的转移系统、各种序列化方法（例如syntactic distance）、基于CKY解码的局部归一化模型等，速度通常都很快，但由于局部归一化并没有考虑到全局特征，所以效果普遍较差。</li></ul><p>详细说两个以往的局部归一化方法吧。例如预测句法树的括号表达式，然后还原成句法树，这种方法效果非常差，因为很难解决括号匹配合法性的问题，模型很难学。再如syntactic distance，因为预测的是浮点数序列，所以约束太松了，只要求相对大小合适就行，可解释性也较差，没有和span紧密结合起来，因此最后效果也一般。最后转移系统也会存在exposure bias的问题，效果也不尽如人意，基本没人使用了。</p><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>回到主题，针对上面这么多问题，我想寻找一种更好的序列表示方法，如果能够和span更直接联系起来就最好了。其实这篇论文idea出来的初期，我是想用上GNN（GAT）的，那么就得有一张图，而传统的成分句法树不适合直接GNN建模，因为节点数不确定，图没法提前获得。因此我就联想到了我师兄去年发的一篇依存句法树应用GAT的工作：<a href="https://www.aclweb.org/anthology/P19-1237/" title="Graph-based Dependency Parsing with Graph Neural Networks" target="_blank" rel="noopener">Graph-based Dependency Parsing with Graph Neural Networks</a>。如果有一个办法能让成分句法树表示成依存树那样就好了！于是我这个idea就逐渐成型了，虽然最后并没有用上GNN。</p><h2 id="序列化方法"><a href="#序列化方法" class="headerlink" title="序列化方法"></a>序列化方法</h2><p>我原论文里面有很多公式和证明的部分，这里我就跳过了，其实方法的思想非常的简单。</p><p><img src="1.jpg" alt="序列化示例"></p><p>如上图所示，句法树原本可能不是二叉的，因此要先转成二叉树，然后这个二叉树在span表中（图c）绿色的部分就是所有的左孩子（包含根结点），红色的部分就是所有的右孩子。</p><p>然后可以轻易发现，所有左孩子的右边界一定不存在重复，因此一定一一对应了 $[1, n]$ 中的值，那么就可以把它们作为序列化后的下标，而相应的左边界就作为序列化后的值。举个例子，图中 $(1, 4)$ 这个span表示的是”loves writing code”这个短语，那么序列化数组$d$的下标4处的值就是 $d_4 = 1$。</p><p>同时可以发现，这个序列满足另一种定义，也就是 $(d_i, i)$ <strong>一定是以 $i$ 作为右边界的最大的span</strong>，这用反证法可以轻易证明。</p><p>最后就可以得到序列化后的数组 $d$，同时这个序列满足两个性质：</p><ul><li>一定满足 $d_i &lt; i$ ，因为 $(d_i, i)$ 是某个左孩子。</li><li>对于任意的 $j &gt; i$，$d_j$ 一定不会在 $(d_i, i)$ 范围里，否则的话 $(d_j, j)$ 就和 $(d_i, i)$产生交叉了。</li></ul><p>同时可以证明，满足如上两个条件的任意非负整数序列都可以唯一还原成一棵句法树。序列化和反序列化伪代码如下：</p><p><img src="2.jpg" alt="序列化和反序列化算法"></p><p>注意这里的反序列化有个前提假设：$d$ 一定要是满足上面两个条件的合法序列！至于不合法的怎么办？下面会详细讲。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型方面没有什么新意，借鉴了依存句法分析模型bi-affine attention。</p><p>输入是词向量、字向量、位置向量拼接：<br>$$<br>x_i = [e_i; c_i; p_i].<br>$$<br>然后用LSTM或者Transformer得到每个单词的隐层表示 $h_i$，为了区分span的左右边界表示，我采用了两套表示：<br>$$<br>l_i = \text{MLP}_l(h_i),\quad r_i = \text{MLP}_r(h_i).<br>$$<br>然后就可以用bi-affine attention计算两个边界的相关性了：<br>$$<br>\alpha_{ij} = l_i^\top {\bf W} r_j + b_1^\top l_i + b_2^\top r_j,<br>$$<br>接着对所有小于 $j$ 的attention做局部归一化，就得到了左边界为 $i$ 的概率：<br>$$<br>P(i|j) = \text{Softmax}_{i}(\alpha_{ij}), \forall i &lt; j.<br>$$<br>最后取概率最高的左边界作为预测的序列值：<br>$$<br>d_j = \mathop{\arg\max}_{i} {[P(i|j)]}, \forall i &lt; j.<br>$$<br>对于句法树的label，我没有直接用序列方法预测，而是先用序列 $d$ 反序列化得到句法结构，然后利用句法结构预测label，这样准确率会高很多：<br>$$<br>P(\ell|i, j) = \text{Softmax}(\text{MLP}_{\text{label}}([l_i; r_j]))_{\ell}.<br>$$<br>损失函数就是 $n$ 项结构损失加上 $2n-1$ 项label损失：<br>$$<br>\mathcal{L} = -\frac{1}{n} (\sum_{i = 1}^{n}{\log P(d_i | i)} + \sum_{(i, j, \ell) \in \mathcal{T}}{\log P(\ell|i, j)}).<br>$$</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>之前提到过，如果预测出来的序列是非法的怎么办呢？其实之前的两个条件，第一个条件可以通过mask的方式保证满足，一般第二个条件无法满足，也就是会出现交叉的span。</p><p>最优解是最小顶点覆盖问题，也就是对于预测出来的 $n$ 个左孩子，两两之间如果交叉了就连边，最后建了一张图。那么选取最少的点（非法span），使得它们的边涵盖了整张图，也就是修改它们使得序列合法。然而这是一个NP hard的问题，复杂度很高，因此我提出了几种近似求解的方法。</p><p>第一种方法是CKY解码，我们直接从 $P(i|j)$ 出发，不解码出序列 $d$ ，也就是直接解码出使得所有左孩子得分之和最高的序列：<br>$$<br>\mathcal{G}(i, j) = \max{\{P(i | k) \times \mathcal{G}(k, j) \mid i &lt; k &lt; j\}},<br>$$</p><p>这种方法时间复杂度是 $O(n^3)$ ，是精确解码，但是复杂度太高意义不大。</p><p>第二种方法是自顶向下解码，然后寻找 $(i, j)$ 的split时，将满足 $d_{k’} \leq i$ 且 $i &lt; k’ &lt; j$ 的所有 $k’$ 中最大的那个 $k’$ 作为split：<br>$$<br>k \gets \max{\{k’ \mid d_{k’} \le i, i &lt; k’ &lt; j\}}.<br>$$</p><p><img src="3.jpg" alt="方法二示例"></p><p>看上图例子可能更好理解一些。这是一种贪心解码，渐进时间复杂度是 $O(n \log n)$ ，实测最后效果和最优解码没有区别。</p><p>第三种方法和方法二类似，直接选取满足 $i &lt; k’ &lt; j$ 的最小的 $d_{k’}$ 就行了：<br>$$<br>k \gets \mathop{\arg\min}_{k’}[d_{k’}].<br>$$</p><p><img src="4.jpg" alt="方法三示例"></p><p>这个方法效果也完全一样，实现起来可能方便一丢丢。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>详细的实验对比结果感兴趣的直接去看论文吧，这里放一个总表：</p><p><img src="5.jpg" alt="PTB和CTB结果"></p><p>可以看出无论是单模型还是采用了BERT，我们的方法都达到了和SOTA完全一样的效果。那么速度怎么样呢？</p><p><img src="6.jpg" alt="速度对比"></p><p>可以看出我们速度远远快于CKY算法，甚至超过很多序列方法，并且我们没有采用Cython来优化for循环。</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p><img src="7.jpg" alt="归一化方法比较"></p><p>和全局归一化模型（CKY算法）相比，他们优化的是整棵句法树span得分之和，而我们优化的是所有的左孩子得分之和。因为我们认为，原来的优化目标是包含冗余的，左孩子得到之后，右孩子可以唯一确定。</p><p>和CKY算法的自顶向下贪心优化+张岳老师提出的两种局部模型结合相比，我认为我们的方法也是不同的。他们的方法会导致更加复杂的span表示，同一个span会被优化两次，因此需要更为复杂的表示来规避这个问题。同时我们的方法只需要矩阵运算来预测结构，span表示简单，速度也更快。</p><p>此外仍然有很多未完成的工作：</p><ul><li>利用我这个序列方法，GNN可以用上了。</li><li>如果用所有的右孩子，可以产生出另一套等价的序列表示，如何结合这两套表示来准确解码？</li><li>其他句法分析任务（CCG，semantic等）都可以转化为我的序列表示，如何联合学习这些任务？</li><li>利用这套表示，其他很多下游任务（机器翻译等）都可以加入句法信息，能否增强它们的性能？</li></ul><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>下一次分享不知道又会到什么时候了，秋招也进入尾声了，下面就是毕业论文了。如果有时间，我还会和大家分享我最近阅读的论文。有缘江湖再见！</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 成分句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NLP 算法岗】提前批暑期实习面（试）经（历）</title>
      <link href="/2020/04/26/summer-interview-experience/"/>
      <url>/2020/04/26/summer-interview-experience/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先申明，这是一份面试【经历】，而【不是】经验，所以基本上对大家没有什么帮助，看个乐子就好，最后结果是来了心心念念的字节啦。</p></blockquote><h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>某不知名末流 985 本硕，三无 FW ：无实习经历，无比赛经历，无项目经历。本科水过一段时间 ACM ，4 月份侥幸中了一篇 ACL ，方向很基础、很冷门，对下游任务最多只是了解。</p><p>这次一共面了 4 家，投递顺序是达摩院、头条 AI Lab、腾讯 WXG、美团 AI 平台。结果到发稿为止，美团最先出结果被我拒了，字节接受了 offer ，腾讯 HR 面结束一周多依然没结果，达摩院二面结束一周多依然没结果。</p><h2 id="达摩院"><a href="#达摩院" class="headerlink" title="达摩院"></a>达摩院</h2><h3 id="一面（4-6）"><a href="#一面（4-6）" class="headerlink" title="一面（4.6）"></a>一面（4.6）</h3><p>一面面试官是实验室师兄介绍认识的，第二天就直接打电话给我了，我还啥都没复习呢？？？</p><p>小哥哥刚毕业没两年吧，水平太太太高了，而且非常了解我这方向，问的广度和深度都很了得。从我论文工作出发，问到传统方法 PCFG、HMM，又问了许多经典论文 Neural CRF Parsing、RNNG、URNNG 等等，幸亏前一晚回顾了一下大致思想，还记得个大概。然后又拓展到强化学习、隐变量等等，幸亏组会也讲过，回顾了一些。</p><p>主要还是靠我师兄前一晚传授了这位面试师兄擅长的领域，针对性的看了些东西。所谓知己知彼，才能百战不殆嘛。最后聊了一个小时。</p><h3 id="二面（4-18）"><a href="#二面（4-18）" class="headerlink" title="二面（4.18）"></a>二面（4.18）</h3><p>不得不说达摩院速度真是太慢了，二面一直等到 12 天后才打来电话。</p><p>二面面试官就不是很懂我这个方向了，但是认真听完了我的论文介绍，因为不是很懂基础，所以我很详细的用例子给他解释了原理。过程中聊得挺开心的，我也基本没有压力（主要原因是美团已经拿到保底了，身上没啥压力）。除了论文以外，其他基础知识就没咋问了，就问了个序列标注咋做。然后就愉快的结束了，一共也聊了一个小时。</p><p>到现在（4.26）又过了 8 天了，还是没任何消息，还是我太菜了。</p><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><h3 id="笔试（4-9）"><a href="#笔试（4-9）" class="headerlink" title="笔试（4.9）"></a>笔试（4.9）</h3><p>美团提前批笔试还是挺简单的（相比之下前天帮学妹做的正式批笔试可真难），一共 5 道题，一个小时就做完了，没啥可说的。</p><h3 id="一面（4-16）"><a href="#一面（4-16）" class="headerlink" title="一面（4.16）"></a>一面（4.16）</h3><p>美团面试也挺放松的吧，主要去的意愿没有其他几家那么大。</p><p>小哥哥是做推荐的，不懂我的句法，我也不懂他的推荐，所以就没啥可聊的。我给他讲了一遍我的论文，他再随意问了两个 Transformer 和 LSTM 的基础细节问题，然后做了两道编程题，就直接结束了。一共也才 40 分钟吧。</p><h3 id="二面（4-16）"><a href="#二面（4-16）" class="headerlink" title="二面（4.16）"></a>二面（4.16）</h3><p>紧接着就直接是二面了，跟一面没啥区别，小哥哥还是做推荐的，还是相看两懵逼。讲了论文，做了两道算法题，然后他给我介绍了 10 分钟他们部门的业务方向，全程我都插不上话。</p><h3 id="HR-面（4-18）"><a href="#HR-面（4-18）" class="headerlink" title="HR 面（4.18）"></a>HR 面（4.18）</h3><p>就这样，HR 小哥直接就打电话给我了，啥也不问直接让我一周内给个回复去不去。</p><p>不过我最后还是拒掉了，讲道理小哥们态度都挺好的吧，也花了这么多时间面试我，挺惭愧的。</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面（4-9）"><a href="#一面（4-9）" class="headerlink" title="一面（4.9）"></a>一面（4.9）</h3><p>上来就给我整了 2 道算法题，都是 LeetCode Easy 难度，第一道题太紧张了还想了一会儿。第二道题嘴贱说了句做过，然后就给我加了一道水题。他会问你能否再优化，直到最优，幸亏都答出来了。</p><p>然后问了论文贡献点。Dependency Parsing是怎么做的？SOTA 是什么？强化学习了解吗？解释了一下策略梯度。Skip-Gram 知道吗？是怎么做的？传统方法 SVM、Boosting 了解吗？（不了解，然后就没问）</p><p>总体来说，除了最后一个传统方法直接说不了解之外，其他都答上来了。自打这开始，我连着复习（预习）了四五天的传统方法，知乎刷了个遍。</p><h3 id="二面（4-13）"><a href="#二面（4-13）" class="headerlink" title="二面（4.13）"></a>二面（4.13）</h3><p>面试官人在美国，手机信号很差听不清，面了 30 分钟就结束了。</p><p>上来先自我介绍，然后介绍了论文。然后对下一步工作有啥想法？最后介绍了他们部门主要做对话和推荐，可能用不上句法。</p><h3 id="HR-面（4-16）"><a href="#HR-面（4-16）" class="headerlink" title="HR 面（4.16）"></a>HR 面（4.16）</h3><p>腾讯 HR 姐姐问的特别特别细，当然问题我都提前网上看过了，就那么些套路。有没有谈恋爱啦，家住哪儿啦，为什么读 NLP 啦，以后想定居哪儿啦等等。聊了半个多小时愉快结束了。</p><p>到现在（4.26）过了 10 天了，还是没任何消息，说好的 5.1 前通知是否被录取呢？不过确实还没到时间哦？</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="一面（4-14）"><a href="#一面（4-14）" class="headerlink" title="一面（4.14）"></a>一面（4.14）</h3><p>一面是个小姐姐，上来先让我自我介绍，然后就是讲论文。因为她不是做这个的，给她讲了各种以往方法以及我的方法。最后做了一道算法题，太紧张了，当场没做出来，一面结束立刻想起来怎么做了，太难顶了。</p><h3 id="二面（4-14）"><a href="#二面（4-14）" class="headerlink" title="二面（4.14）"></a>二面（4.14）</h3><p>紧接着就是二面了。二面小哥哥一看就是个 ACM 大佬，上来先让我自我介绍。但是没讲论文，他应该很懂，直入主题，问我各种论文细节问题，太强了。</p><p>算法题环节，小哥哥先问了句“哟金牌啊”，我立刻感到不妙，是个大佬，赶紧回了句不不不邀请赛，太水了。然后给了两道题目，第一道很水，第二道没写出最优解，整了很久给了两种方法，但都不是最优的。还问我线段树细节，我赶紧回应许久不写了，早已生疏了，太强了，溜了溜了。</p><h3 id="三面（4-15）"><a href="#三面（4-15）" class="headerlink" title="三面（4.15）"></a>三面（4.15）</h3><p>别人都二面啊，咋就给我加了一面，给我慌的。</p><p>上来还是自我介绍。然后小哥哥是做机器翻译的，我说句法可以用注入到机器翻译模型中去。但是他对我这个方向不怎么看好，说句法信息用了效果不是很好。确实，我也表示非常赞同。然后聊了聊以后想做的方向，我是不会再做纯句法方向了，还是下游任务实际一点。最后问我有啥想问的，接着又整了一道算法题。</p><h3 id="HR-面（4-21）"><a href="#HR-面（4-21）" class="headerlink" title="HR 面（4.21）"></a>HR 面（4.21）</h3><p>之前联系的 HR 都是一位小哥哥，没想到视频一开换人了，是个超级好看的小姐姐。也没有什么套路，问了问实习计划之类的。问到租房问题时，我说学校到公司要 20 分钟，她当即反驳我要 25 分钟，我立马断定这小姐姐一定也是我校的（果不其然）。</p><p>最后一直等到今天（4.26），小姐姐终于给我打电话发 offer 啦。心情非常激动，终于不用提心吊胆了，找个实习太难了，菜还是原罪。</p><p>其实一开始只投了达摩院一家的，但是太慢了。后来我就只想去字节了，确实很喜欢它的氛围，那种年轻与活力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实在不好意思，浪费大家这么多时间，看完后应该啥有用的都没看到。和网上面经不大一样，没有考手推 SVM，没有考 Glove 算法，基本就没考什么基础知识。所以我开头就说了嘛，没啥参考价值，大家散了吧。</p><p>也祝大家论文发到手软，offer 吃到饱啦。</p><p>哦对了，以后可能很少更新 LeetCode 题解了，实习了更没空了，也写的累了。如果大家平时做题过程中遇到什么困难，还是可以找我交流啦！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进字节一年了，分享一下当初刷的一百多篇算法题解</title>
      <link href="/2020/04/24/leetcode-conclusions-110/"/>
      <url>/2020/04/24/leetcode-conclusions-110/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写算法题解也有 110 天了，今天就简单给题目归归类吧。</p><p>其实不是很想归类的，主要是有些题目类别太杂，或者多解，或者甚至根本看不出叫啥类别。</p><p>因为题目实在太多，所以就不放链接了，只放了标题，大家可以 <strong>收藏这篇文章，然后去各大平台（博客、公众号、知乎、CSDN、腾讯云社区）或者搜索引擎直接搜索标题</strong> 就行了</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li>【每日算法Day 78】面试经典题：能说出全部四种方法，不录用你都不可能！</li><li>【每日算法Day 92】经典面试题：编辑距离</li><li>每日算法系列【LeetCode 115】不同的子序列</li><li>每日算法系列【LeetCode 124】二叉树中的最大路径和</li><li>【每日算法Day 65】你能顺利救出地下城里的公主吗？</li><li>每日算法系列【LeetCode 188】买卖股票的最佳时机 IV</li><li>【每日算法Day 104】偷电瓶的周某今天放出来了，还不赶紧做这道题防范一下！</li><li>【每日算法Day 105】打家劫舍第二弹：看好你的电瓶车！</li><li>每日算法系列【LeetCode 233】数字 1 的个数</li><li>每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期</li><li>每日算法系列【LeetCode 312】戳气球</li><li>【每日算法Day 106】打家劫舍系列最后一弹，撑住你就赢了！</li><li>每日算法系列【LeetCode 354】俄罗斯套娃信封问题</li><li>每日算法系列【LeetCode 376】摆动序列</li><li>【每日算法Day 85】图解算法：一行代码解决约瑟夫环的变体</li><li>每日算法系列【LeetCode 689】三个无重叠子数组的最大和</li><li>每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费</li><li>每日算法系列【LeetCode 907】子数组的最小值之和</li><li>每日算法系列【LeetCode 943】最短超级串</li><li>每日算法系列【LeetCode 1031】两个非重叠子数组的最大和</li><li>每日算法系列【LeetCode 1039】多边形三角剖分的最低得分</li><li>每日算法系列【LeetCode 1186】删除一次得到子数组最大和</li><li>一个函数解决【LeetCode 买卖股票的最佳时机】系列所有题目！</li><li>【每日算法Day 109】五大解法，带你深入了解完全背包方案数</li><li>【每日算法Day 98】慈善赌神godweiyang教你算骰子点数概率！</li><li>【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！</li><li>【每日算法Day 79】所有人都会做的入门题，但是能看出你的代码能力！</li><li>【每日算法Day 86】面试经典题：把数字翻译成字符串</li><li>【每日算法Day 95】美团笔试题：四面体方案个数</li></ul><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><ul><li>【每日算法Day 78】面试经典题：能说出全部四种方法，不录用你都不可能！</li><li>每日算法系列【LeetCode 121】买卖股票的最佳时机</li><li>每日算法系列【LeetCode 122】买卖股票的最佳时机 II</li><li>每日算法系列【LeetCode 123】买卖股票的最佳时机 III</li><li>每日算法系列【LeetCode 42】接雨水</li><li>【每日算法Day 69】面试经典题：分发糖果问题</li><li>【每日算法Day 91】求解数组中出现次数超过1/3的那个数</li><li>每日算法系列【LeetCode 330】按要求补齐数组</li><li>每日算法系列【LeetCode 376】摆动序列</li><li>每日算法系列【LeetCode 495】提莫攻击</li><li>每日算法系列【LeetCode 556】下一个更大元素 III</li><li>【每日算法Day 64】LeetCode 861. 翻转矩阵后的得分</li><li>每日算法系列【LeetCode 926】将字符串翻转到单调递增</li><li>每日算法系列【LeetCode 927】三等分</li><li>每日算法系列【LeetCode 1053】交换一次的先前排列</li><li>【每日算法Day 87】今天我脱单了，所以大家不用做题了！</li><li>【每日算法Day 88】超越妹妹教你如何做这道排序题</li><li>每日算法系列【kentln供题】模糊的数字</li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li>【每日算法Day 67】经典面试题：手动开根号，你知道几种方法？</li><li>每日算法系列【LeetCode 233】数字 1 的个数</li><li>每日算法系列【LeetCode 319】灯泡开关</li><li>每日算法系列【LeetCode 357】计算各个位数不同的数字个数</li><li>每日算法系列【LeetCode 470】用 Rand7() 实现 Rand10()</li><li>每日算法系列【LeetCode 523】连续的子数组和</li><li>【每日算法Day 61】LeetCode 672. 灯泡开关 Ⅱ</li><li>每日算法系列【LeetCode 829】连续整数求和</li><li>每日算法系列【LeetCode 1006】笨阶乘</li><li>【每日算法Day 68】脑筋急转弯：只要一行代码，但你会证吗？</li><li>每日算法系列【LeetCode 1250】检查「好数组」</li><li>每日算法系列【LeetCode 1363】形成三的最大倍数</li><li>【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</li><li>【每日算法Day 98】慈善赌神godweiyang教你算骰子点数概率！</li><li>【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！</li><li>【每日算法Day 80】所有人都会做的入门题，高级解法来了！</li><li>【每日算法Day 81】面试经典题：关于丑数，你真的理解为什么这么算吗？</li></ul><h2 id="双指针（滑动窗口）"><a href="#双指针（滑动窗口）" class="headerlink" title="双指针（滑动窗口）"></a>双指针（滑动窗口）</h2><ul><li>每日算法系列【LeetCode 16】最接近的三数之和</li><li>每日算法系列【LeetCode 42】接雨水</li><li>【每日算法Day 96】腾讯面试题：合并两个有序数组</li><li>每日算法系列【LeetCode 287】寻找重复数</li><li>每日算法系列【LeetCode 328】奇偶链表</li><li>每日算法系列【LeetCode 658】找到 K 个最接近的元素</li><li>每日算法系列【LeetCode 881】救生艇</li><li>每日算法系列【LeetCode 992】K个不同整数的子数组</li><li>每日算法系列【LeetCode 1004】最大连续1的个数 III</li><li>【每日算法Day 107】面试必考：良心推荐，一题三解，不看后悔一辈子</li><li>【每日算法Day 97】经典面试题：求两个数组最小差</li><li>【每日算法Day 81】面试经典题：关于丑数，你真的理解为什么这么算吗？</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><ul><li>【每日算法Day 75】字节跳动面试题：手撕困难题，看过我Day 71的人都会做了！</li><li>每日算法系列【LeetCode 128】最长连续序列</li><li>每日算法系列【LeetCode 825】适龄的朋友</li><li>【每日算法Day 103】老题新做，几乎不会有人想到的解法，它来了</li><li>【每日算法Day 99】你们可能不知道只用20万赢到578万是什么概念</li><li>每日算法系列【LeetCode 992】K个不同整数的子数组</li><li>【每日算法Day 107】面试必考：良心推荐，一题三解，不看后悔一辈子</li><li>每日算法系列【LeetCode 面试题 17.05】字母与数字</li><li>【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</li><li>【每日算法Day 90】5种方法：求解数组中出现次数超过一半的那个数</li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><ul><li>每日算法系列【LeetCode 153】寻找旋转排序数组中的最小值</li><li>每日算法系列【LeetCode 287】寻找重复数</li><li>每日算法系列【LeetCode 556】下一个更大元素 III</li><li>每日算法系列【LeetCode 658】找到 K 个最接近的元素</li><li>【每日算法Day 83】邻居小孩一年级就会的乘法表，你会吗？</li><li>每日算法系列【LeetCode 719】找出第 k 小的距离对</li><li>每日算法系列【LeetCode 825】适龄的朋友</li><li>每日算法系列【LeetCode 875】爱吃香蕉的珂珂</li></ul><h2 id="单调栈（队列）"><a href="#单调栈（队列）" class="headerlink" title="单调栈（队列）"></a>单调栈（队列）</h2><ul><li>每日算法系列【LeetCode 42】接雨水</li><li>【每日算法Day 69】面试经典题：分发糖果问题</li><li>每日算法系列【LeetCode 239】滑动窗口最大值</li><li>每日算法系列【LeetCode 503】下一个更大元素 II</li><li>每日算法系列【LeetCode 907】子数组的最小值之和</li></ul><h2 id="DFS（BFS）"><a href="#DFS（BFS）" class="headerlink" title="DFS（BFS）"></a>DFS（BFS）</h2><ul><li>每日算法系列【LeetCode 115】不同的子序列</li><li>【每日算法Day 108】一道简单的二叉树题目，写法还是挺多的。</li><li>每日算法系列【LeetCode 312】戳气球</li><li>每日算法系列【LeetCode 329】矩阵中的最长递增路径</li><li>【每日算法Day 62】LeetCode 815. 公交路线</li><li>每日算法系列【LeetCode 827】最大人工岛</li><li>【每日算法Day 70】图解算法：小学生都会的数块数问题，你会吗？</li><li>【每日算法Day 94】经典面试题：机器人的运动范围</li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li>【每日算法Day 72】谷歌面试题：又双叒叕是位运算，最详细的自动机推导过程</li><li>【每日算法Day 61】LeetCode 672. 灯泡开关 Ⅱ</li><li>每日算法系列【LeetCode 810】黑板异或游戏</li><li>【每日算法Day 64】LeetCode 861. 翻转矩阵后的得分</li><li>【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</li><li>【每日算法Day 66】经典面试题：不用四则运算如何做加法？</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>【每日算法Day 89】手动实现字符串转整数（atoi）函数，你会吗？</li><li>【每日算法Day 84】面试必考题：Trie（字典树/前缀树）的实现</li><li>每日算法系列【LeetCode 386】字典序排数</li><li>每日算法系列【LeetCode 926】将字符串翻转到单调递增</li><li>每日算法系列【LeetCode 943】最短超级串</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul><li>【每日算法Day 73】学妹大半夜私聊我有空吗，然后竟然做出这种事！</li><li>每日算法系列【LeetCode 124】二叉树中的最大路径和</li><li>【每日算法Day 108】一道简单的二叉树题目，写法还是挺多的。</li><li>【每日算法Day 106】打家劫舍系列最后一弹，撑住你就赢了！</li><li>【每日算法Day 76】经典面试题：中序遍历的下一个元素，5大解法汇总！</li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul><li>每日算法系列【LeetCode 128】最长连续序列</li><li>每日算法系列【LeetCode 684】冗余连接</li><li>每日算法系列【LeetCode 685】冗余连接 II</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>【每日算法Day 82】面试经典题：求第K大数，我写了11种实现，不来看看吗？</li><li>【每日算法Day 84】面试必考题：Trie（字典树/前缀树）的实现</li><li>每日算法系列【LeetCode 315】计算右侧小于当前元素的个数</li><li>每日算法系列【LeetCode 386】字典序排数</li></ul><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><ul><li>每日算法系列【LeetCode 289】生命游戏</li><li>每日算法系列【LeetCode 810】黑板异或游戏</li><li>【每日算法Day 103】老题新做，几乎不会有人想到的解法，它来了</li><li>每日算法系列【LeetCode 1006】笨阶乘</li><li>【每日算法Day 93】不用额外空间，你会旋转一个矩阵吗？</li><li>每日算法系列【LeetCode 328】奇偶链表</li><li>每日算法系列【EOJ 3031】二进制倒置</li></ul><h2 id="合集"><a href="#合集" class="headerlink" title="合集"></a>合集</h2><ul><li>【每日算法Day 63】LeetCode 第 179 场周赛题解</li><li>【每日算法Day 77】LeetCode 第 181 场周赛题解</li><li>一个函数解决【LeetCode 买卖股票的最佳时机】系列所有题目！</li><li>【每日算法Day 102】美团 AI 平台算法工程师面试编程题</li><li>十大经典排序算法整理汇总（附代码）</li><li>【每日算法Day 101】字节跳动 AI Lab 精选面试编程题</li><li>【每日算法Day 100】字节跳动 AI Lab 面试编程题（三道）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 109】五大解法，带你深入了解完全背包方案数</title>
      <link href="/2020/04/23/leetcode-interview-08-11/"/>
      <url>/2020/04/23/leetcode-interview-08-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天这题是完全背包问题 + 背包问题方案数，我一共列举了 5 种解法，层层递进优化。并且从两个角度殊途同归，最终优化到同一个式子。强烈建议掌握，对理解背包问题有很大帮助。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/coin-lcci/" title="LeetCode 面试题 08.11. 硬币" target="_blank" rel="noopener">LeetCode 面试题 08.11. 硬币</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数量不限的硬币，币值为 <code>25</code> 分、<code>10</code> 分、<code>5</code> 分和 <code>1</code> 分，编写代码计算 <code>n</code> 分有几种表示法。(结果可能会很大，你需要将结果模上 <code>1000000007</code>)</p><p><strong>说明：</strong>  </p><ul><li><code>0 &lt;= n (总金额) &lt;= 1000000</code></li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 5输出:2解释：有两种方式可以凑成总金额:5=55=1+1+1+1+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 10输出:4解释：有四种方式可以凑成总金额:10=1010=5+510=5+1+1+1+1+110=1+1+1+1+1+1+1+1+1+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们规定一些记号，用 $p[i]$ 来表示第 $i$ 种硬币的面值，用 $dp[i][j]$ 表示用前 $i$ 种硬币组成面值 $j$ 的方案数。令 $n$ 表示需要表示的面值，$m$ 表示硬币数。</p><h3 id="朴素想法（错误）"><a href="#朴素想法（错误）" class="headerlink" title="朴素想法（错误）"></a>朴素想法（错误）</h3><p>首先我们可以想到，最朴素的方法不就是<strong>组成面值 $j$ 的方案数等于所有组成面值 $j-p[k]$ 的方案数之和</strong>：<br>$$<br>dp[i][j] = \sum_{k=0}^{i}{dp[i][j-p[k]]}<br>$$</p><p>但是这样有个很严重的问题，就是会产生重复计算，也就是将 <code>6 = 1 + 5</code> 和 <code>6 = 5 + 1</code> 视为两种情况。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划 1"></a>动态规划 1</h3><p>朴素想法的纠正方法就是，<strong>规定拆解后的数字是有序的</strong>，这样就不会出现重复计算了。</p><p>那么具体怎么实现呢？其实只需要加上一个约束，也就是强制令 $p[k]$ 为组成面值 $j$ 的最大面值硬币。那么用掉它之后，组成面值 $j-p[k]$ 的最大面值硬币仍然只能是 $p[k]$ ，这样转移下去就一定是有序的，不会出现面值突然增大的情况。转移方程只需要修改一下转移后的可用硬币 $i$：<br>$$<br>dp[i][j] = \sum_{k=0}^{i}{dp[k][j-p[k]]}<br>$$</p><p>时间复杂度 $O(nm^2)$ ，空间复杂度 $O(nm)$ 。</p><h3 id="动态规划-2（超时）"><a href="#动态规划-2（超时）" class="headerlink" title="动态规划 2（超时）"></a>动态规划 2（超时）</h3><p>另一条思考路线是，我们<strong>假设第 $i$ 个硬币用 $k$ 枚，然后枚举所有的 $k$</strong> 就行了。转移方程很好写：<br>$$<br>dp[i][j] = \sum_{k=0}^{\lfloor j/p[i] \rfloor}{dp[i-1][j-k \cdot p[i]]}<br>$$</p><p>但是这样时间复杂度太高了，直接超时。</p><p>时间复杂度 $O(n^2m)$ ，空间复杂度 $O(nm)$ 。</p><h3 id="转移方程优化"><a href="#转移方程优化" class="headerlink" title="转移方程优化"></a>转移方程优化</h3><blockquote><p>神奇的地方来了，上面两种方法，全部可以优化为同一个式子，仔细看好了。</p></blockquote><p><strong>动态规划 1：</strong>  </p><p>首先看第一个方法，转移方程为：<br>$$<br>dp[i][j] = \sum_{k=0}^{i}{dp[k][j-p[k]]}<br>$$<br>我们令 $i = i - 1$ ，又可以得到：<br>$$<br>dp[i-1][j] = \sum_{k=0}^{i-1}{dp[k][j-p[k]]}<br>$$<br>两式左右两边相减可以得到：<br>$$<br>dp[i][j] = dp[i-1][j] + dp[i][j-p[i]]<br>$$</p><p><strong>动态规划 2：</strong>  </p><p>再看第二个方法，转移方程为：<br>$$<br>dp[i][j] = \sum_{k=0}^{\lfloor j/p[i] \rfloor}{dp[i-1][j-k \cdot p[i]]}<br>$$<br>令 $j = j - p[i]$ ，又可以得到：<br>$$<br>dp[i][j-p[i]] = \sum_{k=1}^{\lfloor j/p[i] \rfloor}{dp[i-1][j-k \cdot p[i]]}<br>$$<br>两式左右两边相减可以得到：<br>$$<br>dp[i][j] = dp[i-1][j] + dp[i][j-p[i]]<br>$$</p><p><strong>最终形式：</strong>  </p><p>所以，最终<strong>两个方法消去求和之后，形式是一样的！</strong>都是：<br>$$<br>dp[i][j] = dp[i-1][j] + dp[i][j-p[i]]<br>$$</p><p>时间复杂度 $O(nm)$ ，空间复杂度 $O(nm)$ 。</p><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>注意到，上面转移方程每个时刻 $i$ 其实只和 $i-1$ 还有 $i$ 时刻有关，所以可以把第一个维度消除掉。这样转移方程就变为了：<br>$$<br>dp[j] = dp[j] + dp[j-p[i]]<br>$$<br>但是需要特别注意的是，这里一共有三项，分别表示的是第 $i$ 时刻、第 $i-1$ 时刻、第 $i$ 时刻。所以在两层循环遍历的时候，<strong>第一层循环必须是遍历硬币 $i$ ，第二层才是遍历组成的面值 $j$ ，这样才不会导致第 $i-1$ 时刻的值被覆盖掉无法访问。</strong></p><p>时间复杂度 $O(nm)$ ，空间复杂度 $O(n)$ 。</p><h3 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h3><p>这个方法就只针对本题硬币种类比较少的情况了。</p><p>假设组成面值 $n$ 需要 $i$ 枚 <code>25</code> 分， $a$ 枚 <code>10</code> 分， $b$ 枚 <code>5</code> 分， $c$ 枚 <code>1</code> 分，那么有：<br>$$<br>n = 25i + 10a + 5b + c<br>$$<br>这里 $i$ 我们是需要枚举的，范围是 $[0, \lfloor n/25 \rfloor]$ ，所以我们令 $r = n - 25i$，那么就得到了：<br>$$<br>r = 10a + 5b + c<br>$$<br>那么 $a$ 的范围是 $[0, \lfloor r/10 \rfloor]$ 。而 $a$ 确定了之后， $b$ 的范围就是 $[0, \lfloor (r-10a)/5 \rfloor]$ 。而 $a, b$ 都确定了之后， $c$ 是唯一确定了的。所以最终的方案数就是：<br>$$<br>\begin{aligned}<br>\sum_{a=0}^{\lfloor r/10 \rfloor}{\sum_{b=0}^{\lfloor (r-10a)/5 \rfloor}{1}} &amp;= \sum_{a=0}^{\lfloor r/10 \rfloor}{(\lfloor (r-10a)/5 \rfloor + 1)}\\<br>&amp;= \sum_{a=0}^{\lfloor r/10 \rfloor}{(\lfloor r/5 \rfloor -2a + 1)}\\<br>&amp;= (\lfloor r/10 \rfloor + 1)(\lfloor r/5 \rfloor + 1) - (\lfloor r/10 \rfloor + 1)\lfloor r/10 \rfloor \\<br>&amp; =(\lfloor r/10 \rfloor + 1)(\lfloor r/5 \rfloor - \lfloor r/10 \rfloor + 1)<br>\end{aligned}<br>$$</p><p>所以最终我们遍历 $i \in [0, \lfloor n/25 \rfloor]$，然后令 $r = n - 25i$。接着令 $x = \lfloor r/10 \rfloor$，$y = \lfloor r/5 \rfloor$，最后对 $(x+1)(y-x+1)$ 进行累加就行了：<br>$$<br>\sum_{i=0}^{\lfloor n/25 \rfloor}{(x+1)(y-x+1)}<br>$$</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划-1（c-）"><a href="#动态规划-1（c-）" class="headerlink" title="动态规划 1（c++）"></a>动态规划 1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> ll mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    ll dp<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>p<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> mod<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-2（超时）（c-）"><a href="#动态规划-2（超时）（c-）" class="headerlink" title="动态规划 2（超时）（c++）"></a>动态规划 2（超时）（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> ll mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    ll dp<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">/</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token operator">/</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>k<span class="token operator">*</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> mod<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="转移方程优化（c-）"><a href="#转移方程优化（c-）" class="headerlink" title="转移方程优化（c++）"></a>转移方程优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> ll mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    ll dp<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">/</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> mod<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空间优化（c-）"><a href="#空间优化（c-）" class="headerlink" title="空间优化（c++）"></a>空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> ll mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    ll dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> mod<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学法（c-）"><a href="#数学法（c-）" class="headerlink" title="数学法（c++）"></a>数学法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> ll mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">waysToChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ll res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">/</span><span class="token number">25</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ll r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">25</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>            ll x <span class="token operator">=</span> r <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">,</span> y <span class="token operator">=</span> r <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span>res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>y <span class="token operator">-</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> mod<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 108】一道简单的二叉树题目，写法还是挺多的。</title>
      <link href="/2020/04/22/leetcode-199/"/>
      <url>/2020/04/22/leetcode-199/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" title="LeetCode 199. 二叉树的右视图" target="_blank" rel="noopener">LeetCode 199. 二叉树的右视图</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,null,5,null,4]输出:[1,3,4]解释：   1            <--- /   \2     3         <--- \     \  5     4       <---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p>dfs 的思路就是直接递归求解左右子树各自能看到的右视图是什么，然后判断两个视图长度。</p><p>如果右子树右视图长度大于等于左子树右视图长度，那左子树完全被挡住。不用管左子树了，直接返回根结点加上右子树右视图就行了。</p><p>否则的话，左子树中超出右子树深度的部分不会被挡住，也会被看到，所以得拼接在右子树右视图后面。</p><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>bfs 的思路就是层次遍历了。对二叉树的每一层，只取最后一个结点就行了。</p><p>bfs 的话就得用一个队列来维护结点值了，那么怎么知道哪些结点是同一层的呢？最初的想法是用一个 <code>pair</code> 再保存一个深度值，但是这样有点多余了。</p><p>我们只需要每次队列中只保存同一层的结点，然后记录下队列大小。然后依次出队，直到出队个数达到之前记录的大小。并且同时将所有的下一层结点入队。这样就能保证这一层的结点全部出队之后，队列中只剩下了下一层的结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="dfs（c-）"><a href="#dfs（c-）" class="headerlink" title="dfs（c++）"></a>dfs（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> left <span class="token operator">=</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> right <span class="token operator">=</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token punctuation">{</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> right<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> right<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> left<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bfs（c-）"><a href="#bfs（c-）" class="headerlink" title="bfs（c++）"></a>bfs（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>sz<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sz<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 107】面试必考：良心推荐，一题三解，不看后悔一辈子</title>
      <link href="/2020/04/21/leetcode-1248/"/>
      <url>/2020/04/21/leetcode-1248/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可能有些同学只会写 <code>python</code> ，看不懂 <code>c++</code>。但是一个是因为我懒，多解时不想再写一遍 <code>python</code> 了，一个是理解算法最重要，语言不重要。今天学妹发来一张图，我觉得说的很好。</p></blockquote><p><img src="1.jpg" alt="院长大大如是说"></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" title="LeetCode 1248. 统计「优美子数组」" target="_blank" rel="noopener">LeetCode 1248. 统计「优美子数组」</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p><p>如果某个<strong>连续</strong>子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「优美子数组」。</p><p>请返回这个数组中「优美子数组」的数目。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,1,2,1,1], k = 3输出:2解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [2,4,6], k = 1输出:0解释：数列中不包含任何奇数，所以不存在优美子数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2输出:16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>为了方便表示，我们下面统一将奇数变为 <code>1</code> ，偶数变为 <code>0</code> ，不难发现这是等价于原来题意的。</strong></p><h3 id="统计奇数位置"><a href="#统计奇数位置" class="headerlink" title="统计奇数位置"></a>统计奇数位置</h3><p>我们发现，如果两个 <code>1</code> 之间（包含自身）一共包含了 <code>k</code> 个 <code>1</code> ，那么这 <code>k</code> 个 <code>1</code> 可以构成的连续子数组个数就是 <strong>左边 <code>0</code> 的个数加一</strong> 乘上 <strong>右边 <code>0</code> 的个数加一</strong>。</p><p>那么如何统计每个 <code>1</code> 前后 <code>0</code> 的个数呢？其实只需要记录一下每个 <code>1</code> 的位置，然后直接用相邻两个 <code>1</code> 的位置相减就可以得到中间 <code>0</code> 的个数加一了。</p><p>所以直接记录每个 <code>1</code> 的位置，为了处理边界，我们还需要在最开始添加上虚拟位置 <code>-1</code> ，在最后添加虚拟位置 <code>n</code> 。</p><p>然后对于第 $i$ 个 <code>1</code> 来说，如果将它作为子数组第一个 <code>1</code> ，那么最后一个 <code>1</code> 应该是第 $i+k-1$ 个 <code>1</code> 。所以直接计算两边 <code>0</code> 的数量，再加一相乘就行了：<br>$$<br>(pos[i] - pos[i-1])\cdot(pos[i+k] - pos[i+k-1])<br>$$</p><p>最后遍历所有的 <code>i</code> ，将第 $i$ 个 <code>1</code> 作为起点，然后累加答案就行了。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>主要思想还是跟上面方法一样，但是不用直接计算 <strong>左边 <code>0</code> 的个数加一</strong> 乘上 <strong>右边 <code>0</code> 的个数加一</strong>。只需要计算 <strong>左边 <code>0</code> 的个数加一</strong> ，然后右指针如果指着 <code>0</code> ，就加上这个值，一直加到右指针为 <code>1</code> 为止。</p><p>所以只需要用常数个变量就行了，<code>even</code> 记录子数组前面有多少个 <code>0</code> ，<code>cnt</code> 记录当前子数组有多少个 <code>1</code> 。用 <code>l</code> 指向子数组开头，<code>r</code> 指向子数组结尾。</p><p>如果 <code>cnt = k</code> ，那就说明子数组中正好有 <code>k</code> 个 <code>1</code> 。那就右移 <code>l</code> ，直到遇到 <code>1</code> 为止，这样就能统计出左边有多少个 <code>0</code> ，记录在 <code>even</code> 中。然后 <code>l</code> 右移跳过这个 <code>1</code> ，同时 <code>cnt</code> 减一。</p><p>如果 <code>cnt &lt; k</code> ，那就说明 <code>1</code> 的数量不够，<code>r</code> 继续右移就行了。同时每移动一次，答案都要加上 <code>even</code> 值，因为你之前 <code>cnt = k</code> 时记录了一下左边 <code>0</code> 的数量，现在右边每一个 <code>0</code> 都得加上它。其实除了初始阶段，其余时候 <code>cnt</code> 都是等于 <code>k-1</code> 的。而初始阶段 <code>even = 0</code> ，所以加上也没事，可以合并写。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>遍历原数组中每个位置 $i$，如果 $i$ 之前（包含自身） <code>1</code> 的个数一共 <code>odd</code> 个（也就是前缀和），那么我们只需要看有多少个位置 $j &lt; i$ 满足 <code>1</code> 的前缀和等于 <code>odd-k</code> ，那么 $[j+1, i]$ 就是正好包含 <code>k</code> 个 <code>1</code> 的子数组。</p><p>所以我们只需要用一个计数数组来记录一下前缀和对应的出现次数就行了，然后每次取出 <code>odd-k</code> 的次数加到答案里就行了。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="统计奇数位置（c-）"><a href="#统计奇数位置（c-）" class="headerlink" title="统计奇数位置（c++）"></a>统计奇数位置（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pos<span class="token punctuation">;</span>        pos<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> pos<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pos<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> pos<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">+</span>k <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>pos<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> pos<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>pos<span class="token punctuation">[</span>i<span class="token operator">+</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> pos<span class="token punctuation">[</span>i<span class="token operator">+</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双指针（c-）"><a href="#双指针（c-）" class="headerlink" title="双指针（c++）"></a>双指针（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> even <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> k <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                even <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> even<span class="token operator">++</span><span class="token punctuation">;</span>                cnt<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">+</span><span class="token operator">=</span> even<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="前缀和（c-）"><a href="#前缀和（c-）" class="headerlink" title="前缀和（c++）"></a>前缀和（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numberOfSubarrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> odd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            odd <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>odd <span class="token operator">>=</span> k<span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>odd<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token punctuation">[</span>odd<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 106】打家劫舍系列最后一弹，撑住你就赢了！</title>
      <link href="/2020/04/20/leetcode-337/"/>
      <url>/2020/04/20/leetcode-337/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/house-robber-iii/" title="LeetCode 337. 打家劫舍 III" target="_blank" rel="noopener">LeetCode 337. 打家劫舍 III</a></p><p><strong>往期回顾：打家劫舍 I ：</strong><br><a href="https://godweiyang.com/2020/04/18/leetcode-198/" title="【每日算法Day 104】偷电瓶的周某今天放出来了，还不赶紧做这道题防范一下！">【每日算法Day 104】偷电瓶的周某今天放出来了，还不赶紧做这道题防范一下！</a></p><p><strong>往期回顾：打家劫舍 II ：</strong><br><a href="https://godweiyang.com/2020/04/19/leetcode-213/" title="【每日算法Day 105】打家劫舍第二弹：看好你的电瓶车！">【每日算法Day 105】打家劫舍第二弹：看好你的电瓶车！</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<strong>根</strong>。 除了<strong>根</strong>之外，每栋房子有且只有一个<strong>父</strong>房子与之相连。一番侦察之后，聪明的小偷意识到<strong>这个地方的所有房屋的排列类似于一棵二叉树</strong>。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,3,null,3,null,1]     3    / \   2   3    \   \      3   1输出:7解释：小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,4,5,1,3,null,1]     3    / \   4   5  / \   \  1   3   1输出:9解释：小偷一晚能够盗取的最高金额 = 4 + 5 = 9.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这次是在一棵树上偷窃了，做法还是一样。对于结点 <code>r</code> 来说，我们还是分为偷和不偷两种情况。</p><p>如果偷的话，它的左右儿子就不能偷了，所以最大价值就是左儿子<strong>不偷</strong>的最大价值，加上右儿子<strong>不偷</strong>的最大价值，再加上 <code>r</code> 的价值。</p><p>而如果不偷的话，最大价值就是左儿子<strong>偷或不偷</strong>的最大价值，加上右儿子<strong>偷或不偷</strong>的最大价值。</p><p>因为需要用到儿子结点偷和不偷两个价值，所以需要在 <code>dfs</code> 时返回两个值，用来表示偷和不偷两个最大价值，具体实现时用 <code>pair</code> 来表示。</p><p>可能有人会用另一种实现方式，用 <code>dfs0</code> 表示不偷的最大价值，<code>dfs1</code> 表示偷的最大价值，然后两个函数互相调用。注意这样理论上是可行的，但是会产生很多重复计算，最终会超时。所以这种方法需要记忆化搜索，比较麻烦，需要用 <code>map&lt;TreeNode*, int&gt;</code> 来保存每个结点的答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="复杂实现方式（c-）"><a href="#复杂实现方式（c-）" class="headerlink" title="复杂实现方式（c++）"></a>复杂实现方式（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dp0<span class="token punctuation">,</span> dp1<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">dfs0</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp0<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> dp0<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp0<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dfs0</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">dfs1</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dfs0</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">dfs1</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp0<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs1</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">!=</span> dp1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp1<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs0</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs0</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp1<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp0<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dfs0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">dfs1</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="精简实现方式（c-）"><a href="#精简实现方式（c-）" class="headerlink" title="精简实现方式（c++）"></a>精简实现方式（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> pii<span class="token punctuation">;</span>    pii <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        pii l <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        pii r <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r0 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>first<span class="token punctuation">,</span> l<span class="token punctuation">.</span>second<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>first<span class="token punctuation">,</span> r<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r1 <span class="token operator">=</span> l<span class="token punctuation">.</span>first <span class="token operator">+</span> r<span class="token punctuation">.</span>first <span class="token operator">+</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>r0<span class="token punctuation">,</span> r1<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pii res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>first<span class="token punctuation">,</span> res<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 105】打家劫舍第二弹：看好你的电瓶车！</title>
      <link href="/2020/04/19/leetcode-213/"/>
      <url>/2020/04/19/leetcode-213/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" title="LeetCode 213. 打家劫舍 II" target="_blank" rel="noopener">LeetCode 213. 打家劫舍 II</a></p><p><strong>往期回顾：打家劫舍 I ：</strong><br><a href="https://godweiyang.com/2020/04/18/leetcode-198/" title="【每日算法Day 104】偷电瓶的周某今天放出来了，还不赶紧做这道题防范一下！">【每日算法Day 104】偷电瓶的周某今天放出来了，还不赶紧做这道题防范一下！</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,3,2]输出:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,1]输出:4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题和上一题唯一区别就是首尾只能选一个偷，那么我们可以分为两种情况。</p><p>如果不偷第一个，那么问题就变成了在后 $n-1$ 个里面偷取的最大价值。</p><p>如果不偷最后一个，那么问题就变成了在前 $n-1$ 个里面偷取的最大价值。</p><p>而这两个转化后的问题就没有首尾连接的约束了，可以直接采用上一题的解法求解，转移方程还是：<br>$$<br>dp[i] = \max{\{dp[i-1], dp[i-2]+p[i]\}}<br>$$</p><p>最终取两种情况的较大值就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> prepre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            now <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> prepre<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prepre <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> now<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">rob1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">rob1</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 104】偷电瓶的周某今天放出来了，还不赶紧做这道题防范一下！</title>
      <link href="/2020/04/18/leetcode-198/"/>
      <url>/2020/04/18/leetcode-198/</url>
      
        <content type="html"><![CDATA[<blockquote><p>偷电瓶的周某今天（2020.04.18）出来啦，打工是不可能打工的，这辈子都不可能打工的，大家可要小心咯。<br>今天开始讲解 LeetCode <strong>打家劫舍</strong>系列三道题目，给大家防范一下！</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/house-robber/" title="LeetCode 198. 打家劫舍" target="_blank" rel="noopener">LeetCode 198. 打家劫舍</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题面描述略有改动，不影响题意。</p></blockquote><p>你是一个专业的小偷，计划偷窃沿路的电瓶车电瓶。每个电瓶价值不一样，影响你偷窃的唯一制约因素就是相邻的电瓶车装有相互连通的防盗系统，如果两辆相邻的电瓶车的电瓶同时被偷，系统会自动报警。</p><p>给定一个代表每辆电瓶车电瓶价值的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,1]输出:4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,7,9,3,1]输出:12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>用 $dp[i]$ 表示偷前 $i$ 辆车电瓶可以获得的最大价值，那么对于第 $i$ 辆车来说，有两种选择。</p><p>如果偷第 $i$ 辆车的电瓶，那么第 $i-1$ 辆车电瓶就不能偷了，能获得的最大价值就是 $dp[i-2] + p[i]$ 。</p><p>如果不偷第 $i$ 辆车的电瓶，那么最大价值就等价于偷前 $i-1$ 辆车的电瓶能获得的最大价值 $dp[i-1]$ 。</p><p>所以最终取两者最大值即可：<br>$$<br>dp[i] = \max{\{dp[i-1], dp[i-2]+p[i]\}}<br>$$</p><p>可以发现，每次计算其实只要用到前两个元素，所以每次维护最后两个值即可，可以将空间优化到常数空间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> prepre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            now <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> prepre<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prepre <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> now<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 103】老题新做，几乎不会有人想到的解法，它来了</title>
      <link href="/2020/04/17/leetcode-846-v2/"/>
      <url>/2020/04/17/leetcode-846-v2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前两天 Day 99 的时候，做过一道顺子的题目，当时有一个网友的妙解有点没看懂，今天我来给大家详细讲解一下。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/hand-of-straights/" title="LeetCode 846. 一手顺子" target="_blank" rel="noopener">LeetCode 846. 一手顺子</a></p><p><strong>往期回顾：</strong><br><a href="https://godweiyang.com/2020/04/13/leetcode-846/" title="【每日算法Day 99】你们可能不知道只用20万赢到578万是什么概念">【每日算法Day 99】你们可能不知道只用20万赢到578万是什么概念</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>卢本伟有一手（hand）由整数数组给定的牌。 </p><p>现在她想把牌重新排列成组，使得每个组的大小都是 <code>W</code>，且由 <code>W</code> 张连续的牌组成。</p><p>如果她可以完成分组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>说明：</strong></p><ul><li><code>1 &lt;= hand.length &lt;= 10000</code></li><li><code>0 &lt;= hand[i] &lt;= 10^9</code></li><li><code>1 &lt;= W &lt;= hand.length</code></li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：hand = [1,2,3,6,2,3,4,7,8], W = 3输出:true解释：卢本伟的手牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：hand = [1,2,3,4,5], W = 4输出:false解释：卢本伟的手牌无法被重新排列成几个大小为 4 的组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题的妙解来自于题解区网友 <code>zhanzq</code>，当时没怎么看懂，现在我来给大家讲解一下。</p><p><a href="https://leetcode-cn.com/problems/hand-of-straights/solution/onlognsuan-fa-by-zhanzq/" title="网友题解地址" target="_blank" rel="noopener">网友题解地址</a></p><p>我们用一个例子来讲解：<br><img src="1.jpg" alt></p><p>假设 <code>W = 3</code>，给定的手牌正好是三个顺子：<code>[1,2,3], [2,3,4], [6,7,8]</code> 。</p><p>那么我们统计出每张牌的数量，并且从小到大排序，记为 <code>count</code> ，这里就是 <code>[1,2,2,1,0,1,1,1,0]</code> ，并且在数字不连续处和末尾补 <code>0</code> （作用后面会详细说）。</p><ul><li>然后从小到大遍历每一张牌，首先 <code>1</code> 只有一张，那么如果它和后面牌能构成顺子，那么 <code>2, 3</code> 至少要有一张才行，于是 <code>total</code> 数组后面两个位置都加上 <code>1</code> 。</li><li>然后遍历到 <code>2</code> ，因为 <code>2</code> 的数量是大于该位置处的 <code>total</code> 值的，所以 <code>2</code> 的数量足够满足前面的牌顺子要求。此外 <code>2</code> 还会多出一张，那么后面两个位置至少要有一张牌才行，于是 <code>total</code> 后面两个位置再加上 <code>1</code> 。</li><li>然后遍历 <code>3, 4</code> ，发现数量正好都等于 <code>total</code> ，那说明它俩正好和前面的牌构成顺子，一点都不会多余。</li><li>然后遍历到 <code>0</code> 了，这就说明和前面的牌断开了。如果这时候 <code>total</code> 不为 <code>0</code> ，就说明中间缺失了一些牌，前面存在顺子没法补足结尾。而如果最开始没有填充 <code>0</code> 的话，就没有办法判断这里的牌是否和前面连续的，你就有可能把 <code>6</code> 这张牌直接接到 <code>4</code> 后面组成顺子了。</li><li>然后遍历 <code>6, 7, 8</code> 同理，在对应位置处更新 <code>total</code> 就行了。</li><li>最后遍历 <code>0</code> ，发现 <code>total</code> 也是 <code>0</code> ，那就说明整副牌可以构成顺子，完美！</li></ul><p>时间复杂度是 $O(n \log n + nW)$ ，这题数据不强也可以过的。</p><p>有没有办法优化呢？其实更新 <code>total</code> 这一步可以优化掉 $O(W)$ 这个复杂度，直接 $O(1)$ 更新 <code>total</code> 。</p><ul><li>首先遍历 <code>1</code> ，因为 <code>1</code> 只有一张，那么如果它和后面牌能构成顺子，那么 <code>2, 3</code> 至少要有一张才行。但是这里我们不对这几张牌的 <code>total</code> 加上一，而是在这个顺子结尾的下一张牌处的 <code>deltas</code> 减去 <code>1</code> 。</li><li>然后遍历 <code>2</code> ，那么这时候没有 <code>total</code> 了，怎么计算应该扣除多少前面顺子需要的 <code>2</code> 呢？其实只需要用前一张牌的牌数加上当前的 <code>deltas</code> 值就行了。为什么呢？前面一张牌有多少张，你当前这张就得至少有那么多去构成顺子，但是如果前面一张牌是某些顺子的结尾，你还得扣掉一些，而扣掉的数值正好就是当前的 <code>deltas</code> ，这在前面顺子的开头处已经记录过了。</li><li>后面操作类似，就不详细阐述了。</li></ul><p>这种方法精髓就在于，不需要直接更新所有的 <code>total</code> 值，只需要在顺子结尾下一个元素处更新一下 <code>deltas</code> 就行了，每次的 <code>total</code> 可以通过上一张牌的 <code>count</code> 和当前的 <code>deltas</code> 推算出来。</p><p>这样总的时间复杂度就降到了 $O(n \log n + n)$，近似 $O(n \log n)$ 。</p><p>不得不说，这个方法还是非常妙的，反正我是一下子想不到的，看了代码都想了很久才想通。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="暴力更新（c-）"><a href="#暴力更新（c-）" class="headerlink" title="暴力更新（c++）"></a>暴力更新（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">valid</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">total</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> total<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> delta <span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> total<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token operator">+</span>W <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> total<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> delta<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> total<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isNStraightHand</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> hand<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> hand<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>W <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span>W<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>hand<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hand<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> hand<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> hand<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">valid</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> W<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化（c-）"><a href="#优化（c-）" class="headerlink" title="优化（c++）"></a>优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">valid</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>count<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">deltas</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">+</span><span class="token operator">=</span> deltas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> delta <span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> pre<span class="token punctuation">;</span>                pre <span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> W <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> deltas<span class="token punctuation">[</span>i<span class="token operator">+</span>W<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> delta<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">></span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isNStraightHand</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> hand<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> hand<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>W <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span>W<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>hand<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hand<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> hand<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> hand<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">valid</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> W<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 102】美团 AI 平台算法工程师面试编程题</title>
      <link href="/2020/04/16/meituan-interview-1/"/>
      <url>/2020/04/16/meituan-interview-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天去尝试了一下美团 AI 平台，两次面试连一起。但是两位面试官小哥都是做推荐的，我们互相都不了解对方怎么做的。于是乎就做算法题，讲论文（把不懂的人讲懂确实困难），然后全程小哥给我介绍他们部门情况，我就挂机听着。不管这家拿不拿得到，就当刷刷经验吧，也挺不错的。一共三道题目，前两道一个最长上升子序列，一道快速排序，就不讲了，都是原题。</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目链接：</strong><br><a href="https://www.nowcoder.com/questionTerminal/1ea5b4eaeff841a4918931791b000756" title="牛客网：分石子" target="_blank" rel="noopener">牛客网：分石子</a></p><p>牛牛有 <code>n</code> 堆石子堆，第 <code>i</code> 堆一共有 <code>a[i]</code> 个石子。</p><p>牛牛可以对任意一堆石子数量大于 <code>1</code> 的石子堆进行分裂操作，分裂成两堆新的石子数量都大于等于 <code>1</code> 的石子堆。</p><p>现在牛牛需要通过分裂得到 <code>m</code> 堆石子，他想知道这 <code>m</code> 堆石子的最小值最大可以是多少？</p><p><strong>示例：</strong>  </p><pre class="line-numbers language-text"><code class="language-text">输入：3,5,[3,5,6]输出：2解释：把5分裂成2和3把6分裂成2和4得到五堆石子[3,2,3,2,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>备注：</strong></p><ul><li>$1 \le n \le 10^5, n \le m \le \sum{a_i}, 1 \le a_i \le 10^9$</li><li>第一个参数 <code>n</code> 代表石子堆的个数</li><li>第二个参数 <code>m</code> 表示需要得到的石子堆数。</li><li>第三个参数 <code>vector a</code> 代表每堆石子堆的石子个数</li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一拿到这个题目，就看出来这是一道二分答案的题目。</p><p>首先定义上下界 <code>l = 1, r = min{a[i]}</code> ，也就是说，每一堆个数最小值至少为 <code>1</code> ，最多就是初始的时候最小的那堆个数。</p><p>然后对于 <code>mid = (l + r) / 2</code> ，含义就是假设最终最小的那堆有 <code>mid</code> 个。我们求出初始时每一堆最多可以划分出多少个数全部大于等于 <code>mid</code> 的子堆，显然个数是 <code>a[i] / mid</code> 取整，记总堆数为 <code>cnt</code>。</p><p>如果 <code>cnt &lt; m</code> ，那么说明 <code>mid</code> 太大了，你最多也不可能划分成 <code>m</code> 堆，所以更新 <code>r = mid - 1</code> 。如果 <code>cnt &gt; m</code> ，那么说明 <code>mid</code> 太小了，你能划分的堆数大于了 <code>m</code> ，那么更新 <code>l = mid + 1</code> 。最后如果 <code>cnt = m</code> ，你就暂存一下答案，因为这时的 <code>mid</code> 是有可能成为最终答案的。但是 <code>mid</code> 还是可能太小了，因为 <code>mid</code> 稍微大一点 <code>cnt</code> 是不会变的，所以继续更新 <code>l = mid + 1</code> 。</p><p>最终返回暂存的答案 <code>res</code> 即可。注意这题的二分框架和之前做过的有所不同，在等号判断上得特别小心，我一开始没想清楚，错了好多次才通过的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">/**     * 分石子     * @param n int整型      * @param m long长整型      * @param a int整型vector      * @return int整型     */</span>    <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span>        ll l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ll mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            ll cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> x <span class="token operator">/</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 101】字节跳动 AI Lab 精选面试编程题</title>
      <link href="/2020/04/15/byte-dance-interview-1/"/>
      <url>/2020/04/15/byte-dance-interview-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天字节三面结束了，超越妹妹保佑我通过吧！今天更新两道同学之前面试 AI Lab 时遇到的题。</p></blockquote><h2 id="0-1-背包问题（浮点数）"><a href="#0-1-背包问题（浮点数）" class="headerlink" title="0-1 背包问题（浮点数）"></a>0-1 背包问题（浮点数）</h2><p>0-1 背包问题，一共 <code>n &lt; 20</code> 个物品，每个物品价格 <code>p[i]</code> （浮点数），重量 <code>w[i]</code> （浮点数），背包容量 <code>M</code> （浮点数）。求最大能装的价值是多少？</p><pre class="line-numbers language-text"><code class="language-text">输入：20 678.9123.56 51.5631.45 23.5662.54 45.6215.32 42.2312.32 65.3265.12 32.4515.65 45.7862.15 98.3232.15 45.6215.44 95.3245.65 99.4532.15 22.4823.56 51.5631.45 23.5662.54 45.6215.32 42.2312.32 65.3265.12 32.4515.65 45.7862.15 98.32输出：1050.07<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>因为这里全部都是浮点数，所以没有办法直接用普通的动态规划来做，这里我提供几个思路。</p><p><strong>方法1：</strong><br>如果小数点只有两位的话，很简单，所有数字统一乘以 100 ，那么就都变成整数了。然后就可以直接用普通的 0-1 背包方法来做。</p><p><strong>方法2：</strong><br>因为 <code>n &lt; 20</code> ，所以直接二进制枚举所有物品可能，然后取出重量小于背包容量，且价格最高的那一种就行了。时间复杂度 $O(n 2^n)$ ，勉强可以接受。</p><p><strong>方法3：</strong><br>将 <code>n</code> 个物品平均分成两份，对每一份做二进制枚举，然后保存所有可能的总重量和对应的总价格。保存在两个数组中，记为 <code>a</code> 和 <code>b</code> ，分别表示两份的所有可能情况。</p><p>预处理出 <code>b</code> 中重量小于等于 <code>b[j].w</code> 的最大价格，保存在 <code>maxp[j]</code> 中。</p><p>分别按照 <code>w</code> 排序，然后用双指针，从重量小的开始遍历 <code>a</code> 中每个元素 <code>a[i]</code> ，在 <code>b</code> 中找出重量最高的那个满足 <code>a[i].w + b[j].w</code> 不超过背包容量的 <code>j</code> 。</p><p>然后 <code>i</code> 移动到 <code>i+1</code> ，也就是重量增加了，那么 <code>j</code> 只能减小了，直到减小到 <code>a[i].w + b[j].w</code> 再次不超过背包容量。然后直接取预处理好的 <code>maxp[j]+a[i].p</code> 和最优答案比较就行了。</p><p>最终时间复杂度是 $(n/2)2^{n/2} + n \log (n/2)$ ，相比上面直接二进制枚举所有情况，大大降低了呀。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span><span class="token keyword">struct</span> node <span class="token punctuation">{</span>    <span class="token keyword">double</span> w<span class="token punctuation">,</span> p<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> node<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> w <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>w<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">double</span> M<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">w</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ca <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> tot_w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tot_p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tot_w <span class="token operator">+</span><span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                tot_p <span class="token operator">+</span><span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tot_w <span class="token operator">></span> M<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tot_w <span class="token operator">&lt;=</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>ca<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> tot_w<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>ca<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> tot_p<span class="token punctuation">;</span>            ca<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>n<span class="token operator">-</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> tot_w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tot_p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tot_w <span class="token operator">+</span><span class="token operator">=</span> w<span class="token punctuation">[</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                tot_p <span class="token operator">+</span><span class="token operator">=</span> p<span class="token punctuation">[</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tot_w <span class="token operator">></span> M<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tot_w <span class="token operator">&lt;=</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>            b<span class="token punctuation">[</span>cb<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> tot_w<span class="token punctuation">;</span>            b<span class="token punctuation">[</span>cb<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">=</span> tot_p<span class="token punctuation">;</span>            cb<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span>ca<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> b<span class="token operator">+</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">maxp</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cb<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        maxp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> cb<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ca<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token operator">+</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">></span> M<span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">+</span>maxp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小长度子数组"><a href="#最小长度子数组" class="headerlink" title="最小长度子数组"></a>最小长度子数组</h2><p>给一个正数数组，找出最小长度连续子数组，其和大于等于 <code>m</code>。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题还是用双指针，首先用 <code>i</code> 遍历每一个位置，然后维护 <code>a[j] ~ a[i]</code> 之间的元素和。如果发现和大于等于 <code>m</code> ，那就更新最小长度，同时增大 <code>j</code> 直到区间和小于 <code>m</code> 。最终时间复杂度是 $O(n)$ 的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">>=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">-</span><span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 100】字节跳动 AI Lab 面试编程题（三道）</title>
      <link href="/2020/04/14/byte-dance-interview/"/>
      <url>/2020/04/14/byte-dance-interview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天连着面了两次字节跳动，勉强撑到了明天三面。一共三道编程题，做的很烂，这里分享一下。</p></blockquote><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给出一条长度为 <code>L</code> 的线段，除了头和尾两个点以外，上面还有 <code>n</code> 个整数点，需要在上面再放 <code>k</code> 个新的点，使得相邻的两个点之间的最大距离最小，求这个最小的距离。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我当时太紧张了，真是脑抽了，还想着弄个优先队列，划分最大的，然后丢进去，再划分最大的，但是是错的。</p><p>正确解法小姐姐走了我才想起来，二分答案 <code>m</code> ，然后扫描一遍判断将每一段划分成小于等于 <code>m</code> 的一共需要多少次。如果次数大于 <code>k</code> ，说明 <code>m</code> 太短了，否则说明 <code>m</code> 太长了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> L<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> L<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> k<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> l <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>给出一个数组 <code>A</code>，找到最大的 <code>A[i] - A[j]</code>，要求 <code>i &gt; j</code>。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这题很简单，直接遍历每个 <code>A[i]</code>，维护它前面最小的那个数 <code>minn</code>，然后求出最大的 <code>A[i] - minn</code> 就行了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> minn <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minn<span class="token punctuation">)</span><span class="token punctuation">;</span>        minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给定一个字符串，对该字符串进行删除操作，保留 <code>k</code> 个字符且相对位置不变，使字典序最小。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>这题也脑抽了，想了一堆方法，<code>dp</code> 复杂度太高，线段树太麻烦，最后用 <code>map</code> 勉强写了一下。</p><p>主要思想是这样的，最后要保留 <code>k</code> 个字符，那么第一个字符只能在下标 <code>0 ~ n-k</code> 中寻找，那肯定找最小的啊，如果有多个就找最前面那个，把它的位置记为 <code>pos</code>。</p><p>然后第二个字符肯定得在下标 <code>pos ~ n-k+1</code> 中寻找，还是一样的思路，找到以后更新 <code>pos</code> 位置，依次找下去找到 <code>k</code> 个为止。</p><p>所以我就利用了 <code>map</code> 的特性，把寻找窗口内的字符个数做一下统计，然后取出 <code>map</code> 中的第一个字符就是字典序最小的了，次数减一，如果减到 0 了就删除掉。</p><p>然后从 <code>pos</code> 位置开始遍历，直到第一个等于你刚刚取出的字符为止，更新 <code>pos</code> 位置。</p><p>最终的时间复杂度是 $O(n \log n + n \log k)$ ，可以直接看作 $O(n \log n)$ 。</p><p><strong>最优解：</strong></p><p>最优解当时没想出来，是用单调栈。维护一个递增的单调栈，我们的目标是保留 <code>k</code> 个字符，也就是删除 <code>n-k</code> 个字符。</p><p>那么如果栈顶元素大于当前遍历元素，并且还没删够 <code>n-k</code> 个，就出栈，当作删除了一个元素。否则的话如果删够了，不管大小关系统统入栈，因为你没法删了。</p><p>最后全遍历完了，如果还没删够，那就继续出栈，直到删够为止。最后把栈里的字符拼接成一个字符串就是答案了。</p><p>时间复杂度是 $O(n)$ 的。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>string <span class="token function">f</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span>k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> c <span class="token operator">=</span> mp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">;</span>        res <span class="token operator">+</span><span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> pos<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> mp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pos <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s <span class="token operator">>></span> k<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最优解：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>string <span class="token function">f</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k <span class="token operator">=</span> n <span class="token operator">-</span> k<span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            k<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span> k<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> res <span class="token operator">+</span><span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s <span class="token operator">>></span> k<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 99】你们可能不知道只用20万赢到578万是什么概念</title>
      <link href="/2020/04/13/leetcode-846/"/>
      <url>/2020/04/13/leetcode-846/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你们可能不知道只用 20 万赢到 578 万是什么概念。<br>我们一般只会用两个字来形容这种人：赌怪！<br>我经常说一句话，当年陈刀仔他能用 20 块赢到 3700 万，我 LBW 用 20 万赢到 500 万不是问题。<br>埋伏他一手，这个牌不能抢，这个牌不用抢，他死定了。<br>反手给一个超级加倍，闷声发大财。他也超级加倍？但是不用怕，他的牌赢不了我。<br>五六七八九十，两个炸，很牛逼这个牌，如果把这个 K 换成 J ，我这个牌将绝杀，但是换不得。<br>单走一个六，SB，直接把 K 走了。<br>走他一张 2 顶他。阿姨快点，阿姨，阿姨你 K 都不要吗？阿姨你快点啊！阿姨别磨磨蹭蹭的。<br>五六七八九十。打错了，应该打 2 的。<br>给阿姨倒杯茶好吧，阿姨给你倒一杯卡布奇诺。<br>给阿姨倒一杯卡布奇诺！开始你的炸弹秀，炸他炸他。漂亮！<br>十七张牌你能秒我？你能秒杀我？！你今天能十七张牌把卢本伟秒了，我！当！场！就把这个电脑屏幕吃掉！！！</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/hand-of-straights/" title="LeetCode 846. 一手顺子" target="_blank" rel="noopener">LeetCode 846. 一手顺子</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>爱丽丝有一手（hand）由整数数组给定的牌。 </p><p>现在她想把牌重新排列成组，使得每个组的大小都是 <code>W</code>，且由 <code>W</code> 张连续的牌组成。</p><p>如果她可以完成分组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>说明：</strong></p><ul><li><code>1 &lt;= hand.length &lt;= 10000</code></li><li><code>0 &lt;= hand[i] &lt;= 10^9</code></li><li><code>1 &lt;= W &lt;= hand.length</code></li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：hand = [1,2,3,6,2,3,4,7,8], W = 3输出:true解释：爱丽丝的手牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：hand = [1,2,3,4,5], W = 4输出:false解释：爱丽丝的手牌无法被重新排列成几个大小为 4 的组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="巧用-map"><a href="#巧用-map" class="headerlink" title="巧用 map"></a>巧用 map</h2><p>这也是最直观的一个方法，用 <code>map</code> 来保存每个数出现的次数。</p><p>然后从最小的数开始，以它作为顺子的开头，然后看顺子里的数在不在 <code>map</code> 里，在就次数减一，不在就直接返回 <code>false</code> 。</p><p>接着重复上面步骤，最后直到 <code>map</code> 为空，最后返回 <code>true</code>。</p><p><code>map</code> 的特性就是你取它的第一个键值对，它的 <code>key</code> 就是最小的，这就很方便了。</p><h2 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h2><p>首先对手牌从小到大进行排序，然后从最小的开始，作为顺子开头，遍历之后的数。如果在数组里，并且没有被访问过，那么就标记为访问过了。</p><p>注意可以提前终止遍历，也就是如果发现某一个顺子还没遍历完，但是访问到的元素已经超过接在顺子后的数了，那就直接返回 <code>false</code> 。</p><h2 id="排序统计2"><a href="#排序统计2" class="headerlink" title="排序统计2"></a>排序统计2</h2><blockquote><p>这题还有个解法，来自于题解区网友 <code>zhanzq</code>，感觉挺不错的。但是我没怎么看懂，如果谁看懂了请教教我。</p></blockquote><p><a href="https://leetcode-cn.com/problems/hand-of-straights/solution/onlognsuan-fa-by-zhanzq/" title="网友题解" target="_blank" rel="noopener">网友题解</a></p><p><img src="1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="巧用-map（c-）"><a href="#巧用-map（c-）" class="headerlink" title="巧用 map（c++）"></a>巧用 map（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isNStraightHand</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> hand<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> hand<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span>W<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> count<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> hand<span class="token punctuation">)</span> count<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> start<span class="token operator">+</span>W<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> count<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">--</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> count<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序统计（c-）"><a href="#排序统计（c-）" class="headerlink" title="排序统计（c++）"></a>排序统计（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isNStraightHand</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> hand<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> hand<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">%</span>W<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>W<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>hand<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hand<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>hand<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>cnt<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>hand<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    vis<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> W<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">!=</span> W<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序统计2，来自于网友zhanzq（c-）"><a href="#排序统计2，来自于网友zhanzq（c-）" class="headerlink" title="排序统计2，来自于网友zhanzq（c++）"></a>排序统计2，来自于网友zhanzq（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">valid</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>lst<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span><span class="token punctuation">{</span>        lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">deltas</span><span class="token punctuation">(</span>sz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pre <span class="token operator">+</span><span class="token operator">=</span> deltas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">&lt;</span> lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> delta <span class="token operator">=</span> lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> pre<span class="token punctuation">;</span>                pre <span class="token operator">=</span> lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> W <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span>                    deltas<span class="token punctuation">[</span>i<span class="token operator">+</span>W<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> delta<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">></span> lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isNStraightHand</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> hand<span class="token punctuation">,</span> <span class="token keyword">int</span> W<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> hand<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sz<span class="token operator">%</span>W<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">sort</span><span class="token punctuation">(</span>hand<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hand<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> hand<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    j<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> sz<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>hand<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> hand<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                i <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token function">valid</span><span class="token punctuation">(</span>lst<span class="token punctuation">,</span> W<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 98】慈善赌神godweiyang教你算骰子点数概率！</title>
      <link href="/2020/04/12/leetcode-interview-60/"/>
      <url>/2020/04/12/leetcode-interview-60/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" title="LeetCode 面试题60. n个骰子的点数" target="_blank" rel="noopener">LeetCode 面试题60. n个骰子的点数</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把 <code>n</code> 个骰子扔在地上，所有骰子朝上一面的点数之和为 <code>s</code>。输入 <code>n</code>，打印出 <code>s</code> 的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 <code>i</code> 个元素代表这 <code>n</code> 个骰子所能掷出的点数集合中第 <code>i</code> 小的那个的概率。</p><p><strong>说明：</strong></p><ul><li><code>1 &lt;= n &lt;= 11</code></li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：1输出:[0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：2输出:[0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>令 $dp[n][s]$ 表示投掷 $n$ 个骰子，点数为 $s$ 的方法数。那么可以根据最后一个骰子的点数情况（$1$ 到 $6$），递归进行计算：<br>$$<br>dp[n][s] = \sum_{i=1}^{6}{dp[n-1][s-i]}<br>$$<br>当然还得加一些约束，例如 $n-1$ 个骰子的点数范围是 $[n-1, 6(n-1)]$ ，所以一定有 $n-1 \le s-i \le 6(n-1)$ ，即 $s-6(n-1) \le i \le s-(n-1)$。所以综上 $i$ 的范围是 $\max{\{1, s-6(n-1)\}} \le i \le \min{\{6, s-(n-1)\}}$，最后的转移方程就是：<br>$$<br>dp[n][s] = \sum_{i=\max{\{1, s-6(n-1)\}}}^{\min{\{6, s-(n-1)\}}}{dp[n-1][s-i]}<br>$$<br>但是，考虑到在计算 $n-1$ 个骰子时，如果 $i &lt; s-6(n-1)$ ，那么 $s-i &gt; 6(n-1)$ ，也就是 $dp[n-1][s-i]$ 是根本不会被计算的。所以初始化的时候如果都是 $0$ ，那么就不用管这个下界了，也就是转移方程为：<br>$$<br>dp[n][s] = \sum_{i=1}^{\min{\{6, s-(n-1)\}}}{dp[n-1][s-i]}<br>$$<br>此外，因为每次计算只会用到 $n-1$ 个骰子的方法数，所以第一个维度可以省去。但是注意计算的时候 $s$ 就得逆序遍历了，这样才不会覆盖掉 $n-1$ 个骰子的方案数，造成后面的计算错误。</p><p>最后答案就是 $\frac{dp[n][s]}{6^n}$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划-空间优化（c-）"><a href="#动态规划-空间优化（c-）" class="headerlink" title="动态规划+空间优化（c++）"></a>动态规划+空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">6</span><span class="token operator">*</span>i<span class="token punctuation">;</span> s <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> s<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>s<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">double</span> total <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> n<span class="token punctuation">;</span> s <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">/</span>total<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 97】经典面试题：求两个数组最小差</title>
      <link href="/2020/04/11/leetcode-interview-16-06/"/>
      <url>/2020/04/11/leetcode-interview-16-06/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/smallest-difference-lcci/" title="LeetCode 面试题 16.06. 最小差" target="_blank" rel="noopener">LeetCode 面试题 16.06. 最小差</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个整数数组 <code>a</code> 和 <code>b</code>，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差。</p><p><strong>说明：</strong></p><ul><li><code>1 &lt;= a.length, b.length &lt;= 100000</code></li><li><code>-2147483648 &lt;= a[i], b[i] &lt;= 2147483647</code></li><li>正确结果在区间 <code>[-2147483648, 2147483647]</code> 内</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}输出:3，即数值对(11, 8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先最暴力的方法就是 $O(n^2)$ 暴力枚举两个数组中的所有数对，然后计算绝对值最小的差值，这样显然是会超时的。</p><p>所以我们先分别对两个数组从小到大进行排序，然后用双指针的方法来计算。</p><ul><li>初始的时候 $i = 0, j = 0$ 分别指着两个数组的第一个元素。</li><li>然后计算 $a[i]-b[j]$ 的绝对值，如果比当前最小值还要小，就更新最小值。</li><li>然后判断 $a[i]$ 和 $b[j]$ 的大小关系。如果 $a[i] &gt; b[j]$ ，那么如果增大 $i$ ，差值只会越来越大，所以只能增大 $j$ 。同理如果 $a[i] &lt; b[j]$ ，那就增大 $i$ 。</li><li>最后如果其中一个数组遍历完了就结束遍历。</li></ul><p>是不是有点类似归并排序的合并数组过程？但是这里有个区别，最后遍历完之后，一定会有某个数组还没遍历完。而那些没遍历的数字其实都大于另一个数组中最大的数，所以没有必要再和另一个数组最大值做差值了。这样差值只会越来越大，没有意义。</p><p>最终的时间复杂度就是 $O(n \log n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">smallestDifference</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">long</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">smallestDifference</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        b<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>b<span class="token punctuation">)</span>        i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2147483647</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> n <span class="token operator">and</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            res <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">,</span> abs<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span> j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 96】腾讯面试题：合并两个有序数组</title>
      <link href="/2020/04/10/leetcode-88/"/>
      <url>/2020/04/10/leetcode-88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>昨天腾讯一面上来就给我整的这道 easy 难度的题，然后我太紧张了还想了一会儿，差点炸裂。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" title="LeetCode 88. 合并两个有序数组" target="_blank" rel="noopener">LeetCode 88. 合并两个有序数组</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中，使 <code>nums1</code> 成为一个有序数组。</p><p><strong>说明：</strong></p><ul><li>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。</li><li>你可以假设 <code>nums1</code> 有足够的空间（空间大小大于或等于 <code>m + n</code>）来保存 <code>nums2</code> 中的元素。</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出:[1,2,2,3,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看到这道题，脑海里应该第一时间想到的是归并排序，但是归并排序需要一个额外的数组用来保存排序后的数组，这里不允许使用额外空间。</p><p>那么我们还是用归并排序的思路来做，试一下两个指针 <code>i = 0</code> 和 <code>j = 0</code> ，初始的时候分别指着 <code>nums1[0]</code> 和 <code>nums2[0]</code> 。然后比较 <code>nums1[i]</code> 和 <code>nums2[j]</code> 大小，如果 <code>nums1[i]</code> 更小，那么就放在原位不动它，然后 <code>i += 1</code>。如果 <code>nums2[j]</code> 更小，那么就交换 <code>nums1[i]</code> 和 <code>nums2[j]</code> ，然后还是 <code>i += 1</code>。这么看貌似可行哦？但是最终一定会先遍历完 <code>nums1</code>，然后 <code>j</code> 还是停留在 <code>0</code> ，然后你会发现 <code>nums2</code> 中的数字还是乱序的，根本没法处理。</p><p>那么怎么利用上 <code>nums1</code> 后面多出的那么多空位呢？我们可以换个思路，从最大的开始遍历。两个指针初始的时候 <code>i = m-1</code> 和 <code>j = n-1</code> ，然后将较大值填充到 <code>nums1</code> 的最后面。最后如果 <code>nums2</code> 中还有剩余，就依次填充到 <code>nums1</code> 最前面就行了。</p><p>这样为什么就可以了呢？因为如果从小到大遍历的话，元素会覆盖掉 <code>nums1</code> 中还没遍历的元素。但是从大到小是填充到尾部，就不会产生覆盖。就算极限情况下 <code>nums2</code> 中元素全部大于 <code>nums1</code> 中元素，也不会覆盖到 <code>nums1</code> 的最后一个元素。</p><p>面试官最后还会问你有啥优化，我当时图省事，最后还把 <code>nums1</code> 中剩下元素填充到 <code>nums1</code> 最前面了，其实完全没有必要，本来就是有序的，等于没有做事。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> m<span class="token operator">+</span>n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        i<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token number">-1</span>        <span class="token keyword">while</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            nums1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 95】美团笔试题：四面体方案个数</title>
      <link href="/2020/04/09/meituan-interview/"/>
      <url>/2020/04/09/meituan-interview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天就更新一道刚做的美团在线编程题吧。</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个四面体，顶点为 <code>S, A, B, C</code>。从 <code>S</code> 出发，每次任意选一条棱走到另一个顶点，可重复走过所有顶点和棱。问走 $k$ 次之后，回到 <code>S</code> 的方案数是多少？答案对 $1e9+7$ 取模。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>明显这是一道动态规划题目，我们令 $dp[i][0]$ 表示走了 $i$ 次之后回到 <code>S</code> 的方案数，令 $dp[i][1]$ 表示走了 $i$ 次之后在 $A, B, C$ 的概率。注意到这里 <code>A, B, C</code> 是对称的，所以方案数应该完全相同，所以我们定义一个就行了。</p><p>那么 $i$ 步回到 <code>S</code> 的方案数应该就是 $i-1$ 步在 <code>A, B, C</code> 的方案数之和：<br>$$<br>dp[i][0] = dp[i-1][1] * 3<br>$$</p><p>$i$ 步在 <code>A</code> 的方案数就是 $i-1$ 步在 <code>B, C</code> 的方案数加上 $i-1$ 步在 <code>S</code> 的方案数：<br>$$<br>dp[i][1] = dp[i-1][1] * 2 + dp[i-1][0]<br>$$</p><p>当然空间还可以优化，因为只跟上一步有关，所以保存上一步两个状态值就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>ll dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="空间优化（c-）"><a href="#空间优化（c-）" class="headerlink" title="空间优化（c++）"></a>空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>ll dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 94】经典面试题：机器人的运动范围</title>
      <link href="/2020/04/08/leetcode-interview-13/"/>
      <url>/2020/04/08/leetcode-interview-13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在忙面试，本来今天都不想更了，但是看基础知识看的太累了，于是写道题排解一下压力。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" title="LeetCode 面试题13. 机器人的运动范围" target="_blank" rel="noopener">LeetCode 面试题13. 机器人的运动范围</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个 <code>m</code> 行 <code>n</code> 列的方格，从坐标 <code>[0, 0]</code> 到坐标 <code>[m-1, n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 <code>k</code> 的格子。例如，当 <code>k</code> 为 <code>18</code> 时，机器人能够进入方格 <code>[35, 37]</code> ，因为 <code>3+5+3+7=18</code>。但它不能进入方格 <code>[35, 38]</code>，因为 <code>3+5+3+8=19</code>。请问该机器人能够到达多少个格子？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：m = 2, n = 3, k = 1输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：m = 3, n = 1, k = 0输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题没有什么算法，比较简单，主要考察你的代码实现能力，这里我写了两个方法，一个 BFS，一个 DFS。</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS 的思路就是用一个队列来保存即将要访问的结点，然后不断出队，将当前结点的四周的结点满足要求的入队。为了避免重复访问，可以用一个 <code>vis</code> 数组来标记已经访问过的结点位置。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS 思路就更加清晰简单了，对于一个结点来说，从它出发可以访问到的结点总数就等于从它四周的结点出发可以访问到的结点总数加一。同样需要用一个 <code>vis</code> 数组来标记已经访问过的结点位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="BFS（c-）"><a href="#BFS（c-）" class="headerlink" title="BFS（c++）"></a>BFS（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> y <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            y <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">vis</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> Q<span class="token punctuation">;</span>        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> p <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> p<span class="token punctuation">.</span>first<span class="token punctuation">,</span> ny <span class="token operator">=</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> x <span class="token operator">=</span> nx <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> ny <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">countDigit</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DFS（c-）"><a href="#DFS（c-）" class="headerlink" title="DFS（c++）"></a>DFS（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">countDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">+</span><span class="token operator">=</span> y <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            y <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> nx<span class="token punctuation">,</span> <span class="token keyword">int</span> ny<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span><span class="token operator">&amp;</span> vis<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> nx <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> ny <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">countDigit</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> vis<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">vis</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> vis<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 93】不用额外空间，你会旋转一个矩阵吗？</title>
      <link href="/2020/04/07/leetcode-interview-01-07/"/>
      <url>/2020/04/07/leetcode-interview-01-07/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第 100 天时，我可能会对这 100 天以来的算法题进行一个总结，然后暂时停止更新 LeetCode 题解了。<br>下一步可能更新 NLP 相关算法了，非常感谢大家每天的支持。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" title="LeetCode 面试题 01.07. 旋转矩阵" target="_blank" rel="noopener">LeetCode 面试题 01.07. 旋转矩阵</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 <code>4</code> 字节。请你设计一种算法，将图像旋转 <code>90</code> 度。</p><p>不占用额外内存空间能否做到？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">给定 matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],原地旋转输入矩阵，使其变为:[  [7,4,1],  [8,5,2],  [9,6,3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">给定 matrix =[  [ 5, 1, 9,11],  [ 2, 4, 8,10],  [13, 3, 6, 7],  [15,14,12,16]], 原地旋转输入矩阵，使其变为:[  [15,13, 2, 5],  [14, 3, 4, 1],  [12, 6, 8, 9],  [16, 7,10,11]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>可以发现，每个格子旋转四次之后都会回到原位。所以对于每个格子，我们只需要交换和它相关的一共四个格子的位置就行了。</p><p>对于格子 <code>(i, j)</code> ，我们可以推算出它旋转后的三个新位置是 <code>(j, n-1-i), (n-1-i, n-1-j), (n-1-j, i)</code> 。所以只需要一个临时变量保存其中一个位置的值，然后按顺序交换位置就行了。</p><p>当然为了避免重复旋转，我们只能枚举四分之一的格子，如果 <code>n</code> 是偶数，如下图所示，我们可以这么划分：</p><p><img src="3.jpg" alt></p><p>如果 <code>n</code> 是奇数，可以如下图这么划分：</p><p><img src="2.jpg" alt></p><p>当然你也可以不规则的划分，如下图这样，只是代码写起来有点费劲：</p><p><img src="1.jpg" alt></p><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>这题还可以不通过模拟旋转来实现旋转。</p><p>上面说过了，格子 <code>(i, j)</code> 旋转后的新位置是 <code>(j, n-1-i)</code> 。</p><p>那么我们可以先沿着主对角线翻转矩阵，这样格子 <code>(i, j)</code> 位置就换到了 <code>(j, i)</code> 。</p><p>然后再左右翻转一下矩阵，格子 <code>(j, i)</code> 就换到了 <code>(j, n-1-i)</code> ，正好等价于旋转后的位置！</p><p>因为翻转每次只需要交换两个格子的位置，所以不需要任何额外变量。</p><p>再提一个交换两个元素的小 trick ，如代码里注释的那样，可以采用异或操作来规避额外变量。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="旋转（c-）"><a href="#旋转（c-）" class="headerlink" title="旋转（c++）"></a>旋转（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="翻转（c-）"><a href="#翻转（c-）" class="headerlink" title="翻转（c++）"></a>翻转（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// swap(matrix[i][j], matrix[j][i]);</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// swap(matrix[i][j], matrix[i][n-1-j]);</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旋转（python）"><a href="#旋转（python）" class="headerlink" title="旋转（python）"></a>旋转（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                tmp <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="翻转（python）"><a href="#翻转（python）" class="headerlink" title="翻转（python）"></a>翻转（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> matrix<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>matrix<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 92】经典面试题：编辑距离</title>
      <link href="/2020/04/06/leetcode-72/"/>
      <url>/2020/04/06/leetcode-72/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/" title="LeetCode 72. 编辑距离" target="_blank" rel="noopener">LeetCode 72. 编辑距离</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：word1 = "horse", word2 = "ros"输出:3解释：horse -> rorse (将 'h' 替换为 'r')rorse -> rose (删除 'r')rose -> ros (删除 'e')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：word1 = "intention", word2 = "execution"输出:5解释：intention -> inention (删除 't')inention -> enention (将 'i' 替换为 'e')enention -> exention (将 'n' 替换为 'x')exention -> exection (将 'n' 替换为 'c')exection -> execution (插入 'u')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道典型的动态规划题目，我们用 $dp[i][j]$ 表示 $word1_{1:i}$ 转换成 $word2_{1:j}$ 所需要的最小步数。那么对于最后一个字符来说，有如下四种情况：</p><ul><li>如果 $word1_{i} = word2_{j}$ ，那么最后一个字符不需要操作，答案就是 $dp[i-1][j-1]$ 。</li><li>如果 最后一步操作是插入得到的，那么问题就转化为了 $word1_{1:i}$ 转换成 $word2_{1:j-1}$ 所需要的最小步数。最后再插入 $word2_{j}$ 就行了，答案就是 $dp[i][j-1] + 1$ 。</li><li>如果 最后一步操作是删除得到的，那么问题就转化为了 $word1_{1:i-1}$ 转换成 $word2_{1:j}$ 所需要的最小步数。最后再删除 $word1_{i}$ 就行了，答案就是 $dp[i-1][j] + 1$ 。</li><li>如果 最后一步操作是替换得到的，那么问题就转化为了 $word1_{1:i-1}$ 转换成 $word2_{1:j-1}$ 所需要的最小步数。最后再将 $word1_{i}$ 替换为 $word2_{j}$ 就行了，答案就是 $dp[i-1][j-1] + 1$ 。</li></ul><p>综上，如果 $word1_{i} = word2_{j}$ ，那么 $dp[i][j] = dp[i-1][j-1]$ 。否则的话：<br>$$<br>dp[i][j] = \min{\{dp[i][j-1], dp[i-1][j], dp[i-1][j-1]\}} + 1<br>$$</p><p>初始化就是，所有的 $dp[0][i] = i$ ，因为需要插入 $i$ 次。所有的 $dp[i][0] = i$ ，因为需要删除 $i$ 次。</p><p>总的时间复杂度就是 $O(nm)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>string word1<span class="token punctuation">,</span> string word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> word2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 插入</span>                dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 删除</span>                dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 替换</span>                dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word1<span class="token punctuation">:</span> str<span class="token punctuation">,</span> word2<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>word1<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>word2<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> word1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> word2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                    <span class="token keyword">continue</span>                dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 91】求解数组中出现次数超过1/3的那个数</title>
      <link href="/2020/04/05/leetcode-229/"/>
      <url>/2020/04/05/leetcode-229/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/majority-element-ii/" title="LeetCode 229. 求众数 II" target="_blank" rel="noopener">LeetCode 229. 求众数 II</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 $n$ 的数组，找出其中所有出现超过 $\lfloor n/3 \rfloor$ 次的元素。</p><p><strong>说明：</strong></p><ul><li>要求算法的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,3]输出:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,1,1,3,3,2,2,2]输出:[1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是求解众数的升级版：<br><a href="https://godweiyang.com/2020/04/04/leetcode-inteview-39/" title="【每日算法Day 90】5种方法：求解数组中出现次数超过一半的那个数">【每日算法Day 90】5种方法：求解数组中出现次数超过一半的那个数</a><br>但是这题没有保证一定存在满足条件的数，不过不要紧。</p><p>首先可以肯定最多有两个数的数量超过 <code>1/3</code> ，这个就不用我过多解释了吧。然后我们只需要找出出现次数最多的两个数，看它俩次数是否超过 <code>1/3</code> 就行了。</p><p>那么怎么找呢？如果存在某个数超过 <code>1/3</code> ，那我们每次删掉三个不同的数，直到最后没法删，最后剩下的数一定有这个超过 <code>1/3</code> 的数。原因很简单，因为每删一次最多删掉一个这个数，而删除最多 <code>1/3</code> 数组长度次之后所有数都被删光了，但是这个数还剩下一点。</p><p>所以我们用两个变量 <code>cand1</code> 和 <code>cand2</code> 表示两个候选人，<code>cnt1</code> 和 <code>cnt2</code> 表示两个候选人数量。那么如果两个候选人有一个和当前数 <code>x</code> 相同，对应的数量就加一。否则的话如果如果有某个候选人为空，就让 <code>x</code> 顶替成为新的候选人。否则的话就说明两个候选人都有，并且 <code>x</code> 和它俩都不相同，那么就同时删除三个不同的数，也就是两个候选人数量各减一，同时删去 <code>x</code> 。</p><p>最后判断两个候选人数量是否超过了 <code>1/3</code> 就行了。</p><p>这里关键点就在于，<strong>每次删除三个不同的数，判断最后剩下的数是否符合题意就行了</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cand1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cand2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cand1 <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cand2 <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt2<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cnt1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cand1 <span class="token operator">=</span> x<span class="token punctuation">;</span>                cnt1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cnt2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cand2 <span class="token operator">=</span> x<span class="token punctuation">;</span>                cnt2<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cnt1<span class="token operator">--</span><span class="token punctuation">;</span>                cnt2<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cnt1 <span class="token operator">=</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> cand1<span class="token punctuation">)</span> cnt1<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> cand2<span class="token punctuation">)</span> cnt2<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt1 <span class="token operator">></span> n<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cand1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt2 <span class="token operator">></span> n<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cand2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        cand1<span class="token punctuation">,</span> cand2<span class="token punctuation">,</span> cnt1<span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> cand1 <span class="token operator">==</span> x<span class="token punctuation">:</span>                cnt1 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cand2 <span class="token operator">==</span> x<span class="token punctuation">:</span>                cnt2 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                cand1 <span class="token operator">=</span> x                cnt1 <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> cnt2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                cand2 <span class="token operator">=</span> x                cnt2 <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                cnt1 <span class="token operator">-=</span> <span class="token number">1</span>                cnt2 <span class="token operator">-=</span> <span class="token number">1</span>        cnt1 <span class="token operator">=</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> cand1<span class="token punctuation">:</span>                cnt1 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> x <span class="token operator">==</span> cand2<span class="token punctuation">:</span>                cnt2 <span class="token operator">+=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> cnt1 <span class="token operator">></span> n<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cand1<span class="token punctuation">)</span>        <span class="token keyword">if</span> cnt2 <span class="token operator">></span> n<span class="token operator">//</span><span class="token number">3</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cand2<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼一年半，我终于摸出了一篇顶会论文</title>
      <link href="/2020/04/04/my-first-paper/"/>
      <url>/2020/04/04/my-first-paper/</url>
      
        <content type="html"><![CDATA[<blockquote><p>就在今天中午，在我失眠了两个晚上之后，ACL 2020 终于发送了录取通知邮件。庆幸的是，我这篇水文竟然也中了。</p></blockquote><p><img src="1.jpg" alt="第一篇论文中啦，过程很惊险刺激"></p><p>其实这篇能中我是根本没想到的，在经历了一年多的摸鱼失败之后，在去年最后一个季度我才拍脑袋想了这个诡异的 idea 。然后搞了一两个月交了论文，苦苦等到二月份，没想到 review 评分还可以（4、3.5、2.5）。不过说实话，我感觉 4 分的那个没有 2.5 分的那个看的透彻。最后和老板一顿 rebuttal ，就只能求佛指望 2.5 分的那个提一提分了。最后感谢 2.5 分的评审仔细阅读了我的回复，提了 1 分，但是诡异的是 4 分的评审给我降到了 3.5 分，估计是之前也没仔细看懂细节吧。不过结局是好的，这三位应该都是这个领域很权威的大佬，不然不会看的这么透彻的。最后三个评审和 meta-review 都给出了一些批评性的意见，这也让我又想起了导师在上次碰壁后说过的一句话：他们能认真看并且提出批评意见，说明这个方向还没死掉，还是有人关注的。</p><p><img src="2.jpg" alt></p><p>我的科（mo）研（yu）生涯还得从保完研开始说起。很多人都问过我为啥不保研去清北复交呢？每次我的回答都差不多吧。一是当时确实懒，嫌夏令营啥的好麻烦，保本校舒舒服服啥都不用干。二是当时不知道看了哪里说研究生导师大于学校，而且确实现在的导师超级 nice ，于是我就留下了。三是心想着早半年进实验室不香吗？能多做些科研。事实证明，早进没啥用，都被我打游戏摸鱼耗光了。</p><p><img src="4.jpg" alt="我普陀区第一盖伦岂是跟你开玩笑的？"></p><p>遥想两年前的寒假，那时候刚刚保研不久。进了实验室第一件事就是做毕业设计了，那时候就给我定下了现在的方向——成分句法分析。不过那时候真是啥都不懂，深度学习也刚入门，句法分析看的几篇论文（还是导师丢给我的）竟然都是传统方法的经典论文。于是毕业论文做的就是传统方法夹杂着深度学习，现在看来就是一坨 shi ，效果差到离谱，数据都没处理好，吹的倒是天花乱坠，还混了个优秀毕业论文。早知如此，当初就应该直接看最新的前沿论文，这样不仅毕业论文好写，也能更早的为现在打下坚实的基础。不过像下面这种经典论文还是必看的，虽然方法现在过时了，但是思想有些还是可以借鉴的。</p><p><img src="3.jpg" alt="我的启蒙论文"></p><p>然后就开始第一次顶会投稿了，上来就给我整了个 ACL 2019 。那时候我还没什么想法，论文倒是看了差不多了，然后拍脑袋想了个改编的点子。其实本质上方法没啥大差别，但是当时啥也不懂啊，觉得挺有新意，就愣愣地拿别人的代码改改跑起来了。最后效果也是难以言尽，就高了一丢丢，估计还是实现上的影响或者多次跑取了个最好的。然后憨憨地写了篇论文，导师还给我认真从头到尾修改了好几遍，最后提交了。第一次出结果也慌的很啊，半夜醒来一直看手机邮箱。然后凌晨两点收到的邮件，睡意朦胧中看了眼第一句写着 we are sorry （当时没有 rebuttal）。评分也不高，只有 3.5、2.5、2.5 ，现在看来 3.5 的那个评审还是给足面子了，要我说 2.5 都高了。当时导师就说下了那句让我印象深刻的话：不要怕，应该感到高兴，他们能认真看并且提出批评意见，说明这个方向还没死掉，还是有人关注的。</p><p>这时候应该才二三月份吧，你要问我这还有大半年呢，你干嘛了？是的，我干嘛了呢？我什么都没干，我直接把这篇一个字没改转投了 CoNLL ，心想一个 CCF C 类会议，总能碰碰运气吧？结果还是低分被拒，事实证明这篇果然是坨 shi ，这时候我自己都已经不想看了，索性丢在了一边再也不管它了。而导师这时候安慰我说，CoNLL 别看是个 C 会，不水的，不要气馁。一直到下半年开学，我基本上没有任何新的 idea ，一直都在召唤师峡谷放纵，然后顺带看完了这个方向几乎所有的论文，但是依旧没有任何 idea 。</p><p><img src="5.jpg" alt></p><p>直到有一天，我看着师兄的 ACL 2019 论文，用 GNN 来做依存句法分析。我就想好像还没人用 GNN 来做过成分句法分析，可是哪来的图呢？依存树可以转变成一张图，结点数量是确定的，在完全图上跑 GAT 可以生成出依存树。但是成分树还有中间结点啊，似乎不好办，于是那段时间我一直在想有没有其他的表示方法，可以把成分树也表示成 GAT 可以处理的形式。</p><p>那段时间真的特别迷茫，不知道这条路走不走得下去。每天跟导师聊天都会抱怨，有监督确实做不下去了，这次投完我一定要转无监督了。然后终于有了这篇论文 idea 的雏形，把句法树转成了线性序列，也有办法跑 GAT 了。但是在代码实现上，我这次学乖了，之前一整年我都是在一份效果不是那么好的代码基础上修改的，用的是 DyNet 深度学习框架。但是这次我决定直接在 SOTA 代码，也就是 ACL 2019 交大同学那篇论文代码基础上进行修改。老话说的对的，确实要站在巨人的肩膀上，会少走很多弯路，自己实现确实锻炼代码能力，但是实在是太耗时间了，当时来不及了。</p><p><img src="8.jpg" alt="实验室打扫的很干净，烦躁的心情也会好点"></p><p>那一个多月，我再也没有出现在召唤师峡谷过（可能出现过一两次嘻嘻），每天晚上都熬到了凌晨一两点才走。调参确实辛苦，尝试了各种参数想把效果再调高一点，但是确实已经差不多到顶了，很难上去了。后来讨论中经师兄提醒又加了 dropout ，效果一下子又上去了很多，那时候才看到了一丝希望。做完了各种实验之后，就顺带着开始写论文了。论文写起来其实挺快的，一个星期就能差不多有了初稿。</p><p>不得不说，导师对我的帮助实在是太大了。跑实验那段时间，每天下午都要和我讨论半天模型细节。刚开始他也不是很懂我的 idea，讲了很久他才明白个大概。等论文写完，他改我的初稿，把我一整页的啰嗦证明浓缩成了很精简的几段话。又把我的 introduction 完全重写了一遍，基本上实验之前的部分全都是他撰写和修改的。后来苦等了两个多月，rebuttal 出来了，因为疫情在家只能远程和导师交流。老板又把我的回复完全重写了一遍，真的看起来读起来完全不同了，rebuttal 确实得找有经验的好好写！</p><p><img src="6.jpg" alt="非常感谢敬爱的我导"></p><p>现在总算松了一口气，一直没有论文，其实我挺为毕业感到担忧的。如果这次不中，我都打算直接水个 C 会混毕业了。实习啥的都不用想太好的了，老老实实找个升经验吧。但是现在中了，还是不能松懈，我还是决定继续想 idea 投之后的几个会。英雄联盟中无极剑圣有句台词：真正的大师，永远怀着一颗学徒的心。不能因为达到毕业要求了就开始混日子了。其实这次说白了还是运气好水上的论文，我感觉我还是很菜。看看网上实习都问 LSTM、SVM 之类的细节原理，我就一脸懵逼，平时我都调包啊，细节我哪里记得？其他很多基础知识也都朦朦胧胧早已不记得了。工程代码能力更别谈了，模型都没手撸过，都是修修改改，以后不知道怎么办呢。别人总吹我，你很强啊、牛啊，其实我自己知道的，我算周围人里面比较菜的了，所谓的强都是表面上的和本科那些没啥用的成绩了，科研和课程差别还是太大了。特别是网上认识了很多很多的大佬之后，越发感觉我根本不值得一提。</p><p><img src="7.jpg" alt="真正的大师，永远怀着一颗学徒的心"></p><p>总结我的硕士前半程，一年划水，idea 做废掉了，半年奇思妙想水了一篇顶会。我的经历并不值得学习，但是我还是想提几点也许可以对科研有帮助的小建议：</p><ul><li>积累是一定要的，你做的这个方向一定要了解的差不多，才能知道下一步朝哪发展。</li><li>不要拘泥于只看你方向论文，去看看其他方向论文，甚至看看 CV 的论文，说不定有能直接拿过来用的 idea 。</li><li>idea 挺随缘的，也许是你在吃饭的时候突然蹦出来的。平时走路、吃饭等闲暇时间可以脑子里想一想，我的 idea 就是冲澡的时候想出来的。</li><li>多跟导师、学长们讨论讨论，可以让你少走弯路，甚至把你从错误的方向拉回来。讨论的时候也许能解决你想了很久都没想通的问题。</li><li>站在巨人的肩膀上。论文多看顶会的，代码多看大牛写的。</li><li>平时组会别人讲论文的时候多听听，虽然跟你方向不搭，可能也能拿来用的，对你的 idea 也有很大启发。</li><li>有时间和精力的，可以写博客，写一点论文解读，写的过程可以解决你没看懂的很多问题。</li></ul><p>下面要开始找实习和准备下一阶段工作了，希望中意的几家公司能要我吧哈哈。这里也感谢所有一直以来支持我的朋友们，祝你们早日顶会发到手软。还有我的几个儿子们，不知道什么时候才能开学呢，几个月没见了，请你们的饭局要约起来了。最后微信名终于改掉了（不中 paper 不改名，拜拜~），下面该考虑脱单的事宜了，操劳的爸妈都把乡下老房子装修好了，就等着我领一个回家了，不知道发量日渐稀少可还有人要哦。</p><p><img src="9.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> 经验总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 90】5种方法：求解数组中出现次数超过一半的那个数</title>
      <link href="/2020/04/04/leetcode-inteview-39/"/>
      <url>/2020/04/04/leetcode-inteview-39/</url>
      
        <content type="html"><![CDATA[<p><img src="1.jpg" alt="论文中了，非常感谢各位的支持！"></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" title="LeetCode 面试题39. 数组中出现次数超过一半的数字" target="_blank" rel="noopener">LeetCode 面试题39. 数组中出现次数超过一半的数字</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>说明：</strong></p><ul><li>1 &lt;= 数组长度 &lt;= 50000</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1, 2, 3, 2, 2, 2, 5, 4, 2]输出:2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>这个方法最简单，用哈希表记录每个数字出现的次数，最后看哪个数字次数超过一半就行了。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>对数组从小到大进行排序，那么众数一定在 <code>nums[n/2]</code> 处。为什么呢？</p><p>因为排序后相同的数都连续了，所以众数最左端的极限情况就是从下标 <code>0</code> 开始往后排，那么因为超过了一半，所以尾部下标一定会超过 <code>n/2</code> 。而最右端的极限情况就是从下标 <code>n-1</code> 往前排，因为超过了一半，所以头部下标也会在 <code>n/2</code> 之前。</p><p>综上，众数所在的区间一定会包含下标 <code>n/2</code> 。</p><p>时间复杂度 $O(n \log n)$ ，空间复杂度 $O(\log n)$ 。</p><h3 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h3><p>其实我第一个想到的方法反而是这个反常规的随机采样方法。因为众数超过了一半，所以采样大概率会采到这个众数。</p><p>那么我们随机采样一个数，然后遍历一遍数组看它的个数。如果个数超过了一半就是它了，否则继续采样，直到采到众数。</p><p>平均时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>如果把区间 <code>[0, n-1]</code> 平均分成两半，那么我们可以证明，原来的众数在某一半区间里依然是众数。</p><p>为什么呢？反证法，假设两半区间的众数都不是原来的众数，那么在左半区间原来的众数一定小于一半，右半区间也是的。加起来之后总数一定小于一半的，和条件是矛盾的。</p><p>所以我们递归求解两半区间的众数，然后看哪个数出现次数较多，众数就是它了。</p><p>时间复杂度 $O(n \log n)$ ，空间复杂度 $O(\log n)$ 。</p><h3 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h3><p>这个方法我一开始也想到了，但是没有想到这竟然有理论解释，而且是大名鼎鼎的摩尔投票算法。</p><p>它的主要步骤是这样的：</p><ul><li>初始化两个变量， <code>cand</code> 表示候选人，<code>cnt</code> 表示赞同它的票数。</li><li>如果 <code>cnt = 0</code>，那么 <code>cand</code> 就设置为当前的数字。</li><li>如果 <code>cand</code> 等于当前数字，那么票数 <code>cnt</code> 加一，否则票数减一。</li><li>最后 <code>cand</code> 就是得票超过一半的众数。</li></ul><p>严格证明比较复杂，是一篇论文，这里说个比较好理解的思路：</p><ul><li>如果当前候选人是众数，那么其他的众数会支持自己，其他的数反对自己。但是因为众数超过了一半，所以众数最后一定会当选。</li><li>如果当前候选人不是众数，那么就惨了，其他的数和众数全都会反对他。那反对票远远超过一半了，肯定会下台，然后换候选人。</li><li>上面两种情况会在 <code>cnt = 0</code> 的时刻进行转换，也就是换候选人。</li></ul><p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="哈希表（c-）"><a href="#哈希表（c-）" class="headerlink" title="哈希表（c++）"></a>哈希表（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>k<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">:</span> mp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">></span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> k<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序（c-）"><a href="#排序（c-）" class="headerlink" title="排序（c++）"></a>排序（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="随机采样（c-）"><a href="#随机采样（c-）" class="headerlink" title="随机采样（c++）"></a>随机采样（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分治（c-）"><a href="#分治（c-）" class="headerlink" title="分治（c++）"></a>分治（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numCount</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findMajority</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ml <span class="token operator">=</span> <span class="token function">findMajority</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mr <span class="token operator">=</span> <span class="token function">findMajority</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ml <span class="token operator">==</span> mr<span class="token punctuation">)</span> <span class="token keyword">return</span> ml<span class="token punctuation">;</span>        <span class="token keyword">int</span> cl <span class="token operator">=</span> <span class="token function">numCount</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> ml<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cr <span class="token operator">=</span> <span class="token function">numCount</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cl <span class="token operator">&lt;</span> cr <span class="token operator">?</span> mr <span class="token operator">:</span> ml<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">findMajority</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="摩尔投票（c-）"><a href="#摩尔投票（c-）" class="headerlink" title="摩尔投票（c++）"></a>摩尔投票（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cand <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cnt<span class="token punctuation">)</span> cand <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> cand<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> cnt<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cand<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈希表（python）"><a href="#哈希表（python）" class="headerlink" title="哈希表（python）"></a>哈希表（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        counts <span class="token operator">=</span> collections<span class="token punctuation">.</span>Counter<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>counts<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span>counts<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序（python）"><a href="#排序（python）" class="headerlink" title="排序（python）"></a>排序（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="随机采样（python）"><a href="#随机采样（python）" class="headerlink" title="随机采样（python）"></a>随机采样（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        majority_count <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            candidate <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>            <span class="token keyword">if</span> sum<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">for</span> elem <span class="token keyword">in</span> nums <span class="token keyword">if</span> elem <span class="token operator">==</span> candidate<span class="token punctuation">)</span> <span class="token operator">></span> majority_count<span class="token punctuation">:</span>                <span class="token keyword">return</span> candidate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分治（python）"><a href="#分治（python）" class="headerlink" title="分治（python）"></a>分治（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> lo<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> hi<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">majority_element_rec</span><span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> lo <span class="token operator">==</span> hi<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>lo<span class="token punctuation">]</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>hi<span class="token operator">-</span>lo<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token operator">+</span>lo            left <span class="token operator">=</span> majority_element_rec<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>            right <span class="token operator">=</span> majority_element_rec<span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>            <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>                <span class="token keyword">return</span> left            left_count <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> left<span class="token punctuation">)</span>            right_count <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> right<span class="token punctuation">)</span>            <span class="token keyword">return</span> left <span class="token keyword">if</span> left_count <span class="token operator">></span> right_count <span class="token keyword">else</span> right        <span class="token keyword">return</span> majority_element_rec<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="摩尔投票（python）"><a href="#摩尔投票（python）" class="headerlink" title="摩尔投票（python）"></a>摩尔投票（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">=</span> <span class="token number">0</span>        candidate <span class="token operator">=</span> None        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                candidate <span class="token operator">=</span> num            count <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> num <span class="token operator">==</span> candidate <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> candidate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 89】手动实现字符串转整数（atoi）函数，你会吗？</title>
      <link href="/2020/04/03/leetcode-8/"/>
      <url>/2020/04/03/leetcode-8/</url>
      
        <content type="html"><![CDATA[<p><img src="1.jpg" alt="还有几个小时ACL2020就出结果了，祈祷！"></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" title="LeetCode 字符串转换整数（atoi）" target="_blank" rel="noopener">LeetCode 字符串转换整数（atoi）</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><ul><li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li><li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li><li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li></ul><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 <code>0</code> 。</p><p><strong>说明：</strong></p><ul><li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li><li>假设我们的环境只能存储 <code>32</code> 位大小的有符号整数，那么其数值范围为 $[−2^{31},  2^{31} − 1]$。如果数值超过这个范围，请返回 <code>INT_MAX</code> （$2^{31} − 1$） 或 <code>INT_MIN</code> （$−2^{31}$） 。</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："42"输出:42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："   -42"输出:-42解释：第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："4193 with words"输出:4193解释：转换截止于数字 '3' ，因为它的下一个字符不为数字。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："words and 987"输出:0解释：第一个非空字符是 'w', 但它不是数字或正、负号。因此无法执行有效的转换。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例5</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："-91283472332"输出:-2147483648解释：数字 "-91283472332" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>官方题解用的有限状态自动机，理解起来也是比较轻松的，写起来也避免了一堆臃肿的 <code>if-else</code> 。但是我这里就不用自动机了，直接模拟就行了，写起来也很轻松好理解！</p><ul><li><p>首先用一个变量 <code>idx</code> 标记当前遍历到的位置，用 <code>sign = 1, -1</code> 表示整数的正负性。</p></li><li><p>然后从 <code>idx = 0</code> 开始，将开头的空格全部去掉。</p></li><li><p>然后判断当前的位置 <code>idx</code> 处的字符是不是 <code>+, -</code> 或者数字，并且 <code>idx</code> 要小于字符串长度。如果一个都没满足，那么说明是非法字符串，直接返回 <code>0</code> 。</p></li><li><p>然后如果当前的位置 <code>idx</code> 处的字符是 <code>-</code> ，那么就令 <code>sign = -1</code> 。否则如果是 <code>+</code> ，就令 <code>sign = 1</code> 。然后遍历后一个字符。</p></li><li><p>最后遍历一段连续的数字，把它转换成整数，注意转换的时候要乘上符号位 <code>sign</code> 。如果发现数字超过了 <code>[INT_MIN, INT_MAX]</code> 范围，就直接返回最大最小值就行了。</p></li><li><p>否则的话最后就是合法整数，直接返回答案。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">>=</span> n <span class="token operator">||</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'+'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'-'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isdigit</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sign <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token function">isdigit</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> res<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>sign<span class="token operator">*</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">></span> INT_MAX<span class="token punctuation">)</span> <span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> INT_MIN<span class="token punctuation">)</span> <span class="token keyword">return</span> INT_MIN<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>        n<span class="token punctuation">,</span> idx <span class="token operator">=</span> len<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        res<span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">if</span> idx <span class="token operator">>=</span> n <span class="token operator">or</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'+'</span> <span class="token operator">and</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'-'</span> <span class="token operator">and</span> <span class="token operator">not</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>            sign <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">:</span>            idx <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> str<span class="token punctuation">[</span>idx<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> c<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">break</span>            res <span class="token operator">=</span> res<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>sign<span class="token operator">*</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> res <span class="token operator">></span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> res <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正则表达式（python）"><a href="#正则表达式（python）" class="headerlink" title="正则表达式（python）"></a>正则表达式（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>min<span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token operator">*</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'^[\+\-]?\d+'</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">31</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 88】超越妹妹教你如何做这道排序题</title>
      <link href="/2020/04/02/leetcode-inteview-16-16/"/>
      <url>/2020/04/02/leetcode-inteview-16-16/</url>
      
        <content type="html"><![CDATA[<p><img src="1.jpg" alt="每日一图：我老婆可爱不？"></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/sub-sort-lcci/" title="LeetCode 面试题 16.16. 部分排序" target="_blank" rel="noopener">LeetCode 面试题 16.16. 部分排序</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，编写一个函数，找出索引 <code>m</code> 和 <code>n</code>，只要将索引区间 <code>[m, n]</code> 的元素排好序，整个数组就是有序的。注意：<code>n-m</code> 尽量最小，也就是说，找出符合条件的最短序列。函数返回值为 <code>[m, n]</code>，若不存在这样的 <code>m</code> 和 <code>n</code>（例如整个数组是有序的），请返回 <code>[-1, -1]</code>。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,4,7,10,11,7,12,6,7,16,18,19]输出:[3,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ul><li><code>0 &lt;= len(array) &lt;= 1000000</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先虽然题目没说，但是实际运行下来数列是单调递增的，所以我们下面默认数列是递增的。</p><p>那么对于元素 <code>a[i]</code> 来说，如果它左边存在大于 <code>a[i]</code> 的元素，那么 <code>a[i]</code> 是一定要参与到排序里去的。或者说如果它右边存在小于 <code>a[i]</code> 的元素，那么 <code>a[i]</code> 也是要参与到排序里去的。</p><p>所以我们只需要寻找最靠右的那个数（满足左边存在大于它的数），和最靠左的那个数（满足右边存在小于它的数），那么这两个数之间就是要排序的区间了。</p><p>为什么最靠右的那个（满足左边存在大于它的数）数一定能保证右边没有更小的数了呢？因为如果右边还有更小的数，那么那个更小的数才是更靠右的啊，这就矛盾了。</p><p>所以我们只需要从左到右扫描一遍，用一个变量维护一下最大值就行了，然后反向再遍历一遍，维护一个最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">subSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxx <span class="token operator">=</span> INT_MIN<span class="token punctuation">,</span> minn <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> maxx<span class="token punctuation">)</span> r <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">else</span> maxx <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> minn<span class="token punctuation">)</span> l <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">else</span> minn <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>l<span class="token punctuation">,</span> r<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> array<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>        maxx<span class="token punctuation">,</span> minn <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10000000</span><span class="token punctuation">,</span> <span class="token number">10000000</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> maxx<span class="token punctuation">:</span> r <span class="token operator">=</span> i            <span class="token keyword">else</span><span class="token punctuation">:</span> maxx <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> minn<span class="token punctuation">:</span> l <span class="token operator">=</span> i            <span class="token keyword">else</span><span class="token punctuation">:</span> minn <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>l<span class="token punctuation">,</span> r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！<br><img src="/medias/contact.jpg" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 87】今天我脱单了，所以大家不用做题了！</title>
      <link href="/2020/04/01/leetcode-1111/"/>
      <url>/2020/04/01/leetcode-1111/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><div align="center"><audio controls="controls" height="100" width="100" autoplay="autoplay" loop="loop"><source src="zhejiushiaima.mp3" type="audio/mp3"></audio></div><blockquote><p>想啥呢，我哪来的女朋友？今天是愚人节，还是给我老老实实做题吧。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/" title="LeetCode 1111. 有效括号的嵌套深度" target="_blank" rel="noopener">LeetCode 1111. 有效括号的嵌套深度</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题面太长晦涩不想看，请直接跳到最后一段。</p></blockquote><p><strong>有效括号字符串</strong> 仅由 <code>&quot;(&quot;</code> 和 <code>&quot;)&quot;</code> 构成，并符合下述几个条件之一：</p><ul><li>空字符串</li><li>连接，可以记作 <code>AB</code>（<code>A</code> 与 <code>B</code> 连接），其中 <code>A</code> 和 <code>B</code> 都是有效括号字符串</li><li>嵌套，可以记作 <code>(A)</code>，其中 A 是有效括号字符串</li></ul><p>类似地，我们可以定义任意有效括号字符串 <code>s</code> 的 <strong>嵌套深度</strong> <code>depth(s)</code>：</p><ul><li><code>s</code> 为空时，<code>depth(&quot;&quot;) = 0</code></li><li><code>s</code> 为 <code>A</code> 与 <code>B</code> 连接时，<code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是有效括号字符串</li><li><code>s</code> 为嵌套情况，<code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是有效括号字符串</li></ul><p>例如：<code>&quot;&quot;</code>，<code>&quot;()()&quot;</code>，和 <code>&quot;()(()())&quot;</code> 都是有效括号字符串，嵌套深度分别为 <code>0</code>，<code>1</code>，<code>2</code>，而 <code>&quot;)(&quot;</code> 和 <code>&quot;(()&quot;</code> 都不是有效括号字符串。</p><p>给你一个有效括号字符串 <code>seq</code>，将其分成两个不相交的子序列 <code>A</code> 和 <code>B</code>，且 <code>A</code> 和 <code>B</code> 满足有效括号字符串的定义（注意：<code>A.length + B.length = seq.length</code>）。</p><p>现在，你需要从中选出 <strong>任意</strong> 一组有效括号字符串 <code>A</code> 和 <code>B</code>，使 <code>max(depth(A), depth(B))</code> 的可能取值最小。</p><p>返回长度为 <code>seq.length</code> 答案数组 <code>answer</code> ，选择 <code>A</code> 还是 <code>B</code> 的编码规则是：如果 <code>seq[i]</code> 是 <code>A</code> 的一部分，那么 <code>answer[i] = 0</code>。否则，<code>answer[i] = 1</code>。即便有多个满足要求的答案存在，你也只需返回 <strong>一个</strong>。</p><blockquote><p>不是我吹牛，我估计一大部分人看完都不知道题目什么意思。一句话概括就是，给你一个合法的括号序列，你需要将其拆分成两个合法的子序列（不连续），使得两个子序列的括号嵌套深度较大者尽量的小。</p></blockquote><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：seq = "(()())"输出:[0,1,1,1,1,0]解释：拆成 "()" 和 "()()" ，最大嵌套深度为 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：seq = "()(())()"输出:[0,0,0,1,1,0,1,1]解释：拆成 "()()" 和 "()()" ，最大嵌套深度为 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ul><li><code>1 &lt;= text.size &lt;= 10000</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>既然想要两个子序列的嵌套深度中较大者尽量小，那么我们最好能够让两个子序列的嵌套深度相同。</p><p>再考虑任意一个原序列中嵌套深度为 $d$ 的合法子序列，我们要想办法把它拆成两半。那么最优的方法肯定是一半嵌套深度为 $\lfloor d/2 \rfloor$ ，一半是 $d - \lfloor d/2 \rfloor$ 。这样两个子序列中嵌套深度较大值就是 $\lceil d/2 \rceil$，而其它任何分法都会导致较大值大于它。</p><p>那么怎么样才能对半分呢？这个其实随意了，但是最为方便的方法就是，嵌套深度为奇数的作为一个子序列，偶数的作为另一个子序列，这样就对半分了，代码还好写。</p><p>具体实现上，我们用一个变量 $cnt$ 来表示当前括号的嵌套深度，那么遇到左括号就深度加一，遇到右括号嵌套深度就是当前的 $cnt$ ，但是遍历完这个括号之后，深度要减一，然后嵌套深度为奇数的括号位置处标记为 1 就行了。</p><p>伪代码也就是：</p><pre class="line-numbers language-text"><code class="language-text">if c = '('    cnt := cnt + 1    mask := cnt&1else    mask := cnt&1    cnt := cnt - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>其实我们可以注意到，不管是加一还是减一，奇偶性的变化都是一致的，也就是减一之后的奇偶性和加一之后是相同的。</p><p>所以我们把减一也变成加一，那么不管遇到什么括号，都是 $cnt$ 加一了，那不就变成了下标 $i$ 了吗？</p><p>我们把上面的伪代码按照这种思路改变一下：</p><pre class="line-numbers language-text"><code class="language-text">if c = '('    cnt := cnt + 1    mask := cnt&1else    mask := cnt&1    cnt := cnt + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后用下标 $i$ 替换掉 $cnt$ :</p><pre class="line-numbers language-text"><code class="language-text">if c = '('    mask := (i+1)&1else    mask := i&1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>继续改写一下，让形式统一一点：</p><pre class="line-numbers language-text"><code class="language-text">if c = '('    mask := ~(i&1)else    mask := i&1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么最后就可以把这两种情况合并了，也就是标记值直接就等于 <code>(i&amp;1)^(c=&#39;(&#39;)</code> 。</p><p>当然我是从代码的角度，从奇偶性推过来的，官方题解是直接严格证明了正确性：</p><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solution/you-xiao-gua-hao-de-qian-tao-shen-du-by-leetcode-s/" title="官方题解：LeetCode 1111. 有效括号的嵌套深度" target="_blank" rel="noopener">官方题解：LeetCode 1111. 有效括号的嵌套深度</a></p><p><img src="1.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxDepthAfterSplit</span><span class="token punctuation">(</span>string seq<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> seq<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">++</span>cnt<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cnt<span class="token operator">--</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepthAfterSplit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seq<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        cnt <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> seq<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>                cnt <span class="token operator">+=</span> <span class="token number">1</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cnt<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cnt<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>                cnt <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简化（c-）"><a href="#简化（c-）" class="headerlink" title="简化（c++）"></a>简化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxDepthAfterSplit</span><span class="token punctuation">(</span>string seq<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> seq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简化（python）"><a href="#简化（python）" class="headerlink" title="简化（python）"></a>简化（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxDepthAfterSplit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seq<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>seq<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 86】面试经典题：把数字翻译成字符串</title>
      <link href="/2020/03/31/leetcode-inteview-46/"/>
      <url>/2020/03/31/leetcode-inteview-46/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" title="LeetCode 面试题46. 把数字翻译成字符串" target="_blank" rel="noopener">LeetCode 面试题46. 把数字翻译成字符串</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：12258输出:5解释：12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ul><li>$0 \le num &lt; 2^{31}$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然这题就是个动态规划问题，我们令 $f[i]$ 表示 $num$ 到第 $i$ 位为止表示的方法数。</p><p>那么我们观察 $num$ 的第 $i$ 位和第 $i-1$ 位，也就是最后两位，记为 $last$。如果 $10 \le last \le 25$，那么就可以把这两位合并成一个字母表示，同时也可以分成两个字母表示，所以 $f[i] = f[i-1] + f[i-2]$ 。但是如果 $last &gt; 25$ ，那就只能分成两个字母来表示了，所以 $f[i] = f[i-1]$ 。那如果 $last &lt; 10$ 会怎么样呢？那说明最后两位是 $0x$ 的形式，这种形式没有办法用一个字母表示，所以只能分成两个字母表示，所以 $f[i] = f[i-1]$ 。</p><p>综上，如果 $10 \le last \le 25$，就有 $f[i] = f[i-1] + f[i-2]$ ；否则的话就有 $f[i] = f[i-1]$ 。</p><p>当然上面这是把 $num$ 拆成了数字形式的字符串来做的，其实这题也可以直接用递归，这样都不用转变成字符串形式了。</p><p>我们直接令 $f(num)$ 表示数字 $num$ 的方法数。那么最后两位结果就是 $last = num \% 100$ ，那么如果 $10 \le last \le 25$，就有 $f(num) = f(num/10) + f(num/100)$ ；否则的话就有 $f(num) = f(num/10)$ 。递归的终止条件就是，如果 $num &lt; 10$ ，那么只有一种表示方法。</p><p>当然这里递归有重复计算，可以采用记忆化搜索，但是因为复杂度太低了，没有必要。</p><p>时间复杂度为 $O(\log_{10}{num})$，也就是 $num$ 的位数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>num<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> last <span class="token operator">=</span> num<span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&lt;=</span> last <span class="token operator">&amp;&amp;</span> last <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>num<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">translateNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>        res<span class="token punctuation">,</span> last <span class="token operator">=</span> self<span class="token punctuation">.</span>translateNum<span class="token punctuation">(</span>num<span class="token operator">//</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> num<span class="token operator">%</span><span class="token number">100</span>        <span class="token keyword">if</span> <span class="token number">10</span><span class="token operator">&lt;=</span>last<span class="token operator">&lt;=</span><span class="token number">25</span><span class="token punctuation">:</span> res <span class="token operator">+=</span> self<span class="token punctuation">.</span>translateNum<span class="token punctuation">(</span>num<span class="token operator">//</span><span class="token number">100</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 85】图解算法：一行代码解决约瑟夫环的变体</title>
      <link href="/2020/03/30/leetcode-390/"/>
      <url>/2020/03/30/leetcode-390/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/elimination-game/" title="LeetCode 390. 消除游戏" target="_blank" rel="noopener">LeetCode 390. 消除游戏</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个从 $1$ 到 $n$ 排序的整数列表。<br>首先，从左到右，从第一个数字开始，每隔一个数字进行删除，直到列表的末尾。<br>第二步，在剩下的数字中，从右到左，从倒数第一个数字开始，每隔一个数字进行删除，直到列表开头。<br>我们不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。<br>返回长度为 $n$ 的列表中，最后剩下的数字。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 9,1 2 3 4 5 6 7 8 92 4 6 82 66输出:6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>还记得几天前讲过的约瑟夫环问题吗？不记得了就回顾一下吧：</p><p><a href="https://godweiyang.com/2020/03/19/leetcode-interview-62/" title="韦阳的博客：【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！">韦阳的博客：【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！</a></p><p><a href="https://zhuanlan.zhihu.com/p/114391147" title="知乎专栏：【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！" target="_blank" rel="noopener">知乎专栏：【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！</a></p><p>当时我们的方法是通过编号映射来递归寻找下一轮存活的人的，那么这题也可以尝试用同样的方法。</p><p>我们分奇偶两种情况来考虑。</p><p><img src="1.jpg" alt><br>如果 $n=2k$ ，那么如上图所示，第一轮消除完了之后，剩下的数字就是绿色的偶数部分。</p><p>接着就要从右往左递归地消除了，那我们从右往左给绿色数字重新编号为 $1$ 到 $k$ ，问题就转化为了 $k$ 个数字的情况下，最后剩余的数字是几了。</p><p>假设我们用 $f(2k)$ 表示初始时 $n=2k$ 个数字最后剩下的编号，那么绿色部分重新编号后最后剩下的数字就是 $f(k)$ 。但是怎么将 $f(k)$ 重新映射回绿色的数字编号呢？</p><p>通过观察我们可以发现，绿色数字整除 $2$ ，再加上蓝色的映射后的编号，结果一定等于 $k+1$ 。所以我们就得到了映射回去的公式：<br>$$<br>f(2k) = 2(k+1-f(k))<br>$$</p><p>比如说你求出来 $f(k) = 2$ ，也就是蓝色部分最后剩下的数字是 $2$ ，那么映射成绿色的编号就是 $2k-2$ ，这就是最初的编号了。</p><p><img src="2.jpg" alt></p><p>如果 $n=2k+1$ ，那么如上图所示，只需要在后面加个橙色的 $2k+1$ 就行了。</p><p>但是第一轮的时候它就被消除了，所以绿色的剩下的编号和之前偶数情况没有任何区别。所以最终的答案也是：<br>$$<br>f(2k+1) = 2(k+1-f(k))<br>$$</p><p>最后发现奇偶情况下，公式其实可以统一起来，用 $n$ 来替换 $k$ 就得到了：<br>$$<br>f(n) = 2\left(\left\lfloor\frac{n}{2}\right\rfloor-f\left(\left\lfloor\frac{n}{2}\right\rfloor\right)\right)<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span><span class="token function">lastRemaining</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>self<span class="token punctuation">.</span>lastRemaining<span class="token punctuation">(</span>n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 84】面试必考题：Trie（字典树/前缀树）的实现</title>
      <link href="/2020/03/29/leetcode-208/"/>
      <url>/2020/03/29/leetcode-208/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" title="LeetCode 208. 实现 Trie (前缀树)" target="_blank" rel="noopener">LeetCode 208. 实现 Trie (前缀树)</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个 Trie （前缀树），包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">Trie trie = new Trie();trie.insert("apple");trie.search("apple");   // 返回 truetrie.search("app");     // 返回 falsetrie.startsWith("app"); // 返回 truetrie.insert("app");   trie.search("app");     // 返回 true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ul><li>你可以假设所有的输入都是由小写字母 $a-z$ 构成的。</li><li>保证所有输入均为非空字符串。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>字典树主要支持<strong>插入字符串、查询字符串是否在字典树中、查询字典树中是否存在某个前缀</strong>等操作，我这里还额外实现了一下 c++ 版本的<strong>删除字符串</strong>操作。</p><h3 id="初始化字典树"><a href="#初始化字典树" class="headerlink" title="初始化字典树"></a>初始化字典树</h3><p>初始化的时候，根结点为空，不用来放任何字符，所有字符串都是从下一层子结点开始存储。</p><p>每个结点有 26 个指针，指向下一层子结点，每个指针代表着下一个不同的字母。</p><p>每个结点还保存了一个变量 <code>isEnd</code> ，用来表示该结点是不是某个字符串结束的位置。</p><h3 id="插入字符串"><a href="#插入字符串" class="headerlink" title="插入字符串"></a>插入字符串</h3><p>从根结点往下递归，如果字符串中下一个字母对应的子结点为空，那就新建一个结点再递归，否则的话就直接递归下去。</p><p>最后把最后一个结点的 <code>isEnd</code> 设置为 1，表示这个结点是字符串的结束位置。</p><h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>从根结点往下递归查找，如果字符串还没遍历结束，但是结点已经空了，说明字符串不在字典树中。否则的话一直查找到最后一个字符，然后看对应结点的 <code>isEnd</code> 是 1 还是 0，如果是 1 ，就存在字符串，否则不存在。</p><h3 id="查询字符串前缀"><a href="#查询字符串前缀" class="headerlink" title="查询字符串前缀"></a>查询字符串前缀</h3><p>和查询字符串过程一模一样，唯一的区别就是最后不用看最后一个结点的 <code>isEnd</code> 了，直接返回 <code>true</code> 。因为既然都查询到了最后一个字符了，说明这个前缀一定存在。</p><h3 id="删除字符串"><a href="#删除字符串" class="headerlink" title="删除字符串"></a>删除字符串</h3><p>这个是我自己实现的，一般来说字典树很少用到删除操作。</p><p>首先整体框架是和查询字符串类似的，从根结点往下递归查询，然后用一个栈保存查询到的结点。</p><p>如果查询过程中直接遇到了空结点，就直接返回，因为都不存在字符串，就不用删除了。然后判断最后一个结点的类型。</p><p>如果它的 <code>isEnd</code> 是 0，说明字符串不存在，那就直接返回不用删了。</p><p>如果它不是叶子结点，说明后面还接着字符串呢，那也不用删了，只要把该结点的 <code>isEnd</code> 设置为 0 就行了。</p><p>否则的话它就是叶子结点，那么就直接删除这个结点，并且从栈里出栈。</p><p>然后从栈里最后一个结点开始删除，直到栈顶的结点不是叶子结点（表示字典树中存在删除字符串的相同前缀字符串）或者 <code>isEnd</code> 是 1（表示字典树中存在删除字符串的前缀子串）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>具体实现上面，c++ 我采用的结构体指针来构建出了一颗树。而 python 我直接用的嵌套的字典，并没有真正的构建出树，只有一个类，这样还挺方便的，但是删除操作有点麻烦，暂时就不写了。</p><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> isEnd<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>Trie<span class="token operator">*</span><span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        isEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> vector<span class="token operator">&lt;</span>Trie<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> next<span class="token punctuation">)</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            node <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        node<span class="token operator">-</span><span class="token operator">></span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token operator">&lt;</span>Trie<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>isEnd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isLeaf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            node<span class="token operator">-</span><span class="token operator">></span>isEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">delete</span> node<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeaf</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>isEnd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">delete</span> node<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">search</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> node<span class="token operator">-</span><span class="token operator">></span>isEnd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>string prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isLeaf</span><span class="token punctuation">(</span>Trie<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>nxt <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>nxt        <span class="token keyword">for</span> c <span class="token keyword">in</span> word<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> node<span class="token punctuation">:</span>                node<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            node <span class="token operator">=</span> node<span class="token punctuation">[</span>c<span class="token punctuation">]</span>        node<span class="token punctuation">[</span><span class="token string">'#'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>nxt        <span class="token keyword">for</span> c <span class="token keyword">in</span> word<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> node<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            node <span class="token operator">=</span> node<span class="token punctuation">[</span>c<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token string">'#'</span> <span class="token keyword">in</span> node    <span class="token keyword">def</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prefix<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>nxt        <span class="token keyword">for</span> c <span class="token keyword">in</span> prefix<span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> node<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            node <span class="token operator">=</span> node<span class="token punctuation">[</span>c<span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 83】邻居小孩一年级就会的乘法表，你会吗？</title>
      <link href="/2020/03/28/leetcode-668/"/>
      <url>/2020/03/28/leetcode-668/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/" title="LeetCode 668. 乘法表中第k小的数" target="_blank" rel="noopener">LeetCode 668. 乘法表中第k小的数</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>几乎每一个人都用乘法表。但是你能在乘法表中快速找到第 $k$ 小的数字吗？</p><p>给定高度 $m$、宽度 $n$ 的一张 $m \times n$ 的乘法表，以及正整数 $k$，你需要返回表中第 $k$ 小的数字。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：m = 3, n = 3, k = 5输出：3解释：乘法表:1    2    32    4    63    6    9第5小的数字是 3 (1, 2, 2, 3, 3).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：m = 2, n = 3, k = 6输出：6解释：乘法表:1    2    32    4    6第6小的数字是 6 (1, 2, 2, 3, 4, 6).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><ul><li>$m$ 和 $n$ 的范围在 $[1, 30000]$ 之间。</li><li>$k$ 的范围在 $[1, mn]$ 之间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>因为 $mn$ 数量级是 $9 \times 10^8$ 级别的，所以显然不能直接枚举，要想一个对数级别的算法。</p><p>对数级别首先想到的肯定是二分了，我们二分第 $k$ 小的数 $mid$ ，然后求出乘法表中小于等于 $mid$ 的数的数量 $cnt$ 。如果发现 $cnt \le mid$ ，那就说明这个答案太大了，还可以继续缩小。否则的话答案太小了，得增大一点。</p><p>那么对于枚举的答案 $mid$ 来说，如何找到乘法表中有多少小于等于它的数呢？我们可以直接从 $1$ 开始枚举，和 $1$ 相乘并且结果小于等于 $mid$ 的数有 $mid$ 个，当然还有个 $n$ 的限制，所以是 $\min{(mid, n)}$ 个。然后和 $2$ 相乘并且结果小于等于 $mid$ 的数有 $\min{(\left\lfloor\frac{mid}{2}\right\rfloor, n)}$ 个。依此类推下去，最终和 $m$ 相乘并且结果小于等于 $mid$ 的数有 $\min{(\left\lfloor\frac{mid}{m}\right\rfloor, n)}$ 个。</p><p>所以最终小于等于 $mid$ 的个数 $cnt$ 就可以计算为：<br>$$<br>\sum_{i=1}^{m}{\min{\left(\left\lfloor\frac{mid}{i}\right\rfloor, n\right)}}<br>$$</p><h3 id="二分法-优化"><a href="#二分法-优化" class="headerlink" title="二分法+优化"></a>二分法+优化</h3><p>当然这题计算还可以进行一些优化。</p><p>首先第 $k$ 小的数是一定小于等于 $k$ 的，所以我们的二分上界可以定为 $k$ 。</p><p>其次注意到当 $i &gt; mid$ 之后，个数一定是 $0$，所以 $i$ 只需要枚举到 $\min{(mid, m)}$ 就行了。</p><p>然后当 $i \le \left\lfloor\frac{mid}{n}\right\rfloor$ 时，有 $\min{\left(\left\lfloor\frac{mid}{i}\right\rfloor, n\right)} = n$，所以这部分的求和结果就是 $n\left\lfloor\frac{mid}{n}\right\rfloor$ 。所以 $cnt$ 又可以写为：<br>$$<br>n\left\lfloor\frac{mid}{n}\right\rfloor + \sum_{i=\left\lfloor\frac{mid}{n}\right\rfloor+1}^{\min{(mid, m)}}{\left\lfloor\frac{mid}{i}\right\rfloor}<br>$$</p><p>最后，对于某个 $i = t$ ，我们会发现如果 $i$ 慢慢增大，某一段连续区间内 $\left\lfloor\frac{mid}{i}\right\rfloor$ 的值都是不会变的。而 $i$ 最大可以增大到 $\left\lfloor\frac{mid}{\left\lfloor\frac{mid}{t}\right\rfloor}\right\rfloor$，那么这一段区间内的求和就可以直接算出来：<br>$$<br>\left\lfloor\frac{mid}{t}\right\rfloor \left(\left\lfloor\frac{mid}{\left\lfloor\frac{mid}{t}\right\rfloor}\right\rfloor-t+1\right)<br>$$<br>接着令 $i$ 直接跳转到 $\left\lfloor\frac{mid}{\left\lfloor\frac{mid}{t}\right\rfloor}\right\rfloor + 1$ 就可以了，这样就不用慢慢加 $1$ 计算了。要特别注意的是最后不能超过 $m$ 。</p><p>理论上这样的计算复杂度是更低的，但是实际运行中速度还不如不加最后一步优化，可能原因是除法操作次数太多了，反而总的操作次数超过了直接遍历计算。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="二分法（c-）"><a href="#二分法（c-）" class="headerlink" title="二分法（c++）"></a>二分法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> m<span class="token operator">*</span>n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">enough</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">enough</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">/</span>i<span class="token operator">&lt;</span>n<span class="token operator">?</span>x<span class="token operator">/</span>i<span class="token operator">:</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt <span class="token operator">>=</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分法-优化（c-）"><a href="#二分法-优化（c-）" class="headerlink" title="二分法+优化（c++）"></a>二分法+优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">enough</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> m<span class="token operator">&lt;</span>mid<span class="token operator">?</span>m<span class="token operator">:</span>mid<span class="token punctuation">,</span> n<span class="token operator">&lt;</span>mid<span class="token operator">?</span>n<span class="token operator">:</span>mid<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">enough</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">/</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">/</span>n<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i <span class="token operator">=</span> d<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            d <span class="token operator">=</span> x<span class="token operator">/</span><span class="token punctuation">(</span>x<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">/</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>d<span class="token operator">&lt;</span>m<span class="token operator">?</span>d<span class="token operator">:</span>m<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt <span class="token operator">>=</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分法（python）"><a href="#二分法（python）" class="headerlink" title="二分法（python）"></a>二分法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">enough</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                cnt <span class="token operator">+=</span> x<span class="token operator">//</span>i <span class="token keyword">if</span> x<span class="token operator">//</span>i<span class="token operator">&lt;</span>n <span class="token keyword">else</span> n            <span class="token keyword">return</span> cnt <span class="token operator">>=</span> k        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token operator">*</span>n        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> enough<span class="token punctuation">(</span>mid<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> r <span class="token operator">=</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span> l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分法-优化（python）"><a href="#二分法-优化（python）" class="headerlink" title="二分法+优化（python）"></a>二分法+优化（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">enough</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt<span class="token punctuation">,</span> i<span class="token punctuation">,</span> d <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">//</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token operator">//</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>                d <span class="token operator">=</span> x<span class="token operator">//</span><span class="token punctuation">(</span>x<span class="token operator">//</span>i<span class="token punctuation">)</span>                cnt <span class="token operator">+=</span> <span class="token punctuation">(</span>x<span class="token operator">//</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>d <span class="token keyword">if</span> d<span class="token operator">&lt;</span>m <span class="token keyword">else</span> m<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                i <span class="token operator">=</span> d<span class="token operator">+</span><span class="token number">1</span>            <span class="token keyword">return</span> cnt <span class="token operator">>=</span> k        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> k        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> enough<span class="token punctuation">(</span>mid<span class="token punctuation">,</span> m <span class="token keyword">if</span> m<span class="token operator">&lt;</span>mid <span class="token keyword">else</span> mid<span class="token punctuation">,</span> n <span class="token keyword">if</span> n<span class="token operator">&lt;</span>mid <span class="token keyword">else</span> mid<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span> r <span class="token operator">=</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span> l <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 82】面试经典题：求第K大数，我写了11种实现，不来看看吗？</title>
      <link href="/2020/03/27/leetcode-215/"/>
      <url>/2020/03/27/leetcode-215/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" title="LeetCode 215. 数组中的第K个最大元素" target="_blank" rel="noopener">LeetCode 215. 数组中的第K个最大元素</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,1,5,6,4] 和 k = 2输出：5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,3,1,2,4,5,5,6] 和 k = 4输出：4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解释：</strong></p><ul><li>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>对数组从大到小排序，取第 $k$ 个元素。</p><p>或者从小到大排序，取第 $n-k+1$ 个元素。</p><h3 id="小根堆-库函数"><a href="#小根堆-库函数" class="headerlink" title="小根堆+库函数"></a>小根堆+库函数</h3><p><code>c++</code> 自带 <code>priority_queue&lt;int&gt;</code> ，可以实现小根堆。</p><p><code>python</code> 自带 <code>heapq</code> ，可以实现小根堆，同时还自带 <code>nlargest</code> 函数可以直接求出前 $k$ 大元素。</p><p>然后维护一个大小为 $k$ 的小根堆，保存最大的 $k$ 个数，堆顶就是第 $k$ 大的数。新元素入堆，如果堆中元素个数大于 $k$ ，就将堆顶元素出堆。</p><h3 id="大根堆-库函数"><a href="#大根堆-库函数" class="headerlink" title="大根堆+库函数"></a>大根堆+库函数</h3><p><code>c++</code> 自带 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code> ，可以实现大根堆。</p><p><code>python</code> 没有大根堆实现。</p><p>然后维护一个大小为 $n-k+1$ 的大根堆，保存最小的 $n-k+1$ 个数，堆顶就是第 $n-k+1$ 小的数，即第 $k$ 大的数。新元素入堆，如果堆中元素个数大于 $n-k+1$ ，就将堆顶元素出堆。</p><h3 id="小根堆-手写"><a href="#小根堆-手写" class="headerlink" title="小根堆+手写"></a>小根堆+手写</h3><p>利用原地算法，直接将原数组当作一个小根堆。</p><p>首先对前 $k$ 个元素建立初始堆。然后遍历后面的元素，如果大于堆顶元素的话，就和堆顶元素交换位置，并调整堆。</p><p>小根堆大小始终为 $k$ 。</p><h3 id="大根堆-手写"><a href="#大根堆-手写" class="headerlink" title="大根堆+手写"></a>大根堆+手写</h3><p>利用原地算法，直接将原数组当作一个大根堆。</p><p>首先对前 $n-k+1$ 个元素建立初始堆。然后遍历后面的元素，如果小于堆顶元素的话，就和堆顶元素交换位置，并调整堆。</p><p>大根堆大小始终为 $n-k+1$ 。</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>思想类似于快速排序，首先随机选取一个元素 $p$，然后将区间内元素比 $p$ 小的都放在 $p$ 左边，比 $p$ 大的都放在 $p$ 右边。</p><p>然后看 $p$ 的下标 $i$，如果 $i+1 = n-k+1$，那就说明 $p$ 就是第 $n-k+1$ 小（第 $k$ 大）的元素，直接返回即可。否则如果 $i+1 &lt; n-k+1$，那就说明第 $k$ 大元素在 $p$ 的右边区间内，递归寻找即可。否则就在左边区间，递归寻找。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="排序（c-）"><a href="#排序（c-）" class="headerlink" title="排序（c++）"></a>排序（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小根堆-STL优先队列（c-）"><a href="#小根堆-STL优先队列（c-）" class="headerlink" title="小根堆+STL优先队列（c++）"></a>小根堆+STL优先队列（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Q<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大根堆-STL优先队列（c-）"><a href="#大根堆-STL优先队列（c-）" class="headerlink" title="大根堆+STL优先队列（c++）"></a>大根堆+STL优先队列（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小根堆-手写（c-）"><a href="#小根堆-手写（c-）" class="headerlink" title="小根堆+手写（c++）"></a>小根堆+手写（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大根堆-手写（c-）"><a href="#大根堆-手写（c-）" class="headerlink" title="大根堆+手写（c++）"></a>大根堆+手写（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择（c-）"><a href="#快速选择（c-）" class="headerlink" title="快速选择（c++）"></a>快速选择（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> l<span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序（python）"><a href="#排序（python）" class="headerlink" title="排序（python）"></a>排序（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小根堆-heapq（python）"><a href="#小根堆-heapq（python）" class="headerlink" title="小根堆+heapq（python）"></a>小根堆+heapq（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span>k<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="小根堆-手写（python）"><a href="#小根堆-手写（python）" class="headerlink" title="小根堆+手写（python）"></a>小根堆+手写（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">:</span>                c1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span>                c <span class="token operator">=</span> c2 <span class="token keyword">if</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">and</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> c1                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                p <span class="token operator">=</span> c        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token operator">//</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            adjust<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>            nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            adjust<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大根堆-手写（python）"><a href="#大根堆-手写（python）" class="headerlink" title="大根堆+手写（python）"></a>大根堆+手写（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">:</span>                c1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span>                c <span class="token operator">=</span> c2 <span class="token keyword">if</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">and</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">else</span> c1                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                p <span class="token operator">=</span> c        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            adjust<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>            nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            adjust<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速选择（python）"><a href="#快速选择（python）" class="headerlink" title="快速选择（python）"></a>快速选择（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>            p<span class="token punctuation">,</span> m <span class="token operator">=</span> l<span class="token operator">+</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token punctuation">,</span> l            nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>                    m <span class="token operator">+=</span> <span class="token number">1</span>            nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>            <span class="token keyword">return</span> m        <span class="token keyword">def</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>            m <span class="token operator">=</span> partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span>            <span class="token keyword">if</span> k <span class="token operator">==</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span>            <span class="token keyword">if</span> k <span class="token operator">&lt;</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>            <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> k<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> quickSelect<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 81】面试经典题：关于丑数，你真的理解为什么这么算吗？</title>
      <link href="/2020/03/26/leetcode-inteview-17-09/"/>
      <url>/2020/03/26/leetcode-inteview-17-09/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/get-kth-magic-number-lcci/" title="LeetCode 面试题 17.09. 第 k 个数" target="_blank" rel="noopener">LeetCode 面试题 17.09. 第 k 个数</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：k = 5输出：9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题和主站的<strong>LeetCode 264. 丑数 II</strong>是一个意思：<br><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p>最直观的想法就是，假设已经生成了 $n$ 个丑数，那么我们把每个丑数都乘上 3，5，7，得到的结果中大于已经生成的所有丑数并且最小的那个就是下一个丑数。</p><p>但是这样会产生很多重复的丑数，所以也可以用一个优先队列，将已经生成的丑数从小到大保存下来。然后取出队首最小的那个丑数，给它乘上 3，5，7，将新的三个数入队，并且队首的这个数出队，这样就不会再产生重复的数了。</p><p>上面这种方法已经可以过这道题了，但是还有更简单的方法。</p><p>假设我们用一个数组 $f$ 来从小到大保存每一个丑数，那么 $f[0]$ 就保存着最小的丑数 1 。用三个指针 $p_3, p_5, p_7$ 分别指着最小的那个可以和 $3,5,7$ 相乘的丑数。那么初始的时候都是 0，因为 $f[0]$ 可以和三个因子相乘。</p><p>然后判断 $3f[p_3], 5f[p_5], 7f[p_7]$ 三个数谁最小，哪个新丑数最小，就让那个指针往后加 1 ，同时把那个新丑数作为下一个更大的丑数。</p><p>这么做为什么是对的呢？我们将 $f$ 数组写成三行相同的形式：</p><p><img src="1.jpg" alt></p><p>那么每一行的指针就表示了有资格和 3，5，7 相乘的最小的丑数。比如 $p_3=3$ ，那就说明只有 $f[3]$ 才有资格和 3 相乘，生成新的丑数，而之前的 $f[2]$ 早就和 3 乘过了，再乘就重复了没有意义。但是可能这时 $p_5=2$，也就是 $f[2]$ 还没和 5 乘过，所以还是有资格乘 5 生成新的丑数的。</p><p>本质上相当于用了三个优先队列，来存储已生成的丑数。但是因为已生成的丑数是递增的，所以就用普通的队列也就是数组+指针就行了。每次三个队首元素乘上对应因子比较一下，取最小的那个出队，并且三个队列都要入队新丑数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getKthMagicNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx5 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx7 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>idx3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>idx5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>idx7<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> res<span class="token punctuation">[</span>idx3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> idx3<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> res<span class="token punctuation">[</span>idx5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span> idx5<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> res<span class="token punctuation">[</span>idx7<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">)</span> idx7<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getKthMagicNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> k        idx3<span class="token punctuation">,</span> idx5<span class="token punctuation">,</span> idx7 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">[</span>idx3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>idx5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>idx7<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> res<span class="token punctuation">[</span>idx3<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">:</span> idx3 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> res<span class="token punctuation">[</span>idx5<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">:</span> idx5 <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> res<span class="token punctuation">[</span>idx7<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">7</span><span class="token punctuation">:</span> idx7 <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 80】所有人都会做的入门题，高级解法来了！</title>
      <link href="/2020/03/25/leetcode-inteview-08-31-v2/"/>
      <url>/2020/03/25/leetcode-inteview-08-31-v2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>题目还是昨天的题，昨天已经介绍了三种解法了，今天介绍一个最快的方法。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" title="LeetCode 面试题 08.01. 三步问题" target="_blank" rel="noopener">LeetCode 面试题 08.01. 三步问题</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>三步问题。有个小孩正在上楼梯，楼梯有 $n$ 阶台阶，小孩一次可以上 $1$ 阶、$2$ 阶或 $3$ 阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模 $1000000007$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 3 输出：4解释：有四种走法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 5输出：13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>昨天的题解地址：<br><a href="https://godweiyang.com/2020/03/24/leetcode-inteview-08-01/" title="韦阳的博客：【每日算法Day 79】所有人都会做的入门题，但是能看出你的代码能力！">韦阳的博客：【每日算法Day 79】所有人都会做的入门题，但是能看出你的代码能力！</a></p><p><a href="https://zhuanlan.zhihu.com/p/115799226" title="知乎专栏：【每日算法Day 79】所有人都会做的入门题，但是能看出你的代码能力！" target="_blank" rel="noopener">知乎专栏：【每日算法Day 79】所有人都会做的入门题，但是能看出你的代码能力！</a></p><p>昨天是通过动态规划来解决的，转移方程为：<br>$$<br>f[i] = f[i-1] + f[i-2] + f[i-3]<br>$$<br>初始情况是 $f[1] = 1, f[2] = 2, f[3] = 4$ 。</p><p>如果通过递推的方式来求解的话，时间复杂度是 $O(n)$ ，但是我们还可以用矩阵快速幂的方法加速到 $O(\log n)$ 。</p><p>相信大家快速幂一定听说过（没听说过当我没说），如果让你求 $a^n$，那么可以分两种情况。如果 $n$ 是偶数，那么可以计算 $a^{n/2}$，然后求它的平方 $(a^{n/2})^2$ 就行了。如果 $n$ 是奇数，那么可以计算 $a^{(n-1)/2}$，然后求它的平方 $a \cdot (a^{(n-1)/2})^2$ 就行了。这样只需要用 $O(\log n)$ 的复杂度就可以计算出 $a^n$ 了。</p><p>类似的，如果我们要计算一个矩阵的幂 $A^n$，也可以将其拆分成两半，然后计算一半再平方就行了。</p><p>那么这题跟矩阵有什么关系呢？如果我们把转移方程右边三项写成向量形式：<br>$$<br>\begin{bmatrix}<br>    f_{i-3} &amp; f_{i-2} &amp; f_{i-1}<br>\end{bmatrix}<br>$$<br>那么给它右边乘上一个矩阵 $A$：<br>$$<br>\begin{bmatrix}<br>    0 &amp; 0 &amp; 1 \\<br>    1 &amp; 0 &amp; 1 \\<br>    0 &amp; 1 &amp; 1<br>\end{bmatrix}<br>$$<br>那么就会得到向量：<br>$$<br>\begin{bmatrix}<br>    f_{i-2} &amp; f_{i-1} &amp; f_{i-1}+f_{i-2}+f_{i-3}<br>\end{bmatrix}<br>$$<br>即：<br>$$<br>\begin{bmatrix}<br>    f_{i-2} &amp; f_{i-1} &amp; f_{i}<br>\end{bmatrix}<br>$$<br>所以乘一次矩阵 $A$ 就可以得到下一个 $f$ 值，那么从初始的向量 $\begin{bmatrix}1 &amp; 2 &amp; 4\end{bmatrix}$ 开始，乘上 $A^{n-3}$ 就可以得到 $\begin{bmatrix}f_{n-2} &amp; f_{n-1} &amp; f_{n}\end{bmatrix}$ 了。</p><p>而这里的 $A^{n-3}$ 就可以通过矩阵快速幂来计算得到。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>ll<span class="token operator">>></span> vvl<span class="token punctuation">;</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span>ll<span class="token operator">></span> vl<span class="token punctuation">;</span><span class="token keyword">const</span> ll p <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vvl <span class="token function">mat_mul</span><span class="token punctuation">(</span>vvl<span class="token operator">&amp;</span> A<span class="token punctuation">,</span> vvl<span class="token operator">&amp;</span> B<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c <span class="token operator">=</span> B<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vvl <span class="token function">C</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">vl</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">(</span>C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> p<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> C<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vvl <span class="token function">mat_pow</span><span class="token punctuation">(</span>vvl<span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vvl <span class="token function">B</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token function">vl</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> B <span class="token operator">=</span> <span class="token function">mat_mul</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>            A <span class="token operator">=</span> <span class="token function">mat_mul</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>            n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> B<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vvl <span class="token function">mat_pow_rec</span><span class="token punctuation">(</span>vvl<span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> A<span class="token punctuation">;</span>        vvl B <span class="token operator">=</span> <span class="token function">mat_pow_rec</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        B <span class="token operator">=</span> <span class="token function">mat_mul</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">mat_mul</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> B<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">waysToStep</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vl f <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        vvl A <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        vvl B <span class="token operator">=</span> <span class="token function">mat_pow</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token number">-3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ll res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>res <span class="token operator">+</span><span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mat_pow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        m <span class="token operator">=</span> A<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        B <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>m<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int64<span class="token punctuation">)</span>        <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>                B <span class="token operator">=</span> np<span class="token punctuation">.</span>mod<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>B<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>int64<span class="token punctuation">)</span>            A <span class="token operator">=</span> np<span class="token punctuation">.</span>mod<span class="token punctuation">(</span>np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>A<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span>np<span class="token punctuation">.</span>int64<span class="token punctuation">)</span>            n <span class="token operator">>></span><span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">return</span> B<span class="token punctuation">;</span>    <span class="token keyword">def</span> <span class="token function">waysToStep</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>p <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span>        A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int64<span class="token punctuation">)</span>        B <span class="token operator">=</span> self<span class="token punctuation">.</span>mat_pow<span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token number">-3</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> int<span class="token punctuation">(</span>res<span class="token operator">%</span>self<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 79】所有人都会做的入门题，但是能看出你的代码能力！</title>
      <link href="/2020/03/24/leetcode-inteview-08-01/"/>
      <url>/2020/03/24/leetcode-inteview-08-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>这两天要帮老师录制一下题解视频，所以题目挑简单一点的，减（shui）轻（liang）大（pian）家（wen）压（zhang）力。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" title="LeetCode 面试题 08.01. 三步问题" target="_blank" rel="noopener">LeetCode 面试题 08.01. 三步问题</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>三步问题。有个小孩正在上楼梯，楼梯有 $n$ 阶台阶，小孩一次可以上 $1$ 阶、$2$ 阶或 $3$ 阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模 $1000000007$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 3 输出：4解释：有四种走法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 5输出：13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题是动态规划入门题，我相信大家都会做，如果不会做，那就当我没说过这句话。</p><p>令 $f[i]$ 为上 $i$ 个台阶的方案数，那么最后一步可以是跳 $1$ 步，或者跳 $2$ 步，或者跳 $3$ 步过去的，所以就有：<br>$$<br>f[i] = f[i-1] + f[i-2] + f[i-3]<br>$$<br>初始情况就是 $f[1] = 1, f[2] = 2, f[3] = 4$ 。</p><p>然后利用取模的加法公式，可以每算出一个 $f[i]$ 都取一下模。</p><p>当然了这题太水了，我主要就是想看看大家会怎么实现呢？</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="定义长度为-n-的数组"><a href="#定义长度为-n-的数组" class="headerlink" title="定义长度为 $n$ 的数组"></a>定义长度为 $n$ 的数组</h3><p>最朴素的方法当然是定义长度为 $n$ 的数组，然后算就完事了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> ll p <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e6</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ll f<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">waysToStep</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i<span class="token number">-3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义四个变量"><a href="#定义四个变量" class="headerlink" title="定义四个变量"></a>定义四个变量</h3><p>但是这样太费空间了啊，其实每次只需要用到之前的三个状态就行了，然后还要用个临时变量用来交换状态值，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> ll p <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">waysToStep</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>        ll a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> d<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            d <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> c<span class="token punctuation">;</span>            c <span class="token operator">=</span> d<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> d<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义长度为-3-的数组"><a href="#定义长度为-3-的数组" class="headerlink" title="定义长度为 $3$ 的数组"></a>定义长度为 $3$ 的数组</h3><p>但是用 $4$ 个变量也太丑陋了，对于我这种处女座患者（对不起我是射手座）来说，完全无法忍受！</p><p>所以我直接定义了一个长度为 $3$ 的数组，然后下标对 $3$ 取模来实现循环数组，这样代码看起来就很舒服啦：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ll<span class="token punctuation">;</span><span class="token keyword">const</span> ll p <span class="token operator">=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">waysToStep</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ll f<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> f<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应读者要求，再来个 <code>python</code> 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">waysToStep</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            f<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span>            f<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">%=</span> <span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> int<span class="token punctuation">(</span>f<span class="token punctuation">[</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 78】面试经典题：能说出全部四种方法，不录用你都不可能！</title>
      <link href="/2020/03/23/leetcode-55/"/>
      <url>/2020/03/23/leetcode-55/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/jump-game/" title="LeetCode 55. 跳跃游戏" target="_blank" rel="noopener">LeetCode 55. 跳跃游戏</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,3,1,1,4]输出：true解释：我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,1,0,4]输出：false解释：无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="动态规划-正推"><a href="#动态规划-正推" class="headerlink" title="动态规划+正推"></a>动态规划+正推</h3><p>用 $dp[i]$ 表示位置 $i$ 是否可达，初始的时候都是 $0$ ，只有 $dp[0] = 1$ ，因为起点一定是可达的。</p><p>然后从位置 $0$ 开始遍历。对于位置 $i$ ，如果发现 $dp[i] = 0$，那么从前面的位置无法到达它，那么就更无法到达后面的位置了，所以直接返回 <code>false</code> 。</p><p>否则的话，它能到达的范围是 $i+1$ 到 $i+nums[i]$ ，所以把这部分的 $dp$ 值都标记为 $1$ 。</p><p>如果发现 $i+nums[i] \ge n-1$ ，就说明当前位置直接就能跳到终点了，直接返回 <code>true</code> 。</p><p>时间复杂度 $O(n^2)$，空间复杂度 $O(n)$ 。</p><h3 id="动态规划-倒推"><a href="#动态规划-倒推" class="headerlink" title="动态规划+倒推"></a>动态规划+倒推</h3><p>用 $dp[i]$ 表示从位置 $i$ 能否到达终点，初始的时候都是 $0$ ，只有 $dp[n-1] = 1$ ，因为从终点一定是可到达终点的。</p><p>然后从位置 $n-2$ 开始往前遍历。对于位置 $i$ ，如果 $i+nums[i] \ge n-1$，那就说明当前位置直接就可以到达终点，那么就令 $dp[i] = 1$ 。</p><p>否则的话遍历所有的 $dp[i+1]$ 到 $dp[i+nums[i]]$ ，如果其中有等于 $1$ 的，那就说明先跳到那个位置，就能再跳到终点了。一个都没有的话 $dp[i] = 0$ 。</p><p>最后看 $dp[0]$ 是否为 $1$ 就行了。</p><p>时间复杂度 $O(n^2)$，空间复杂度 $O(n)$ 。</p><h3 id="贪心-正推"><a href="#贪心-正推" class="headerlink" title="贪心+正推"></a>贪心+正推</h3><p>在上面的动态规划方法中，对于位置 $i$ ，我们需要把他能到达的位置全部做上标记。</p><p>但是其实没有必要这么做，只需要记录一下能到的最远的那个位置 $maxx$ 就行了。如果遍历之后的位置 $j$ 时，发现 $maxx &lt; j$ ，那就说明之前的所有位置最远都无法到达 $j$ ，那就直接返回 <code>false</code> 。否则的话，比较一下当前能到达的最远位置，更新一下 $maxx$ 的值。</p><p>时间复杂度 $O(n)$，空间复杂度 $O(1)$ 。</p><h3 id="贪心-倒推"><a href="#贪心-倒推" class="headerlink" title="贪心+倒推"></a>贪心+倒推</h3><p>还是从上面的动态规划方法改变来的，上面动态规划在位置 $i$ ，需要遍历所有它能到达的位置，然后看有没有位置能够到达终点。</p><p>其实只需要看能到的最远的那个位置就行了，我们用 $minn$ 表示后面的位置中最靠前的那个能够到达终点的位置。如果最远到达位置满足 $i+nums[i] \ge minn$，那就说明位置 $i$ 可以直接跳到 $minn$ ，那么就更新 $minn = i$ 。否则的话怎么跳都跳不到终点，因为 $i$ 和 $minn$ 之间的位置都是无法到达终点的。</p><p>需要注意的是，这里最远的位置 $i+nums[i]$ 不一定能到达终点哦，但是中间的某个位置可能能够达到。</p><p>时间复杂度 $O(n)$，空间复杂度 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划-正推（c-）"><a href="#动态规划-正推（c-）" class="headerlink" title="动态规划+正推（c++）"></a>动态规划+正推（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-倒推（c-）"><a href="#动态规划-倒推（c-）" class="headerlink" title="动态规划+倒推（c++）"></a>动态规划+倒推（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="贪心-正推（c-）"><a href="#贪心-正推（c-）" class="headerlink" title="贪心+正推（c++）"></a>贪心+正推（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> maxx<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxx <span class="token operator">>=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="贪心-倒推（c-）"><a href="#贪心-倒推（c-）" class="headerlink" title="贪心+倒推（c++）"></a>贪心+倒推（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> minn <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> minn<span class="token punctuation">)</span> minn <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">!</span>minn<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 77】LeetCode 第 181 场周赛题解</title>
      <link href="/2020/03/22/leetcode-week-181/"/>
      <url>/2020/03/22/leetcode-week-181/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="周赛链接"><a href="#周赛链接" class="headerlink" title="周赛链接"></a>周赛链接</h2><p><a href="https://leetcode-cn.com/contest/weekly-contest-181" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-181</a></p><h2 id="LeetCode-5364-按既定顺序创建目标数组"><a href="#LeetCode-5364-按既定顺序创建目标数组" class="headerlink" title="LeetCode 5364. 按既定顺序创建目标数组"></a>LeetCode 5364. 按既定顺序创建目标数组</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/create-target-array-in-the-given-order/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>c++ <code>vector</code> 自带 <code>insert</code> 函数，直接用就行了。</p><h3 id="代码（c-）"><a href="#代码（c-）" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">createTargetArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> target<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            target<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>index<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5178-四因数"><a href="#LeetCode-5178-四因数" class="headerlink" title="LeetCode 5178. 四因数"></a>LeetCode 5178. 四因数</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/four-divisors/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/four-divisors/</a></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>直接求出每个数因数个数就行了，对于每个数 $x$，只需要枚举到 $\sqrt{x}$ 就行了，另外如果因子个数已经大于 $4$ 了，就直接退出。</p><h3 id="代码（c-）-1"><a href="#代码（c-）-1" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">sumFourDivisors</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i <span class="token operator">&lt;=</span> x<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span>i <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">%</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                    sum <span class="token operator">+</span><span class="token operator">=</span> i <span class="token operator">+</span> x<span class="token operator">/</span>i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5366-检查网格中是否存在有效路径"><a href="#LeetCode-5366-检查网格中是否存在有效路径" class="headerlink" title="LeetCode 5366. 检查网格中是否存在有效路径"></a>LeetCode 5366. 检查网格中是否存在有效路径</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/</a></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>可以用 bfs 或者 dfs ，我这里采用的是 bfs 。</p><p>整体框架和普通的 bfs 完全一模一样，那么问题就在于如何判断两个格子能否相连。在代码中体现为 <code>link</code> 函数，我们给它传了三个参数：$a$，$b$ 表示两个格子的街道标号（题面里解释了），$d$ 表示两个格子的位置关系（$0$：左右，$1$：右左，$2$：上下，$3$：下上）。</p><p>其中 $d=1$ 和 $d=3$ 都可以通过交换 $a$ 和 $b$ 的顺序，来分别转换成 $d=0$ 和 $d=2$ 。</p><p>对于 $d=0$ 来说，左右能连接的情况，只有<strong>右边有出口</strong>的格子（$a=1,4,6$）接上<strong>左边有入口</strong>的格子（$b=1,3,5$）。</p><p>对于 $d=2$ 来说，上下能连接的情况，只有<strong>下边有出口</strong>的格子（$a=2,3,4$）接上<strong>上边有入口</strong>的格子（$b=2,5,6$）。</p><p>其他情况全部无法连接。</p><p>这样最后 bfs 遍历到了 $(n-1,m-1)$ 就能到达终点，否则就无法到达。</p><h3 id="代码（c-）-2"><a href="#代码（c-）-2" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> d <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            d<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>a<span class="token operator">==</span><span class="token number">4</span><span class="token operator">||</span>a<span class="token operator">==</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>b<span class="token operator">==</span><span class="token number">3</span><span class="token operator">||</span>b<span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">2</span><span class="token operator">||</span>a<span class="token operator">==</span><span class="token number">3</span><span class="token operator">||</span>a<span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>b<span class="token operator">==</span><span class="token number">2</span><span class="token operator">||</span>b<span class="token operator">==</span><span class="token number">5</span><span class="token operator">||</span>b<span class="token operator">==</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">hasValidPath</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">vis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> Q<span class="token punctuation">;</span>        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> p <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> p<span class="token punctuation">.</span>first<span class="token punctuation">,</span> y <span class="token operator">=</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> n<span class="token number">-1</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">link</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    vis<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5367-最长快乐前缀"><a href="#LeetCode-5367-最长快乐前缀" class="headerlink" title="LeetCode 5367. 最长快乐前缀"></a>LeetCode 5367. 最长快乐前缀</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/longest-happy-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-happy-prefix/</a></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>kmp 模板题，细节就不说了，网上教程漫天铺地都是的。就一个函数，是个模板直接用就行了。最后求出来的 $next[i]$ 就表示了 $s[0]$ 到 $s[i]$ 子串的最长相同前缀后缀的长度，所以答案就是 $next[n-1]$ 。</p><h3 id="代码（c-）-3"><a href="#代码（c-）-3" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> q <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                k <span class="token operator">=</span> next<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> k<span class="token operator">++</span><span class="token punctuation">;</span>            next<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    string <span class="token function">longestPrefix</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">next</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">getNext</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> next<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 76】经典面试题：中序遍历的下一个元素，5大解法汇总！</title>
      <link href="/2020/03/21/leetcode-inteview-04-06/"/>
      <url>/2020/03/21/leetcode-inteview-04-06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/successor-lcci/" title="LeetCode 面试题 04.06. 后继者" target="_blank" rel="noopener">LeetCode 面试题 04.06. 后继者</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p><p>如果指定节点没有对应的“下一个”节点，则返回 null。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：root = [2,1,3], p = 1  2 / \1   3输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：root = [5,3,6,2,4,null,null,1], p = 6      5     / \    3   6   / \  2   4 /   1输出：null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="BST-递归"><a href="#BST-递归" class="headerlink" title="BST+递归"></a>BST+递归</h3><p>首先本题中的二叉树还是个二叉搜索树，也就是中序遍历是单调递增的，所以我们可以利用这个性质来简化查找过程。</p><ul><li>如果结点 <code>p</code> 的值大于等于 <code>root</code> 的值，说明 <code>p</code> 的后继结点在 <code>root</code> 右子树中，那么就递归到右子树中查找。</li><li>如果结点 <code>p</code> 的值小于 <code>root</code> 的值，说明 <code>p</code> 在 <code>root</code> 左子树中，而它的后继结点有两种可能，要么也在左子树中，要么就是 <code>root</code>：<ul><li>如果左子树中找到了后继结点，那就直接返回答案。</li><li>如果左子树中没有找到后继结点，那就说明 <code>p</code> 的右儿子为空，那么 <code>root</code> 就是它的后继结点。</li></ul></li></ul><h3 id="BST-非递归"><a href="#BST-非递归" class="headerlink" title="BST+非递归"></a>BST+非递归</h3><ul><li>如果 <code>p</code> 有右儿子，那么它的后继结点就是右子树的最左边的儿子。</li><li>如果 <code>p</code> 没有右儿子，那么它的后继结点就是，沿着 <code>p</code> 往上到 <code>root</code> 的路径中，第一个左儿子在路径上的结点。因为这个结点的左子树中 <code>p</code> 是最右边的结点，是最大的，所以它就是 <code>p</code> 的后继结点。因为是二叉搜索树，我们就可以从根结点开始往 <code>p</code> 走，根据结点值的大小决定走的方向。</li></ul><h3 id="一般树-递归"><a href="#一般树-递归" class="headerlink" title="一般树+递归"></a>一般树+递归</h3><p>那如果是一般的二叉树，中序遍历就不满足单调递增了，这时候我们就只能找出中序遍历的结点顺序，然后才能得到 <code>p</code> 的后继结点。</p><p>所以我们直接采用递归来做中序遍历就行了，中序遍历结果保存下来，最后取 <code>p</code> 的下一个结点。</p><h3 id="一般树-非递归"><a href="#一般树-非递归" class="headerlink" title="一般树+非递归"></a>一般树+非递归</h3><p>当然还可以采用栈来做中序遍历，这样就是非递归了。同样结果保存下来，最后取 <code>p</code> 的下一个结点。</p><h3 id="一般树-Morris遍历"><a href="#一般树-Morris遍历" class="headerlink" title="一般树+Morris遍历"></a>一般树+Morris遍历</h3><p>如果看过我前两天的一道关于二叉搜索树的题解：<br><a href="https://godweiyang.com/2020/03/18/leetcode-99/" title="【每日算法Day 73】学妹大半夜私聊我有空吗，然后竟然做出这种事！">韦阳的博客：【每日算法Day 73】学妹大半夜私聊我有空吗，然后竟然做出这种事！</a></p><p><a href="https://zhuanlan.zhihu.com/p/114143194" title="【每日算法Day 73】学妹大半夜私聊我有空吗，然后竟然做出这种事！" target="_blank" rel="noopener">知乎专栏：【每日算法Day 73】学妹大半夜私聊我有空吗，然后竟然做出这种事！</a></p><p>那么你一定会知道这个 Morris 遍历算法，用常数空间来解决结点无法访问父结点的问题。这里就不细讲了，请直接看之前的题解。方法是一样的，用 Morris 遍历得到中序遍历，然后遍历一遍找到 <code>p</code> ，输出它的下一个结点就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="BST-递归（c-）"><a href="#BST-递归（c-）" class="headerlink" title="BST+递归（c++）"></a>BST+递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">>=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> left <span class="token operator">?</span> left <span class="token operator">:</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BST-非递归（c-）"><a href="#BST-非递归（c-）" class="headerlink" title="BST+非递归（c++）"></a>BST+非递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode<span class="token operator">*</span> res <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;</span> p<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> root<span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一般树-递归（c-）"><a href="#一般树-递归（c-）" class="headerlink" title="一般树+递归（c++）"></a>一般树+递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一般树-非递归（c-）"><a href="#一般树-非递归（c-）" class="headerlink" title="一般树+非递归（c++）"></a>一般树+非递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> res<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一般树-Morris遍历（c-）"><a href="#一般树-Morris遍历（c-）" class="headerlink" title="一般树+Morris遍历（c++）"></a>一般树+Morris遍历（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">inorderSuccessor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> res<span class="token punctuation">;</span>        TreeNode <span class="token operator">*</span>rightmost <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rightmost <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">&amp;&amp;</span> rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rightmost <span class="token operator">=</span> rightmost<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>                    root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                    rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                    root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 75】字节跳动面试题：手撕困难题，看过我Day 71的人都会做了！</title>
      <link href="/2020/03/20/leetcode-41/"/>
      <url>/2020/03/20/leetcode-41/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/first-missing-positive/" title="LeetCode 41. 缺失的第一个正数" target="_blank" rel="noopener">LeetCode 41. 缺失的第一个正数</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,0]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,4,-1,1]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,8,9,11,12]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong>   </p><ul><li>你的算法的时间复杂度应为 $O(n)$，并且只能使用常数级别的空间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果之前一直坚持看我题解的同学，应该前几天刚看过下面这道题：<br><a href="https://godweiyang.com/2020/03/16/leetcode-interview-17-19/" title="韦阳的博客：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法">韦阳的博客：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</a></p><p><a href="https://zhuanlan.zhihu.com/p/113534188" title="知乎专栏：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法" target="_blank" rel="noopener">知乎专栏：【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</a></p><p>那道题是要求 $1$ 到 $n$ 中缺失的两个数，于是我们开辟一个大小为 $n$ 的数组，将所有数字放到下标对应的位置，然后看哪两个位置是空着的。为了使用原地算法，我们直接在原数组上进行操作。</p><p>回到本题，我们要寻找的是第一个缺失的正整数。其实问题的本质是一样的，如果数组的长度是 $n$ ，那么最多只能填充 $1$ 到 $n$ 这 $n$ 个正整数，所以缺失的正整数一定小于等于 $n+1$ 。</p><p>那么我们把小于等于 $0$ 或者大于 $n$ 的数全部赋值为 $-1$ ，因为它们是多少不要紧，不影响最后的结果。然后和上面题目方法一样，用原地算法，把每个数字放入对应下标的位置。最后从左到右扫描一遍数组，如果发现有位置是 $-1$ ，那么第一个缺失的正数就是它了。如果扫描完 $1$ 到 $n$ 发现全都在，那么第一个缺失的就是 $n+1$ 了。当然可能缺失很多正数，所以扫描到第一个缺失正数之后，就要直接返回结果了。</p><p>因为我们要保存 $1$ 到 $n$ 之间的数，所以数组长度不够，要在后面扩充一个才行。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 74】经典面试题：约瑟夫环，我敢打赌你一定不会最后一种方法！</title>
      <link href="/2020/03/19/leetcode-interview-62/"/>
      <url>/2020/03/19/leetcode-interview-62/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" title="LeetCode 面试题62. 圆圈中最后剩下的数字" target="_blank" rel="noopener">LeetCode 面试题62. 圆圈中最后剩下的数字</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>$0,1,\ldots,n-1$ 这 $n$ 个数字排成一个圆圈，从数字 $0$ 开始，每次从这个圆圈里删除第 $m$ 个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，$0,1,2,3,4$ 这 $5$ 个数字组成一个圆圈，从数字 $0$ 开始每次删除第 $3$ 个数字，则删除的前 $4$ 个数字依次是 $2,0,4,1$，因此最后剩下的数字是 $3$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 5, m = 3输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 10, m = 17输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong>   </p><ul><li>$1 \le n \le 10^5$</li><li>$1 \le m \le 10^6$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>用一个循环链表按顺序存储 $0$ 到 $n-1$ 中的数，然后每 $m$ 个数删除掉链表中的一个结点，最后剩下的数就是答案了。</p><p>这种方法时间复杂度是 $O(nm)$ ，显然太高了，所以这里也不会给大家实现代码。</p><h3 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h3><p>首先 $n$ 个人的编号依次是 $0,1,\ldots,n-1$ ，然后踢掉了编号为 $k = (m-1)\%n$ 的人，这时候剩下的人编号为 $0,1,\ldots,k-1,k+1, \ldots,n-1$ 。</p><p>下一个踢掉的人就要从 $k+1$ 开始数了，所以我们把剩下的人编号从 $k+1$ 开始重新排个序，变成 $k+1, \ldots, n-1,0,\ldots,k-1$ 。这样编号又变成连续的了，而问题规模缩减成了 $n-1$ 个人。</p><p>剩下的这 $n-1$ 个人的编号我们做一下映射，映射成 $0,1,\ldots,n-2$ ，这样就能递推下去求解了。映射的公式就是，映射后的编号为 $x$ ，那么映射之前的编号就是 $(x+k+1)\%n = (x+m)\%n$ 。</p><p>也就是说，如果我们求出了 $n-1$ 个人最后剩下的人编号 $x$ ，那么 $n$ 个人最后剩下的人编号就是 $(x+m)\%n$ 。</p><p>用 $f(n)$ 表示 $n$ 个人最后剩下的人编号，那么就有：<br>$$<br>f(n) = (f(n-1) + m) \% n<br>$$</p><p>这样的话时间复杂度就降到了 $O(n)$ 。</p><blockquote><p>对于本题这个方法已经够用了，但是如果 $n$ 非常大，比如 $n \le 10^{12}$ ，但是 $m$ 不是很大，比如 $m \le 1000$ ，那么这时候这种方法就会超时了。具体的题目请自行百度 HDU 3089 。</p></blockquote><h3 id="递推法加速"><a href="#递推法加速" class="headerlink" title="递推法加速"></a>递推法加速</h3><p>注意观察上面的递推式 $f(n) = (f(n-1) + m) \% n$ ，如果 $m$ 很小，而 $n$ 很大的话，递推到后面要加很多次 $m$ 才会对 $n$ 求余。所以我们可以直接一下子加很多次 $m$ ，然后再求余，这样就能加速了。</p><p>加了 $t$ 次 $m$ 之后，递推式变成了：<br>$$<br>f(n+t-1) = (f(n-1)+tm)\%(n+t-1)<br>$$</p><p>假设加了 $t$ 次 $m$ 之后才产生了取余，那么就有 $f(n-1) + tm \ge n+t-1$ ，即 $t \ge \frac{n-f(n-1)-1}{m-1}$ 。所以每次都可以加 $\left\lceil \frac{n-f(n-1)-1}{m-1} \right\rceil$ 个 $m$ ，代码实现时用下取整，也就是 $\left\lfloor \frac{n-f(n-1)+m-3}{m-1} \right\rfloor$ 。</p><p>此外还需要注意，如果发现 $i-1+t &gt; n$ ，也就是后面都不需要取余了，那么就直接一步加到底，退出循环得到答案。</p><p>这个方法时间复杂度不是很好分析，但应该也是对数级别的。</p><h3 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h3><p>这个方法在我之前的文章中已经讲过了：<br><a href="https://godweiyang.com/2018/04/16/concrete-math-8/" title="韦阳的博客：具体数学-第8课（取整进阶）">韦阳的博客：具体数学-第8课（取整进阶）</a></p><p><a href="https://zhuanlan.zhihu.com/p/35820332" title="知乎专栏：具体数学-第8课（取整进阶）" target="_blank" rel="noopener">知乎专栏：具体数学-第8课（取整进阶）</a></p><p>知乎高赞回答也整理过了一遍：<br><a href="https://www.zhihu.com/question/358255792/answer/974983270" title="世界上有哪些代码量很少，但很牛逼很经典的算法或项目案例？" target="_blank" rel="noopener">世界上有哪些代码量很少，但很牛逼很经典的算法或项目案例？</a></p><p>大致思想也是重新编号，做编号映射，但是和上面递推法不同的是复杂度降到了对数级别。</p><p>这里就不详细讲了，大家可以去看上面的文章，这里直接给出伪代码：</p><pre class="line-numbers language-python"><code class="language-python">D <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">while</span> D <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span>n<span class="token punctuation">:</span>    D <span class="token operator">=</span> kans <span class="token operator">=</span> mn<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中 $k = \left\lceil \frac{m}{m-1}D \right\rceil$ 。</p><p>不过这个这里的编号是 $1$ 到 $n$ ，所以最后答案要减去 $1$ 。</p><p>这种方法将时间复杂度降到了 $O(\log_{\frac{m}{m-1}}{(m-1)n})$ ，用对数换底公式后得到 $O(\frac{\ln{(m-1)}+\ln{(n)}}{\ln{(m)}-\ln{(m-1)}})$ 。</p><p>可以看出，这种方法适用于 $n$ 特别大，但是 $m$ 特别小的情况。否则的话如果 $m$ 很大，分母会非常小，导致复杂度非常高。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="递推法（c-）"><a href="#递推法（c-）" class="headerlink" title="递推法（c++）"></a>递推法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>last <span class="token operator">+</span><span class="token operator">=</span> m<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递推法加速（c-）"><a href="#递推法加速（c-）" class="headerlink" title="递推法加速（c++）"></a>递推法加速（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">+</span><span class="token operator">=</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">-</span>last<span class="token operator">+</span>m<span class="token number">-3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span>t<span class="token number">-1</span> <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                last <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token punctuation">(</span>last <span class="token operator">+</span><span class="token operator">=</span> t<span class="token operator">*</span>m<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span>t<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学法（c-）"><a href="#数学法（c-）" class="headerlink" title="数学法（c++）"></a>数学法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lastRemaining</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> D <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>n<span class="token operator">*</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>D <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            D <span class="token operator">=</span> <span class="token punctuation">(</span>m<span class="token operator">*</span>D<span class="token operator">+</span>m<span class="token number">-2</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>n<span class="token operator">*</span>m<span class="token operator">-</span>D<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 73】学妹大半夜私聊我有空吗，然后竟然做出这种事！</title>
      <link href="/2020/03/18/leetcode-99/"/>
      <url>/2020/03/18/leetcode-99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>竟然甩给我一道算法题做，太可恶了嘤嘤嘤。</p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" title="LeetCode 99. 恢复二叉搜索树" target="_blank" rel="noopener">LeetCode 99. 恢复二叉搜索树</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,3,null,null,2]   1  / 3  \   2输出：[3,1,null,null,2]   3  / 1  \   2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,4,null,null,2]  3 / \1   4   /  2输出：[2,1,4,null,null,3]  2 / \1   4   /  3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进阶：</strong>   </p><ul><li>使用 $O(n)$ 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先不考虑空间复杂度，因为二叉搜索树的中序遍历是单调递增的，所以我们只需要求出它的中序遍历。然后两个结点被调换过位置，等价于递增序列中两个数调换了位置。那么我们只需要找出序列中第一个逆序对（前一个数）和最后一个逆序对（后一个数）就行了，然后换回它俩的位置。</p><p>但是中序遍历无论使用递归实现还是栈实现，空间复杂度都是树的高度，不是常数。</p><p>想一下为什么我们需要用递归或者栈来实现中序遍历？因为从根结点开始进入左子树之后，遍历完了左子树还需要回到根结点，然后再进入右子树继续遍历。但是如果你没有栈，你就没法从左子树回到根结点了，因为左子树中没有结点能指到根结点。</p><p>我们需要解决的就是这个问题，这里我们引入 <strong>Morris 遍历算法</strong>。</p><p>下图是一个二叉搜索树例子：<br><img src="1.jpg" alt></p><p>我们用递归来做中序遍历，访问结点的顺序是 <code>4212346567</code> （这个序列就是 Morris 遍历得到的序列）。注意到非叶子结点 <code>246</code> 会被访问两次，第一次是作为根结点进入左子树，第二次是递归返回了，中序遍历到自己了。</p><p>那么不用递归或者栈，我们怎么在第二次成功返回根结点呢？注意到叶子结点的左右儿子都是空的，所以可以利用它们来指向根结点。</p><p>用结点 <code>4</code> 举个例子。首先访问 <code>4</code> ，然后遍历它的左子树。左子树的最后一个遍历的结点是 <code>3</code> ，那么我们就把 <code>3</code> 的右儿子指向根结点 <code>4</code> 。这样遍历完左子树之后，还能通过 <code>3</code> 的右儿子回到根结点 <code>4</code> ，接着继续遍历右子树。</p><p>所以在第一次访问根结点时，首先要找出它左子树中最右边的那个叶子结点，把它的右儿子指向根结点。然后才能放心地递归遍历左子树，不用担心回不去啦。</p><p>具体实现的时候还有一些细节，看代码更好理解，我都写在注释里面了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">recoverTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>rightmost <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果有左子树，就递归遍历左子树。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rightmost <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 找出左子树的最右边一个叶子结点</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">&amp;&amp;</span> rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rightmost <span class="token operator">=</span> rightmost<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 如果左子树最右边的叶子结点的右儿子是空的，</span>                <span class="token comment" spellcheck="true">// 那就说明根结点是第一次访问，那么就把它的右儿子指向根结点。</span>                <span class="token comment" spellcheck="true">// 然后递归遍历左子树。</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>                    root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 否则的话说明根结点是第二次访问了，</span>                <span class="token comment" spellcheck="true">// 那就说明左子树已经递归完毕了，</span>                <span class="token comment" spellcheck="true">// 那么就判断一下是否存在逆序对。</span>                <span class="token comment" spellcheck="true">// 记得把左子树最右叶子结点的右儿子改回空指针。</span>                <span class="token comment" spellcheck="true">// 然后递归遍历右子树了。</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">></span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> x <span class="token operator">=</span> pre<span class="token punctuation">;</span>                        y <span class="token operator">=</span> root<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    rightmost<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                    pre <span class="token operator">=</span> root<span class="token punctuation">;</span>                    root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果没有左子树，那就直接遍历右子树，同时判断是否存在逆序对。</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">></span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> x <span class="token operator">=</span> pre<span class="token punctuation">;</span>                    y <span class="token operator">=</span> root<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                pre <span class="token operator">=</span> root<span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">,</span> y<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 72】谷歌面试题：又双叒叕是位运算，最详细的自动机推导过程</title>
      <link href="/2020/03/17/leetcode-137/"/>
      <url>/2020/03/17/leetcode-137/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/single-number-ii/" title="LeetCode 137. 只出现一次的数字 II" target="_blank" rel="noopener">LeetCode 137. 只出现一次的数字 II</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong><br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,2,3,2]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[0,1,0,1,0,1,99]输出：99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="逐位考虑"><a href="#逐位考虑" class="headerlink" title="逐位考虑"></a>逐位考虑</h3><p>我们单独看二进制某一位，先不看单独的那个数，其他所有数字都出现了 3 次，所以那一位是 1 的个数一定是 3 的倍数。</p><p>再考虑这个出现一次的数，如果这一位是 1 ，那么这一位 1 的次数模 3 为 1 ，否则的话模 3 就是 0 。</p><p>那么就很简单了，统计一下有多少个数这一位上是 1 ，然后模 3 取余数，结果就是这个单独的数这一位上的值了。</p><p>遍历 32 位整数的每一位，就可以得到这个单独的数是多少了。</p><p><strong>推广到一般情况：</strong><br>如果其他数都出现了 $k$ 次，一个数出现了一次。那么如果 $k$ 是偶数，还是把所有的数异或起来就行了。如果 $k$ 是奇数，那么统计每一位是 1 的个数，然后模 $k$ 取余数就能得到那个单独的数了。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>我们还可以用自动机来做这题，根据某一位 1 的个数，我们可以得到如下的状态自动机：<br><img src="1.png" alt><br>初始的时候在状态 0 （有 0 个 1），然后如果下一个数这一位是 1，就进入状态 1（有 1 个 1），接着如果下一个数这一位是 1，就进入状态 2（有 2 个 1），接着如果下一个数这一位是 1，就进入状态 3（有 3 个 1），最后如果再来了一个数这一位还是 1，就说明是一个新的数了，等价于回到了状态 1。而每个状态如果来的数这一位是 0 ，都会保持状态不变。</p><p>当然这个自动机还可以简化，注意观察可以发现状态 3 和状态 0 是等价的（输入 0 都保持不变，输入 1 都会进入状态 1）。所以我们将状态 1 和状态 3 合并为一个状态 0 ，得到如下的状态自动机：<br><img src="2.jpg" alt></p><p>因为一共有三个状态，所以我们需要用两个变量来表示状态。用 <code>once</code> 表示是否在状态 1，用 <code>twice</code> 来表示是否在状态 2 。那么两个变量都为 0 就表示在状态 0 。然后可以得到如下的状态转移表：<br><img src="3.jpg" alt></p><p>注意观察 <code>once</code> 只有两种情况下转移后为 1 。一种是 <code>once=0, twice=0, x=1</code> ，另一种是 <code>once=1, twice=0, x=0</code> 。其他所有情况下 <code>once</code> 都转移为 0 。这两种情况都满足 <code>x^once=1</code> 并且 <code>twice=0</code> ，所以 <code>once</code> 的转移就是 <code>once = (x^once) &amp; (~twice)</code> 。</p><p>同理，观察 <code>twice</code> 只有两种情况下转移后为 1 。一种是 <code>once=1, twice=0, x=1</code> ，另一种是 <code>once=0, twice=1, x=0</code> 。其他所有情况下 <code>twice</code> 都转移为 0 。这两种情况都满足 <code>x^twice=1</code> 并且 <code>once^twice=1</code> ，所以 <code>twice</code> 的转移就是 <code>twice = (x^twice) &amp; (once^twice)</code> 。<strong>但是</strong>！！！ <code>once</code> 已经抢先一步转移过了，所以值已经变掉了，一个解决方法就是用临时变量保存一下前一个状态的 <code>once</code> 值。另一个方法就是，这两种情况下，<code>once</code> 都会转移到 0 ，所以判断条件直接用转移后的 <code>once=0</code> 就行了，随后转移就是 <code>twice = (x^twice) &amp; (~once)</code> 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="逐位考虑（c-）"><a href="#逐位考虑（c-）" class="headerlink" title="逐位考虑（c++）"></a>逐位考虑（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">>></span>i<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>cnt<span class="token operator">%</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位运算（c-）"><a href="#位运算（c-）" class="headerlink" title="位运算（c++）"></a>位运算（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> once <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> twice <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            once <span class="token operator">=</span> <span class="token punctuation">(</span>once<span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>twice<span class="token punctuation">)</span><span class="token punctuation">;</span>            twice <span class="token operator">=</span> <span class="token punctuation">(</span>twice<span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>once<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> once<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a href="https://leetcode-cn.com/problems/single-number/" title="LeetCode 136. 只出现一次的数字" target="_blank" rel="noopener">LeetCode 136. 只出现一次的数字</a><br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" title="LeetCode 面试题56 - I. 数组中数字出现的次数" target="_blank" rel="noopener">LeetCode 面试题56 - I. 数组中数字出现的次数</a><br><a href="https://leetcode-cn.com/problems/missing-two-lcci/" title="LeetCode 面试题 17.19. 消失的两个数字" target="_blank" rel="noopener">LeetCode 面试题 17.19. 消失的两个数字</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</title>
      <link href="/2020/03/16/leetcode-interview-17-19/"/>
      <url>/2020/03/16/leetcode-interview-17-19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/missing-two-lcci/" title="LeetCode 面试题 17.19. 消失的两个数字" target="_blank" rel="noopener">LeetCode 面试题 17.19. 消失的两个数字</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，包含从 $1$ 到 $N$ 所有的整数，但其中缺了两个数字。你能在 $O(N)$ 时间内只用 $O(1)$ 的空间找到它们吗？</p><p>以任意顺序返回这两个数字均可。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1]输出：[2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,3]输出：[1,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>$nums.length \le 30000$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>首先将数组里的数再加上 $1$ 到 $n$ 中所有的数构成一个更大的集合，那么问题就变成了<strong>一个数组里有两个数只出现了一次，其余数都出现了两次，求这两个数是多少？</strong></p><p>是不是很熟悉？这其实就是 LeetCode 另一道位运算题目：<br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" title="LeetCode 面试题56 - I. 数组中数字出现的次数" target="_blank" rel="noopener">LeetCode 面试题56 - I. 数组中数字出现的次数</a></p><p>首先还是常规套路，把所有的数异或起来，得到的值 $x$ 一定就是出现一次的两个数的异或值。</p><p>那么再回顾一道最基本的位运算题：<br><a href="https://leetcode-cn.com/problems/single-number/" title="LeetCode 136. 只出现一次的数字" target="_blank" rel="noopener">LeetCode 136. 只出现一次的数字</a></p><p>也就是<strong>一个数组里有一个数只出现了一次，其余数都出现了两次，求这个数是多少？</strong>这就很简单了，只需要全部异或起来就是这个数的值了。</p><p>那么回到本题，有没有办法将这 $2n-2$ 个数拆分成两个集合，每个集合都满足上面这种最简单的条件（只有一个数出现了一次）呢？</p><p>刚刚得到了两个只出现一次数字的异或值 $x$ ，那么 $x$ 中的 $1$ 就表示了这两个数那一位是不同的。那就很简单了啊，我们把所有 $2n-2$ 个数那一位是 $0$ 的归为一个集合，那一位是 $1$ 的归为一个集合，那么这两个只出现一次的数一定会分属两个不同的集合。而其他出现了两次的数，每个数字都会在同一个集合里。</p><p>最后对两个集合分别求异或值，就得到了两个出现一次数的值了。</p><p>这里有个关键点，就是按照 $x$ 某一位为 $1$ 来划分两个集合，其实取任意一位是 $1$ 的位都是可以的。但是最简单的方法就是取最低位 $1$ ，因为这样可以采用位运算 $x \&amp; (-x)$ 直接得到。</p><p>位运算系列还有一个进阶版：<br><a href="https://leetcode-cn.com/problems/single-number-ii/" title="LeetCode 137. 只出现一次的数字 II" target="_blank" rel="noopener">LeetCode 137. 只出现一次的数字 II</a></p><p>这题就与本题无关了，我们留着下次继续讲。</p><h3 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h3><p>首先假设缺失的两个数字为 $x, y$ 。</p><p>令 $S_1$ 为 $nums$ 数组中的元素和，$S_2$ 为 $nums$ 数组中的元素平方和。</p><p>再用 $1$ 到 $n$ 的元素和减去 $S_1$ 就得到了 $x+y$ 的值，记为 $a$。用 $1$ 到 $n$ 的元素平方和减去 $S_2$ 就得到了 $x^2+y^2$ 的值，记为 $b$。</p><p>最后只要解出下面这个二元二次方程组就行了：<br>$$<br>\begin{aligned}<br>&amp;x + y = a   \\<br>&amp;x^2 + y^2 = b<br>\end{aligned}<br>$$<br>用求根公式可以解出两个解是：<br>$$<br>\frac{a \pm \sqrt{2b-a^2}}{2}<br>$$<br>其中：<br>$$<br>\begin{aligned}<br>&amp;a = \sum_{i=1}^n{i} - \sum_{i=0}^{n-3}{nums[i]} = \frac{n(n+1)}{2}  - \sum_{x \in nums}{x}  \\<br>&amp;b = \sum_{i=1}^n{i^2} - \sum_{i=0}^{n-3}{(nums[i])^2} = \frac{n(n+1)(2n+1)}{6} - \sum_{x \in nums}{x^2}<br>\end{aligned}<br>$$</p><h3 id="下标哈希"><a href="#下标哈希" class="headerlink" title="下标哈希"></a>下标哈希</h3><p>一个很直觉的方法就是，我新开辟一个大小为 $n+1$ 的数组，然后把 $nums$ 数组中的元素都放在新数组中下标对应的位置，最后看哪两个位置没有数就行了。但是现在要用原地算法，不允许新开辟空间，那我们就只能直接放在原数组里面了。</p><p>首先我们还是得把原数组扩展到大小为 $n+1$，也就是在末尾增加 $3$ 个空间，数字就放 $-1$。</p><p>然后遍历数组，对于 $nums[i]$ 来说，它的位置上最后放的应该是数字 $i$ 才对，而 $nums[i]$ 应该被放在下标为 $nums[i]$ 的位置。所以我们把 $nums[i]$ 移动到下标为 $nums[i]$ 的位置上去，但是 $nums[i]$ 位置上的数字怎么办呢？不能直接覆盖，不然就再也无法访问了，所以我们把它移动到下标 $i$ 的位置就行了。也就是说交换下标 $i$ 和 $nums[i]$ 位置上的两个数。</p><p>那么问题接着来了，位置 $nums[i]$ 上面的数对了，但是位置 $i$ 上面的数还是错的啊。那么只要继续重复交换操作，直到位置 $i$ 位置上面的数是 $i$ ，或者是 $-1$ 就行了。</p><p>最后所有数都摆回正确位置了，再扫描一遍数组，如果 $nums[i] = -1$ ，就说明 $i$ 这个数不在数组里。</p><p>这个方法理论上适合缺任意 $k$ 个数，只需要一开始在数组后面补上 $k+1$ 个 $-1$ 就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="位运算（c-）"><a href="#位运算（c-）" class="headerlink" title="位运算（c++）"></a>位运算（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> lb <span class="token operator">=</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&amp;</span>lb<span class="token punctuation">)</span> y <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&amp;</span>lb<span class="token punctuation">)</span> y <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>y<span class="token punctuation">,</span> y<span class="token operator">^</span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学法（c-）"><a href="#数学法（c-）" class="headerlink" title="数学法（c++）"></a>数学法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> S1 <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> S2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> S2 <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">*</span>x<span class="token punctuation">;</span>        <span class="token keyword">long</span> a <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span>S1<span class="token punctuation">;</span>        <span class="token keyword">long</span> b <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">6</span><span class="token operator">-</span>S2<span class="token punctuation">;</span>        <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>b<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>b<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下标哈希（c-）"><a href="#下标哈希（c-）" class="headerlink" title="下标哈希（c++）"></a>下标哈希（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 70】图解算法：小学生都会的数块数问题，你会吗？</title>
      <link href="/2020/03/15/leetcode-959/"/>
      <url>/2020/03/15/leetcode-959/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/" title="LeetCode 959. 由斜杠划分区域" target="_blank" rel="noopener">LeetCode 959. 由斜杠划分区域</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 \ 用 “\\” 表示。）。</p><p>返回区域的数目。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  " /",  "/ "]输出：2解释：2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="1.png" alt></p><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  " /",  "  "]输出：1解释：2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="2.png" alt></p><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  "\\/",  "/\\"]输出：4解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3.png" alt></p><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  "/\\",  "\\/"]输出：5解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="4.png" alt></p><p><strong>示例5</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  "//",  "/ "]输出：3解释：2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="5.png" alt></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题如果不用写代码，直接让你数的话，那就非常简单了。但是要想实现代码，还是有点麻烦的。</p><p>最主要的麻烦点在于，如果表示出斜杠的划分？这里我提供了三种不同的方法。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p><img src="6.jpg" alt><br>如上图所示，首先将每个格子划分成 3 x 3 的更小的网格，然后对角线上填充 1 来表示斜杠，其余地方全部填充 0 。</p><p>那么问题就转化为了求一个 3N x 3N 的网格上的 0 的连通块一共有几块，这就用普通的 dfs 搜一遍就知道了。</p><p>那么这里有个问题，为什么不能每个格子划分成 2 x 2 呢？如下图所示，这样会导致两个格子中的 0 无法只用上下左右四个方向来联通：<br><img src="9.jpg" alt></p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><p><img src="7.jpg" alt><br>如上图所示，这种方法采用了并查集的思想。</p><p>首先将一个格子用 X 划分成四块，上图左半部分是各自之间的连通性，两个格子的相邻部分是一定连通的。</p><p>而右半部分是格子内部的连通性。如果有斜杠，那就将斜杠两边的两小块都连起来。如果没有斜杠，那就将四小块都连起来，而这只需要三条线就够了。</p><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><p><img src="8.jpg" alt><br>如上图所示，这个方法还是采用了并查集的思想。这次我们不以格子为计算单元了，我们来看格点。</p><p>初始的时候，四周一圈的格点都是连通的（红色线），而内部的格点都是孤立的。这时候只有一个区域，也就是整个平面。</p><p>然后一个格子一个格子添加斜杠。首先添加绿色斜杠，也就是连接 0 和 5 格点，这时候发现这两个点不在一个连通块里，那么就没有产生区域。</p><p>然后添加蓝色斜杠，也就是连接 2 和 5 格点，这时候发现这两个点在同一个连通块里，那么就产生了一个新的区域（也就是灰色部分）。</p><p>这样遍历完所有斜杠，就能知道增加了几块新的区域了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法-1（c-）"><a href="#方法-1（c-）" class="headerlink" title="方法 1（c++）"></a>方法 1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">regionsBySlashes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">new_grid</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> new_grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法-2（c-）"><a href="#方法-2（c-）" class="headerlink" title="方法 2（c++）"></a>方法 2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">==</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> fu <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> fv <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fu <span class="token operator">==</span> fv<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>fv<span class="token punctuation">]</span> <span class="token operator">=</span> fu<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">regionsBySlashes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>n<span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token operator">*</span>n<span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">*</span>n<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token number">-4</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">4</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">,</span> s<span class="token number">-3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token operator">*</span>n<span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法-3（c-）"><a href="#方法-3（c-）" class="headerlink" title="方法 3（c++）"></a>方法 3（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">==</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> fu <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> fv <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fu <span class="token operator">==</span> fv<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>fv<span class="token punctuation">]</span> <span class="token operator">=</span> fu<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">regionsBySlashes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    u <span class="token operator">=</span> i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    v <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    u <span class="token operator">=</span> i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">;</span>                    v <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">merge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 69】面试经典题：分发糖果问题</title>
      <link href="/2020/03/14/leetcode-135/"/>
      <url>/2020/03/14/leetcode-135/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/candy/" title="LeetCode 135. 分发糖果" target="_blank" rel="noopener">LeetCode 135. 分发糖果</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老师想给孩子们分发糖果，有 $N$ 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 $1$ 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,0,2]输出：5解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,2]输出：4解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题虽然难度定义成<strong>困难</strong>，但其实代码不长，思路也比较简单清晰。</p><p>首先明确一下题目中的两个条件，我们可以把所有人的分数在坐标轴中连起来，这样就形成了一个波形图（<strong>图片来自官方题解</strong>）：<br><img src="1.png" alt><br>那么这就像一座一座山峰一样，在谷底（左右两边分数都大于等于它）糖果数一定是 $1$ 。从谷底往两侧扩展，糖果数逐渐加 $1$ 就行了。</p><p>要注意的一点是图中 pt.13 那个位置也是一个谷底，因为它右边的分数等于它。</p><p>那么问题的关键就是如何找到这些谷底了。</p><h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><p>首先初始化所有人都分到 $1$ 个糖果。</p><p>然后从左向右遍历一次所有分数，如果发现分数小于等于前一个人分数，那暂时不用管，因为你从左向右是没法知道下坡的点距离谷底还有多远的。而如果发现分数大于前一个人分数，那么就在前一个人糖果数基础上，再多分一个给他，因为是上坡，所以谷底一定在左边已经遍历过了，是知道距离的。</p><p>接着就是遍历下坡了，也就是从右向左遍历所有分数，同理如果发现分数大于后一个人分数，那么就在后一个人糖果数基础上，再多分一个给他。</p><p>但是这里要处理一个冲突，那就是峰顶既是上坡，又是下坡，其实只要两次遍历完取上坡和下坡中糖果数较大的那个就行了。</p><p>总结一下就是<strong>一次从左向右遍历所有上坡，一次从右向左遍历所有下坡，峰顶取两次较大值</strong>。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>从上面方法中可以看出，本题求解的难点就在于从左向右遍历的时候，下坡到底有多长没法知道，必须全部遍历完了才能知道。还有就是山峰的值必须看左右两边的上坡下坡有多长。</p><p>为了解决这个问题，我们可以用变量 <code>up</code> 记录上坡的长度，<code>down</code> 记录下坡的长度。</p><p>当遇到谷底的时候，就表明一座山遍历结束了，那么我们只需要比较 <code>up</code> 和 <code>down</code> 的大小就知道峰顶取值了。</p><p>而如何判断一座山遍历结束呢？假设现在遍历到了第 $i$ 个学生，我们再用两个变量，<code>ns</code> 表示 $i-1$ 到 $i$ 的变化趋势（$1$：上升，$-1$：下降，$0$：不变），<code>os</code> 表示前一个时刻 $i-2$ 到 $i-1$ 的变化趋势。那么谷底只有下面三种情况：</p><ul><li>$os &lt; 0$ 且 $ns &gt; 0$ 。也就是前一个时刻在下降，当前时刻上升了，那显然第 $i-1$ 个学生是谷底。</li><li>$os &lt; 0$ 且 $ns = 0$ 。也就是前一个时刻在下降，当前时刻不变，这种情况下第 $i-1$ 个学生也是谷底，因为根据题意，他的糖果数没必要比第 $i$ 个学生多。</li><li>$os &gt; 0$ 且 $ns = 0$ 。也就是前一个时刻在上升，当前时刻不变。这种情况下，山峰只有上坡（到峰顶 $i-1$ 结束），没有下坡，所以这座山也遍历结束了，得计算糖果数了。</li></ul><p>这座山峰的的糖果数可以表示为三部分之和：上坡、下坡和峰顶。上坡就是 $1+2+\ldots+up$，下坡就是 $1+2+\ldots+down$，峰顶就是 $\max{\{up, down\}}+1$ 。算完了之后，这座山峰就再也不用考虑了， <code>up</code> 和 <code>down</code> 都清零。</p><p>在具体实现的时候，这个方法细节有点多，一不小心就会错，直接看代码注释吧。</p><p>继续看下面这张图：<br><img src="1.png" alt><br>贴一段官方的样例解释：<br><img src="2.jpg" alt></p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>我们用一个单调栈来保存单调下降的得分，也就是下坡。</p><p>当遍历到第 $i$ 个学生时，如果栈顶元素 $j$ 的得分小于等于 $i$ 的得分，也就是遇到谷底了，那么就出栈，直到栈空。</p><p>最后用一个很大的数将栈里所有元素顶出来就行了。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>第一种解法最容易理解和实现，也不用考虑什么特殊情况。但是后两种方法处理起来就稍稍有点麻烦了，需要结合样例和代码来理解。但是本质上都是一样的，都是从谷底（糖果数为 $1$）开始，向两周扩展。方法一是先从每个谷底向右边上坡扩展，再向左边下坡扩展。方法二是计算出相邻两个谷底之间的上坡下坡长度，然后直接计算。第三个方法是从每个谷底先向左边下坡扩展，再向右边上坡扩展。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="两次遍历（c-）"><a href="#两次遍历（c-）" class="headerlink" title="两次遍历（c++）"></a>两次遍历（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一次遍历（c-）"><a href="#一次遍历（c-）" class="headerlink" title="一次遍历（c++）"></a>一次遍历（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> up <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> down <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> os <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ns <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ns <span class="token operator">=</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ratings<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>ratings<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这座山峰遍历结束，计算糖果数。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>os <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> os <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里看似好像峰顶没有加 1，其实是 count(down) 减去了 1。</span>                <span class="token comment" spellcheck="true">// 因为谷底是共享的，所以将谷底给了下一座山峰的上坡。</span>                sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> down<span class="token punctuation">)</span><span class="token punctuation">;</span>                up <span class="token operator">=</span> down <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ns <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> up<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ns <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> down<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果是平原，说明谷底不会共享，之前少加的 1 再补上。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ns<span class="token punctuation">)</span> sum<span class="token operator">++</span><span class="token punctuation">;</span>            os <span class="token operator">=</span> ns<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 最后一座山峰循环里不会计算到，再加上。</span>        sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> down<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈（c-）"><a href="#单调栈（c-）" class="headerlink" title="单调栈（c++）"></a>单调栈（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ratings<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> ratings<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> j <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token number">-1</span> <span class="token operator">&amp;&amp;</span> ratings<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ratings<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    sum <span class="token operator">+</span><span class="token operator">=</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 68】脑筋急转弯：只要一行代码，但你会证吗？</title>
      <link href="/2020/03/13/leetcode-1227/"/>
      <url>/2020/03/13/leetcode-1227/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/" title="LeetCode 1227. 飞机座位分配概率" target="_blank" rel="noopener">LeetCode 1227. 飞机座位分配概率</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 位乘客即将登机，飞机正好有 $n$ 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p><p>剩下的乘客将会：</p><ul><li>如果他们自己的座位还空着，就坐到自己的座位上。</li><li>当他们自己的座位被占用时，随机选择其他座位。</li></ul><p>第 $n$ 位乘客坐在自己的座位上的概率是多少？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 1输出：1.00000解释：第一个人只会坐在自己的位置上。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 2输出：0.50000解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题呢代码相当之简单，但是我看了看题解区能真正理解的也不是很多，很多都是揣着糊涂装明白，稀里糊涂就当证过了。</p><p>首先题目并没有说第一个乘客座位号就是 $1$ 啊？也没说最后一个乘客座位号就是 $n$ 啊？所以大家的假设是怎么来的？这一点没有说清。其实很简单，不管每个乘客编号是多少，我们不用管，我们只要看他入场的次序就行了，所以我们就按照入场次序给他们重新编个号，这样的话就是按照 $1$ 到 $n$ 的编号入场了（也就是这里的编号代表的是入场的次序，而不是实际的座位号）。</p><p>然后就是 $1$ 号进场了，可以分为下面几种情况：</p><ul><li>他有 $\frac{1}{n}$ 的概率选择坐在 $1$ 号座位上。这样 $2$ 到 $n$ 号位置都不会被占，那么 $n$ 号坐在自己座位的概率就是 $1.0$ 。</li><li>他有 $\frac{1}{n}$ 的概率选择坐在 $n$ 号座位上。这样 $2$ 到 $n-1$ 号位置都不会被占，而 $n$ 号只能坐在 $1$ 号座位上，那么概率就是 $0.0$ 。</li><li>他有 $\frac{1}{n}$ 的概率选择坐在 $i$ 号座位上，其中 $2 \le i \le n-1$。这样 $2$ 到 $i-1$ 号位置都不会被占，他们都坐在自己的的位置上。而 $i$ 号乘客就犯难了，他的座位被 $1$ 号占了，他不知道坐哪了。这时候，如果他选择坐 $1$ 号座位，那么 $i+1$ 到 $n$ 号乘客还是坐在自己位置，相安无事。而如果他选择坐在 $i+1$ 到 $n$ 号中的某个位置，那么必然又会产生新的冲突，这样就不好求解了啊！</li></ul><p>对于第三种情况，我们可以换个角度看问题。现在面临的问题是，$i$ 号选择坐在哪？这时候还没入场的有 $i$ 到 $n$ 号乘客，而座位还剩 $1$ 和 $i+1$ 到 $n$ 号。那既然 $i$ 号乘客坐在 $1$ 号座位的话，后面的人都能坐回原位，那我们就把 $1$ 号座位当作是 $i$ 号乘客原本的座位就行了嘛，反正我最后又不要求 $i$ 号乘客坐回原位的概率，你坐哪都没事，只要别影响到其他人就行了。那么问题的规模就被缩小到了 $n-i+1$ ，我们递归求解就行了。</p><p>令 $f(n)$ 表示 $n$ 个人的情况下，最后一个人坐回原位的概率，按照上面的分析，我们可以列出递推式：<br>$$<br>f(n) = \frac{1}{n}\left(1 + \sum_{i=2}^{n-1}{f(n-i+1)}\right)<br>$$<br>这个递推式想必大家高中就会求了，令 $n = n-1$再写出一项：<br>$$<br>f(n-1) = \frac{1}{n-1}\left(1 + \sum_{i=2}^{n-2}{f(n-i)}\right)<br>$$<br>然后两式相减得到：<br>$$<br>nf(n) - (n-1)f(n-1) = f(n-1)<br>$$<br>即：<br>$$<br>f(n) = f(n-1) = \cdots = f(2)<br>$$<br>那么我们就可以得到最终的答案了，对任意的 $n \ge 2$ 都有 $f(n) = f(2) = 0.5$ 。</p><p>还有一个特例就是 $f(1) = 1.0$ ，这样这题就证好了。</p><p>这题最关键的一步就是 $1$ 号坐在了 $i$ 号座位后，$i$ 号何去何从？如果你能换个角度，把 $1$ 号座位给 $i$ 号（因为给他之后，对后面的乘客座位没有任何影响，那么就能把 $1$ 号座位看成就是 $i$ 号乘客的），那么问题就能递归下去了。题解区许多人这一步为什么能递归下去？根本没有讲清楚。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">nthPersonGetsNthSeat</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-py"><code class="language-py">class Solution:    def nthPersonGetsNthSeat(self, n: int) -> float:        return 1 if n==1 else .5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 67】经典面试题：手动开根号，你知道几种方法？</title>
      <link href="/2020/03/12/leetcode-69/"/>
      <url>/2020/03/12/leetcode-69/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/" title="LeetCode 69. x 的平方根" target="_blank" rel="noopener">LeetCode 69. x 的平方根</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 <code>int sqrt(int n)</code> 函数。</p><p>计算并返回 $n$ 的平方根，其中 $n$ 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：4输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：8输出：2解释：8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>为了更加通用，我们这里直接实现 <code>double sqrt(double n)</code> 函数。也就是求出 $\sqrt{n}$ 的精确值，然后取整就行了。</p><p>今天要教给大家的主要有三种方法：<strong>牛顿法</strong>、<strong>二分法</strong>和<strong>梯度下降法</strong>，速度上是依次下降的。</p><p>首先令 $\sqrt{n} = x$ ，也就是 $x^2 - n = 0$ ，也就是我们要求 $x^2 - n$ 的零点。</p><p>如果我们把 $x^2 - n$ 当作某个函数的导数，那么原函数就是 $f(x) = \frac{1}{3}x^3 - nx$ ，它的导数就是 $f’(x) = x^2 - n$ 。</p><p>现在问题很明朗了，要求 $\sqrt{n}$ 的值，等价于求 $f’(x) = 0$ 的根，等价于求 $f(x)$ 的极小值点（因为导数在非负数区间上零点唯一）。</p><h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>求 $f’(x) = 0$ 的根可以采用牛顿法。</p><p>首先选取一个初值 $x_0$ ，然后在函数 $(x_0, f’(x_0))$ 处作切线，求出切线与 $x$ 轴交点 。接着将交点坐标作为新的 $x_0$ ，然后重复上面步骤，直到 $f’(x_0)$ 和 $0$ 差值小于某个阈值。</p><p>直接给出计算得到的更新公式吧，大家也可以自己通过切线方程推导一下：<br>$$<br>x_0 \leftarrow x_0 - \frac{f’(x_0)}{f’’(x_0)} = \frac{1}{2}(x_0+\frac{n}{x_0})<br>$$<br>还可以通过泰勒展开得到这个公式，这里就不详细阐述了。</p><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>求 $f(x)$ 的极小值点可以采用梯度下降法。</p><p>首先选取一个初值 $x_0$ ，然后按照 $f(x_0)$ 的导数的逆方向更新 $x_0$ ，具体更新多少取决于你设置的学习率 $lr$ 。</p><p>更新公式就是：<br>$$<br>x_0 \leftarrow x_0 - lr \cdot f’(x_0) = x_0 - lr \cdot (x_0^2 - n)<br>$$</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>这就是很普通的二分方法了，因为 $f’(x)$ 在 $[0,\infty)$ 区间上是单调递增的，所以可以采用二分法求出零点，这里就不赘述了。</p><h3 id="速度比较"><a href="#速度比较" class="headerlink" title="速度比较"></a>速度比较</h3><p>我运行了一下从 $100$ 到 $10000$ 每 $100$ 个数开根号的结果，统计了一下三种方法需要的计算次数，如下图所示：<br><img src="1.jpg" alt><br>可以发现，牛顿法和二分法都是速度很快的，随着 $n$ 增大，需要的次数越来越多。但是梯度下降法的次数和学习率关系很大，学习率大了可能收敛次数变小，但是可能不收敛（左右振荡）。随着 $n$ 的增大，梯度下降法所需要的次数反而下降了，因为 $n$ 越大，函数越陡峭， $x_0$ 处的导数就越大，这样 $x_0$ 的更新幅度特别大。但是 $n$ 特别大了以后，梯度下降法需要的时间就非常长了，学习率不是很好设置了。而导数也已经超出了 <code>int</code> 范围，实现上也不是很方便。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>具体实现上这题有几个注意的点，因为这题只要求你返回取整结果，所以要特别当心浮点数误差。</p><p>而梯度下降法实现时，学习率不能太大，不然会产生振荡，此外还会导致 $x_0$ 更新幅度过大，直接变成负数，然后就陷入了死循环。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> y <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token function">newtonSqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> y<span class="token operator">*</span>y <span class="token operator">></span> x <span class="token operator">?</span> y<span class="token number">-1</span> <span class="token operator">:</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">newtonSqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> x0 <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1e-6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            x0 <span class="token operator">=</span> <span class="token number">0.5</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">/</span>x0<span class="token operator">+</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x0<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">binarySqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">>=</span> <span class="token number">1e-6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">double</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token operator">*</span>m <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> l <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 超时</span>    <span class="token keyword">double</span> <span class="token function">gdSqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> x0 <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1e-6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">double</span> lr <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1e-3</span><span class="token punctuation">,</span> <span class="token number">1e-1</span><span class="token operator">*</span>x0<span class="token operator">/</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            x0 <span class="token operator">=</span> x0<span class="token operator">-</span>lr<span class="token operator">*</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x0<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 66】经典面试题：不用四则运算如何做加法？</title>
      <link href="/2020/03/11/leetcode-interview-65/"/>
      <url>/2020/03/11/leetcode-interview-65/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" title="LeetCode 面试题65. 不用加减乘除做加法" target="_blank" rel="noopener">LeetCode 面试题65. 不用加减乘除做加法</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 $+,-,*,/$ 四则运算符号。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：a = 1, b = 1输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$a, b$ 均可能是负数或 $0$</li><li>结果不会溢出 $32$ 位整数</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为不允许采用四则运算，所以只能考虑位运算了。</p><p>其实就是用二进制来模拟加法操作。首先将两个数最低位相加，如果都是 $1$ ，那么就得到 $0$ ，并且进位 $1$ ，然后接着算下一位。</p><p>但是这样一位一位模拟不方便实现，更简单的实现方法是直接把两个数对应位相加，不管进位。然后进位单独计算，如果某一位两个数都是 $1$ ，那么进位就会对下一位产生影响。然后接着算不进位求和加上进位的值，再计算新的进位，依次重复下去，直到进位为 $0$ 为止。</p><p>用一个实际的例子来演示一下，计算 $3+7$ 的值，其中 $s$ 表示每一步不考虑进位的求和，$c$ 表示每一步的进位，最后得到结果 $1010$ ，也就是十进制的 $10$ ：<br><img src="1.jpg" alt></p><p>但是这里还是用到了加法怎么办呢？因为是二进制，所以不考虑进位求和的话，可以直接采用<strong>异或</strong>运算。而计算进位的话，直接用<strong>位与</strong>和<strong>左移一位</strong>就行了。</p><p>在 c++ 和 python 具体实现中，还有几个注意事项：</p><ul><li>LeetCode c++ 不允许负数左移操作，所以要转换成无符号整数。</li><li>python 因为位数没有限制，所以负数补码会很长，所以要位与 0xffffffff 处理成 $32$ 位整型数。</li><li>c++ 还可以写成递归形式，也就是 $a+b$ 可以递归成 $s+c$ ，其中 $s$ 表示不进位求和结果，$c$ 表示进位的值。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="非递归（c-）"><a href="#非递归（c-）" class="headerlink" title="非递归（c++）"></a>非递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>            a <span class="token operator">^</span><span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> carry<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归（c-）"><a href="#递归（c-）" class="headerlink" title="递归（c++）"></a>递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">^</span>b<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非递归（python）"><a href="#非递归（python）" class="headerlink" title="非递归（python）"></a>非递归（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xffffffff</span>        b <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xffffffff</span>        <span class="token keyword">while</span> b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            carry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span>            a <span class="token operator">^</span><span class="token operator">=</span> b            b <span class="token operator">=</span> carry        <span class="token keyword">return</span> a <span class="token keyword">if</span> a <span class="token operator">&lt;</span> <span class="token number">0x80000000</span> <span class="token keyword">else</span> <span class="token operator">~</span><span class="token punctuation">(</span>a<span class="token operator">^</span><span class="token number">0xffffffff</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="投机取巧（python）"><a href="#投机取巧（python）" class="headerlink" title="投机取巧（python）"></a>投机取巧（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 65】你能顺利救出地下城里的公主吗？</title>
      <link href="/2020/03/10/leetcode-174/"/>
      <url>/2020/03/10/leetcode-174/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/dungeon-game/" title="LeetCode 174. 地下城游戏" target="_blank" rel="noopener">LeetCode 174. 地下城游戏</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><table><thead><tr><th align="center">-2（K）</th><th align="center">-3</th><th align="center">-3</th></tr></thead><tbody><tr><td align="center">-5</td><td align="center">-10</td><td align="center">1</td></tr><tr><td align="center">10</td><td align="center">30</td><td align="center">-5（P）</td></tr></tbody></table><p><strong>提示：</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="错误解法"><a href="#错误解法" class="headerlink" title="错误解法"></a>错误解法</h3><p>首先我们肯定想到的是从左上到右下动态规划，那么对于 $(i, j)$ 这个格子来说，它有两个选择，可以从 $(i-1, j)$ 或者 $(i, j-1)$ 过来。</p><p>我们令 $dp[i][j]$ 表示从左上角走到 $(i, j)$ 这个格子所需要的最小生命值，那么我们选择 $\min{\{dp[i-1][j], dp[i][j-1]\}}$ ，也就是两个<strong>来向</strong>中较小的那个走过来。但是考虑了当前格子的数值之后，路线上所需生命的最小值是可能增大的，而这时候可能选择两个来向中较大的那个反而更好（因为那个来向数值之和比较大），所以这里就产生了矛盾，无法求解。</p><p>举个简单的例子：</p><table><thead><tr><th align="center">1（K）</th><th align="center">-3</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">-2</td><td align="center">0</td></tr><tr><td align="center">-3</td><td align="center">-3</td><td align="center">-3（P）</td></tr></tbody></table><p>这个例子中如果只看走到格子 $(1, 2)$ 的结果的话，肯定是 下 -&gt; 右 -&gt; 右 最好，因为这样初始生命只需要 2 就够了。而另一条路 右 -&gt; 右 -&gt; 下 则需要初始生命 3 。</p><p>但是如果继续走到格子 $(2, 2)$ ，那么最优方向一定是从 $(1, 2)$ 过来（另一个方向负数太多）。但是到 $(1, 2)$ 的最优路线保存的是 下 -&gt; 右 -&gt; 右 这一条，走到终点总和是 -4 ，初始所需最小生命增大为 5 。而另一条原本不怎么好的路线 右 -&gt; 右 -&gt; 下 总和是 -2 ，初始所需最小生命 3 ，所以仍然保持不变。</p><p>这样看来原本不好的路线在最后的结果里是可能会变好的，所以不好保存下来直接递推。</p><h3 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h3><p>既然从左上到右下没法动态规划，我们不妨从右下到左上动态规划看看。</p><p>我们令 $dp[i][j]$ 表示从 $(i, j)$ 这个格子走到右下角所需要的最小生命值，同样我们选择两个<strong>去向</strong>中的较小值 $\min{\{dp[i+1][j], dp[i][j+1]\}}$ 。然后考虑了格子 $(i, j)$ 之后， $dp[i][j]$ 就更新为：<br>$$<br>dp[i][j] = \max{\{1, \min{\{dp[i+1][j], dp[i][j+1]\}} - dungeon[i][j]\}}<br>$$<br>为什么这里选择两个去向中所需初始生命较小的那个就没问题了呢？</p><h3 id="严格证明"><a href="#严格证明" class="headerlink" title="严格证明"></a>严格证明</h3><p><img src="1.jpg" alt><br>考虑上图这种情况，这里我把 $(i, j)$ 抽象为了 $x$ ，右边一格抽象为了 $s$ ，右下角抽象为了 $t$ 。然后 $s \to t$ 走下面这条路所需初始生命值最小，路径上格子记为 $d$ ，另一条路径上格子记为 $d’$ 。</p><p>因为走路径 $d$ 所需的初始生命值更小，所以我们有：<br>$$<br>\max{\left\{ \max_k{\left\{ -\sum_{i=1}^k{d_i} \right\}}, 1 \right\}} &lt; \max{\left\{ \max_k{\left\{ -\sum_{i=1}^k{d’_i} \right\}}, 1 \right\}}<br>$$<br>等价于：<br>$$<br>\max_k{\left\{ -\sum_{i=1}^k{d_i} \right\}} &lt; \max_k{\left\{ -\sum_{i=1}^k{d’_i} \right\}}<br>$$<br>这时候我们在两边 $\max{\{\cdot\}}$ 里面同时加上 $-x$ ，大小关系是不会变的。</p><p>而错误解法中，考虑下图这种情况：<br><img src="2.jpg" alt><br>同样我们可以得到：<br>$$<br>\max_k{\left\{ -\sum_{i=1}^k{d_i} \right\}} &lt; \max_k{\left\{ -\sum_{i=1}^k{d’_i} \right\}}<br>$$</p><p>到这里为止和上面正确解法是一模一样的。但是，加上 $-x$ 之后，和上面正解的区别就是，<strong>正解求和里每一项都加了，所以大小关系不变，但是错解只有一项加了（就是所有值全加起来），大小关系无法确定</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calculateMinimumHP</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> dungeon<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> dungeon<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> dungeon<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> minn<span class="token operator">-</span>dungeon<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 64】LeetCode 861. 翻转矩阵后的得分</title>
      <link href="/2020/03/09/leetcode-861/"/>
      <url>/2020/03/09/leetcode-861/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个二维矩阵 $A$ 其中每个元素的值为 $0$ 或 $1$。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 $0$ 都更改为 $1$，将所有 $1$ 都更改为 $0$。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出：39解释：转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$1 \le A.length \le 20$</li><li>$1 \le A[0].length \le 20$</li><li>$A[i][j]$ 是 $0$ 或 $1$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要明确一个显而易见的事实：</p><ul><li>每一行、每一列要么不翻转，要么翻转一次，再多是等价的，没有意义。</li></ul><h3 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h3><p>因为行列数最多 $20$ ，所以我们可以枚举每一行的翻转状态（$0$：不翻转，$1$：翻转）。</p><p>然后对于每一列，我们只需要看不翻转的 $1$ 多，还是翻转后 $1$ 多就行了。</p><p>这样的时间复杂度是 $O(2^{R}C)$，极限情况下是 $2e^7$ 左右，还是可能会超时的。</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>再仔细观察，我们可以发现要想最终和最大，第一列必须全为 $1$ 。</p><p>证明很简单，对于任意一行，如果它的第一位是 $1$ ，那么这一位的二进制数值就是 $2^{C-1}$ 。反之如果这一位是 $0$ ，那么即使后面所有位全为 $1$ ，总数值也只能达到 $2^{C-1}-1$ 。所以第一位是一定要为 $1$ 的。</p><p>这样就很简单了，每一行的翻转情况其实是确定的。如果第一位是 $1$ ，就不翻转，否则就翻转。</p><p>然后每一列还是看不翻转的 $1$ 多，还是翻转后 $1$ 多。</p><p>这样的时间复杂度只有 $O(RC)$ 。</p><p>那么可能有人会问：为啥不把每行第一位全翻转为 $0$ ，然后翻转第一列使得每行第一位全 $1$ 呢？其实这样是等价的，完全就相当于将之前的方法倒转过来（翻转不翻转操作颠倒）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">matrixScore</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cnt <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> n<span class="token operator">-</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> cnt<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 63】LeetCode 第 179 场周赛题解</title>
      <link href="/2020/03/08/leetcode-week-179/"/>
      <url>/2020/03/08/leetcode-week-179/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>起床打开 leetcode，准备看看今天搞点啥题目水一水的，突然发现周赛还剩 1 小时整。看了眼题目也都挺简单的，就把 4 道题都做掉了。</p></blockquote><h2 id="LeetCode-5352-生成每种字符都是奇数个的字符串"><a href="#LeetCode-5352-生成每种字符都是奇数个的字符串" class="headerlink" title="LeetCode 5352. 生成每种字符都是奇数个的字符串"></a>LeetCode 5352. 生成每种字符都是奇数个的字符串</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题就没什么好说的了，如果 $n$ 是奇数，那就生成 $n$ 个 $a$ 。如果 $n$ 是偶数，那就生成 $n-1$ 个 $a$ ，再加上 $1$ 个 $b$ 。</p><h3 id="代码（python）"><a href="#代码（python）" class="headerlink" title="代码（python）"></a>代码（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateTheString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"a"</span><span class="token operator">+</span><span class="token string">"b"</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">"a"</span><span class="token operator">*</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5353-灯泡开关-III"><a href="#LeetCode-5353-灯泡开关-III" class="headerlink" title="LeetCode 5353. 灯泡开关 III"></a>LeetCode 5353. 灯泡开关 III</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher-iii/</a></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果某一个时刻灯都是蓝色的，等价于所有的亮灯都连续排列在数组最左边，没有间断。所以只需要判断当前时刻亮灯的最大编号是否等于亮灯的数量就行了。</p><p>比赛的时候傻 x 了，第一个想到的竟然是树状数组，于是直接把模板套过来过了。</p><h3 id="代码（c-）"><a href="#代码（c-）" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numTimesAllBlue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> light<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> light<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> light<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxx <span class="token operator">==</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>树状数组：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">50010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">numTimesAllBlue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> light<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> light<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add</span><span class="token punctuation">(</span>light<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> light<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>maxx<span class="token punctuation">)</span> <span class="token operator">==</span> maxx<span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5354-通知所有员工所需的时间"><a href="#LeetCode-5354-通知所有员工所需的时间" class="headerlink" title="LeetCode 5354. 通知所有员工所需的时间"></a>LeetCode 5354. 通知所有员工所需的时间</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/</a></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先根据 $manager$ 数组来建图，边权就是父结点到子结点的通知时间。然后从根结点开始做 dfs ，求出根结点到每个叶子结点的路径长度的最大值。</p><h3 id="代码（c-）-1"><a href="#代码（c-）-1" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">numOfMinutes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> headID<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> manager<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> informTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>manager<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                G<span class="token punctuation">[</span>manager<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>headID<span class="token punctuation">,</span> informTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> headID<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> informTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>informTime<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> informTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxx<span class="token operator">+</span>informTime<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5355-T-秒后青蛙的位置"><a href="#LeetCode-5355-T-秒后青蛙的位置" class="headerlink" title="LeetCode 5355. T 秒后青蛙的位置"></a>LeetCode 5355. T 秒后青蛙的位置</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/frog-position-after-t-seconds/</a></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先建图，然后从 $1$ 号结点开始，还是用 dfs 。每往下走一次，时间 $t$ 减 $1$ 。如果 $t = 0$ 或者到了叶子结点了，就判断结点是否为 $target$ ，是就返回 $1$ ，不是就返回 $0$ 。每次概率除以当前结点的子结点个数，然后再乘上所有子结点 dfs 结果的最大值（因为结果不是 $0$ 就是正确概率）。</p><h3 id="代码（c-）-2"><a href="#代码（c-）-2" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">frogPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">G</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> target<span class="token punctuation">,</span> G<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">||</span> <span class="token punctuation">(</span>fa <span class="token operator">&amp;&amp;</span> sz <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">double</span> p <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>fa <span class="token operator">?</span> sz<span class="token number">-1</span> <span class="token operator">:</span> sz<span class="token punctuation">)</span><span class="token punctuation">,</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span> t<span class="token number">-1</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> G<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token operator">*</span>maxx<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 62】LeetCode 815. 公交路线</title>
      <link href="/2020/03/07/leetcode-815/"/>
      <url>/2020/03/07/leetcode-815/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们有一系列公交路线。每一条路线 $routes[i]$ 上都有一辆公交车在上面循环行驶。例如，有一条路线 $routes[0] = [1, 5, 7]$，表示第一辆（下标为 $0$）公交车会一直按照 $1 \to 5 \to 7 \to 1 \to 5 \to 7 \to 1 \to \ldots$ 的车站路线行驶。</p><p>假设我们从 $S$ 车站开始（初始时不在公交车上），要去往 $T$ 站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回 $-1$ 表示不可能到达终点车站。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6输出：2解释：最优策略是先乘坐第一辆公交车到达车站 7, 然后换乘第二辆公交车到车站 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$1 \le routes.length \le 500$.</li><li>$1 \le routes[i].length \le 500$.</li><li>$0 \le routes[i][j] &lt; 10 ^ 6$.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们可以将每一条线路视作一个点，对于任意两条线路，如果它们经过的车站有交集，那么就在两点之间连一条边，这样就构成了一张图。</p><p>图中有些点（路线）是包含起点 $S$ 的，我们把它们都作为起点。而有些点（路线）是包含终点 $T$ 的，我们把它们都作为终点。</p><p>那么问题就转化为了求起点到终点的最短路径。因为起点和终点数量可能有多个，所以我们新建两个结点，一个起点用来指向所有包含 $S$ 的点，一个终点用来指向所有包含 $T$ 的点。接下来问题就变成了单源最短路径问题了。</p><p>因为本题中边并没有权值（或者说都是 $1$），那么我们就可以直接用 BFS 来进行求解最短路。</p><p>建图的时候，对于任意两条路线，我们要判断它们车站是否存在交集。可以事先对每条线路的车站编号进行排序，然后用双指针法判断。最好排完序还要去重，防止数据有重复。不过实际运行中，就算不排序也能通过，说明数据给的就是有序的了。</p><p>最终时间复杂度由几部分决定。假设路线数量是 $N$，每条路线最多有 $M$ 个车站。那么排序复杂度为 $O(NM \log M)$，建图复杂度为 $O(N^2M)$，BFS 复杂度为 $O(N^2)$。因此总的时间复杂度忽略低阶项之后为 $O(N^2M)$。看起来貌似还是有点高，但其实建图的时候，大多数情况下双指针法并不会遍历完所有的车站，所以达不到 $O(M)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numBusesToDestination</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> routes<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>S <span class="token operator">==</span> T<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> routes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">sort</span><span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        routes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>S<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        routes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>T<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> G <span class="token operator">=</span> <span class="token function">buildGraph</span><span class="token punctuation">(</span>routes<span class="token punctuation">,</span> S<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">BFS</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">buildGraph</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> routes<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> routes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">G</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> su <span class="token operator">=</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sv <span class="token operator">=</span> routes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>u <span class="token operator">&lt;</span> su <span class="token operator">&amp;&amp;</span> v <span class="token operator">&lt;</span> sv<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> routes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>u<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> routes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>v<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                        G<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> G<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">BFS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> S <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> T <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>        dis<span class="token punctuation">[</span>S<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> v <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                    dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> T<span class="token punctuation">)</span> <span class="token keyword">return</span> dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 61】LeetCode 672. 灯泡开关 Ⅱ</title>
      <link href="/2020/03/06/leetcode-672/"/>
      <url>/2020/03/06/leetcode-672/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一个房间，墙上挂有 $n$ 只已经打开的灯泡和 $4$ 个按钮。在进行了 $m$ 次未知操作后，你需要返回这 $n$ 只灯泡可能有多少种不同的状态。</p><p>假设这 $n$ 只灯泡被编号为 $[1, 2, 3 …, n]$，这 $4$ 个按钮的功能如下：</p><ul><li>将所有灯泡的状态反转（即开变为关，关变为开）</li><li>将编号为偶数的灯泡的状态反转</li><li>将编号为奇数的灯泡的状态反转</li><li>将编号为 $3k+1$ 的灯泡的状态反转（$k = 0, 1, 2, \ldots$)</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 1, m = 1.输出：2解释：状态为: [开], [关]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 2, m = 1.输出：3解释：状态为: [开, 关], [关, 开], [关, 关]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 3, m = 1.输出：4解释：状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$n$ 和 $m$ 都属于 $[0, 1000]$.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要知道，<strong>一个操作做两次就等于没做</strong>，所以一个操作只有<strong>没做</strong>和<strong>做了</strong>两种状态，也就是说有效操作数量最多 $4$ 次：$m = \min{\{m, 4\}}$。</p><p>然后我们观察每一个操作对灯状态（初始都开着，状态都为 $1$）的影响：</p><ul><li>操作 $1$ 每 $1$ 个灯状态就要反转一次，也就是灯的状态按照周期 $1$ 重复（与 $(1,\ldots)$ 异或）。</li><li>操作 $2$ 每 $2$ 个灯状态就要反转一次，也就是灯的状态按照周期 $2$ 重复（与 $(0,1,\ldots)$ 异或）。</li><li>操作 $3$ 每 $2$ 个灯状态就要反转一次，也就是灯的状态按照周期 $2$ 重复（与 $(1,0,\ldots)$ 异或）。</li><li>操作 $4$ 每 $3$ 个灯状态就要反转一次，也就是灯的状态按照周期 $3$ 重复（与 $(1,0,0,\ldots)$ 异或）。</li></ul><p>综上，我们只需要取周期的最小公倍数 $6$ 就行了。也就是<strong>只需要看前 $6$ 盏灯的最终状态，就能唯一确定后面所有灯的最终状态</strong>。</p><p>形式化表示，用 $a_i = \{0, 1\}$ 表示第 $i$ 个操作是否用过。那么对于第 $i$ 盏灯来说，它的最终状态可以表示为：<br>$$<br>s_i = 1 \oplus a_1 \oplus a_2 [i \% 2 = 0] \oplus a_3 [i \% 2 = 1] \oplus a_4 [i \% 3 = 1]<br>$$<br>由此可以推出： $s_i = s_{i+6}$，也就是灯的最终状态以 $6$ 为周期。</p><p>到此其实可以直接暴力枚举 $1 \le n \le 6, 1 \le m \le 4$ 的所有状态了，但是还是有优化空间的。</p><p>如果我们列出前 $6$ 盏灯的状态：</p><ul><li>$s_1 = 1 \oplus a_1 \oplus a_3 \oplus a_4$</li><li>$s_2 = 1 \oplus a_1 \oplus a_2$</li><li>$s_3 = 1 \oplus a_1 \oplus a_3$</li><li>$s_4 = 1 \oplus a_1 \oplus a_2 \oplus a_4$</li><li>$s_5 = 1 \oplus a_1 \oplus a_3$</li><li>$s_6 = 1 \oplus a_1 \oplus a_2$</li></ul><p>我们可以看出，<strong>如果前 $3$ 盏灯状态确定了，可以唯一确定出后 $3$ 盏灯状态</strong>。因此，我们只需要计算前 $3$ 盏灯有多少种状态就行了。</p><p>最终经过枚举计算（$1 \le n \le 3, 0 \le m \le 4$）：</p><ul><li>如果 $m = 0$ ，那么就只有 $1$ 种状态（灯都开着）。</li><li>否则如果 $n = 1$ ，那么有 $2$ 种状态。</li><li>否则如果 $n = 2$ ，若 $m = 1$，就有 $3$ 种状态；若 $m \ge 2$ ，就有 $4$ 种状态。</li><li>否则如果 $n \ge 3$ ，若 $m = 1$，就有 $4$ 种状态；若 $m = 2$ ，就有 $7$ 种状态；若 $m \ge 3$ ，就有 $8$ 种状态。</li></ul><p>如果你实在不想手动计算，那你可以枚举所有的 $16$ 种操作状态，然后保存前三盏灯的状态到一个集合中，最终输出集合大小就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">flipLights</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipLights</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span>        m <span class="token operator">=</span> min<span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python（枚举）"><a href="#python（枚举）" class="headerlink" title="python（枚举）"></a>python（枚举）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipLights</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>        seen <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> cand <span class="token keyword">in</span> itertools<span class="token punctuation">.</span>product<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repeat <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> sum<span class="token punctuation">(</span>cand<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> m <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">and</span> sum<span class="token punctuation">(</span>cand<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>                A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>min<span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    light <span class="token operator">=</span> <span class="token number">1</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">2</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span>                    A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>light<span class="token punctuation">)</span>                seen<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 319】灯泡开关</title>
      <link href="/2020/03/05/leetcode-319/"/>
      <url>/2020/03/05/leetcode-319/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>初始时有 $n$ 个灯泡关闭。 第 $1$ 轮，你打开所有的灯泡。 第 $2$ 轮，每两个灯泡你关闭一次。 第 $3$ 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 $i$ 轮，每 $i$ 个灯泡切换一次开关。 对于第 $n$ 轮，你只切换最后一个灯泡的开关。 找出 $n$ 轮后有多少个亮着的灯泡。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：3输出：1解释：初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先有 $n$ 个灯泡，假设编号为 $1$ 到 $n$ 。第 $1$ 轮，所有编号是 $1$ 的倍数的灯泡被开关了一次。第 $2$ 轮，所有编号是 $2$ 的倍数的灯泡被开关了一次。类推下去，第 $i$ 轮，所有编号是 $i$ 的倍数的灯泡被开关了一次。</p><p>综上，对于编号为 $i$ 的灯泡来说，它最终被开关的次数取决于 $i$ 有几个因数。如果有奇数个因数，那么它最后就是开着的，否则就是关着的。</p><p>那么我们有一个定理：<strong>如果一个正整数有奇数个因数，那么它一定是完全平方数</strong>。</p><p>最浅显的证明就是，一个数 $i$ 的因数按照从小到大排个序，首尾两两一对之积一定等于 $i$ 。而如果因数只有奇数个，最中间一个因数 $x$ 只会出现一次，那么 $i = x^2$ 。</p><p>严格证明也不难，首先将 $i$ 质因数分解为：<br>$$<br>i = p_1^{c_1}p_2^{c_2}\cdots p_k^{c_k}<br>$$<br>那么 $i$ 的因数个数就是：<br>$$<br>(c_1+1)(c_2+1)\cdots (c_k+1)<br>$$<br>因为 $i$ 的因数个数是奇数，所以任意 $c_j + 1$ 必定是奇数，即任意 $c_j$ 必定是偶数。</p><p>那么 $i$ 就可以写作：<br>$$<br>i = (p_1^{c_1/2}p_2^{c_2/2}\cdots p_k^{c_k/2})^2<br>$$<br>这就证明了 $i$ 一定是一个完全平方数。</p><p>所以问题就转化为了<strong>求 $1$ 到 $n$ 之间有多少个完全平方数</strong>。答案就是 $\left\lfloor\sqrt{n}\right\rfloor$ 。</p><p>在具体实现的时候，为了防止出现浮点数误差（比如 $\sqrt{9}$ 算出来是 $2.9999$ ，取整得到 $2$），我们可以计算 $\left\lfloor\sqrt{n+0.5}\right\rfloor$ 的结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">bulbSwitch</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1363】形成三的最大倍数</title>
      <link href="/2020/03/04/leetcode-1363/"/>
      <url>/2020/03/04/leetcode-1363/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 digits，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。</p><p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p><p>如果无法得到答案，请返回一个空字符串。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [8,1,9]输出："981"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [8,6,7,1,0]输出："8760"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [1]输出：""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [0,0,0,0,0,0]输出："0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= digits.length &lt;= 10^4</li><li>0 &lt;= digits[i] &lt;= 9</li><li>返回的结果不应包含不必要的前导零。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要知道一个小学生都知道的定理：<strong>如果一个数可以被 $3$ 整除，那么它的每一位上的数之和也可以被 $3$ 整除，反之也成立。</strong></p><p>那么问题就转化为了挑选出最多的数，使得和是 $3$ 的倍数。我们可以先求出所有数之和，记为 $sum$ ，然后有如下三种情况：</p><ul><li>如果 $sum \% 3 = 0$ ，那么所有数都选中就行了。</li><li>如果 $sum \% 3 = 1$ ，那么必须删掉一个模 $3$ 余 $1$ 的数（按照从小到大顺序删除 1、4、7）。如果这三个数都没有，那就要删除两个模 $3$ 余 $2$ 的数（按照从小到大顺序删除 2、5、8，删除两次）。</li><li>如果 $sum \% 3 = 2$ ，那么必须删掉一个模 $3$ 余 $2$ 的数（按照从小到大顺序删除 2、5、8）。如果这三个数都没有，那就要删除两个模 $3$ 余 $1$ 的数（按照从小到大顺序删除 1、4、7，删除两次）。</li></ul><p>最终将剩下的数按照从小到大顺序排序，拼接在一起就行了。</p><p>注意如果有前导 $0$ ，就说明答案就是 $0$ 。</p><p>时间复杂度为 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">del</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cnt<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">==</span> q <span class="token operator">&amp;&amp;</span> cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">--</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string <span class="token function">largestMultipleOfThree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            sum <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">&amp;&amp;</span> <span class="token function">del</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">del</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">-</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">del</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">-</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">+</span><span class="token operator">=</span> i<span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"0"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 128】最长连续序列</title>
      <link href="/2020/03/03/leetcode-128/"/>
      <url>/2020/03/03/leetcode-128/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 $O(n)$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[100, 4, 200, 1, 3, 2]输出：4解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>因为题目要求 $O(n)$ 的时间复杂度，所以不能排序。</p><p>我们可以遍历每个数 $x$，假设它是某个连续序列的开头，那么首先要满足 $x-1$ 不在数组中，然后从 $x+1$ 开始逐渐增大，看最大多少还在数组里。</p><p>实现上查询数字在不在数组里可以采用哈希表，复杂度是 $O(1)$ 的。虽然看起来遍历每个数是 $O(n)$ ，以它为开头逐渐增大又是 $O(n)$ ，但是我们其实只会对开头的数遍历最大能达到多少。这样两层循环总的遍历次数其实还是 $O(n)$ 的。</p><p>总的时间复杂度就是 $O(n)$ 。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>我们可以把任意两个相差为 $1$ 的数之间连上边，那么数组就变成了若干个子树，我们只需要求结点数量最多的那个子树就行了。</p><p>用并查集可以实现连接两个连续序列，合并成一个连续序列，并且快速查询这个序列长度是多少。</p><p>首先初始的时候，数组中的每个数都自成一个子树（它自己就是根结点）。然后遍历每一个数 $x$ ，如果 $x+1$ 也在数组中，那就合并这两个数所在的子树，并且统计合并后的子树大小。</p><p>总的时间复杂度也是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="哈希表（c-）"><a href="#哈希表（c-）" class="headerlink" title="哈希表（c++）"></a>哈希表（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> y<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并查集（c-）"><a href="#并查集（c-）" class="headerlink" title="并查集（c++）"></a>并查集（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> fa<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">==</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        y <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>        cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> cnt<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>            cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fa<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">merge</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析【EMNLP19】多粒度自注意力机制（MG-SA）</title>
      <link href="/2020/03/02/emnlp19-mgsa/"/>
      <url>/2020/03/02/emnlp19-mgsa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="http://arxiv.org/abs/1909.02222" title="Multi-Granularity Self-Attention for Neural Machine Translation" target="_blank" rel="noopener">Multi-Granularity Self-Attention for Neural Machine Translation</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在主流的机器翻译模型基本都是采用多头注意力机制来对句子进行编码解码，但是有一些研究表明，这么多 head 其实并不是都有用的，有些 head 的信息是冗余的，所以本文就想充分利用一下这些冗余的 head 。</p><p>此外，统计机器翻译的研究也表明了，对短语的翻译效果可能要好于对单个单词的翻译，所以本文将一些 head 用来建模短语（比如 2-gram 或者 3-gram）。</p><p>最后本文在两个翻译任务（WMT14 英译德和 NIST 中译英）上做了实验，效果都要好于普通的 Transformer ，但是运行速度上慢了许多。</p><h2 id="多粒度自注意力机制（MG-SA）"><a href="#多粒度自注意力机制（MG-SA）" class="headerlink" title="多粒度自注意力机制（MG-SA）"></a>多粒度自注意力机制（MG-SA）</h2><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>首先将单词级别的输入 $H = h_1, \ldots, h_n \in \mathbb{R}^{n \times d}$ 映射为短语级别的表示 $H_g \in \mathbb{R}^{p \times d_g}$：<br>$$<br>H_g = F_h(H)<br>$$<br>其中 $F_h$ 是第 $h$ 个 head 对应的映射函数，针对不同的短语粒度有不同的映射函数。而 $p$ 是短语的个数，不同粒度个数也是不同的。</p><p>然后对于第 $h$ 个 head 来说，将 $H, H_g, H_g$ 分别做线性变换，得到自注意力机制的 query、key 和 value：<br>$$<br>Q^h, K^h, V^h = HW^h_Q, H_gW^h_K, H_gW^h_V<br>$$<br>这样三种向量都被映射到了相同的维度：$Q_h \in \mathbb{R}^{n \times d_h}, K_h \in \mathbb{R}^{p \times d_h}, V_h \in \mathbb{R}^{p \times d_h}$ 。</p><p>接着做 self-attention 得到每个单词的输出：<br>$$<br>O^h = \text{ATT}(Q^h, K^h)V^h<br>$$<br>最后将 $N$ 个 head 输出拼接起来得到了最后的输出：<br>$$<br>\text{MG-SA}(H) = [O^1, \ldots, O^N]<br>$$</p><h3 id="短语划分"><a href="#短语划分" class="headerlink" title="短语划分"></a>短语划分</h3><p>短语划分有两种方式，一种是 n-gram ，一种是根据句法树划分。n-gram 划分方式就是将句子 $x$ 等分为 $M$ 个短语得到 $P_x = (p_1, \ldots. p_M)$ 。而句法树划分就是按照句法树的不同层次得到不同粒度的短语，如下图所示：<br><img src="1.png" alt><br>绿色框是第一层，有 2 个短语，粒度比较大。红色框是第二层，有 4 个短语，粒度小一点。</p><h3 id="短语组合"><a href="#短语组合" class="headerlink" title="短语组合"></a>短语组合</h3><p>每个短语 $p_m$ 的表示可以用不同的网络来得到：<br>$$<br>g_m = \text{COM}(p_m)<br>$$<br>这里 $\text{COM}$ 函数可以用 CNN、LSTM 或者自注意力网络（SAN）。</p><p>最后所有短语的表示记为 $G_x = (g_1, \ldots, g_M)$ 。</p><h3 id="短语交互"><a href="#短语交互" class="headerlink" title="短语交互"></a>短语交互</h3><p>这些短语之间也像单词一样做一下上下文表示，效果可能会更好：<br>$$<br>H_g = \text{REC}(G_x)<br>$$<br>这里 $\text{REC}$ 可以选择 LSTM 或者编码结构能力好的 <a href="http://arxiv.org/abs/1810.09536" title="Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks" target="_blank" rel="noopener">ON-LSTM</a> 。</p><p>最后如下图所示，通过<strong>短语划分</strong>、<strong>短语组合</strong>、<strong>短语交互</strong>，模型得到了不同粒度的各个短语表示：<br><img src="2.png" alt></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>这里添加了一个辅助任务用来增强效果：短语标签预测。也就是对于 $G_x = (g_1, \ldots, g_M)$ 而言，在句法树中对应着 $M$ 个短语标签 $T_x = (t_1, \ldots, t_M)$ 。然后用一个线性变换接 softmax 来预测标签的概率：<br>$$<br>p = softmax(W_t g_i + b_t)<br>$$<br>最后标签预测的损失函数就是：<br>$$<br>\mathcal{L}_{tag} = -\sum_{i=1}^M{t_i \log p(t_i)}<br>$$</p><p>最终的损失函数还得再加上机器翻译的损失：<br>$$<br>\mathcal{L} = -\sum_{i=1}^L{y_i \log P(y_i)} + \lambda \mathcal{L}_{tag}<br>$$<br>这里的 $y_i$ 就是机器翻译的输出单词，$\lambda$ 在实验中设置为了 $0.001$。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>模型是在 Transformer 基础上修改的，把四分之一的 head 还用来做单词级别的 self-attention 。对于 n-gram 划分来说，四分之三的 head 分别用来做 2-gram、3-gram 和 4-gram 短语的 self-attention 。对于句法树短语划分来说，四分之三的 head 正好对应了最高的三层短语的 self-attention 。</p><p>实验主要得出了三点结论，如果不想看细节的，可以只看结论了：</p><ul><li>融入了 MG-SA 的 Transformer 的确提高了机器翻译的 BLUE 得分。</li><li>MG-SA 确实可以促进目标短语的生成。</li><li>MG-SA 确实可以捕捉到不同粒度的短语信息。</li></ul><h3 id="不同短语组合策略"><a href="#不同短语组合策略" class="headerlink" title="不同短语组合策略"></a>不同短语组合策略</h3><p><img src="3.jpg" alt><br>可以看出三种策略效果都比普通的 Transformer 好，SAN 的效果最好，所以后面实验都用 SAN 。</p><h3 id="不同-encoder-层"><a href="#不同-encoder-层" class="headerlink" title="不同 encoder 层"></a>不同 encoder 层</h3><p><img src="4.jpg" alt><br>MG-SA 用的层数越低效果越好，只用在最低层上效果最好（可能是因为直接和单词表示接触，对短语建模更有利），所以后面实验都只用到最低层上。</p><h3 id="短语划分、标签监督和短语交互策略影响"><a href="#短语划分、标签监督和短语交互策略影响" class="headerlink" title="短语划分、标签监督和短语交互策略影响"></a>短语划分、标签监督和短语交互策略影响</h3><p><img src="5.jpg" alt><br>这个也不用过多解释，说明了句法树划分短语比 n-gram 划分短语效果好，短语标签预测辅助任务确实有用，用 ON-LSTM 融合短语确实要更好。</p><h3 id="输出-n-gram-性能提升"><a href="#输出-n-gram-性能提升" class="headerlink" title="输出 n-gram 性能提升"></a>输出 n-gram 性能提升</h3><p><img src="6.jpg" alt><br>通过对翻译结果的 n-gram 的 BLEU 得分进行分析，可以看出几种 MG-SA 的变体效果都是好于普通的 Transformer 的，说明了确实可以促进目标短语的生成。</p><h3 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h3><p><img src="7.jpg" alt><br>无论是 Transformer 的 base 还是 large 版本，加上 MG-SA 之后效果都有较大提升，base 版本加上去之后效果甚至逼近了 large 版本，同时参数量并没有多太多。</p><h3 id="attention-可视化"><a href="#attention-可视化" class="headerlink" title="attention 可视化"></a>attention 可视化</h3><p><img src="8.jpg" alt><br>可以看出，普通的 Transformer（左边）每个词主要聚焦于前后一个词和句子结束标记，而 MG-SA 则大多聚焦于句子的关键词“三峡工程”和“首要任务”。</p><h3 id="多粒度标签预测任务"><a href="#多粒度标签预测任务" class="headerlink" title="多粒度标签预测任务"></a>多粒度标签预测任务</h3><p><img src="9.jpg" alt><br>做了 5 个探测任务：Voice（主动被动）、Tense（时态）、TSS（根结点下层标签序列预测）、SPC（单词的最小包含短语标签）和 POS（词性标注）。</p><p>模型就是在 MG-SA 的 encoder 上面接了一个 MLP ，然后做分类。encoder 分为两种，一种是固定参数，用 NMT 训练好的 encoder ，一种是重新训练 encoder 。</p><p>主要得到以下几点结论：</p><ul><li>重新训练 encoder 结果比直接用 NMT 的 encoder 效果提升大（除了 SPC 和 POS）。</li><li>用句法树划分短语效果比 n-gram 划分短语效果好。</li><li>用 NMT 的 encoder 时，只有 SPC 和 POS 效果提升大（主要这两个任务粒度小，都是单词级别的，任务很简单）。</li><li>重新训练 encoder 时前三个任务有提升（因为粒度比较大，而后两个仅靠 MLP 就能学的很好了）。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文提出了一种多粒度的自注意力机制，将其加入到了 Transformer 的 encoder 中。不仅仅是机器翻译任务，其他许多任务例如阅读理解、语言推理、情感分类等都可以用上这种方法，更好的融入短语结构信息。</p><p>其实这篇和 <a href="http://arxiv.org/abs/1909.06639" title="Tree Transformer: Integrating Tree Structures into Self-Attention" target="_blank" rel="noopener">Tree Transformer: Integrating Tree Structures into Self-Attention</a> 挺类似的，都是在 Transformer 的 self-attention 上面做了手脚，加入了一些结构上的信息，增强 encoder 的编码能力。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 329】矩阵中的最长递增路径</title>
      <link href="/2020/03/02/leetcode-329/"/>
      <url>/2020/03/02/leetcode-329/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [  [9,9,4],  [6,6,8],  [2,1,1]]输出：4解释：最长递增路径为 [1, 2, 6, 9]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [  [3,4,5],  [3,2,6],  [2,2,1]]输出：4解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DFS-记忆化搜索"><a href="#DFS-记忆化搜索" class="headerlink" title="DFS+记忆化搜索"></a>DFS+记忆化搜索</h3><p>对于点 $[x, y]$ 来说，以它为终点的最长递增路径一定会经过上下左右四个点其一。所以如果它四周的点小于 $[x, y]$ ，就递归遍历四周的点，然后以 $[x, y]$ 为终点的最长递增路径长度就是以四周小于它的点为终点的最长递增路径长度加 $1$ ：<br>$$<br>dfs(x, y) = \max{\{dfs(x-1, y), dfs(x+1, y), dfs(x, y-1), dfs(x, y+1)\}} + 1<br>$$<br>注意这里四周的点首先不能超过边界，然后数值上必须小于 $[x, y]$ 。</p><p>但是直接这样会有很多重复计算，所以我们必须用记忆化搜索，用 $dp[x][y]$ 保存搜索结果。如果发现已经计算过了，就不再递归，直接返回结果。</p><p>最终每个格子最多遍历一遍，时间复杂度是 $O(nm)$ 。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>把每个格子当作一个点，然后从数值小的点向四周比它大的点连一条有向边，最终一定会形成一个有向无环图，问题就转变成了求有向无环图中的最长路径。</p><p>方法是先找到所有入度为 $0$ 的结点，然后放入一个队列，依次从队列里取出结点，从图中删除这些结点。然后图中就出现了新的入度为 $0$ 的结点了，它们路径长度加 $1$ 。接着重复上面的操作，直到最后没有结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="DFS-记忆化搜索（c-）"><a href="#DFS-记忆化搜索（c-）" class="headerlink" title="DFS+记忆化搜索（c++）"></a>DFS+记忆化搜索（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">longestIncreasingPath</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> dp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拓扑排序（c-）"><a href="#拓扑排序（c-）" class="headerlink" title="拓扑排序（c++）"></a>拓扑排序（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">longestIncreasingPath</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">degree</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> Q<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> nx <span class="token operator">=</span> i <span class="token operator">+</span> dx<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> j <span class="token operator">+</span> dy<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">,</span> y <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">></span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">--</span>degree<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    dp<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【kentln供题】模糊的数字</title>
      <link href="/2020/03/01/kentln-0/"/>
      <url>/2020/03/01/kentln-0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>感谢 <strong>kentln</strong> 供题，题目的出处已经不记得了，只能凭印象描述一下题意。</p></blockquote><p>大致意思就是给你一个字符串 $s$ ，表示一个正整数，但是有些位已经模糊了（用 $x$ 表示）。现在知道它一定能被 $n$ 整除，求 $s$ 表示的正整数一共有多少种可能？注意，不允许出现前导 $0$ 。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：8x4171x 5输出：20解释：第一个 x 可以取 0 到 9 一共 10 个数，第二个 x 只能取 0 或者 5 ，所以一共有 10 * 2 = 20 种可能。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：x9953xx 1输出：900解释：第一个 x 可以取 1 到 9 一共 9 个数，后面两个 x 随便取，所以一共有 9 * 10 * 10 = 900 种可能。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$6 \le s.length \le 9$</li><li>$1 \le n \le 100$</li><li>输入数据可能不止一组，请输入到文件结束为止</li><li>数据组数 $T = 10000$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题最暴力的方法就是枚举所有的数，然后判断每个数是否是 $n$ 倍数就行了，时间复杂度是 $O(10^{s.length} \cdot T)$ ，最大可以达到 $10^{13}$ 级别，无法接受！</p><p>那么我们从 $s$ 的最低位（也就是第 0 位）开始考虑，假设当前已经考虑到了第 $i$ 位。我们用数组 $c[k]$ 表示前面 $i-1$ 位表示的所有数字中余数为 $k$ 可能有几种，初始的时候 $c[0] = 1$ ，其它都为 $0$ （因为一位都没有的话，就当作 $0$ 处理）。</p><p>如果第 $i$ 位不是 $x$ ，那就说明第 $i$ 位上面已经有数字了。否则的话可以取 $0$ 到 $9$ 之间任意数（如果 $x$ 在最高位，排除掉 $0$）。</p><p>假设第 $i$ 位取 $j$ ，那么第 $i$ 位上面的数字在整个数字中的大小就是 $j \cdot 10^i$ 。假设它对 $n$ 取模结果是 $q = (j \cdot 10^i) \% n$ ，那么对于前 $i-1$ 位来说，余数为 $k$ 的答案有 $c[k]$ 种。加上第 $i$ 位之后，余数变成了 $(q+k)\%n$ ，所以前 $i$ 位余数为 $(q+k)\%n$ 的答案要加上 $c[k]$ 。</p><p>最后整个 $s$ 的可能情况种数就是 $c[0]$ 。</p><p>时间复杂度为 $O(s.length \cdot 10 \cdot n \cdot T)$ ，极限情况下会达到 $9 \cdot 10^{7}$ 级别，还可以接受。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> lb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rb <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                lb <span class="token operator">=</span> rb <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lb <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">tc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> lb<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> rb<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">*</span> pow<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    tc<span class="token punctuation">[</span><span class="token punctuation">(</span>q<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            c <span class="token operator">=</span> tc<span class="token punctuation">;</span>            pow <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p>因为这题忘了出处了，所以评测的话得靠自己运行，然后和正确答案比较。</p><p>输入数据和标准输出在 <strong>公众号后台回复【kentln-0】</strong> 下载，步骤如下：</p><ul><li>首先在你的 c++ 程序 <code>main</code> 函数开头加上如下两句：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>作用就是重定向输入输出，从 <code>in.txt</code> 读入数据，输出答案到 <code>out.txt</code> 中。</li><li>编译你的 c++ 程序 <code>g++ 代码文件名.cpp -o test</code> ，并运行 <code>./test</code> 。</li><li>然后比较你的输出和标准输出区别，采用命令 <code>comp ans.txt out.txt</code> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个函数解决【LeetCode 买卖股票的最佳时机】系列所有题目！</title>
      <link href="/2020/03/01/leetcode-btbss/"/>
      <url>/2020/03/01/leetcode-btbss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目和题解汇总"><a href="#题目和题解汇总" class="headerlink" title="题目和题解汇总"></a>题目和题解汇总</h2><p>之前介绍了【LeetCode 买卖股票的最佳时机】系列一共六道题目，这里把之前的题解还有题目链接汇总一下，方便大家查找。</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" title="LeetCode 121. 买卖股票的最佳时机" target="_blank" rel="noopener">LeetCode 121. 买卖股票的最佳时机</a><br><a href="https://zhuanlan.zhihu.com/p/108895299" title="每日算法系列【LeetCode 121】买卖股票的最佳时机" target="_blank" rel="noopener">每日算法系列【LeetCode 121】买卖股票的最佳时机</a></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" title="LeetCode 122. 买卖股票的最佳时机 II" target="_blank" rel="noopener">LeetCode 122. 买卖股票的最佳时机 II</a><br><a href="https://zhuanlan.zhihu.com/p/108902700" title="每日算法系列【LeetCode 122】买卖股票的最佳时机 II" target="_blank" rel="noopener">每日算法系列【LeetCode 122】买卖股票的最佳时机 II</a></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" title="LeetCode 123. 买卖股票的最佳时机 III" target="_blank" rel="noopener">LeetCode 123. 买卖股票的最佳时机 III</a><br><a href="https://zhuanlan.zhihu.com/p/108908636" title="每日算法系列【LeetCode 123】买卖股票的最佳时机 III" target="_blank" rel="noopener">每日算法系列【LeetCode 123】买卖股票的最佳时机 III</a></p><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" title="LeetCode 188. 买卖股票的最佳时机 IV" target="_blank" rel="noopener">LeetCode 188. 买卖股票的最佳时机 IV</a><br><a href="https://zhuanlan.zhihu.com/p/108925381" title="每日算法系列【LeetCode 188】买卖股票的最佳时机 IV" target="_blank" rel="noopener">每日算法系列【LeetCode 188】买卖股票的最佳时机 IV</a></p><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" title="LeetCode 714. 买卖股票的最佳时机含手续费" target="_blank" rel="noopener">LeetCode 714. 买卖股票的最佳时机含手续费</a><br><a href="https://zhuanlan.zhihu.com/p/108930022" title="每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费" target="_blank" rel="noopener">每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费</a></p><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" title="LeetCode 309. 买卖股票的最佳时机" target="_blank" rel="noopener">LeetCode 309. 最佳买卖股票时机含冷冻期</a><br><a href="https://zhuanlan.zhihu.com/p/108931927" title="每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期" target="_blank" rel="noopener">每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期</a></p><h2 id="通用解法"><a href="#通用解法" class="headerlink" title="通用解法"></a>通用解法</h2><p>上面六道题目中，前四题限制了买卖的次数，第五题加入了手续费，第六题加入了冻结时间。所以我们提出一般性的问题：</p><p><strong>给定每天的价格 $prices$，最大买卖次数 $k$，手续费 $fee$，冻结时间 $freeze$，求最大利润。</strong></p><p>观察前面六题的代码，我们可以在第四题基础上进行修改，这样代码量比较小。</p><p>首先是增加手续费，这个很简单，只需要在 $dp1$ 更新时减去一个手续费 $fee$ 就行了。</p><p>有点麻烦的是冻结时间。在第六题代码中，增加了一个维度用来保存每一只股票之前（包含）的最大利润，目的是为了获取相隔一个冻结时间之前的股票以前可以获得的最大利润。但是通用情况下不能这么保存，不然的话空间复杂度就变成了 $O(nk)$ ，极限情况下会爆掉。</p><p>解决方法就是，因为对于第 $i$ 只股票来说，只需要访问它与 $dp1[i-freeze-1]$ 之间的数值，那么我们只需要保存 $freeze + 1$ 大小的数组就行了。在访问的时候，采用取模的方法，来让数组滚动起来。</p><p>还有一些细节，比如如果 $k \ge n / 2$，那么问题就退化为了没有买卖次数限制，也就是第五题和第六题的情况。如果不这样处理的话，按照上面方法做，时间复杂度和空间复杂度都是 $O(nk)$ ，可能会吃不消。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        limit <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> k <span class="token operator">>=</span> n<span class="token operator">//</span><span class="token number">2</span> <span class="token keyword">else</span> <span class="token number">1</span>        k <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">if</span> k <span class="token operator">>=</span> n<span class="token operator">//</span><span class="token number">2</span> <span class="token keyword">else</span> k        dp0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp0<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span> <span class="token keyword">if</span> limit <span class="token keyword">else</span> j<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp1<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp0<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>fee<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第五题-1"><a href="#第五题-1" class="headerlink" title="第五题"></a>第五题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> fee<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> fee<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第六题-1"><a href="#第六题-1" class="headerlink" title="第六题"></a>第六题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期</title>
      <link href="/2020/02/29/leetcode-309/"/>
      <url>/2020/02/29/leetcode-309/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,0,2]输出：3解释：对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第六题。</p><p>这题其实就是在系列题目第二题基础上加了个限制条件，也就是每次卖了之后，隔一天才能继续买。</p><p>模仿第五题，还是采用动态规划。令 $dp0[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是买）可以获得的最大利润， $dp1[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是卖）可以获得的最大利润。那么类似的有如下转移方程：<br>$$<br>\begin{aligned}<br>dp0[i] &amp;= \max{\left\{dp0[i-1], dp1[i-2] - price[i]\right\}} \\<br>dp1[i] &amp;= \max{\left\{dp1[i-1], dp0[i-1] + price[i]\right\}}<br>\end{aligned}<br>$$</p><p>初始情况就是 $dp0[0] = -price[0]$ 和 $dp1[0] = 0$ 。</p><p>和第二、五题区别就是 $dp0[i]$ 的转移方程中有个 $dp1[i-2]$ ，也就是得隔一项，去算前前一天之前（包含）的买卖最大利润。</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">:</span>                dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp0<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp1<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费</title>
      <link href="/2020/02/28/leetcode-714/"/>
      <url>/2020/02/28/leetcode-714/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润:  在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第五题。</p><p>这题其实就是在系列题目第二题基础上加了个手续费，也就是无限次买卖股票，但是每次卖的时候都得交一笔手续费。</p><p>这时候就不能和第二题一样，每次连续上升子区间都买卖一次了，因为如果买卖一次都不够交手续费的话，就不能进行买卖。或者一段连续下降子区间的差值小于手续费，那么就得把这段下降子区间也包含进去，前后只卖买一次。</p><p>所以我们换个思路，还是沿用第四题的动态规划思路。令 $dp0[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是买）可以获得的最大利润， $dp1[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是卖）可以获得的最大利润。那么类似的有如下转移方程：<br>$$<br>\begin{aligned}<br>dp0[i] &amp;= \max{\left\{dp0[i-1], dp1[i-1] - price[i]\right\}} \\<br>dp1[i] &amp;= \max{\left\{dp1[i-1], dp0[i-1] + price[i] - fee\right\}}<br>\end{aligned}<br>$$</p><p>初始情况就是 $dp0[0] = -price[0]$ 和 $dp1[0] = 0$ 。</p><p>此外这里还可以优化去掉一个维度，因为每个时刻状态只与前一个时刻有关。</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> fee<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp0<span class="token punctuation">,</span> dp1 <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp1 <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">,</span> dp0<span class="token operator">+</span>p<span class="token operator">-</span>fee<span class="token punctuation">)</span>            dp0 <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">,</span> dp1<span class="token operator">-</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 188】买卖股票的最佳时机 IV</title>
      <link href="/2020/02/27/leetcode-188/"/>
      <url>/2020/02/27/leetcode-188/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,4,1], k = 2输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,6,5,0,3], k = 2输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第四题。</p><p>这题是最一般的情况了，也就是最多可以买卖 $k$ 次。那么我们采用动态规划来求解。</p><p>令 $dp0[i][j]$ 为第 $i$ 只股票之前（包含）买卖 $j$ 次（且最后一次操作为<strong>买入</strong>）可以获得的最大利润，$dp1[i][j]$ 为第 $i$ 只股票之前（包含）买卖 $j$ 次（且最后一次操作为<strong>卖出</strong>）可以获得的最大利润。</p><p>那么对于 $dp0[i][j]$ 来说，最后一次操作是买入，所以分为两种情况。</p><ul><li>一种是不买第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为买入）的最大利润：<br>$$dp0[i][j] = dp0[i-1][j]$$</li><li>一种是买第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j-1$ 次（且最后一次操作为卖出）的最大利润：<br>$$dp0[i][j] = dp1[i-1][j-1] - price[i]$$</li></ul><p>而对于 $dp1[i][j]$ 来说，最后一次操作是卖出，所以分为两种情况。</p><ul><li>一种是不卖第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为卖出）的最大利润：<br>$$dp1[i][j] = dp1[i-1][j]$$</li><li>一种是卖第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为买入）的最大利润：<br>$$dp1[i][j] = dp0[i-1][j] + price[i]$$</li></ul><p>综上转移方程就是：<br>$$<br>\begin{aligned}<br>dp0[i][j] &amp;= \max{\left\{dp0[i-1][j], dp1[i-1][j-1] - price[i]\right\}} \\<br>dp1[i][j] &amp;= \max{\left\{dp1[i-1][j], dp0[i-1][j] + price[i]\right\}}<br>\end{aligned}<br>$$</p><p>初始情况就是 $n = 0$ 和 $k = 0$ 时，单独计算一下就行了。</p><p>此外本题还可以优化成一维数组，就不展开介绍了，大家可以参考代码。</p><p>时间复杂度是 $O(nk)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> k <span class="token operator">>=</span> n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> max<span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> res        dp0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>p<span class="token punctuation">)</span>                dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 123】买卖股票的最佳时机 III</title>
      <link href="/2020/02/26/leetcode-123/"/>
      <url>/2020/02/26/leetcode-123/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,6,4,3,1]输出：0解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第三题。</p><p>本题中买卖次数变成了最多两次，那么我们可以照搬之前只能买卖一次的做法。首先如果我们假设第一只股票卖出去时价格是 $price[i]$ ，那么它之前的最优买入价格（也就是最低的价格）计算方法和第一题相同，只需要用一个变量存储就行了。而第二次买卖我们只需要知道 $price[i]$ 右边进行一次买卖最多能赚到多少钱就行了。这可以通过从右向左倒过来预处理处理，方法和第一题完全相同。</p><p>记第 $i$ 只股票左边（包含）买卖一次最大利润为 $left[i]$ ，右边（包含）买卖一次最大利润为 $right[i]$ ，那么最终的答案就是：<br>$$<br>\sum_{0 &lt; i &lt; n-2}{left[i] + right[i+1]}<br>$$</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        minn <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minn<span class="token punctuation">)</span>            minn <span class="token operator">=</span> min<span class="token punctuation">(</span>minn<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        maxx<span class="token punctuation">,</span> maxp<span class="token punctuation">,</span> res <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxp <span class="token operator">=</span> max<span class="token punctuation">(</span>maxp<span class="token punctuation">,</span> maxx<span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxx <span class="token operator">=</span> max<span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>maxp<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 122】买卖股票的最佳时机 II</title>
      <link href="/2020/02/25/leetcode-122/"/>
      <url>/2020/02/25/leetcode-122/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第二题。</p><p>这题买卖次数变成了不限，但是仍然要求在买之前必须先卖掉股票。那么观察股票的价格曲线，最优策略就是在每一段单调上升的子区间里，区间开始时购买，区间结束时卖出。这样就能保证所有的上升区间全部充分利用到了。正确性证明也不难，假设买卖过程中包含了一段下降的子区间，那么去掉它，在下降区间开头卖出，在下降区间末尾买入，得到的利润一定大于包含这段下降区间。</p><p>在具体实现时，我们可以计算相邻两个股票价格差，如果价格是上升的，那就在利润上加上它，否则就不用管。</p><p>最终的答案就是：<br>$$<br>\sum_{0 &lt; i &lt; n}{\max{\left\{price[i] - price[i-1], 0\right\}}}<br>$$</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> max<span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 121】买卖股票的最佳时机</title>
      <link href="/2020/02/24/leetcode-121/"/>
      <url>/2020/02/24/leetcode-121/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第一题。</p><p>这道题目要求只能买卖一次股票。所以最佳策略一定是挑一个最低的价格买入，再挑一个最高的价格卖出。但是还有另一个限制条件，那就是你得先买，然后才能卖出去。</p><p>所以我们只需要枚举每个股票，把它当作卖出的那一只股票，然后只需要求出它之前价格最低的那一只股票就行了。价格最低的股票可以用一个变量来进行维护，然后枚举所有卖出的股票，减去它之前价格最低的那一只股票，然后和最优答案进行比较，最终就能得到最多能赚多少钱了。</p><p>最终答案就是：<br>$$<br>\max_{0 \le i &lt; n}{\left\{price[i] - \min_{0 \le j &lt; i}{\left\{price[j]\right\}}\right\}}<br>$$</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        minn<span class="token punctuation">,</span> res <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minn<span class="token punctuation">)</span>            minn <span class="token operator">=</span> min<span class="token punctuation">(</span>minn<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 面试题 17.05】字母与数字</title>
      <link href="/2020/02/22/leetcode-interview-17-05/"/>
      <url>/2020/02/22/leetcode-interview-17-05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。</p><p>返回该子数组，若不存在这样的数组，返回一个空数组。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]输出：["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["A","A"]输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>array.length &lt;= 100000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回忆之前做过的一道题目：<a href="https://godweiyang.com/2020/02/02/leetcode-523/">每日算法系列【LeetCode 523】连续的子数组和</a>，是不是有点相似？那道题是要求是否含有总和为 $k$ 的整数倍的连续子数组。而本题要求的是最长的子数组，满足数字和字母个数相等。</p><p>我们可以把字母抽象成 $-1$ ，数字抽象成 $1$ ，那么子数组的总和含义就是数字个数与字母个数的差值。假设子数组 $[l, r]$ 是满足字母个数和数字个数相等的，那么这段子数组总和必然是 $0$ 。如果我们用前缀和来进行优化的话，$sum[r] - sum[l-1] = 0$ ，也就是说 $sum[r]$ 和 $sum[l-1]$ 的值是相等的。</p><p>所以我们只需要求一遍前缀和，如果 $sum[i]$ 没有在之前出现过，那就保存一下 $sum[i]$ 最开始出现的下标是 $i$ 。否则的话就看一下当前子数组长度 $i - sum[i]$ 和历史最优的长度 $r - l$ 谁大，然后决定更不更新。</p><p>实际实现中 c++ 还是可以采用 <code>unordered_map</code> 来当作哈希表保存下标。</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">findLongestSubarray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        mp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">isdigit</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">&lt;</span> i<span class="token operator">-</span>mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    l <span class="token operator">=</span> mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> array<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findLongestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> array<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        mp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span>        cnt<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> s <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token keyword">in</span> mp<span class="token punctuation">:</span>                <span class="token keyword">if</span> r<span class="token operator">-</span>l <span class="token operator">&lt;</span> i<span class="token operator">-</span>mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                    r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> array<span class="token punctuation">[</span>l<span class="token punctuation">:</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.2.4时GitHub超过15个粉丝就可以领取3000元啦！</title>
      <link href="/2020/02/22/hs-airdrop/"/>
      <url>/2020/02/22/hs-airdrop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了标题，你可能会觉得这又是个诈骗或者广告，但是这次确实是在送钱。白嫖一时爽，一直白嫖一直爽。</p><p>怎么回事呢，官网在这：<a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a>，原话是这么说的：</p><blockquote><p>The Handshake Organization raised money from top Silicon Valley investors including A16Z and Sequoia. They donated $10.2mm to GNU, Mozilla, and other internet foundations. Now they’re giving away ~4662 Handshake coins to qualifying developers on GitHub.</p></blockquote><p>翻译成中文，大致意思就是握手（handshake）组织筹集到了一笔资金，分给了好几个组织，还给 github 每个符合要求的用户捐了 4662 个握手币。握手币可以兑换成比特币，再换成人民币。具体多少呢？<strong>大概也就 0.05 个左右比特币，人民币三五千左右吧</strong>。</p><p>那么重点来了，要符合什么要求呢？要求如下，主要有两点：</p><ul><li>你的 github 账号在 2019 年 2 月 4 号那一周之前拥有 <strong>15 个及以上的粉丝</strong>。</li><li>你的 github 账号在 2019 年 2 月 4 号那一周之前创建过 <strong>SSH key</strong>，并且现在还保留着。</li></ul><p>如果你不知道是否符合要求，也不要紧，按照下面步骤做就是了，不符合会弹出提示的。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><blockquote><p>本人电脑系统 Windows 10 专业版 1909，Node.js 版本 10.16.0，npm 版本 6.13.7，其他环境操作大致相同，可能会有小问题，欢迎评论区留言。</p></blockquote><p>首先你电脑里需要 Node.js 和 python 2 的运行环境，安装地址在下面：</p><p><strong>Node.js：</strong><br><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><p><strong>python2：</strong><br><a href="https://www.anaconda.com/distribution/#download-section" target="_blank" rel="noopener">https://www.anaconda.com/distribution/#download-section</a></p><h2 id="下载-hs-airdrop"><a href="#下载-hs-airdrop" class="headerlink" title="下载 hs-airdrop"></a>下载 hs-airdrop</h2><p>运行下面命令：</p><pre><code>git clone https://github.com/handshake-org/hs-airdrop.git</code></pre><h2 id="安装-hs-airdrop-需要的依赖"><a href="#安装-hs-airdrop-需要的依赖" class="headerlink" title="安装 hs-airdrop 需要的依赖"></a>安装 hs-airdrop 需要的依赖</h2><pre><code>cd hs-airdrop &amp;&amp; npm install</code></pre><h2 id="找到你的-SSH-key-存放目录"><a href="#找到你的-SSH-key-存放目录" class="headerlink" title="找到你的 SSH key 存放目录"></a>找到你的 SSH key 存放目录</h2><p>如果你是 Linix ，存放目录一般是 <code>~/.ssh</code> 。如果你跟我一样是 Windows 10，存放目录一般是 <code>C:\Users\你的用户名\.ssh</code> 。</p><p>然后在目录下找到你的 SSH key 文件，注意一定要是符合要求（2019 年 2 月 4 号之前）的那个。例如我的文件路径是 <code>C:\Users\godweiyang\.ssh\id_rsa</code> 。</p><h2 id="生成你的握手币钱包地址"><a href="#生成你的握手币钱包地址" class="headerlink" title="生成你的握手币钱包地址"></a>生成你的握手币钱包地址</h2><p>打开 <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a>，跳转到第 4 步，点击 <code>Click To Show Your Handshake Wallet Address</code> ，然后就会生成出一串如下字符，就是你的钱包地址：</p><p><img src="1.jpg" alt></p><h2 id="生成加密证明"><a href="#生成加密证明" class="headerlink" title="生成加密证明"></a>生成加密证明</h2><p>直接运行如下命令：</p><pre><code>./bin/hs-airdrop &lt;path to key&gt; &lt;address&gt; &lt;fee&gt;</code></pre><p>其中 <code>&lt;path to key&gt;</code> 是刚刚 SSH key 文件路径，<code>&lt;address&gt;</code> 是上一步生成的钱包地址，<code>&lt;fee&gt;</code> 是手续费（单位是握手币），设为默认 0.01 就行了。</p><p>例如我的命令是：</p><pre><code>./bin/hs-airdrop C:\Users\godweiyang\.ssh\id_rsa hs1qxxxxxxxxxxx 0.01</code></pre><p>然后会让你输入 <code>Passphrase</code> ，一般都是空，直接回车就行了。</p><p>运行成功了之后界面是这样的：<br><img src="2.jpg" alt></p><p><strong>报错解决 1 ：</strong><br>如果你是 Windows，你可能会遇到 <code>TypeError: stdin.setRawMode is not a function</code> 错误，不用担心，只需要将命令修改为下面这样：</p><pre><code>node bin/hs-airdrop &lt;path to key&gt; &lt;address&gt; &lt;fee&gt;</code></pre><p>也就是前面加一个 <code>node</code> ，并且运行程序路径最前面去掉 <code>./</code> 就行了。</p><p><strong>报错解决 2 ：</strong><br>可能运行了三四分钟之后，会弹出 <code>Error: read ECONNRESET</code> 错误，这是因为要下载一个 github 仓库，太大了下不下来。</p><p>解决方法就是先下载 <a href="https://gitee.com/shidenggui/hs-tree-data" target="_blank" rel="noopener">https://gitee.com/shidenggui/hs-tree-data</a> 这个仓库内容，然后将仓库内容复制到 <code>C:\Users\你的用户名\.hs-tree-data</code> 目录下。这样运行的时候就不需要下载了，直接就能运行。</p><h2 id="复制-base64-代码"><a href="#复制-base64-代码" class="headerlink" title="复制 base64 代码"></a>复制 base64 代码</h2><p>等待三五分钟，如果成功了，你有资格，那么就会生成一串下面这样的 base64 代码：<br><img src="4.png" alt></p><p>将它复制到 <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a> 最后一步如下框框里（<strong>注意一定要去除 base64 代码中的换行符，让它只有一行！</strong>）：<br><img src="3.jpg" alt></p><h2 id="到账后提现"><a href="#到账后提现" class="headerlink" title="到账后提现"></a>到账后提现</h2><p>到账时间不好说，至少需要 16 个小时，至多你就等着吧，到账的是 HNS 币，也就是握手币。</p><p>然后打开 <a href="https://www.namebase.io/kyc/basic" target="_blank" rel="noopener">https://www.namebase.io/kyc/basic</a> 进行实名认证（不然没法转成比特币），提供身份证、驾照或者护照都可以。</p><p>打开 <a href="https://www.namebase.io/sell" target="_blank" rel="noopener">https://www.namebase.io/sell</a> 将握手币兑换成比特币。</p><p>具体比特币钱包地址如何获取、比特币怎么转换成人民币等操作就不介绍了，网上教程很多。</p><blockquote><p>笔者写这篇文章的时候还没到账，就不截图了，我先去等着了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 685】冗余连接 II</title>
      <link href="/2020/02/22/leetcode-685/"/>
      <url>/2020/02/22/leetcode-685/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着 $N$ 个节点（节点值不重复 $1, 2, …, N$）的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 $[u, v]$，用以表示有向图中连接顶点 $u$ 和 $v$ 和顶点的边，其中父节点 $u$ 是子节点 $v$ 的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有 $N$ 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [1,3], [2,3]]输出：[2,3]解释：  1 / \v   v2-->3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [2,3], [3,4], [4,1], [1,5]]输出：[4,1]解释：5 <- 1 -> 2     ^    |     |    v     4 <- 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>输入的二维数组大小在 $3$ 到 $1000$。</li><li>二维数组中的整数在 $1$ 到 $N$ 之间，其中 $N$ 是输入数组的大小。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题是上一道题<a href="https://zhuanlan.zhihu.com/p/108220276" target="_blank" rel="noopener">LeetCode 685. 冗余连接</a>的进阶版，区别就是无向图变成了有向图。</p><p>上一道题解说过，无向图能构成一棵树的条件是没有环，那么有向图的条件是什么呢？</p><p>首先还是得没有环，其次因为是边是有向的，所以一个结点只能有一个父结点（也就是入度为 $1$）。那么这题解法就有了。</p><ul><li>首先判断有没有入度为 $2$ 的结点，如果有的话，那两条边一定有一条得删掉。</li><li>按照出现时间从后到前看那两条边，删掉其中一条之后是否能构成一棵树（也就是无环）。如果删掉了无环，那就直接返回这条边作为答案。</li><li>如果入度全是 $1$ ，那就直接按照出现时间从前到后看添加了哪一条边之后开始出现了环，那么那条边就是答案。</li></ul><p>判断能否构成一棵树的话还是用并查集，唯一区别就是不需要用<strong>按秩合并</strong>的优化了，而且给定有向边 $[u, v]$，只能把 $v$ 接在 $u$ 下面。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> degree<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> edges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>degree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> degree<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token operator">++</span>degree<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>degree<span class="token punctuation">[</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">wrongEdge</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">wrongEdge</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wrongEdge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> except<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> except<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">same</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> u<span class="token operator">==</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">?</span> u <span class="token operator">:</span> f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> edges<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>n <span class="token operator">=</span> len<span class="token punctuation">(</span>edges<span class="token punctuation">)</span>        degree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            degree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> edges<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> degree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>wrongEdge<span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>wrongEdge<span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrongEdge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> edges<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">==</span> ex<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>same<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>join<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> u        self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">join</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> v<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u    <span class="token keyword">def</span> <span class="token function">same</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 684】冗余连接</title>
      <link href="/2020/02/21/leetcode-684/"/>
      <url>/2020/02/21/leetcode-684/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着 $N$ 个节点（节点值不重复 $1, 2, …, N$）的树及一条附加的边构成。附加的边的两个顶点包含在 $1$ 到 $N$ 中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对 $[u, v]$ ，满足 $u &lt; v$，表示连接顶点 $u$ 和 $v$ 的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着 $N$ 个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 $[u, v]$ 应满足相同的格式 $u &lt; v$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [1,3], [2,3]]输出：[2,3]解释：  1 / \2 - 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [2,3], [3,4], [1,4], [1,5]]输出：[1,4]解释：5 - 1 - 2    |   |    4 - 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>输入的二维数组大小在 $3$ 到 $1000$。</li><li>二维数组中的整数在 $1$ 到 $N$ 之间，其中 $N$ 是输入数组的大小。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先因为这是一个无向图，所以不需要考虑谁是树根。</p><p>那么我们一条条边加入到图里去，直到出现了环为止，那么这条边就是冲突的边，需要删除掉。</p><p>那么怎么判断是否出现了环呢？如果加入一条边 $[u, v]$ 的时候，两个结点所在的连通块不是同一个，那么一定没有环。否则的话，两个结点连在了同一棵子树上，那么一定会产生一个环。</p><p>如何高效的判断两个结点是否在同一棵子树上呢？这就需要用到一个数据结构——<strong>并查集</strong>。</p><p>并查集采用一个数组 $f[i]$ 来表示结点 $i$ 的父结点。那么初始的时候没有任何边，定义所有结点的父结点等于它自身： $f[i] = i$ 。</p><p>当加入一条边 $[u, v]$ 的时候，可以沿着 $u \to f[u] \to f[f[u]] \to \cdots$ 的路径递归找到 $u$ 所在子树的根结点 $ru$（$v$ 同理得到 $rv$），然后只需要判断两个根结点是否相同就行了。如果根结点相同，那么就产生环了，直接输出这个冲突边就行。否则的话就要把这两棵子树连到一起，最简单的做法就是直接把 $ru$ 连到 $rv$ 下面，当作它的子结点，那么就需要更新 $f[ru] = rv$ 。</p><p>下面讲两个常用的并查集优化。</p><p><strong>路径压缩：</strong><br>因为我们无需关注每一棵子树结构是什么样的，我们只关注它的根结点是谁。所以为了减小查找根结点的时间，每个结点离根结点要尽量近。</p><p>那么我们定义查找根结点函数 $find(u)$ ，如果 $u = f[u]$ ，那么不用找了，它自己就是根结点。否则的话调用 $find(f[u])$ 递归寻找子树的根结点。最后做一步路径压缩的优化，把根结点当作 $u$ 的父结点：$f[u] = find(f[u])$ 。这样下次再查找的时候，路径长度就变为了 $1$ ，一步就能找到根结点了。</p><p><strong>按秩合并：</strong><br>合并两棵子树的时候，为了使得合并后的子树高度尽量小，我们需要把高度小的那棵子树接在高度高的那棵下面，当作儿子。</p><p>所以我们定义一个 $rank[i]$ 数组，用来记录 $i$ 这个结点作为根结点的子树高度，初始时全都是 $1$ 。那么在合并的时候，把 $rank$ 值小的接到大的下面去，如果一样怎么办呢？随便接，然后把合并后的根结点 $rank$ 值加 $1$ 就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> rank<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findRedundantConnection</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">same</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>u<span class="token punctuation">,</span> v<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> u<span class="token operator">==</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">?</span> u <span class="token operator">:</span> f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRedundantConnection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> edges<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>edges<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>rank <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>same<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>join<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> u        self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">join</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> v<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u            <span class="token keyword">if</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">same</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1006】笨阶乘</title>
      <link href="/2020/02/20/leetcode-1006/"/>
      <url>/2020/02/20/leetcode-1006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p><p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：<code>乘法(*)，除法(/)，加法(+)和减法(-)</code>。</p><p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（floor division），所以 <code>10 * 9 / 8</code> 等于 11。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：4输出：7解释：7 = 4 * 3 / 2 + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：10输出：12解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$1 \le N \le 10000$</li><li>$-2^{31} \le answer \le 2^{31} - 1$  （答案保证符合 32 位整数。）</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>笨方法我就不写了，按照运算顺序模拟一遍，数量比较少的话，应该也不会超时。</p><p>这道题可以用简单的数学计算来优化一下，首先笨阶乘数学形式是下面这样的：<br>$$<br>clumsy(n) = \left\lfloor\frac{n(n-1)}{n-2}\right\rfloor + (n-3) - \left\lfloor\frac{(n-4)(n-5)}{n-6}\right\rfloor + \cdots<br>$$</p><p>好像看不出什么东西，那么我们先去掉取整符号看看：<br>$$<br>\left\lfloor\frac{n(n-1)}{n-2}\right\rfloor = \left\lfloor\frac{(n-2)(n-2)+3(n-2)+2}{n-2}\right\rfloor = \left\lfloor n+1+\frac{2}{n-2}\right\rfloor<br>$$</p><p>所以当 $n \ge 5$ 时，取整符号可以直接去掉：<br>$$<br>\left\lfloor\frac{n(n-1)}{n-2}\right\rfloor = n + 1<br>$$</p><p>所以我们就讨论 $n \ge 5$ 时的情况，笨函数可以写成：<br>$$<br>clumsy(n) = n+1 + n-3 - (n-3) + \cdots = n+1 + d(n)<br>$$</p><p>也就是第一个取整（$3$ 项）结果是 $n+1$ ，而后面每 $4$ 项结果是 0 ，最后还剩余不足 $4$ 项的结果 $d(n)$ 。</p><p>那么 $d(n)$ 的取值有 $4$ 种情况：</p><ul><li>$n \% 4 = 0$ ，也就是最后剩余 $1$ 项时，$d(n) = 1$ 。</li><li>$n \% 4 = 1$ ，也就是最后剩余 $2$ 项时，$d(n) = 2 - 1 = 1$ 。</li><li>$n \% 4 = 2$ ，也就是最后剩余 $3$ 项时，$d(n) = 3 - 2 \times 1 = 1$ 。</li><li>$n \% 4 = 3$ ，也就是最后剩余 $0$ 项时，$d(n) = 0$ 。</li></ul><p>但是考虑到取整函数只有在 $n \ge 5$ 时才等于 $n+1$ ，也就是最后剩余的项数大于 $2$ 时才行。那么上面的 $4$ 种情况的 $1、4$ 两种，就要特殊处理一下前一个取整结果：</p><ul><li>$n \% 4 = 0$ ，也就是最后剩余 $1$ 项时，$d(n) = 5 - 4 \times 3 / 2 + 1 = 0$ 。</li><li>$n \% 4 = 1$ ，也就是最后剩余 $2$ 项时，$d(n) = 2 - 1 = 1$ 。</li><li>$n \% 4 = 2$ ，也就是最后剩余 $3$ 项时，$d(n) = 3 - 2 \times 1 = 1$ 。</li><li>$n \% 4 = 3$ ，也就是最后剩余 $0$ 项时，$d(n) = 4 - 3 \times 2 / 1 = -2$ 。</li></ul><p>综上，$n &lt; 5$ 时的结果直接算出来就行了，$n \ge 5$ 时结果就是 $n+1+d(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">clumsy</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> N <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> N<span class="token operator">>=</span><span class="token number">5</span> <span class="token operator">?</span> N<span class="token operator">+</span>d<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">:</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">clumsy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        q <span class="token operator">=</span> N <span class="token operator">&amp;</span> <span class="token number">3</span>        a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>        d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> N<span class="token operator">+</span>d<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token keyword">if</span> N<span class="token operator">>=</span><span class="token number">5</span> <span class="token keyword">else</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 287】寻找重复数</title>
      <link href="/2020/02/19/leetcode-287/"/>
      <url>/2020/02/19/leetcode-287/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 $n + 1$ 个整数的数组 $nums$，其数字都在 $1$ 到 $n$ 之间（包括 $1$ 和 $n$），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>说明</strong></p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 $O(1)$ 的空间。</li><li>时间复杂度小于 $O(n^2)$ 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,3,4,2,2]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,3,4,2]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>根据抽屉原理，如果大小为 $m$ 的抽屉里放了大于 $m$ 个数，那么一定有一个抽屉里至少放了两个数。</p><p>那我们不妨统计一下数组中有多少个数满足 $1 \le nums[i] \le m$ ，数量记为 $cnt$ 。</p><p>如果 $cnt &gt; m$ ，那么根据抽屉原理，$1$ 到 $m$ 中一定有一个数出现了至少两次。</p><p>反之如果 $cnt \le m$ ，那么说明满足 $m+1 \le nums[i] \le n$ 的数的数量是 $n+1-cnt \ge n-m+1$ ，而抽屉大小是 $n-m$ ，所以根据抽屉原理，$m+1$ 到 $n$ 中一定有一个数出现了至少两次。</p><p>综上，可以采用二分法，不断缩小 $m$ 的范围，最终得到这个出现至少两次的数的值。</p><p>时间复杂度 $O(n \log n)$ 。</p><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>因为 $nums$ 中数据范围是 $1$ 到 $n$ ，所以 $nums[0] = x \neq 0$ 。那么接着用 $x$ 作为下标来索引值，得到 $nums[x] = y$ 。如果 $y$ 已经出现过了 ，那么重复值已经找到了。否则的话 $y$ 还没出现过的话，继续用 $y$ 作为下标来索引，直到出现重复值。</p><p>可以发现按照这种方法索引下去，形成了一个链，也就是 $0 \to x \to y \to \cdots$ 。最终这条链末端一定会产生出一个环，那么环的入口一定就是那个重复的数。</p><p>举个例子，如下图所示，最终环产生在了 $2 \to 4 \to 2$ 上面，而 $2$ 又是链进入环的入口，所以重复的数就是 $2$ 。</p><p><img src="1.png" alt></p><p>那么如何求<strong>链表中的环</strong>呢？这其实是一道面试经常会问到的经典题，标准解法就是用两个<strong>快慢指针</strong>。</p><p>初始时两个指针指着链表头结点，然后同时移动。慢指针一次移动一个结点，快指针一次移动两个结点。当下一次快指针又和慢指针相遇时，停止移动。然后用第三个指针指着头结点，慢指针留在原地，两者同时移动，都是一次移动一个结点，直到相遇。这时两者指着的结点就是环的入口了。</p><p>大家可以用上面的例子自己画图演示一下，我下面严格证明一下为什么这样是对的。</p><p>假设如下图所示，链表中链的长度是 $m$ ，环的长度是 $n$ 。</p><p><img src="4.jpg" alt></p><p>假设慢指针和快指针第一次相遇时，慢指针移动的距离是 $x$ ，那么快指针移动距离就是 $2x$ 。</p><p>可以列出等式 $2x - x = kn$ ，也就是两者距离差值一定是环长度的正整数 $k$ 倍，同时 $k$ 是使得 $x = kn \ge m$ 的最小正整数，即 $(k-1)n &lt; m \le kn$。这时候慢指针离入口的距离是 $n - (x - m) = m - (k - 1)n$ ，也就是说，慢指针只需要再多绕 $k-1$ 个环的长度，就能恰好和从头结点而来的指针相遇在入口处。</p><p>时间复杂度 $O(n)$ 。</p><p><strong>扩展：</strong>  </p><p>那有人可能会问了，那要是链最后回到了 $0$ ，不就没有链，只有环了吗？哪来的入口？这是对的，所以本题中限制了 $nums$ 数组里都是大于 $0$ 的，如果范围是 $0$ 到 $n-1$ 的话，不能直接用数值但下标索引了，不然会出现下面这种情况，也就是 $0$ 也在环里了。</p><p><img src="2.jpg" alt></p><p>其实这种情况我们只需要稍稍修改一下索引，让 $0$ 不可能出现在环里就行了，也就是让 $nums[i] + 1$ 当作索引，如下图所示。最终重复的数只需要减去 $1$ 就行了。</p><p><img src="3.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="二分法（c-）"><a href="#二分法（c-）" class="headerlink" title="二分法（c++）"></a>二分法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> m<span class="token punctuation">)</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快慢指针法（c-）"><a href="#快慢指针法（c-）" class="headerlink" title="快慢指针法（c++）"></a>快慢指针法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> find <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>find <span class="token operator">!=</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            find <span class="token operator">=</span> nums<span class="token punctuation">[</span>find<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> find<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分法（python）"><a href="#二分法（python）" class="headerlink" title="二分法（python）"></a>二分法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            cnt <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">&lt;=</span>m <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> cnt <span class="token operator">></span> m<span class="token punctuation">:</span>                r <span class="token operator">=</span> m            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快慢指针法（python）"><a href="#快慢指针法（python）" class="headerlink" title="快慢指针法（python）"></a>快慢指针法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> slow <span class="token operator">==</span> fast<span class="token punctuation">:</span>                <span class="token keyword">break</span>        find <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> find <span class="token operator">!=</span> slow<span class="token punctuation">:</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            find <span class="token operator">=</span> nums<span class="token punctuation">[</span>find<span class="token punctuation">]</span>        <span class="token keyword">return</span> find<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【EOJ 3031】二进制倒置</title>
      <link href="/2020/02/18/eoj-3031/"/>
      <url>/2020/02/18/eoj-3031/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 $n(0 \le n \le 10^{100})$ 、将 $n$ 的 334 位二进制表示形式（不包括开头可能的值为 0 的位，$n=0$ 表示为 1 位 0）前后倒置，输出倒置后的二进制数对应的整数。</p><p>例如： $n=10$ ，其二进制表示为（330 个 0）1010 ，倒置后为 0101 ，对应输出就是 5 。</p><p><strong>题目链接</strong><br><a href="https://acm.ecnu.edu.cn/problem/3031/" target="_blank" rel="noopener">https://acm.ecnu.edu.cn/problem/3031/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题考查的主要是大数的进制转换，其他没有什么算法技巧，但是对代码实现要求还是挺高的，适合用来锻炼你的<strong>耐心</strong>和<strong>代码风格</strong>。</p><p>整体思路非常简单，不就是先把输入的 10 进制数 $x$ 转化成 2 进制数 $b$ ，再把 $b$ 所有位颠倒过来，最后再把 $b$ 转化成 10 进制输出就行了。</p><p>所以整体代码拆分成了三步，先从 10 进制转 2 进制，再颠倒 2 进制，最后从 2 进制转 10 进制。</p><p>为了代码的普适性，我这里直接实现了从任意 $a$ 进制 转化为任意 $b$ 进制的算法，这样更加方便调用。</p><p>这就涉及到了<strong>大数的任意进制转换</strong>问题，假设 $x$ 是 $a$ 进制数，我们要把它转化为 $b$ 进制的 $y$ （初始时为空）。那么转化步骤如下：</p><ul><li>求 $x \% b$ ，并把余数接在 $y$ 的最高位。</li><li>令 $x = \left\lfloor x / b \right\rfloor$ 。</li><li>重复步骤 1 ，直到 $x = 0$ 。</li></ul><p>部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    y<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">mod</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来非常简单，但是步骤 1 和 2 都涉及到了<strong>大数的求余</strong>和<strong>大数的除法</strong>算法，所以我们还得实现这两个算法。</p><p>大数求余只要从 $x$ 最高位开始计算 $x$ 的大小，并同时对 $b$ 求余，然后由于求余的加法和乘法定理，我们可以始终保持 $x &lt; b$ ，这样就能用一个 <code>int</code> 类型保存余数了。</p><p>部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mod</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">*</span> a <span class="token operator">+</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大数除法类似，从 $x$ 最高位开始除 $b$ ，并注意要把余数带到下一位，最后还得去掉前导 0 。</p><p>部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">div</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> q <span class="token operator">*</span> a<span class="token punctuation">;</span>        q <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span><span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// string转化为vector&lt;int>，倒序存储</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">s2i</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> idx <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> idx<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a进制下x%b，x倒序存储</span><span class="token keyword">int</span> <span class="token function">mod</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">*</span> a <span class="token operator">+</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a进制下x/b，x倒序存储</span><span class="token keyword">void</span> <span class="token function">div</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> q <span class="token operator">*</span> a<span class="token punctuation">;</span>        q <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span><span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a进制下s转化为b进制string</span>string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token function">s2i</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> y<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">mod</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'0'</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin <span class="token operator">>></span> T<span class="token punctuation">;</span>    string x<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> T<span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> x<span class="token punctuation">;</span>        string x2 <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>x2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"case #"</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"case #%d:"</span> <span class="token operator">%</span>i<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>str<span class="token punctuation">(</span>bin<span class="token punctuation">(</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> eoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 658】找到 K 个最接近的元素</title>
      <link href="/2020/02/15/leetcode-658/"/>
      <url>/2020/02/15/leetcode-658/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5], k=4, x=3输出：[1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5], k=4, x=-1输出：[1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>k 的值为正数，且总是小于给定排序数组的长度</li><li>数组不为空，且长度不超过 10^4</li><li>数组里的每个元素与 x 的绝对值不超过 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>这题要找离 $x$ 最近的 $k$ 个元素，又因为数组是排好序的，所以离 $x$ 最远的元素一定在数组两端。</p><p>那么我们只需要用两个指针，一个指针 $l$ 指着第一个元素，一个指针 $r$ 指着最后一个元素。如果 $r - l \ge k$ ，那就说明窗口中元素个数大于 $k$ ，那么就要删除一个元素。删除哪个呢？就看 $arr[l]$ 和 $arr[r]$ 谁离 $x$ 更远，就删除谁。如果一样远，就删除大的元素 $arr[r]$ 。就这样删到窗口中只剩 $k$ 个元素为止。</p><p>这个方法时间复杂度是 $O(n)$ 。</p><h3 id="二分-滑动窗口"><a href="#二分-滑动窗口" class="headerlink" title="二分+滑动窗口"></a>二分+滑动窗口</h3><p>如果 $n$ 太大，那么仅仅靠滑动窗口显然不行。注意观察答案所在的窗口可以发现，这个长度为 $k$ 的窗口一定是靠近 $x$ 的，也就是 $x$ 要么在窗口前一个位置，要么在窗口后一个位置，要么在窗口中间某个位置。 $x$ 和窗口中间绝对不可能有其他的数组元素。</p><p>那么我们可以二分找到第一个比 $x$ 大的元素（找第一个比它小的元素也行），然后左右各伸展出 $k$ 的长度，最终答案窗口一定就在这个范围之内。然后继续使用上面的滑动窗口来求解。</p><p>这个方法时间复杂度缩减到了 $O(\log n + k)$ 。</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>如果 $k$ 太大，那么上面的方法又没有意义了，还是会退化到 $O(n)$ 。</p><p>上面两个方法都是先把窗口范围定到某一个区间里，然后一点一点的缩小窗口大小，最终得到答案的。那么能否直接判断出长度为 $k$ 的答案窗口位置在哪里呢？</p><p>按照上面的思路，长度为 $k$ 的窗口一定是通过长度为 $k+1$ 的窗口删除首尾之一元素得到的。那么我们观察某一个特定的长度为 $k+1$ 的窗口 $[l, l+k]$ ，如果 $arr[l]$ 离 $x$ 距离比 $arr[l+k]$ 离 $x$ 更远的话，那就要删除 $arr[l]$ ，同时说明 $l$ 以及它左边的所有元素都不可能是答案窗口的左边界。反之如果 $arr[l]$ 离 $x$ 距离小于等于 $arr[l+k]$ 离 $x$ 的距离，那么就要删除 $arr[l+k]$ 了，同时说明 $l$ 右边的元素都不可能是答案窗口的左边界。</p><p>综上，我们可以用二分直接寻找答案窗口的左边界。这样时间复杂度就降到了 $O(\log n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="滑动窗口（c-）"><a href="#滑动窗口（c-）" class="headerlink" title="滑动窗口（c++）"></a>滑动窗口（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token operator">+</span>k<span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分-滑动窗口（c-）"><a href="#二分-滑动窗口（c-）" class="headerlink" title="二分+滑动窗口（c++）"></a>二分+滑动窗口（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        l <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token operator">+</span>k<span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分（c-）"><a href="#二分（c-）" class="headerlink" title="二分（c++）"></a>二分（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token operator">-</span>k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>m<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token operator">+</span>k<span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="滑动窗口（python）"><a href="#滑动窗口（python）" class="headerlink" title="滑动窗口（python）"></a>滑动窗口（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span>        <span class="token keyword">while</span> r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">:</span>            <span class="token keyword">if</span> x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">:</span>l<span class="token operator">+</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分-滑动窗口（python）"><a href="#二分-滑动窗口（python）" class="headerlink" title="二分+滑动窗口（python）"></a>二分+滑动窗口（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m        r <span class="token operator">=</span> min<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span>k<span class="token number">-1</span><span class="token punctuation">)</span>        l <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l<span class="token operator">-</span>k<span class="token punctuation">)</span>        <span class="token keyword">while</span> r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">:</span>            <span class="token keyword">if</span> x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">:</span>l<span class="token operator">+</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分（python）"><a href="#二分（python）" class="headerlink" title="二分（python）"></a>二分（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span>k        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> x<span class="token operator">-</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>m<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">:</span>l<span class="token operator">+</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 328】奇偶链表</title>
      <link href="/2020/02/14/leetcode-328/"/>
      <url>/2020/02/14/leetcode-328/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：1->2->3->4->5->NULL输出：1->3->5->2->4->NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：2->1->3->5->6->4->7->NULL输出：2->3->6->7->1->5->4->NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题要求使用原地算法，也就是不允许额外新建一个链表，只能使用常数的空间复杂度来实现。</p><p>要把奇数位置串起来，再把偶数位置串起来，最后把偶数位置链表接到奇数位置链表末尾。因为 <code>head</code> 表示的就是奇数位置链表的第一个结点，所以我们只需要再新建一个变量 <code>even_head</code> 指向 <code>head-&gt;next</code> ，也就是偶数位置链表的第一个结点。</p><p>此外还需要新建两个指针 <code>odd</code> 和 <code>even</code> 分别指向当前遍历到的奇偶结点，初始时分别指向奇偶头结点。</p><p>接下来只需要分成奇偶两条链，各自串联下去就行了。也就是每次把 <code>odd-&gt;next</code> 指向 <code>odd-&gt;next-&gt;next</code> ，把 <code>even-&gt;next</code> 指向 <code>even-&gt;next-&gt;next</code> 。也就是隔了一个元素，把当前结点下一个结点指向它的下一个和它奇偶位置相同的结点。注意的是，这里一定要先改变 <code>even-&gt;next</code> ，再改变 <code>odd-&gt;next</code> 。因为 <code>odd</code> 是在 <code>even</code> 前一个的，先改变它指向的下一个元素并不会影响 <code>even</code> 后面的元素。但是如果你先改变了 <code>even</code> 指向的下一个元素，那么 <code>odd-&gt;next-&gt;next</code> 就变了，就无法指向正确的结点了。</p><p>如果我们换个写法，先把 <code>odd-&gt;next</code> 指向 <code>even-&gt;next</code> ，再把 <code>even-&gt;next</code> 指向 <code>even-&gt;next-&gt;next</code> ，你就能很清楚的看出来了，必须先改变 <code>odd-&gt;next</code> ，因为它依赖于 <code>even-&gt;next</code> 。</p><p>最后把 <code>odd</code> 指向 <code>odd-&gt;next</code> ，把 <code>even</code> 指向 <code>even-&gt;next</code> ，继续遍历下一个结点。</p><p>什么时候停止呢？链表的最后一个结点要么是奇数结点，要么是偶数结点。如果是偶数结点，那么最后 <code>even</code> 不为空，但是它的下一个结点 <code>even-&gt;next</code> 为空，这时候结束遍历。如果是奇数结点，那么最后 <code>odd</code> 不为空，但是 <code>even</code> 为空，那么也结束遍历。综上，如果 <code>even</code> 或者 <code>even-&gt;next</code> 为空的时候，结束遍历。</p><p>最后只需要把 <code>odd</code> 的下一个结点指向 <code>even_head</code> 就能把两个链表串起来了。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ ，因为只用到了 3 个额外指针。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> even_head <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> odd <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> even <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>even <span class="token operator">&amp;&amp;</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            odd<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            even<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            odd <span class="token operator">=</span> odd<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            even <span class="token operator">=</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        odd<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> even_head<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        even_head<span class="token punctuation">,</span> odd<span class="token punctuation">,</span> even <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> even <span class="token keyword">is</span> <span class="token operator">not</span> None <span class="token operator">and</span> even<span class="token punctuation">.</span>next <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next            even<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            odd <span class="token operator">=</span> odd<span class="token punctuation">.</span>next            even <span class="token operator">=</span> even<span class="token punctuation">.</span>next        odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even_head        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 926】将字符串翻转到单调递增</title>
      <link href="/2020/02/13/leetcode-926/"/>
      <url>/2020/02/13/leetcode-926/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是单调递增的。</p><p>我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 S，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。</p><p>返回使 S 单调递增的最小翻转次数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："00110"输出：1解释：我们翻转最后一位得到 00111.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："010110"输出：2解释：我们翻转得到 011111，或者是 000111。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："00011000"输出：2解释：我们翻转得到 00000000。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 中只包含字符 ‘0’ 和 ‘1’</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要想把字符串变成递增的，只有两种可能，一种就是从某一处开始全是 1 ，之前都是 0 或者没有，另一种就是全 0 。那么我们只需要遍历这个 1 开始的位置就行了。</p><p>对于位置 i ，我们假设从它开始后面都是 1 ，前面都是 0 ，那么需要修改的的次数就是它后面 0 的数量减去它前面 1 的数量。</p><p>如果我们用数组预处理出来位置 i 开始到最后 1 的数量，记为 $dp[i]$ 。那么它后面 0 的数量就可以表示为 $n - i - dp[i]$ ，也就是后面的长度减去 1 的数量。而它前面 1 的数量可以表示为 $dp[0] - dp[i]$ ，也就是 1 的总数量减去 i 后面 1 的数量。</p><p>那么总的修改次数就是 $n - i - dp[i] + dp[0] - dp[i]$ ，我们只需要遍历所有的 i ，找出最小值就行了。</p><p>另外还需要比较一下 $dp[0]$ 的大小，也就是把所有的 1 都修改为 0 。</p><p>最终时间复杂度是 $O(n)$ ，空间复杂度也是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minFlipsMonoIncr</span><span class="token punctuation">(</span>string S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>n<span class="token operator">-</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minFlipsMonoIncr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'1'</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>n<span class="token operator">-</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1186】删除一次得到子数组最大和</title>
      <link href="/2020/02/12/leetcode-1186/"/>
      <url>/2020/02/12/leetcode-1186/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。</p><p>换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p><p>注意，删除一个元素后，子数组 不能为空。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：arr = [1,-2,0,3]输出：4解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：arr = [1,-2,-2,3]输出：3解释：我们直接选出 [3]，这就是最大和。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：arr = [-1,-1,-1,-1]输出：-1解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= arr.length &lt;= 10^5</li><li>-10^4 &lt;= arr[i] &lt;= 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先回顾一道很相似的题目，也就是求连续子数组的最大值，并不需要删除元素。</p><p>这其实只需要用动态规划就能实现了，也就是计算以 $arr[i]$ 结尾的连续子数组的最大值，记为 $dp[i]$ 。那么它一定要取 $arr[i]$ ，而前面的元素的话，如果 $dp[i-1] &gt; 0$ ，也就是以 $arr[i-1]$ 为结尾的连续子数组最大值大于 0 ，那就加上前面的最大值，否则的话只取 $arr[i]$ 就行了。最终答案就是取所有 $dp[i]$ 中最大的，状态转移方程是：<br>$$<br>dp[i] = arr[i] + max(dp[i-1], 0)<br>$$</p><p>回到本题，如果一个元素都不删除的话，那么做法就和上面一模一样。如果删除一个元素的话，那么它的左右两边就分成了两个连续的子数组了。</p><p>那么我们假设删除的是 $arr[i]$ ，那么我们只要求左右两边子数组的最大值之和，也就是以 $arr[i-1]$ 结尾和以 $arr[i+1]$ 开头的两个连续子数组的最大值之和。以 $arr[i-1]$ 结尾上面已经求过了，以 $arr[i+1]$ 开头和上面方法类似，从后往前求一遍就行了。这样预处理完两个动态规划数组之后，遍历删除的元素，就能 $O(n)$ 时间内算出最大值。</p><p>具体实现的时候，注意到删除的元素是有限制的，其实只需要遍历删除 $arr[1]$ 到 $arr[n-2]$ 就行了，因为删除首尾两个元素的话，剩下来一个子数组，答案已经包含在开始的预处理之中了。</p><p>空间方面，从右往左求以 $arr[i]$ 开头的连续子数组最大值的时候，没有必要保存到数组里了，直接用变量保存，然后同时计算删除 $arr[i]$ 之后最大值就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maximumSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> arr<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximumSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        res<span class="token punctuation">,</span> last <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>last<span class="token punctuation">)</span>            last <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> max<span class="token punctuation">(</span>last<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 927】三等分</title>
      <link href="/2020/02/11/leetcode-927/"/>
      <url>/2020/02/11/leetcode-927/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。</p><p>如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来：</p><ul><li>A[0], A[1], …, A[i] 组成第一部分；</li><li>A[i+1], A[i+2], …, A[j-1] 作为第二部分；</li><li>A[j], A[j+1], …, A[A.length - 1] 是第三部分。</li><li>这三个部分所表示的二进制值相等。</li></ul><p>如果无法做到，就返回 [-1, -1]。</p><p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,0,1,0,1]输出：[0,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,1,0,1,1]输出：[-1,-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>3 &lt;= A.length &lt;= 30000</li><li>A[i] == 0 或 A[i] == 1</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题虽然名义上是个难题，其实基本没有用到什么算法，只是代码实现上略微繁琐了一点。</p><p>想象如果这个数组能分成三个子数组，每个子数组表示的数字都相同，那么首先<strong>每个子数组中 1 的数量一定要相等！</strong></p><p>所以我们先统计 1 的数量，如果它不是 3 的倍数，那么一定不存在划分方式，直接返回无解就行了。如果数量是 0 ，就说明数组全 0 ，那么随便划分都是合理的，任意返回就行了。</p><p>接下来将 1 的数量等分为 3 份 ，然后遍历数组，找出 3 个子数组的左右边界（注意这个边界表示的是每个子数组第一个 1 和最后一个 1 的位置）。这时候还没结束，因为最后一个子数组末尾会多出来很多 0 。所以我们需要在前两个子数组后面加上等量的 0 。</p><p>最后遍历一遍三个子数组，判断是否完全相等就行了。</p><p>听起来是很简单，代码实现的时候还是有几个小细节的。比如求边界的时候，可以利用求余操作，保存到两个数组里，这样写起来美观方便。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">threeEqualParts</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt1 <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cnt1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        cnt1 <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> l<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> r<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeEqualParts</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        cnt1 <span class="token operator">=</span> sum<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">if</span> cnt1<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>        cnt1 <span class="token operator">//=</span> <span class="token number">3</span>        cnt <span class="token operator">=</span> <span class="token number">0</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                l<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">//</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token keyword">if</span> cnt<span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                r<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">//</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">or</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 503】下一个更大元素 II</title>
      <link href="/2020/02/10/leetcode-503/"/>
      <url>/2020/02/10/leetcode-503/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,1]输出：[2,-1,2]解释：第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong><br>输入数组的长度不会超过 10000。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题中循环数组其实不用管，只需要再复制一遍数组接在后面就行了，那么关键还是如何求每个数后面第一个比它大的数。</p><p>我们可以从右往左遍历数组，如果遍历到某个数，那么它右边所有比它小的数都不用再考虑了。因为再继续遍历下去的话，它右边比它还小的数是绝对不可能成为第一个大的数的。</p><p>这样我们只需要保存每个数右边比它大的数就行了，这就需要用到单调栈了。对于 $nums[i]$ 来说，我们只需要不断出栈，直到栈顶元素大于它就行了，那么这时候栈顶元素就是 $nums[i]$ 右边第一个比它大的数。如果栈是空的，就说明它右边没有更大的数了。</p><p>而在具体实现的时候，没必要真的把数组复制一遍接在后面，只需要用求余操作就能解决了。</p><p>最终每个元素出栈入栈一次，时间复杂度是 $O(n)$ ，空间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">>=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        stack<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">>=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">else</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 16】最接近的三数之和</title>
      <link href="/2020/02/09/leetcode-16/"/>
      <url>/2020/02/09/leetcode-16/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [-1，2，1，-4], target = 1.输出：2解释：与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最暴力的方法就是直接枚举三个不同的数，然后求出差值最小的和，但是这样时间复杂度是 $O(n^3)$ ，太高了。</p><p>那么我们先枚举一个数试试，并且假设它是最小的数，然后寻找比它大的两个数就行了，这就需要我们先对数组进行排序（假设排序后数组是 $a$ ）。</p><p>如果枚举的数是 $a[i]$ ，那么我们只需要寻找和 $t - a[i]$ 差值最小的两个数之和就行了。</p><p>如果用双指针的方法，初始时令 $l = i + 1$ ，同时 $r = n - 1$ 。那么如果 $a[i] + a[l] + a[r] &gt; t$ ，就说明 $r$ 太大了，需要左移。否则的话如果 $a[i] + a[l] + a[r] &lt; t$ ，就说明 $l$ 太小了，需要右移。在不断移动的过程中更新最小差值就行了，因为 $l$ 和 $r$ 最终一共只移动了 $O(n)$ 步，所以总的时间复杂度只有 $O(n \log n + n^2)$ ，忽略低阶项之后只有 $O(n^2)$ ，还是可以接受的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> sum<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">abs</span><span class="token punctuation">(</span>res<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> res <span class="token operator">=</span> sum<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10000000</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token number">-1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> s <span class="token operator">==</span> target<span class="token punctuation">:</span>                    <span class="token keyword">return</span> s                <span class="token keyword">if</span> abs<span class="token punctuation">(</span>s<span class="token operator">-</span>target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> abs<span class="token punctuation">(</span>res<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res <span class="token operator">=</span> s                <span class="token keyword">if</span> s <span class="token operator">></span> target<span class="token punctuation">:</span>                    r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 719】找出第 k 小的距离对</title>
      <link href="/2020/02/08/leetcode-719/"/>
      <url>/2020/02/08/leetcode-719/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,3,1]k = 1输出：0解释：所有数对如下：(1,3) -> 2(1,1) -> 0(3,1) -> 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>2 &lt;= len(nums) &lt;= 10000.</li><li>0 &lt;= nums[i] &lt; 1000000.</li><li>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>注意到这题 $n$ 比较大，所以不能算出所有的数对差值，然后排序，这样时间复杂度就是 $O(n^2 \log {n^2})$ 了。</p><p>直觉上应该先给数组从小到大排个序，那么差值最小值就是 0 ，最大值就是 $nums[n-1] - nums[0]$ ，答案肯定也就在这个区间里了。</p><p>那么我们可以从最大的差值开始，看是否有数对满足这个差值，并且这个差值还得是第 $k$ 小的。对于差值 $m$ ，如果它是第 $k$ 小的，说明所有数对中差值小于等于 $m$ 的数对个数 $c$ 一定大于等于 $k$ 。因为如果第 $k$ 小的差值只有一个数对满足，那么 $c = k$ ，否则的话就有多个数对差值都是 $m$ ，那就有 $c &gt; k$ 。于是我们找到第一个满足 $c &lt; k$ 的差值就行了，再加 1 就是最终的答案。</p><p>那么怎么求小于等于 $m$ 的数对个数 $c$ 呢？因为排过序了，所以可以采用双指针的方法，初始时 $l = r = 0$ ，对于每个右指针 $r$ ，我们移动左指针 $l$ ，直到 $nums[r] - nums[l] \le m$ 。那么最终 $r - l$ 就是以 $nums[r]$ 作为较大数的数对个数。因为两个指针都是向右移动的，所以每次计算个数只需要 $O(n)$ 的时间复杂度。</p><p>所以这个方法最终总的时间复杂度为 $O(Wn + n \log n)$ ，因为最大差值 $W$ 还是太大，所以还是没有办法直接遍历。</p><p>又注意到随着 $m$ 的减小， $c$ 也是单调减小的，所以可以二分寻找 $m$ 。如果 $c \ge k$ ，那么说明答案小于等于 $m$ ，于是令 $r = m$ 。如果 $c &lt; k$ ，那么说明答案一定大于 $m$ ，于是令 $l = m + 1$ ，最终答案就是 $l$ 。</p><p>这样二分优化之后，最终的时间复杂度为 $O(n\log W + n\log n)$ ，可以接受。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">smallestDistancePair</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nums<span class="token punctuation">)</span> <span class="token operator">>=</span> k<span class="token punctuation">)</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> r <span class="token operator">-</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">smallestDistancePair</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>K<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>            cnt<span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>            <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> K<span class="token punctuation">:</span>                    l <span class="token operator">+=</span> <span class="token number">1</span>                cnt <span class="token operator">+=</span> r <span class="token operator">-</span> l            <span class="token keyword">return</span> cnt        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> count<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">>=</span> k<span class="token punctuation">:</span>                r <span class="token operator">=</span> m            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 289】生命游戏</title>
      <link href="/2020/02/07/leetcode-289/"/>
      <url>/2020/02/07/leetcode-289/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ul><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ul><p>根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  [0,1,0],  [0,0,1],  [1,1,1],  [0,0,0]]输出：[  [0,0,0],  [1,0,1],  [0,1,1],  [0,1,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进阶</strong></p><ul><li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li><li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题要求你根据数组每个元素四周的状态来更新数组元素。如果使用一个辅助数组，遍历原数组，然后保存更新后的状态到辅助数组里。这样的话轻轻松松，没有任何难度。但是这题意思是让你不使用辅助数组，直接修改原数组元素，达到一样的目的。</p><p>这样的话就不能直接修改原数组元素了，不然当你遍历下一个元素的时候，它周围的值都变掉了，还怎么看它要不要变呢？所以我们应该想办法把变化前变化后的元素都保存下来。</p><p>因为这题只有两个状态 0 和 1 ，所以我们可以用两位二进制来表示变化前和后的状态，第一位表示变化后，第二位表示变化前。 00，10，01，11 分别表示 0 不变、0 变到 1 、1 变到 0 、1 不变四种变化情况。这样的话就算你直接修改了元素值，也能获取到它的原来的值。最后只需要进行第二遍扫描，取出变化后的值，也就是第一位就行了。</p><p>判断和修改都可以通过位运算来完成。判断修改前是否为 1 可以通过 $x\&amp;1$ 来看。用 m 表示修改（1）或者不修改（0），那么更新后元素就变成了 $x + (m &lt;&lt; 1)$ 。最后更新后的数组元素就是 $x &gt;&gt; 1$ 了。</p><p>而边界问题很好处理，只需要判断一下有没有超出边界就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        cnt<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        dx <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>        dy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                cnt <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    nx<span class="token punctuation">,</span> ny <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&lt;</span> n <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&lt;</span> m <span class="token operator">and</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                        cnt <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> cnt<span class="token operator">==</span><span class="token number">2</span> <span class="token operator">or</span> cnt<span class="token operator">==</span><span class="token number">3</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> cnt<span class="token operator">==</span><span class="token number">3</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 556】下一个更大元素 III</title>
      <link href="/2020/02/06/leetcode-556/"/>
      <url>/2020/02/06/leetcode-556/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：12输出：21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：21输出：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要发现一个性质，如果调换两个数位之后，整个数字变大了，那说明第一个数位的数字小于第二个数位的数。所以我们只需要找到一个顺序对，调换它俩顺序就行了。</p><p>但是如果存在两个顺序对 $(i_1, j_1)$ 和 $(i_2, j_2)$ ，那我们就要找 $i$ 更大的那个，因为前面的尽量不动才会使调换后的数字最小。</p><p>如果 $i$ 相同的话，就要在 $i$ 右边找最小的使得 $nums[j] &gt; nums[i]$ 的数，这样 $i$ 处的数字才是最小的，同时整体数字还会变大。</p><p>最后因为 $i$ 处已经变大了，所以 $i$ 后面的数字全部都要升序排列，这样整体数字才是最小的。</p><p>所以整体算法就有了，我们从右往左找，找到第一个上升的位置 $i$ ，也就是 $nums[i] &lt; nums[j]$ 。这样 $i$ 右边就是降序了，不存在顺序对。然后在 $i$ 右边的数字中二分查找最小的大于 $nums[i]$ 的数 $nums[j]$ ，调换它俩位置。最后把 $i$ 右边的数字变成升序即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span><span class="token operator">++</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            n <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> ok <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span>i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> a<span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                ok <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">></span> INT_MAX <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">(</span>n<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> res            <span class="token keyword">if</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span> <span class="token operator">and</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        res <span class="token operator">=</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                        <span class="token keyword">break</span>                s <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> res                <span class="token keyword">return</span> int<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">if</span> int<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;</span> pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还可以直接用 c++ 标准库函数 <code>next_permutation</code> 直接生成下一个更大的字符串排列，然后转换成整数就行了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">next_permutation</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token function">stoll</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res <span class="token operator">></span> INT_MAX <span class="token operator">||</span> res <span class="token operator">&lt;=</span> n <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1039】多边形三角剖分的最低得分</title>
      <link href="/2020/02/05/leetcode-1039/"/>
      <url>/2020/02/05/leetcode-1039/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。</p><p>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。</p><p>返回多边形进行三角剖分后可以得到的最低分。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3]输出：6解释：多边形已经三角化，唯一三角形的分数为 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong><br><img src="1.png" alt></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,7,4,5]输出：144解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,3,1,4,1,5]输出：13解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>3 &lt;= A.length &lt;= 50</li><li>1 &lt;= A[i] &lt;= 100</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一个凸 $n$ 边多边形，不停切割下去，最终一定是能切割成 $n-2$ 个三角形。那么按照什么顺序切割才能方便求解呢？</p><p>可以发现，一刀下去，两个多边形只有一条边是在内部，其他边都是连续的外围的边，如下图所示：</p><p><img src="2.jpg" alt></p><p>所以右边的多边形我们可以用 $(i, j)$ 二维状态来表示。</p><p>那么继续切割下去，例如切割左边那块多边形，我们应该先把 $(i, j)$ 这条边对应的三角形给找出来，那就是在 $(i, j)$ 之间找到第三个点 $k$ ，如下图所示：</p><p><img src="3.jpg" alt></p><p>这样右边多边形就被划分为了 3 块，其中除了 $(i, j, k)$ 这个三角形外，两外两块多边形仍然满足只有一条内边的性质，所以可以继续用二位状态表示为 $(i, k)$ 和 $(k, j)$。</p><p>那如果不先找三角形 $(i, j, k)$ 会怎么样呢。如下图所示：</p><p><img src="4.jpg" alt></p><p>这样的话，多边形 $(i, k_1, k_2, j)$ 就会出现两条内边，那么这种多边形就很难用简单的二维状态来表示了，程序中很难实现。</p><p>最后就能用二维动态规划来递归求解了。用 $(i, j)$ 表示多边形 $i \to i+1 \to \cdots j$ ，其中只有 $j \to i$ 是内边。设 $dp[i][j]$ 表示多边形 $(i, j)$ 切割后最小得分，那么只需要找到上面所说的切割点 $k$ 就行了，转移方程为：<br>$$<br>dp[i][j] = \min(dp[i][k] + dp[k][j] + A[i] \cdot A[j] \cdot A[k])<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    tmp <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span>                tmp <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>                    tmp <span class="token operator">=</span> min<span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 495】提莫攻击</title>
      <link href="/2020/02/04/leetcode-495/"/>
      <url>/2020/02/04/leetcode-495/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p><img src="1.jpg" alt="兔宝宝提莫"></p><p>现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。</p><p>你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,4], 2输出：4解释：在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。在第 4 秒开始时，提莫再次攻击艾希，使得艾希获得另外 2 秒的中毒时间。所以最终输出 4 秒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2], 2输出：3解释：在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。但是在第 2 秒开始时，提莫再次攻击了已经处于中毒状态的艾希。由于中毒状态不可叠加，提莫在第 2 秒开始时的这次攻击会在第 3 秒钟结束。所以最终输出 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为数组是时间序列，所以是给你排好序的，不需要你自己排序。</p><p>那么对于 $t[i]$ 来说，如果 $t[i-1]+d \le t[i]$ 的话，就说明前一时刻的中毒效果已经过去了，那么当前时刻的中毒效果持续时间都是属于当前时刻的，答案加上 $d$ 就行了。但是如果 $t[i-1]+d &gt; t[i]$ ，那么前一时刻的中毒效果还在，等前一时刻的中毒效果过去了，剩下的中毒时间才能算是当前时刻的，而扣除掉上一时刻剩余的时间为 $t[i] - t[i-1]$ 。所以最后属于当前时刻的中毒时间只要取 $t[i] - t[i-1]$ 和 $d$ 的最小值就行了。</p><p>最终时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findPoisonedDuration</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> timeSeries<span class="token punctuation">,</span> <span class="token keyword">int</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> timeSeries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> n <span class="token operator">?</span> duration <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>timeSeries<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findPoisonedDuration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> timeSeries<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>timeSeries<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">else</span> duration        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> min<span class="token punctuation">(</span>timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>timeSeries<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这题难度其实称不上中等，选取这道题完全是因为有我最爱的小提莫！</p><p>如果有同样喜爱英雄联盟的召唤师（小姐姐最棒了），可以加我好友一起开黑呀。本人<strong>艾欧尼亚</strong>（<strong>ID：godweiyang</strong>）黄金水平，虽然很菜，但是打字速度快！</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏！编码器中如何融入结构信息？这几篇论文一定不要错过</title>
      <link href="/2020/02/03/encoder-syntactic/"/>
      <url>/2020/02/03/encoder-syntactic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>编码器已经成为了很多 NLP 模型中的基本结构。不管你是做机器翻译，还是做句法分析，不管你是需要得到单词的上下文表示，还是需要得到句子的表示，你都需要一个强有力的编码器。输入一个句子，编码器最终输出每个单词的表示或者整个句子的表示。</p><p>而近些年来 NLP 领域用的比较多的编码器有 CNN ，RvNN ，RNN （尤其是 LSTM）和 Transformer 等等，今天我们主要关注最后两个。在编码器中加入结构信息有很多种用途。一是利用结构信息增强编码器的结构表示，进而提高下游任务的性能。二可以无监督学习出句子的句法树（如果融入的是句法结构信息的话）。</p><p>下面就给大家简要分享几篇融入了结构信息的编码器的论文。</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p><a href="http://arxiv.org/abs/1711.02013" title="ICLR18: Neural Language Modeling by Jointly Learning Syntax and Lexicon" target="_blank" rel="noopener">Neural Language Modeling by Jointly Learning Syntax and Lexicon</a></p><p><img src="1.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/yikangshen/PRPN" target="_blank" rel="noopener">https://github.com/yikangshen/PRPN</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2019/03/31/iclr18-prpn/">https://godweiyang.com/2019/03/31/iclr18-prpn/</a></p><p>本文提出了一种新的语言模型叫做 PRPN ，隐式地建模句法树信息。具体实现上，模型分为了三个部分：Parsing 模块、Reading 模块和 Predict 模块。其中 Parsing 模块用 CNN 来预测相邻两个单词的句法距离（概念详见 <a href="http://aclweb.org/anthology/P18-1108" title="ACL18: Straight to the Tree: Constituency Parsing with Neural Syntactic Distance" target="_blank" rel="noopener">Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</a>），通过句法距离就可以还原出句子的句法树了。Reading 模块用来建模上下文，同时还融入了前面时刻预测出来的句法距离信息。Predict 模块用来预测下一个单词是什么，做语言模型。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p><a href="https://www.aclweb.org/anthology/N19-1116/" title="NAACL19: Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders" target="_blank" rel="noopener">Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders</a></p><p><img src="3.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/iesl/diora" target="_blank" rel="noopener">https://github.com/iesl/diora</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2019/07/25/diora/">https://godweiyang.com/2019/07/25/diora/</a></p><p>这篇论文提出了 DIORA 模型，主要使用 inside-outside 算法来计算每个 span 的表示和得分。其中 inside 过程其实就是自底向上计算所有 span 的得分和表示，而 outside 过程自顶向下计算 span 表示。最后目标函数也和其他模型有所不同，一般目标函数不是语言模型就是下游任务，但是这里用 outside 过程得到的所有单词的表示和得分来计算损失函数，也就是最大化每个单词的所有可能的句法树的得分总和。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p><a href="http://arxiv.org/abs/1904.03746" title="NAACL19: Unsupervised Recurrent Neural Network Grammars" target="_blank" rel="noopener">Unsupervised Recurrent Neural Network Grammars</a></p><p><img src="4.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/harvardnlp/urnng" target="_blank" rel="noopener">https://github.com/harvardnlp/urnng</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2019/04/20/naacl19-urnng/">https://godweiyang.com/2019/04/20/naacl19-urnng/</a></p><p>本文提出了 URNNG 模型，用变分方法和 RNNG 来做无监督句法分析。具体实现上是用两个网络，第一个是 inference 网络，来推理出句子对应的隐变量（也就是句法树）的条件概率。然后再用生成网络 RNNG 来建模句子和隐变量的联合概率。最后对这个联合概率求和得到句子的概率，也就是用语言模型来作为目标任务。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p><a href="http://arxiv.org/abs/1810.09536" title="ICLR19: Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks" target="_blank" rel="noopener">Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks</a></p><p><img src="5.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/yikangshen/Ordered-Neurons" target="_blank" rel="noopener">https://github.com/yikangshen/Ordered-Neurons</a></p><p><strong>论文解读：</strong><br><a href="https://kexue.fm/archives/6621" target="_blank" rel="noopener">https://kexue.fm/archives/6621</a></p><p>这篇论文是 ICLR2019 的最佳论文之一，主要思想是赋予 LSTM 的神经元层级信息，对神经元排序（有序神经元），同时引入两个新的门控单元（主遗忘门和主输入门），来建模句子的层级结构信息。模型基于的最主要的指导思想就是：<strong>层级越高，颗粒度越粗，那么它在句子中的跨度就越大</strong>。输入一个单词之后，判断单词的层级和历史层级之间的大小关系，然后看情况更新参数的不同维度，低层保留历史信息，高层直接用输入信息覆盖，中间部分就用普通的 LSTM 更新。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p><a href="http://arxiv.org/abs/1909.02134" title="EMNLP19: PaLM: A Hybrid Parser and Language Model" target="_blank" rel="noopener">PaLM: A Hybrid Parser and Language Model</a></p><p><img src="7.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/Noahs-ARK/PaLM" target="_blank" rel="noopener">https://github.com/Noahs-ARK/PaLM</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2020/01/09/emnlp19-palm/">https://godweiyang.com/2020/01/09/emnlp19-palm/</a></p><p>本文在 LSTM 中融入 attention ，对于每个单词，都计算它和左边所有单词的 attention ，然后利用这个 attention 来融合历史信息，增强当前时刻的上下文表示。在解码句法树的时候，自顶向下解码，对于某个 span ，只需要贪心地找出使右儿子 span 得分最大的那个 split 就行了。至于这个 attention ，有没有句法树监督都是可以的，实际上没有句法树监督的话对语言模型效果更好。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p><a href="http://arxiv.org/abs/1909.06639" title="EMNLP19: Tree Transformer: Integrating Tree Structures into Self-Attention" target="_blank" rel="noopener">Tree Transformer: Integrating Tree Structures into Self-Attention</a></p><p><img src="6.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/yaushian/Tree-Transformer" target="_blank" rel="noopener">https://github.com/yaushian/Tree-Transformer</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2020/01/06/emnlp19-tree-transformer/">https://godweiyang.com/2020/01/06/emnlp19-tree-transformer/</a></p><p>本文和 Transformer 主要区别就是在每一层的 attention 之外还添加了一个成分 attention ，用来表示两个单词属于同一个短语之内的概率。最后总的 attention 就是原来的 attention 和成分 attention 做元素乘，这样的话同一个短语之间的 attention 就比较大，而不同短语之间的 attention 就很小。最后要想解码句法树的话，就还是用句法距离的算法，自顶向下解码句法树。</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p><a href="http://arxiv.org/abs/1909.02222" title="EMNLP19: Multi-Granularity Self-Attention for Neural Machine Translation" target="_blank" rel="noopener">Multi-Granularity Self-Attention for Neural Machine Translation</a></p><p><img src="10.jpg" alt></p><p>本文提出了多粒度的 Self-Attention 网络，也就是把原始的 Transformer 中的不同的 head 变成了不同的粒度。将一个句子分成了多个不重叠的短语，然后用 CNN 之类网络得到每个短语的表示，然后把单词当作 query ，短语当作 key ，做 self-attention 得到每个单词的粗粒度上下文表示。不同的短语切分方式对应着不同的粒度，可以用 n-gram 方式切分短语，也可以用句法树的不同层来切分短语。最后把不同粒度的单词表示拼在一起就行了。</p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p><a href="https://www.aclweb.org/anthology/P19-1030/" title="ACL19: You Only Need Attention to Traverse Trees" target="_blank" rel="noopener">You Only Need Attention to Traverse Trees</a></p><p><img src="2.jpg" alt></p><p>这篇论文思想也不复杂，论文目的是要设计一个能够编码句法树的网络，最终得到句子的向量表示，来给下游任务用。对于成分句法树，某个结点的表示可以由它的所有子结点做 self-attention ，然后经过一系列变换得到。对于依存句法树，某个单词的表示可以由它的父亲单词和所有儿子单词做 self-attention ，然后经过一系列变换得到。其实网络结构整体上看和递归神经网络是很像的，只是结点的结合函数借用了 Transformer 中的 self-attention ，模型名字作者也称为了 Tree-Transformer 。</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p><a href="http://arxiv.org/abs/1908.00449" title="CoRR19: Tree-Transformer: A Transformer-Based Method for Correction of Tree-Structured Data" target="_blank" rel="noopener">Tree-Transformer: A Transformer-Based Method for Correction of Tree-Structured Data</a></p><p><img src="9.jpg" alt></p><p>这篇文章并没有发出来，只是挂在了 arxiv 上，所以写的也是有很多错误的。主要提出了一个 Tree to Tree 的模型（类比 seq to seq 模型），按照 top-down 的顺序对一个句法树（或者代码的语法树等等）进行编码，然后 decoder 再按照 top-down 的顺序生成出一棵句法树。和普通的 Transformer 区别就是把中间的 feed-forward network 替换成了他这里的 tree conv block ，用来结合一个结点、它的父亲结点和所有兄弟结点的表示，如果没有的话就用零向量替代。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><a href="https://openreview.net/pdf?id=HJxK5pEYvr" title="ICLR20: Tree-Structured Attention with Hierarchical Accumulation" target="_blank" rel="noopener">Tree-Structured Attention with Hierarchical Accumulation</a></p><p><img src="11.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/nxphi47/tree_transformer" target="_blank" rel="noopener">https://github.com/nxphi47/tree_transformer</a></p><p>这篇论文 reviewer #1 也说了，写的公式符号有点晦涩难懂，不是很清楚。结构复杂，如果不公开源码很难实现。反正我也是看得云里雾里的，一头雾水。大致思想就是用一个矩阵，列数正好就是句子长度，每一行就对应了句法树的一个结点，外加一行叶子结点。矩阵中某一行，如果对应结点子树包含了某个单词，那一列就是有结点的特征向量的，否则就是零向量。然后对矩阵先按行做累和，再按列做加权求和，最后得到每个结点的向量表示。然后就是怎么把它融入到 Transformer 中了，写的是真的晦涩难懂，有兴趣的去看原论文吧。</p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p><a href="https://openreview.net/pdf?id=BJgQ4lSFPH" title="ICLR20: StructBERT: Incorporating Language Structures into Pre-training for Deep Language Understanding" target="_blank" rel="noopener">StructBERT: Incorporating Language Structures into Pre-training for Deep Language Understanding</a></p><p><img src="12.jpg" alt></p><p><strong>论文解读：</strong><br><a href="https://zhuanlan.zhihu.com/p/103207343" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103207343</a></p><p>这是阿里巴巴司罗老师团队改进的一种 BERT 模型，叫做 StructBERT 。主要就是在原本的 BERT 基础上新增加了两个预训练任务。一个是单词级别的，最大化长度为 K 的一段子句的正确词序的概率。一个是句子级别的，分为预测下一个句子、上一个句子和不同文档的随机句子三种。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> encoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 233】数字 1 的个数</title>
      <link href="/2020/02/03/leetcode-233/"/>
      <url>/2020/02/03/leetcode-233/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：13输出：6解释：数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题是我搜数位 dp 题目搜出来的，于是我直接用数位 dp 方法把它过了，后来发现其实没必要这么麻烦，简单的计算就能算出来了，这里两个方法我都讲一下。</p><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>我们不妨用 n = 12345 来举个例子。要求小于等于 n 的数字里有多少个 1 ，我们不妨转换个角度，看某一位数字是 1 的话，有多少数字小于 n 。</p><p>例如从右向左数第 i = 2 位（数字 3 ），如果这一位取 1 ，那么左边 2 位如果取 0-11 ，那么右边 2 位就没有任何限制，从 0 取到 99 都行。如果左边 2 位如果取 12 ，那么就得考虑 n 中第 i 位是几了，如果大于 1 ，那么右边 2 位还是没有限制；如果等于 1 ，那么右边 2 位只能取 0-45 ；如果等于 0 ，那就没得取了。</p><p>下面这张图是我打的草稿，看的更清楚一点：</p><p><img src="1.jpg" alt></p><p>一般化描述就是，考虑从右往左数第 i 位是 1 的数字数量。那么 n 中第 i 位左边部分的数字是 $\left\lfloor \frac{n}{10^{i+1}} \right\rfloor$ ，而右边可以取的数量是 $10^i$ ，相乘就是总的数量 $\left\lfloor \frac{n}{10^{i+1}} \right\rfloor \cdot 10^i$ 。如果左边直接取最大值，那么就要考虑第 i 位数字是几了，计算可以得到第 i 位数字为 $\left\lfloor \frac{n}{10^{i}} \right\rfloor \% 10$ ，记为 x 。如果 $x &gt; 1$ ，那么右边无限制，有 $10^i$ 种取法；如果 $x = 1$ ，那么右边有 $n \% 10^i + 1$ 种取法；如果 $x = 0$ ，那么右边无法取，因为第 i 位都没法取 1 。</p><p>综上，令 $x = \left\lfloor \frac{n}{10^{i}} \right\rfloor \% 10$ ，那么答案就是：<br>$$<br>\left\lfloor \frac{n}{10^{i+1}} \right\rfloor \cdot 10^i + 10^i \cdot [x &gt; 1] + (n \% 10^i + 1) \cdot [x = 1]<br>$$</p><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p>数位 dp 就麻烦许多了，不想看的可以直接跳过了。</p><p>首先我们从最高位开始往右递归计算，用 pos, count, limit 来表示计算到第 pos 位（从左往右，和数学方法不一样）时，已经出现了 count 个 1 ，并且之后的数字有无限制（也就是能否取遍 0-9 ），这种状态之下方法数是多少。</p><p>那么第 pos 位我们可以取的数字有哪些呢？如果 limit = 1 也就是有限制，那么只能取 0-n中第pos位，如果没有限制那就取 0-9 。</p><p>假设第 pos 位取 1 ，那么 pos 就转移到了 pos+1 ，count 转移到了 count+1 ，limit 呢？只有当原来有限制，并且第 pos 位正好取了最大值也就是 n 中第 pos 位数字时，limit 还是 1 ，否则的话限制取消，后面的数字随便取。如果第 pos 位不取 1 ，那么除了 count 不变以外，其他两个状态还是跟上面一样转移。</p><p>终止状态的话，如果遍历到了最后一位结束，就返回 count 数量就行了，表示当前数字中有 count 个 1 。</p><p>这样的话会有很多重复计算的状态，所以需要用到记忆化搜索，用 dp[pos][count] 来保存 pos, count, limit=0 状态下的答案。为什么只保存 limit=0 的答案呢？因为只有无限制的情况下，后面的数字才能随便取，跟 n 是多少没有关系。否则的话 n 变了后面的值就会受限于 n ，那么就不是一个定值了，没法保存。</p><p>那么 limit=1 不保存的话会不会超时呢？不会的，因为每一位只有一种取法会使得后面的数字继续有限制，所以整体上来看，有限制的状态个数是个常数，并不需要担心超时。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="数学方法（c-）"><a href="#数学方法（c-）" class="headerlink" title="数学方法（c++）"></a>数学方法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> x <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> i <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数位dp（c-）"><a href="#数位dp（c-）" class="headerlink" title="数位dp（c++）"></a>数位dp（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pos<span class="token punctuation">)</span> <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>limit <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ub <span class="token operator">=</span> limit <span class="token operator">?</span> a<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ub<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pos<span class="token number">-1</span><span class="token punctuation">,</span> count<span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limit<span class="token operator">&amp;&amp;</span>i<span class="token operator">==</span>a<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> limit <span class="token operator">?</span> res <span class="token operator">:</span> dp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span><span class="token operator">++</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            n <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学方法（python）"><a href="#数学方法（python）" class="headerlink" title="数学方法（python）"></a>数学方法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            res <span class="token operator">+=</span> n <span class="token operator">//</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> i            x <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">//</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span>            res <span class="token operator">+=</span> i <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> x            i <span class="token operator">*=</span> <span class="token number">10</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 523】连续的子数组和</title>
      <link href="/2020/02/02/leetcode-523/"/>
      <url>/2020/02/02/leetcode-523/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[23,2,4,6,7], k = 6输出：True解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[23,2,6,4,7], k = 6输出：True解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>数组的长度不会超过 10000 。</li><li>你可以认为所有数字总和在 32 位有符号整数范围内。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>直接枚举所有的区间，然后求出每个区间的和，看是不是 k 的整数倍就行了。这种方法时间复杂度是 $O(n^3)$ ，一定过不了的。</p><h3 id="前缀和优化"><a href="#前缀和优化" class="headerlink" title="前缀和优化"></a>前缀和优化</h3><p>还是枚举所有区间，但是预处理的时候把所有的前缀和保存到数组里，这样区间求和就可以直接计算出来了。最后时间复杂度是 $O(n^2)$ ，理论上应该还是没法通过，但是这题数据太弱，竟然勉强通过了。</p><h3 id="求余优化"><a href="#求余优化" class="headerlink" title="求余优化"></a>求余优化</h3><p>假设前缀和为 sum ，那么区间 [i, j] 的和就可以表示为 sum[j]-sum[i-1] ，如果它是 k 的倍数，就说明了 sum[j] 和 sum[i-1] 模 k 的余数是相同的。</p><p>那么我们就可以提前把 sum 数组里的每个数都对 k 求余，然后看有没有两个余数是相同的，并且距离大于等于 2 就行了。</p><p>这只需要用一个哈希表就可以判断一个数有没有在之前出现过了。如果一个数没有出现过，就把它的下标放进哈希表。否则的话就判断当前下标和哈希表中的下标差值，如果大于等于 2 ，就找到合法区间了，直接返回 true 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">checkSubarraySum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        mp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>sum <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">==</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkSubarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        mp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        mp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            sum <span class="token operator">%=</span> k            <span class="token keyword">if</span> sum <span class="token operator">not</span> <span class="token keyword">in</span> mp<span class="token punctuation">:</span>                mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>c++ 有多种实现方法，可以用 map 、hash_map 、unordered_map 等多种数据结构。其中 hash_map 不在标准库里，这里没法使用。理论上 unordered_map 比 map 会快一点，但是实际运行中没有发现差别。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 115】不同的子序列</title>
      <link href="/2020/02/01/leetcode-115/"/>
      <url>/2020/02/01/leetcode-115/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p><p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：S = "rabbbit", T = "rabbit"输出：3解释：如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。(上箭头符号 ^ 表示选取的字母)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：S = "babgbag", T = "bag"输出：5解释：如下图所示, 有 5 种可以从 S 中得到 "bag" 的方案。 (上箭头符号 ^ 表示选取的字母)babgbag^^ ^babgbag^^    ^babgbag^    ^^babgbag  ^  ^^babgbag    ^^^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="dfs-记忆化搜索"><a href="#dfs-记忆化搜索" class="headerlink" title="dfs+记忆化搜索"></a>dfs+记忆化搜索</h3><p>这题要求字符串 s 中有多少子序列正好等于字符串 t ，那么我们不如从最后一个字符看起，假设 s 和 t 的长度分别为 n 和 m 。</p><p>如果 s[n-1] 和 t[m-1] 不相等，那么显然只能在 s[0] 到 s[n-2] 之中寻找 t 。</p><p>如果 s[n-1] 和 t[m-1] 相等，那么有两种选择。一种是这两个字符对应上，然后在 s[0] 到 s[n-2] 之中寻找 t[0] 到 t[m-2] 。另一种是不用 s[n-1] ，还是和上一种情况一样，在 s[0] 到 s[n-2] 之中寻找 t 。两种选择的方案数加起来就是答案了。</p><p>那么递归终止条件是什么呢？如果发现 s 已经空了，但是 t 还有字符没有对应上，那么方案数一定为 0 。如果 t 空了，那么不管 s 还剩多少字符，都说明 t 已经找到对应的子序列了，方案数加 1 。</p><p>为了防止重复计算，还要加上记忆化搜索，用数组记录一下每个状态的方案数。状态 (i, j) 就表示在 s[0] 到 s[i] 中寻找 t[0] 到 t[j] 的方案数。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>当然一般上面那种 dfs 都可以转化成动态规划的写法。</p><p>这里动态规划就是从长度比较短的字符串开始求解。初始状态是 dp[i][0] ，表示 s[0] 到 s[i] 之中有多少个 t[0] ，这很容易求出来。</p><p>然后两层循环遍历两个的字符串的结尾，跟上面 dfs 方法一样，如果 s[i] 和 t[j] 不相等，那么 dp[i][j] = dp[i-1][j] ；否则的话再加上一个 dp[i-1][j-1] 就行了。</p><h3 id="动态规划-空间优化"><a href="#动态规划-空间优化" class="headerlink" title="动态规划+空间优化"></a>动态规划+空间优化</h3><p>上面动态规划方法有个问题就是字符串如果太长的话，空间会吃不消。而仔细观察就会发现，当循环到 i ，然后遍历 j 的时候，其实只会用到 i-1 的状态。那么我们就可以去掉第一维，只保存 j 的所有状态就行了。</p><p>但是有个注意的点是，第二层循环 j 的顺序要变一下，要从大往小遍历。因为 j 需要用到 (i-1, j-1) 时刻的状态值，如果你从小到大遍历，那么 (i, j-1) 的方案数就会把 (i-1, j-1) 的方案数覆盖掉，之后你获取到的就不是 i-1 时刻的方案数了。</p><p>另一个小区别是 dp[i][0] 的计算被移到了第一层循环的最后，而不是初始化就计算好了。这是因为第一维 i 被去掉了，所以只能在用到的时候再更新计算。</p><h3 id="动态规划-空间优化-时间优化"><a href="#动态规划-空间优化-时间优化" class="headerlink" title="动态规划+空间优化+时间优化"></a>动态规划+空间优化+时间优化</h3><p>其实上面一个方法速度已经不错了，但是时间上还是有优化的余地的。</p><p>可以发现，只有当 s[i] = t[j] 的时候，才需要更新 (i, j) 的方案数。所以我们只需要提前预处理出来每个字母 s[i] 在 字符串 t 中的哪些位置出现过就行了。然后遍历的时候只需要直接取出这些位置来更新就行了。</p><p>而实际运行中也会发现， dfs 要比动态规划快很多！这是因为 dfs 只会遍历合法的那些状态，而动态规划会把所有状态都计算出来，不管对最后的答案有没有帮助。</p><p>举个例子，s = “abcbbbb” ， t = “abc” ，因为 t 只在 s 的前三个字母中出现了，所以如果我们寻找 t 的子串 “ab” 在 s 中出现次数的时候，从第二个 b 开始都是没有任何意义的，因为后面都没有 c 给你匹配了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="dfs-记忆化搜索（c-）"><a href="#dfs-记忆化搜索（c-）" class="headerlink" title="dfs+记忆化搜索（c++）"></a>dfs+记忆化搜索（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span><span class="token operator">&amp;</span> dp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化（c-）"><a href="#动态规划-空间优化（c-）" class="headerlink" title="动态规划+空间优化（c++）"></a>动态规划+空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化-时间优化（c-）"><a href="#动态规划-空间优化-时间优化（c-）" class="headerlink" title="动态规划+空间优化+时间优化（c++）"></a>动态规划+空间优化+时间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">pos</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pos<span class="token punctuation">[</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> sz<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> p <span class="token operator">=</span> pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dfs-记忆化搜索（python）"><a href="#dfs-记忆化搜索（python）" class="headerlink" title="dfs+记忆化搜索（python）"></a>dfs+记忆化搜索（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>m <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（python）"><a href="#动态规划（python）" class="headerlink" title="动态规划（python）"></a>动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>m <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化（python）"><a href="#动态规划-空间优化（python）" class="headerlink" title="动态规划+空间优化（python）"></a>动态规划+空间优化（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> m        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化-时间优化（python）"><a href="#动态规划-空间优化-时间优化（python）" class="headerlink" title="动态规划+空间优化+时间优化（python）"></a>动态规划+空间优化+时间优化（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> m        pos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>            pos<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> pos<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这题还有个坑爹的地方，就是用动态规划写的时候，数组数据类型必须定义成 long 类型，否则会爆 int 范围，但是最终的答案又在 int 范围内。这其实就是因为动态规划计算了很多无用的状态，这些状态里有超出 int 范围的。而 dfs 用 int 就完全没有问题。</p><p>本题还是非常不错的，带你一步步从最好写的 dfs ，然后转化成动态规划，然后优化空间，减少数组维度，最后优化时间。优化时间在 c++ 上面提升不明显，但是 python 提升非常大，直接超过了 100% 的方法。</p><p>时间上还有一些小 trick ，我这里没有考虑，留给大家思考。比如对于状态 (i, j) ，如果 n-i &lt; m-j ，那么就没必要更新了，因为 s 中剩下来的字符串都不够 t 剩下来的去匹配的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 239】滑动窗口最大值</title>
      <link href="/2020/01/31/leetcode-239/"/>
      <url>/2020/01/31/leetcode-239/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong><br>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双端单调队列"><a href="#双端单调队列" class="headerlink" title="双端单调队列"></a>双端单调队列</h3><p>本题要找长度为 k 的区间的最大值。模拟这个区间的移动过程，可以发现，右边增加一个数，左边必然会去掉一个数。</p><p>那么最大的数有什么性质呢？可以发现，如果扫描区间末尾，在已经遍历过的数之中，一个数 a 在 b 前面，并且 a 还比 b 小，那么 a 在之后的区间里永远无法成为最大值。</p><p>所以我们遍历到一个数时，它之前的所有比它小的数都可以去掉了，只保留比它大的数就行了。这就让人想到了之前介绍过的单调栈，但是本题中是先进先出，所以要改用单调队列。此外队列末尾不仅要增加元素，还得维护单调递减，适当去除一些元素，所以队列两端都得有插入和删除的功能。所以本题要使用双端队列，而队列中的元素又是单调递减的，所以又是双端单调队列。</p><p>这样思路就很明确了：</p><ul><li>遍历元素 nums[i] ，然后跟队列尾部元素比较，如果比尾部元素大，就出队，然后继续比较，直到 nums[i] 小于尾部元素，然后将它入队。</li><li>然后用一下队列首部元素的下标，计算出队列中区间的长度，如果大于 k 了，那么队首元素就要出队。</li><li>最后队首元素就是当前区间的最大值。</li></ul><h3 id="分块法"><a href="#分块法" class="headerlink" title="分块法"></a>分块法</h3><p>试想如果我们将数组划分为相同大小的若干块，每一块中最大值都是知道的话，那么要求区间最大值，只需要看它在哪几块里就行了。</p><p>那么块的大小应该设成多少呢？</p><p>如果块大小为 k ，就可以发现长度为 k 的区间 [i, j] 要么正好就是一个完整的块，要么跨越了两个相邻块。那么我们只需要知道 i 到它那块末尾元素中最大值，以及 j 到它那块开头最大值就行了，两个部分合并求最大值就是区间的最大值了。而每个元素到它自己那块的开头和末尾的最大值都可以预处理出来，方法和求前缀和类似。</p><p>那为什么块大小不能是其他值呢？如果块大小大于 k ，那么会出现区间完全包含于一块之中的情况，那就和不分块一样了。如果块大小小于 k ，那么就会出现区间横跨了好几块，那么还得遍历中间块的最大值。极端情况下如果块大小为 1 ，那么就等于暴力求解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="双端单调队列（c-）"><a href="#双端单调队列（c-）" class="headerlink" title="双端单调队列（c++）"></a>双端单调队列（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端单调队列-数组实现（c-）"><a href="#双端单调队列-数组实现（c-）" class="headerlink" title="双端单调队列+数组实现（c++）"></a>双端单调队列+数组实现（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Q</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>r<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            Q<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分块法（c-）"><a href="#分块法（c-）" class="headerlink" title="分块法（c++）"></a>分块法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lmax</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rmax</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">==</span> n<span class="token number">-1</span><span class="token punctuation">)</span> rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端单调队列（python）"><a href="#双端单调队列（python）" class="headerlink" title="双端单调队列（python）"></a>双端单调队列（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collections<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        Q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>Q<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                Q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            Q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">-</span> Q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">:</span>                Q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端单调队列-数组实现（python）"><a href="#双端单调队列-数组实现（python）" class="headerlink" title="双端单调队列+数组实现（python）"></a>双端单调队列+数组实现（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collections<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        Q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> r<span class="token operator">-</span>l <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>r<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            Q<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> i            r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> i <span class="token operator">-</span> Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>             <span class="token keyword">if</span> i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分块法（python）"><a href="#分块法（python）" class="headerlink" title="分块法（python）"></a>分块法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collections<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        lmax<span class="token punctuation">,</span> rmax <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">==</span> n<span class="token number">-1</span><span class="token punctuation">:</span>                rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>rmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>max<span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>双端队列在 c++ 和 python 中都有 deque 的实现，如果你不会用的话，也可以用一个数组自己模拟一下，我觉得反而更加方便一点。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 312】戳气球</title>
      <link href="/2020/01/30/leetcode-312/"/>
      <url>/2020/01/30/leetcode-312/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] <em> nums[i] </em> nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,5,8]输出：167解释：nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="dfs-记忆化搜索"><a href="#dfs-记忆化搜索" class="headerlink" title="dfs+记忆化搜索"></a>dfs+记忆化搜索</h3><p>对于区间 [l, r] ，我们考虑最后一个被戳破的气球 k ，那么之前的步骤我们可以分为两步，也就是求 [l, k-1] 和 [k+1, r] 之间的最大分数。</p><p>那么为什么不考虑先戳破 k 呢？因为这样的话 [l, k-1] 和 [k+1, r] 就会连接在一起，两个子状态就不能独立计算了，互相会产生影响。</p><p>两个子区间的最大的分算完之后，最后 k 的得分就是 nums[l-1] <em> nums[k] </em> nums[r+1] ，取使得总得分最高的 k 就行了。</p><p>有一个小技巧就是，提示里也说了，就是刚开始的时候在首尾各添加一个分数为 1 的虚拟气球。</p><p>但是直接这样递归会超时，因为有很多的子状态都重复计算了，所以可以用一个全局的数组保存每个状态的分数。初始化为 -1 ，如果某个状态计算过了，就直接返回它的值就行了，不然就递归计算。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>上面的方法是自顶向下的，其实也可以转化成自底向上的，也就是从小的区间开始算起，最后算最大的，这就是动态规划的方法，具体的实现细节和上面是一模一样的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="dfs-记忆化搜索（c-）"><a href="#dfs-记忆化搜索（c-）" class="headerlink" title="dfs+记忆化搜索（c++）"></a>dfs+记忆化搜索（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> k<span class="token number">-1</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">+</span>len<span class="token number">-1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dfs-记忆化搜索（python）"><a href="#dfs-记忆化搜索（python）" class="headerlink" title="dfs+记忆化搜索（python）"></a>dfs+记忆化搜索（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>l<span class="token punctuation">,</span> k<span class="token number">-1</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（python）"><a href="#动态规划（python）" class="headerlink" title="动态规划（python）"></a>动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 424】替换后的最长重复字符</title>
      <link href="/2020/01/29/leetcode-424/"/>
      <url>/2020/01/29/leetcode-424/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：s = "ABAB", k = 2输出：4解释：用两个'A'替换为两个'B',反之亦然。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：s = "AABABBA", k = 1输出：4解释：将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。子串 "BBBB" 有最长重复字母, 答案为 4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong><br>字符串长度和 k 不会超过 10^4。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题和之前做过的一题非常类似：<a href="https://godweiyang.com/2020/01/09/leetcode-1004/">每日算法系列【LeetCode 1004】最大连续1的个数 III</a>，只不过这题字符数量变成了 26 个。</p><p>方法和那题类似，都是用滑动窗口。用数组 count 记录每个字母出现的次数，并且用变量 cmax 记录窗口中出现次数最多的字母数量。</p><p>当前窗口是 [l, r] ，如果保留窗口中出现次数最多的字母，将其他字母全部替换为这个字母，那么替换次数就是 $r - l + 1 - cmax$ 。如果它大于 k ，那就说明不能继续向右扩展，而是需要左端点右移，缩小窗口了。缩小的过程中时刻更新 cmax 的值就行了，直到 $r - l + 1 - cmax$ 再次小于等于 k ，然后继续右移 r 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cmax<span class="token punctuation">,</span> <span class="token operator">++</span>count<span class="token punctuation">[</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> cmax <span class="token operator">></span> k<span class="token punctuation">)</span>                count<span class="token punctuation">[</span>s<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> cmax<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> r <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            cmax <span class="token operator">=</span> max<span class="token punctuation">(</span>cmax<span class="token punctuation">,</span> count<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> cmax <span class="token operator">></span> k<span class="token punctuation">:</span>                count<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            r <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>注意这里代码实现上面有个很大的问题，就是右移左端点缩小窗口的时候， cmax 并没有跟着减小，这样为什么还是对的呢？这种情况下， cmax保存的其实是历史出现次数最多的字母的次数。而你不改变 cmax ，就会导致中间过程中出现很多不符合题意的窗口，也就是实际要修改的数量大于 k 的窗口，但是因为你 cmax 偏大，算下来修改数量偏小，它又是符合题意的。不过不影响，这些错误的窗口的长度一定是小于你之前算到的正确窗口的长度的（如果大于了，那么 cmax 一定会被更新）。</p><p><strong>下面解释来自于algsCG：</strong></p><blockquote><p>因为我们只对最长有效的子字符串感兴趣，所以我们的滑动窗口不需要收缩，即使窗口可能覆盖无效的子字符串。我们可以通过在右边添加一个字符来扩展窗口，或者将整个窗口向右边移动一个字符。而且我们只在新字符的计数超过历史最大计数（来自覆盖有效子字符串的前一个窗口）时才增长窗口。也就是说，我们不需要精确的当前窗口的最大计数;我们只关心最大计数是否超过历史最大计数;这只会因为新字符而发生。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 42】接雨水</title>
      <link href="/2020/01/28/leetcode-42/"/>
      <url>/2020/01/28/leetcode-42/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="1.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[0,1,0,2,1,0,1,3,2,1,2,1]输出：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法1（按列算）"><a href="#方法1（按列算）" class="headerlink" title="方法1（按列算）"></a>方法1（按列算）</h3><p>这也是最容易理解的一种方法，我们计算每一个柱子上方的水最多有多高就行了，而这个高度取决于它的左右两边最高的柱子分别是多高。</p><p>当然可以暴力求左右两端最高的高度了，不过其实只需要预处理一下，用数组保存一下每个位置左右两端最高的高度就行了。</p><p>最后答案的话就是用左右两边最高高度的较小值，减去这根柱子的高度。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ ，需要扫描两遍数组。</p><h3 id="方法2（按行算）"><a href="#方法2（按行算）" class="headerlink" title="方法2（按行算）"></a>方法2（按行算）</h3><p>我们可以发现，每一行水左右肯定都会被柱子卡住（显然是废话）。那么从左向右遍历柱子，如果高度在下降，那么显然不会蓄水。如果高度上升了，那就说明中间是个低点，这之间可以蓄水。而这个下降的高度用单调栈来维护就行了，栈里我们只放下标。</p><p>那到底蓄水多少呢？假设 q 是栈顶下标，p 是栈顶第二个元素下标，那么一定有 $h[p] \ge h[q]$ 。现在进来一个 $h[i] &gt; h[q]$ ，那么 q 就是一个低点，而 p ， q ， i 之间的蓄水（比 $h[q]$ 高，比 $h[p]$ 和 $h[i]$ 都低的部分）可以计算为 $(\min(h[p], h[i]) - h[q])\cdot(i - p - 1)$ 。然后把 q 出栈，继续用栈顶两个元素计算。</p><p>那么为什么这里只需要计算 p 和 i 之间比 $h[q]$ 高的那部分矩形就行了呢？因为比它低的部分在之前都已经算过了，而比它高的部分在之后还会计算到。</p><p>用下面这张示意图可以看的更清楚一点：</p><p><img src="1.jpg" alt></p><p>红色表示栈里的元素，白色表示已经出栈了，绿色表示当前准备进栈的元素。那么这时候我们上面求的就是 3 号水块的面积，而 1 和 2 水块在之前进栈操作中就已经求出来了， 4 水块的话在之后（q 出栈，p 和 i 进行比较）也会被计算到。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ ，需要扫描一遍数组，但是每个元素会入栈再出栈，所以操作次数和方法1其实是一样的。</p><h3 id="方法3（双指针优化方法1）"><a href="#方法3（双指针优化方法1）" class="headerlink" title="方法3（双指针优化方法1）"></a>方法3（双指针优化方法1）</h3><p>方法 1 中，我们需要用到一个额外数组来保存左右两边的最大值，其实我们可以用双指针法来规避这个问题。</p><p>考虑用两个指针 l 和 r 分别从最左和最右端往中间靠拢，同时用 lmax 记录 l 左边的最高高度，用 rmax 记录 r 右边的最高高度。</p><p>此时如果 $h[l] &lt; h[r]$ ，那么我们计算 l 处能蓄水多高，如果 $h[l] \ge h[r]$ ，我们计算 r 处蓄水多高。这样我们时刻只计算低的那边的答案，就能保证 l 两边的最高处较小值一定是 lmax ，r 两边同理。为什么呢？你模拟一遍左右切换的过程就会发现，当 $h[l] &gt; h[r]$ 的时候，切换到计算 r 那边去了，再继续等到 $h[r] &gt; h[l]$ 的时候，又切回计算 l 这边了，所以两端 l 和 r 的值始终保证：当它固定不动，计算另一端高度时，它一定是这一边最高的。</p><p>那么如果 $h[l] &lt; h[r]$ ，我们怎么计算 $h[l]$ 处蓄水多高呢？如果 $h[l] \ge lmax$ ，那么 l 处根本就没法蓄水，因为它是最高的，所以更新 lmax 就行了。否则的话 l 两边最大高度较小值一定是 lmax ，还是按照方法 1 那样计算就行了。</p><p>这样的话，就不需要额外维护一个高度数组了。时间复杂度 $O(n)$ ，空间复杂度 $O(1)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1（c-）"><a href="#方法1（c-）" class="headerlink" title="方法1（c++）"></a>方法1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lmax</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> rmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rmax<span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（c-）"><a href="#方法2（c-）" class="headerlink" title="方法2（c++）"></a>方法2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法3（c-）"><a href="#方法3（c-）" class="headerlink" title="方法3（c++）"></a>方法3（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">,</span> lmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">>=</span> lmax<span class="token punctuation">)</span> lmax <span class="token operator">=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> res <span class="token operator">+</span><span class="token operator">=</span> lmax <span class="token operator">-</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>=</span> rmax<span class="token punctuation">)</span> rmax <span class="token operator">=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> res <span class="token operator">+</span><span class="token operator">=</span> rmax <span class="token operator">-</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法1（python）"><a href="#方法1（python）" class="headerlink" title="方法1（python）"></a>方法1（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        lmax <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        rmax<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rmax <span class="token operator">=</span> max<span class="token punctuation">(</span>rmax<span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">+=</span> min<span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（python）"><a href="#方法2（python）" class="headerlink" title="方法2（python）"></a>方法2（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                mid <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                res <span class="token operator">+=</span> <span class="token punctuation">(</span>min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法3（python）"><a href="#方法3（python）" class="headerlink" title="方法3（python）"></a>方法3（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> lmax<span class="token punctuation">,</span> rmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">>=</span> lmax<span class="token punctuation">:</span>                    lmax <span class="token operator">=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> lmax <span class="token operator">-</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>=</span> rmax<span class="token punctuation">:</span>                    rmax <span class="token operator">=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> rmax <span class="token operator">-</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题方法还是很多的，最好需要画个示意图，模拟一下运行过程。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 810】黑板异或游戏</title>
      <link href="/2020/01/27/leetcode-810/"/>
      <url>/2020/01/27/leetcode-810/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个黑板上写着一个非负整数数组 nums[i] 。小红和小明轮流从黑板上擦掉一个数字，小红先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p><p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p><p>假设两个玩家每步都使用最优解，当且仅当小红获胜时返回 true。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1, 1, 2]输出：false解释：小红有两个选择: 擦掉数字 1 或 2。如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么小明可以擦掉任意数字，因为小红会成为擦掉最后一个数字的人，她总是会输。如果小红擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。小红仍然会输掉游戏。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= N &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 2^16</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>小红获胜的条件就是，某一步轮到她的时候，所有数异或等于 0 。</p><p>而反过来，她输的条件就是，面对 n 个数，无论她选哪个数，去掉这个数之后剩下的数的异或都等于 0 。</p><p>假设 n 个数的异或为 S ，也就是令：<br>$$<br>S = x_1 \oplus x_2 \oplus \dots \oplus x_n<br>$$<br>因为两个相同的数的异或为 0 ，所以去掉任意一个数 $x_i$ 之后的异或为 $S \oplus x_i = 0$ ，所以 $S = x_i$ ，也就是所有的数都相等。</p><p>此时如果 n 是偶数，那么 n 个数的异或必为 0 ，和小红必输矛盾了，所以 n 一定要是奇数。</p><p>也就是说，如果 n 是偶数，那么小红总有办法去掉一个数，然后使得剩下的数异或不为 0 ，这时小明就没办法获胜。而不管小明擦除哪个数，轮到小红的时候个数又变成了偶数，小红就可以继续不输擦除下去。直到最后，一定是小红面对着空的数集，最终获胜。</p><p>而 n 是奇数的时候，无论小红选什么数，小明面对的都是偶数个数，那么小明必胜。</p><p>综上，n 是偶数小红必胜，或者刚开始 n 个数异或就是 0 ，这样不管奇偶，小红都能获胜。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">xorGame</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">!</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> reduce<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">xorGame</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> reduce<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>xor<span class="token punctuation">,</span> nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>官方题解是这么说的：如果 n 是偶数，那么小红有很大概率获胜，因为如果游戏能够一直进行下去，小明将会是擦除最后一个数的人，轮到小红时黑板上已经没有数，小红获胜。然后再推测 n 是偶数情况下的必胜条件，但是这样带有一点先猜后验证的成分。</p><p>所以我的推测方法直接从必胜条件出发，推测出 n 是偶数，这样过渡自然，更符合思考的路线。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 153】寻找旋转排序数组中的最小值</title>
      <link href="/2020/01/26/leetcode-153/"/>
      <url>/2020/01/26/leetcode-153/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>(例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,4,5,1,2]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[4,5,6,7,0,1,2]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题如果直接遍历一遍的话，时间复杂度是 $O(n)$ ，也能过。但是这题显然想要你更快，也就是用 $O(\log n)$ 的时间复杂度来做出来，那我们只能选择用二分法。</p><p>因为序列从中间切开来，然后调换过顺序，所以是先上升，再下降一下，然后再上升。并且第二段上升的最大值 $nums[n-1]$ 是一定小于第一段上升的最小值 $nums[0]$ 的，所以最小值一定是第二段的第一个数。</p><p>假设我们二分的时候，左端点 l ，右端点 r ，中间点是 m 。</p><p>如果 $nums[l] &gt; nums[r]$ ，那说明左端点在第一段，右端点在第二段。这时如果 $nums[m] \ge nums[l]$ ，那么 m 也在第一段，所以 l 需要右移；否则的话 m 在第二段， r 需要左移。</p><p>如果 $nums[l] \le nums[r]$ ，那么两个端点都在第二段，是单调上升的，那最小值一定就是 l 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    r <span class="token operator">=</span> m<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> l<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> m            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> l        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 386】字典序排数</title>
      <link href="/2020/01/26/leetcode-386/"/>
      <url>/2020/01/26/leetcode-386/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 n, 返回从 1 到 n 的字典顺序。</p><p>例如，给定 n = 13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p><p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h3><p>首先把 1 到 n 所有整数的字符串形式放进数组，然后对这个字符串数组进行排序，最后把所有字符串转换成对应的整数就行了。</p><p>时间复杂度是 $O(n \log n)$ ，空间复杂度是 $O(n)$。</p><h3 id="字典树法"><a href="#字典树法" class="headerlink" title="字典树法"></a>字典树法</h3><p>还可以按从小到大顺序直接生成所有整数，首先观察如下的字典树：</p><p><img src="1.jpg" alt="字典树"></p><p>可以看出来，这是一棵 10 叉的字典树，第一层根节点，第二层没有 0 （因为不能有前导 0 ），后面的每一层都是在上一层的基础上添加一位 0 到 9 。</p><p>而如果按照前序遍历的顺序遍历这棵树，得到的整数序列就是字典序从小到大的。但是这棵树深度是没有限制的啊，所以如果遍历到的数字 x 大于 n 的话，就要结束遍历，回溯到上一层。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="排序法（c-）"><a href="#排序法（c-）" class="headerlink" title="排序法（c++）"></a>排序法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> s<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            s<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序法（python）"><a href="#排序法（python）" class="headerlink" title="排序法（python）"></a>排序法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字典树法（c-）"><a href="#字典树法（c-）" class="headerlink" title="字典树法（c++）"></a>字典树法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字典树法（python）"><a href="#字典树法（python）" class="headerlink" title="字典树法（python）"></a>字典树法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">></span> n<span class="token punctuation">:</span>            <span class="token keyword">return</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>字典序法的递归需要耗费更大的空间，而在实际运行中， python 代码排序法的运行速度甚至比字典序法更快，这说明了 python 递归是真的慢。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 825】适龄的朋友</title>
      <link href="/2020/01/25/leetcode-825/"/>
      <url>/2020/01/25/leetcode-825/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>人们会互相发送好友请求，现在给定一个包含有他们年龄的数组，ages[i] 表示第 i 个人的年龄。</p><p>当满足以下条件时，A 不能给 B（A、B不为同一人）发送好友请求：</p><ul><li>age[B] &lt;= 0.5 * age[A] + 7</li><li>age[B] &gt; age[A]</li><li>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</li></ul><p>否则，A 可以给 B 发送好友请求。</p><p>注意如果 A 向 B 发出了请求，不等于 B 也一定会向 A 发出请求。而且，人们不会给自己发送好友请求。 </p><p>求总共会发出多少份好友请求?</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[16,16]输出：2解释：二人可以互发好友申请。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[16,17,18]输出：2解释：好友请求可产生于 17 -> 16, 18 -> 17.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[20,30,100,110,120]输出：3解释：好友请求可产生于 110 -> 100, 120 -> 110, 120 -> 100.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= ages.length &lt;= 20000.</li><li>1 &lt;= ages[i] &lt;= 120.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>仔细观察一下这三个条件，我们把 $age[A]$ 简写为 a ，把 $age[B]$ 简写为 b ，那么如果 a 可以向 b 发送邀请的话，必须同时满足下面三个条件：</p><ul><li>$a \le 2b-15$</li><li>$a \ge b$</li><li>$a \ge 100 || b \le 100$</li></ul><p>可以发现，如果满足了条件 2 ，那么一定会满足条件 3 ，所以最终只需要满足 $b \le a \le 2b-15$ 就行了。</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>这题最暴力的方法显然就是遍历任意数对 a 和 b ，看两个数是否符合这个条件，但是时间复杂度太高，不可行。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>另一个方法是先对数组进行排序，然后遍历每一个数作为 b ，然后二分寻找 $2b-15$ 在哪就行了，中间的数字都可以作为 a ，这样最终的时间复杂度是 $O(n \log n)$ 。</p><h3 id="计数法"><a href="#计数法" class="headerlink" title="计数法"></a>计数法</h3><p>有没有更好的办法呢？注意到年龄的范围最大只有 120 ，那么我们可以统计每个年龄出现的人数，用 $c[i]$ 来表示 i 岁的人数。那么 b 岁的人数就有 $c[b]$ 个，而符合条件的 a 在 $[b, 2b-15]$ 之间。其中 $a = b$ 需要单独讨论，因为包含了自己邀请自己的情况，这种情况邀请的数量是 $c[b] \cdot (c[b] - 1)$ 。而 a 在 $[b+1, 2b-15]$ 范围内的话，数量是 $\sum_{b+1 \le a \le 2b-15}{c[b] \cdot c[a]}$ 。所以最终的总数量就是：<br>$$<br>\begin{aligned}<br>S_b &amp;= \sum_{b+1 \le a \le 2b-15}{c[b] \cdot c[a]} + c[b] \cdot (c[b] - 1)    \\<br>&amp;= c[b] \cdot (\sum_{b \le a \le 2b-15}{c[a]} - 1)<br>\end{aligned}<br>$$<br>如果用前缀和 $sum$ 来预处理 $c$ 数组的话，可以进一步简化为：<br>$$<br>S_b = c[b] \cdot (sum[2b-15] - sum[b-1] - 1)<br>$$<br>考虑到 $2b-15$ 可能会大于数组中年龄的最大值，所以我们设置一个阈值来截断它。最终的总数量就是 $\sum_{b}{S_b}$ ，这里 b 的取值范围是有讲究的。因为不等式需要满足 $b \le 2b-15$ ，所以 $b \ge 15$ 。这样最终的时间复杂度降到了 $O(MA)$ ，其中 MA 表示年龄的最大值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numFriendRequests</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ages<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> MA <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ages<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>ages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> MA<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span> b <span class="token operator">&lt;=</span> MA<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>sum<span class="token punctuation">[</span><span class="token function">min</span><span class="token punctuation">(</span>MA<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>b<span class="token number">-15</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>b<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numFriendRequests</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ages<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        MA <span class="token operator">=</span> <span class="token number">120</span>        count<span class="token punctuation">,</span> S <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>ages<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> age <span class="token keyword">in</span> ages<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>age<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> count<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>min<span class="token punctuation">(</span>MA<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>b<span class="token number">-15</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-</span> S<span class="token punctuation">[</span>b<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心有所鼠，鼠年快乐~</title>
      <link href="/2020/01/24/happy-shu-year/"/>
      <url>/2020/01/24/happy-shu-year/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><blockquote><p>首先，新的一年祝大家鼠年快乐啦。不要问我心有所鼠到底是什么意思，我心里只有学习~ 虽然这个年发生了很多事情，可能不是很好过，但是我相信一切都会过去的。我们应该微笑着面对困难，奥里给~</p></blockquote><p>今年因为武汉新型冠状病毒的传播，哪里都不敢去了呢。大家最好还是宅在家里，不要去拜年串门了。但是长辈们说了不听啊，特别是广大农村里的老人们，他们可不在意，一口一个没事，劝了也不听呢。反正我是打算好了，初一开始哪里都不去了，死宅在家里啦~</p><p><img src="4.jpg" alt="钟南山院士友情提示"></p><p>不过我还是恰了顿百人年夜饭，现在新闻都劝人别聚会，别串门，想想都有点怕，希望没事！</p><p>也不知道来吃饭的有没有武汉回来的，应该没有吧。老人特别多，抵抗力差，疾病多，希望一切安康~</p><p><img src="1.jpg" alt="村里的农家乐，还有小舞台可以K歌"></p><p><img src="2.jpg" alt="一共11桌，估摸着一百多号人，后怕！"></p><p>两个表外甥女也越长越可爱啦，也在上海读书，这次回来过年了~</p><p><img src="3.jpg" alt="卡哇伊的小妹妹"></p><p>很多武汉小伙伴都逃到上海去了，我马上也要“逃回去”了，这不票都买好了。</p><p><img src="5.jpg" alt="大年初七就溜咯"></p><p>都说大城市传染源更多，看起来更危险。而我这苏北农村，情况可能好很多，也没有太多武汉务工回来的人。但是我更相信上海的防护措施，相信上海的医疗条件，相信我们学校的封闭管理。我觉得我宿舍-实验室两点一线，死宅着应该问题不大。</p><p>现在口罩是真的难买，我爸街上药店逛了几圈才买到了10个普通医用口罩，还限购。幸亏我哥给我留了几个N95和一次性无纺布的。这下去上海的路上安心多了，希望到时候能平安到达！</p><p><img src="7.jpg" alt="今年过节不收礼，收礼只收N95"></p><p><img src="6.jpg" alt="不要问我头发哪里去了，问就是没有了"></p><p>最后在鼠年，我只有四个愿望：</p><ul><li>疫情快快好，大家都安康~</li><li>ACL 2020 accepted~</li><li>粉丝up up up~</li><li>心有所鼠~（暗示属老鼠的？）</li></ul><p>最后衷心的祝愿大家鼠年心想事成~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新年 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 376】摆动序列</title>
      <link href="/2020/01/24/leetcode-376/"/>
      <url>/2020/01/24/leetcode-376/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 [6,-3,5,-7,3] 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5,6,7,8,9]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题题面说的啰里啰唆的，其实就一句话：给你一个序列，找出最长的一个子序列，其中子序列相邻两个数的大小是波形的（也就是大小大小大等等这样的）。</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>用 dfs 枚举所有可能的子序列，然后看最长的是多少，这种方法显然会超时。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>其实看到这道题，我第一个想到了最长上升子序列，这不就变了个形式嘛，于是动态规划解法直接就有了。</p><p>用 $dp[i][s]$ 表示以 $nums[i]$ 结尾的符合条件的最长子序列长度，其中 s 取 1 表示在 $nums[i]$ 处子序列上升，取 0 表示下降。那么我们只需要遍历之前的所有 j ，如果 $nums[j] &lt; nums[i]$ ，那么在 j 处必须是要下降的，更新：<br>$$<br>dp[i][1] = \max_j{\{dp[j][0]\}}<br>$$<br>如果 $nums[j] &gt; nums[i]$ ，那么在 j 处必须是要上升的，更新：<br>$$<br>dp[i][0] = \max_j{\{dp[j][1]\}}<br>$$<br>然后取数组中最大值就是答案了，时间复杂度 $O(n^2)$ 。</p><h3 id="动态规划-时间优化"><a href="#动态规划-时间优化" class="headerlink" title="动态规划+时间优化"></a>动态规划+时间优化</h3><p>换个定义，用 $dp[i][s]$ 表示 $nums[i]$ 之前的最长子序列，注意和上面的区别就是不一定以 $nums[i]$ 结尾了。 s 取 1 表示最后两个数是上升的，取 0 表示最后两个数是下降的。</p><p>这里分为几种情况：</p><ul><li>$nums[i-1] &lt; nums[i]$ :<ul><li>考虑 $dp[i][0]$ ，也就是最后两个数下降的，那肯定不能取 $nums[i]$ ，因为 $nums[i-1]$ 比它更小、更优，所以直接更新为 $dp[i-1][0]$ 。</li><li>考虑 $dp[i][1]$ ，也就是最后两个数上升的，那如果不取 $nums[i]$ ，那更新为 $dp[i-1][1]$ ；如果取的话，我们就要保证 i-1 之前最后两个数是下降的，并且之前的最后一个数小于 $nums[i]$ 。我们可以证明， i-1 之前的最后两个下降的数一定满足：第二个数 $nums[j]$ 是小于 $nums[i]$ 的，因为如果 $nums[j] &gt;= nums[i]$ ，那么 j 到 i 之间的数一定是单调下降的，否则存在更长的子序列，那么就和 $nums[i-1] &lt; nums[i]$ 矛盾了。综上，取的话 $dp[i][1]$ 更新为 $dp[i-1][0]+1$ 。</li></ul></li><li>$nums[i-1] &gt; nums[i]$ :<br>  同样考虑最后两个数上升还是下降，分析和上面一样。</li></ul><p>综上考虑，时间复杂度可以降为 $O(n)$ ，空间复杂度是 $O(n)$ 。</p><h3 id="动态规划-空间优化"><a href="#动态规划-空间优化" class="headerlink" title="动态规划+空间优化"></a>动态规划+空间优化</h3><p>在上面优化的基础上，我们还可以观察到，每一次 $dp[i][s]$ 其实只会用到 $dp[i-1][s]$ ，所以我们只需要保存当前和前一时刻的状态就行了，空间复杂度可以降为 $O(1)$ 。</p><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>其实这题还可以直接贪心做，考虑一段连续的上升序列，最优子序列一定是包括了首尾两个数的，因为首是最小的数，选了它才能给前一个数留出更大的上升空间，而尾是最大的数，选了它才能给下一个数留出更多的下降空间。</p><p>所以我们贪心的扫描一遍数组，遇到上升或者下降的转折点就选取这个数。而如果数组不升不降，也就是不变的话，就不用管它，因为这些相同的数里面只需要选取一个就行了。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-时间优化（c-）"><a href="#动态规划-时间优化（c-）" class="headerlink" title="动态规划+时间优化（c++）"></a>动态规划+时间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化（c-）"><a href="#动态规划-空间优化（c-）" class="headerlink" title="动态规划+空间优化（c++）"></a>动态规划+空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="贪心（c-）"><a href="#贪心（c-）" class="headerlink" title="贪心（c++）"></a>贪心（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> pre_ord <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> ord <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ord <span class="token operator">!=</span> pre_ord<span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>            pre_ord <span class="token operator">=</span> ord<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>鼠年快乐，新年献给大家的第一道题，尽量写的详细一点。</p><p>官方题解没有严谨的证明，虽然方法也是这 5 种，但是没有说清楚，不能令人信服。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 943】最短超级串</title>
      <link href="/2020/01/23/leetcode-943/"/>
      <url>/2020/01/23/leetcode-943/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。</p><p>我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["alex","loves","leetcode"]输出："alexlovesleetcode"解释："alex"，"loves"，"leetcode" 的所有排列都会被接受。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["catg","ctaagt","gcta","ttca","atgcatc"]输出："gctaagttcatgcatc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 12</li><li>1 &lt;= A[i].length &lt;= 20</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>这是每日算法系列更新以来，做过最难的一道题目了，也是第一次涉及到字符串类型的题目。如果觉得难，可以忽略今天这题。</p></blockquote><p>这题意思就是，给你 n 个字符串，任意两个字符串如果拼接在一起的话，首尾可能会有重合的部分，那么就按照最长的重合部分拼接上去。要求的是 n 个字符串怎么排列，然后依次拼接，得到的最终字符串长度最短？</p><p>最暴力的方法当然就是枚举所有排列，然后把他们拼起来看长度，这样的话光是阶乘的复杂度就不可接受了。</p><p>这题就要用到<strong>状态压缩动态规划</strong>了，按照字面意思理解就是动态规划的状态是经过压缩的，那具体什么意思呢？</p><p>首先我们用二进制来表示每个字符串选取状态， 1 表示选取， 0 表示没有选取。比如 4 个字符串 ，我们选取了第 0 个和第 2 个，那么我们就可以用 1010 来表示这个选取状态，而 1010 转化成 10 进制就是 10 ，所以我们就可以用 10 这个数字来表示这种选取状态。状态最小值是 0 ，表示一个都没有选取，最大值是 $2^n-1$ ，表示所有的字符串都选取了。</p><p>然后定义 $dp[s][i]$ 表示选取状态为 s 的情况下，最后一个字符串是第 i 个的情况下，最短的长度是多少。那么去掉第 i 个字符串，选取状态就变成了 $s \oplus 2^i$ ，其中 $\oplus$ 表示异或操作。然后遍历所有的 $dp[s \oplus 2^i][j]$ ，也就是看前一个状态以哪个字符串结尾长度最短。那么状态更新就是：<br>$$<br>dp[s][i]=\min{\{dp[s \oplus 2^i][j]+A[i].length-o[j][i]\}}<br>$$<br>其中 $o[j][i]$ 表示 $A[j]$ 和 $A[i]$ 最大重合的长度，可以预处理出来。</p><p>与此同时，我们还需要一个数组 $path[s][i]$ ，用来保存 s 状态下结尾是 $A[i]$ 时，前一个字符串最优是哪个。在做完动态规划之后，再进行回溯，找出整个最优序列是什么。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">shortestSuperstring</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                o<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">overlap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> INF<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">>></span>j<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                            path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                last <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> seq <span class="token operator">=</span> <span class="token punctuation">{</span>last<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> last<span class="token punctuation">;</span>            last <span class="token operator">=</span> path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">;</span>            seq<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>            s <span class="token operator">=</span> s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>seq<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> seq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string res <span class="token operator">=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>o<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">overlap</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> na <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nb <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>na<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>na<span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">overlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>        na<span class="token punctuation">,</span> nb <span class="token operator">=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>min<span class="token punctuation">(</span>na<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> a<span class="token punctuation">[</span>na<span class="token operator">-</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">shortestSuperstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>        n<span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        M <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>n        o <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                o<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>overlap<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>INF<span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> s <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i <span class="token operator">!=</span> j <span class="token operator">and</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">>></span>j<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>len<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                            dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>len<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>                            path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j        last <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">:</span>                last <span class="token operator">=</span> i        seq <span class="token operator">=</span> <span class="token punctuation">[</span>last<span class="token punctuation">]</span>        s <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> last            last <span class="token operator">=</span> path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span>            seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>last<span class="token punctuation">)</span>            s <span class="token operator">=</span> s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">)</span>        seq <span class="token operator">=</span> seq<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>o<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还是有点难度的，我还是看了答案后才自己写出来的，如果实在不会，不要勉强。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 881】救生艇</title>
      <link href="/2020/01/22/leetcode-881/"/>
      <url>/2020/01/22/leetcode-881/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：people = [1,2], limit = 3输出：1解释：1 艘船载 (1, 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：people = [3,2,2,1], limit = 3输出：3解释：3 艘船分别载 (1, 2), (2) 和 (3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：people = [3,5,3,4], limit = 5输出：4解释：4 艘船分别载 (3), (3), (4), (5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题第一直觉就是，对于一个人 people[i] 来说，装了他之后船上还剩 limit-people[i] 的空间，所以第二个人要尽量装能装得下的人中最重的那个。</p><p>那如果直接这么遍历显然不行，时间复杂度是 $O(n^2)$ 的。所以我们先对重量进行排序，然后从最轻的人开始看，如果他能和最重的坐一个船，那就去掉他们俩，在剩下的人里继续找；如果不能的话，那么最重的人只能单独坐船，然后看能不能和第二重的人坐一个船，依次下去。</p><p>具体实现上，只需要用两个指针，一个指着最小的数，一个指着最大的数就行了，时间复杂度是 $O(n)$ ，但是由于还得调用一次快速排序，所以最终时间复杂度是 $O(n \log n)$ 。</p><p>当然，因为这题重量范围比较小，所以如果采用计数排序，可以进一步降低时间复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="双指针（c-）"><a href="#双指针（c-）" class="headerlink" title="双指针（c++）"></a>双指针（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> people<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> people<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>people<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> people<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双指针（python）"><a href="#双指针（python）" class="headerlink" title="双指针（python）"></a>双指针（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        people<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>people<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> people<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> people<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序（c-）"><a href="#计数排序（c-）" class="headerlink" title="计数排序（c++）"></a>计数排序（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> people<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>limit<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> limit<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sp<span class="token punctuation">[</span>count<span class="token punctuation">[</span>people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token punctuation">[</span>people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sp<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> sp<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序（python）"><a href="#计数排序（python）" class="headerlink" title="计数排序（python）"></a>计数排序（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        sp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>people<span class="token punctuation">)</span>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>limit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> people<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> limit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> people<span class="token punctuation">:</span>            sp<span class="token punctuation">[</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        res<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>people<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> sp<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> sp<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题注意写循环的时候也有技巧的，我们实现的时候，对于最大值 people[r] ，先给他分配一条船，再看最小的人能否和他一条船，如果可以，那就顺便带上（ l 加 1 ），如果不可以的话，那就 r 减 1 ，继续看下一个更重的人。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 829】连续整数求和</title>
      <link href="/2020/01/21/leetcode-829/"/>
      <url>/2020/01/21/leetcode-829/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 N ，试求有多少组连续正整数满足所有数字之和为 N ?</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：5输出：2解释：5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：9输出：3解释：9 = 9 = 4 + 5 = 2 + 3 + 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：15输出：4解释：15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= N &lt;= 10^9</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道非常经典的数学题，挺基础的，不知道为什么这也能算困难难度的题目？</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>遍历所有的连续数字区间 (i, j) ，然后求和看等不等于 N 。这种方法时间复杂度是 $O(n^2)$ ，显然不可行。</p><h3 id="暴力法优化"><a href="#暴力法优化" class="headerlink" title="暴力法优化"></a>暴力法优化</h3><p>遍历所有的连续数字区间的左端点 i。然后假设区间长度为 n ，那么根据求和公式有 (2i+n-1)n/2=N ，然后只需要看这个方程的解是否是整数就行。时间复杂度可以降到 $O(n)$ ，但还是太高了。</p><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>根据上面的求和公式，对于起点 i 和长度 n ，求和得到 (2i+n-1)n/2=N 。我们可以先粗略推算一下 i 和 n 的范围，起点 i 的范围是 [1, N]毋庸置疑，而区间长度 n 的范围就可以考究一下了，一个出发点是：上面式子可以解出 i=(N-n(n-1)/2)/n ，而 i&gt;=1 ，可以解出 (n+1)n&lt;=2N ，所以 n 的范围其实只有根号 N 级别，可以直接遍历。另一个出发点是最小的 n 个数加起来就是 1 加到 n 等于 n(n+1)/2 ，这个要小于等于 N ，解出来也是 (n+1)n&lt;=2N 。</p><p>所以我们只需要从 1 开始遍历 n ，直到 (n+1)n&gt;2N 为止，然后判断 (N-n(n-1)/2)/n 是否是整数就行了（前面终止条件可以保证 i 一定大于 0 ）。</p><p>最终时间复杂度降到了 $O(\sqrt(N))$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="数学方法（c-）"><a href="#数学方法（c-）" class="headerlink" title="数学方法（c++）"></a>数学方法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">consecutiveNumbersSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>N <span class="token operator">-</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学方法（python）"><a href="#数学方法（python）" class="headerlink" title="数学方法（python）"></a>数学方法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">consecutiveNumbersSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">*</span> N<span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">-</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还可以用质因数分解等方法进一步优化，但是没有必要。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 907】子数组的最小值之和</title>
      <link href="/2020/01/20/leetcode-907/"/>
      <url>/2020/01/20/leetcode-907/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p><p>由于答案可能很大，因此返回答案模 10^9 + 7。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 30000</li><li>1 &lt;= A[i] &lt;= 30000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题意思是，遍历所有的连续子数组，然后求所有子数组中最小值之和。</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>遍历所有区间，然后对于每个区间找出最小值求和。这种方法时间复杂度是 $O(n^3)$ ，显然不可行。</p><h3 id="暴力法优化"><a href="#暴力法优化" class="headerlink" title="暴力法优化"></a>暴力法优化</h3><p>对于区间左端点 i ，遍历所有的右端点 j ，然后维护最小值，时间复杂度可以降到 $O(n^2)$ ，但还是太高了。</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>既然我们不能先遍历区间，然后找最小值，那么我们不如顺序倒过来，对于每个值，我们找有多少区间里面，它是最小值。</p><p>对于一个数字 A[i] 来说，如果在某个区间 [j, k] 里面它是最小值，那么 [j, k] 包含 A[i] 的子数组的最小值也一定是 A[i] 。所以我们只需要找出最大的那个区间，使得 A[i] 是最小值就行了。</p><p>另一个性质是，左右端点 j 和 k 是相互独立的，不会影响，因为 [i, k] 的改变并不会改变 [j, i] 的最小值。所以我们只需要分别求出 A[i] 往左和往右的最远距离就行了。</p><p>因为往左和往右求解方法是类似的，所以我们只需要看一个方向就行了。同样不能遍历一遍，不然就和暴力法没区别了嘛。这时候就要介绍神器了——<strong>单调栈</strong>。</p><p>单调栈是一个栈，后进先出，里面的元素是单调递增或递减的。而在这题里面，我们要求的是 A[i] 左边最远的距离，等价于求左边第一个比它小的数字 A[j] 。而 A[j+1], …, A[i] 都大于等于 A[i] ，所以都可以作为符合要求区间的左端点。</p><p>这里单调栈只需要维护一个单调上升的子序列就行了，遍历到一个数 A[i] 的时候，如果栈顶的元素大于等于 A[i] ，那么就出栈，直到第一个小于 A[i] 的数 A[j] 为止，那么 A[i] 为最小值的区间左端点可选择数量为 j - i。为什么这样是对的呢？因为 A[j] 是栈里面第一个小于 A[i] 的数，而 A[j] 后面的数都大于 A[j] ，这样才不会把 A[j] 顶出栈。而如果栈是空的，就说明 A[i] 前面的所有元素都大于等于它，那么所有区间都符合条件了。</p><p>而右边最大的范围同理可以求得，但是这里有个需要注意的地方！如果存在两个相同的数，这么算不是会导致同一个区间在两个数的位置处计算两次吗？所以要稍稍改进一下，既然向左计算的时候，已经包含了相等的值了，那么向右计算就要排除掉了。也就是从右往左计算右边最远范围的时候，只能计算右边第一个小于等于它的位置，而向左是计算第一个小于它的位置。这样就不会重复计算了。</p><h3 id="单调栈-动态规划"><a href="#单调栈-动态规划" class="headerlink" title="单调栈+动态规划"></a>单调栈+动态规划</h3><p>上面的方法不仅要考虑两端的范围，还得考虑去重，真是麻烦又容易写错。下面介绍一种更加好写又不容易写错的方法，只是不那么容易想到。</p><p>我们定义 sum[i] 为所有以 i 为右端点的区间的最小值之和，同样用单调队列的方法来寻找左边最远的距离，使得区间内 A[i] 是最小值。假设用单调队列找到了左边第一个比 A[i] 小的数是 A[j] ，那么 sum[i] 就可以加上 (i - j) * A[i] ，因为 A[j] 往右都是 A[i] 最小。而 A[j] 再往左呢？这些区间最小值等价于直接以 A[j] 为右端点的最小值，因为 A[j] 往右的数都比它大，没有影响，所以 sum[i] 再加上 sum[j] 就行了。</p><p>上面两种方法时间复杂度都是 $O(n)$ 的，因为进栈出栈最多也只需要 2n 次。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单调栈（c-）"><a href="#单调栈（c-）" class="headerlink" title="单调栈（c++）"></a>单调栈（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nxt</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp<span class="token punctuation">,</span> sn<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> sp<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> i <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sn<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>sn<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> sn<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sn<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> n <span class="token operator">-</span> i <span class="token operator">:</span> sn<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>            sn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈（python）"><a href="#单调栈（python）" class="headerlink" title="单调栈（python）"></a>单调栈（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        pre <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        nxt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        sp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        sn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                sp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> i <span class="token operator">-</span> sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            sp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>sn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>sn<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                sn<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">-</span> i <span class="token keyword">if</span> len<span class="token punctuation">(</span>sn<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> sn<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> i            sn<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        res <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD        <span class="token keyword">return</span> int<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈-动态规划（c-）"><a href="#单调栈-动态规划（c-）" class="headerlink" title="单调栈+动态规划（c++）"></a>单调栈+动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> sp<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span>  A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>            sp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>res <span class="token operator">+</span><span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈-动态规划（python）"><a href="#单调栈-动态规划（python）" class="headerlink" title="单调栈+动态规划（python）"></a>单调栈+动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        summ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        sp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                sp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            summ<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> summ<span class="token punctuation">[</span>sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            sp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        res <span class="token operator">=</span> sum<span class="token punctuation">(</span>summ<span class="token punctuation">)</span> <span class="token operator">%</span> MOD        <span class="token keyword">return</span> int<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题虽然是个中等难度的题，但是还是比一些难题难做一些的，通过这题主要去学会单调栈的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 875】爱吃香蕉的珂珂</title>
      <link href="/2020/01/19/leetcode-875/"/>
      <url>/2020/01/19/leetcode-875/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：piles = [3,6,7,11], H = 8输出：4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：piles = [30,11,23,4,20], H = 5输出：30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：piles = [30,11,23,4,20], H = 6输出：23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= piles.length &lt;= 10^4</li><li>piles.length &lt;= H &lt;= 10^9</li><li>1 &lt;= piles[i] &lt;= 10^9</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>简单复述一下题意，就是有 N 堆香蕉，每堆有 piles[i] 个，现在要求一个整数速度 K ，吃一堆香蕉要的时间是 piles[i] / K （不是整数要上取整），问使得吃完所有香蕉所需总时间小于等于 H 的最小速度 K 是多少？</p><p>显然 K 越小，吃每堆香蕉所需要的时间就越长，总时间也就越长，那么自然而然可以想到二分答案 K 。</p><p>对于当前的 K ，我们遍历数组，算出总时间，如果总时间大于 H ，那就说明 K 太小了，还得提速；如果总时间小于等于 H ，那就说明速度 K 还可以降一点，总时间可能不变（因为存在上取整），也可能变大。</p><p>这样最终的时间复杂度仅仅只有 $O(n \log \mathcal{M})$ ，其中 $\mathcal{M}$ 是数组中的最大值，也就是二分上界。但其实这里还可以优化一下二分的上下界，比如上界，最大其实就是数组中的最大元素大小， K 再大也没有意义了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minEatingSpeed</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> piles<span class="token punctuation">,</span> <span class="token keyword">int</span> H<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>piles<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> piles<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> piles<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> maxv<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> l<span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> H<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minEatingSpeed</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> piles<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> H<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        maxv <span class="token operator">=</span> max<span class="token punctuation">(</span>piles<span class="token punctuation">)</span>        l <span class="token operator">=</span> <span class="token number">1</span>        r <span class="token operator">=</span> maxv        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> l            cnt <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> p <span class="token keyword">in</span> piles<span class="token punctuation">:</span>                cnt <span class="token operator">+=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> m            <span class="token keyword">if</span> cnt <span class="token operator">></span> H<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>注意上面的代码还是有几个小细节的：</p><ul><li>二分终止条件设置的是 $l &gt;= r$ ，所以 $l$ 的更新必须是 $l = m + 1$ ，因为如果 $l = r - 1$ 的话，$m$ 会等于 $l$ 。</li><li>为了防止整型溢出，计算 $l$ 和 $r$ 均值的时候不要写 $(l + r) / 2$ 。</li><li>上取整简单写法就是 $(p + m - 1) / m$ 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 470】用 Rand7() 实现 Rand10()</title>
      <link href="/2020/01/18/leetcode-470/"/>
      <url>/2020/01/18/leetcode-470/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。</p><p>不要使用系统的 Math.random() 方法。</p><p><strong>思考</strong></p><ul><li>rand7()调用次数的 期望值 是多少 ?</li><li>你能否尽量少调用 rand7() ?</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>刚看到这题觉得挺有意思的，再看一脸懵逼，这怎么做？后来看了题解才懂了，原来是这个意思。</p><p>题目要求只能给你用 rand7 函数，也就是均匀生成 1 到 7 之间的整数。但是现在要求你生成 1 到 10 之间的整数，那么肯定只生成一次是不够的，因为状态数都不够嘛，那就生成多次看看。</p><p>如果生成两次，那么就得到了两个 1 到 7 之间的整数，然后怎么转换为 1 到 10 呢。如果这两个数两两组合，那么可以得到 49 种状态，可以用来表示 1 到 49 这 49 个数字，如果想要让 1 到 10 均匀分布，那么每个数字最多只能分配 4 次。具体分配情况如下所示：</p><pre class="line-numbers language-text"><code class="language-text">1  2  3  4  5  6  78  9  10 1  2  3  45  6  7  8  9  10 12  3  4  5  6  7  89  10 1  2  3  4  56  7  8  9  10 .  ..  .  .  .  .  .  .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：每行下标代表第一个随机数 1 到 7 （r1 表示），每列下标代表第二个随机数 1 到 7 （r2 表示）。而转换后的随机数可以表示为 $(7 (r1 - 1) + r2 - 1) % 10 + 1$ ，注意到最后 9 个数没有用到，因为它们不足以表示 1 到 10 这 10 个数，如果表示了概率就不等了。</p><p>那么如果根据上面式子算出来落在了最后 9 个数范围内怎么办呢？这时候我们就拒绝它，重新生成两个数就行了，直到落在前 40 个数范围里。这种方法的期望采样次数是多少呢？<br>$$<br>    \begin{aligned}<br>        E &amp;= 2 + 2 \cdot \frac{9}{49} + 2 \cdot (\frac{9}{49})^2 + \cdots \<br>        &amp;= 2 \sum_{n=0}^{\infty}{(\frac{9}{49})^n} \<br>        &amp;= 2 \cdot \frac{1}{1-\frac{9}{49}} \<br>        &amp;=2.45<br>    \end{aligned}<br>$$</p><p>所以平均只需要 2.45 次就可以均匀的采样到 1 到 10 之间的整数啦。那么这背后的数学原理是什么呢？其实就是<strong>拒绝采样</strong>。</p><p>蒙特卡洛方法大家应该都很熟悉了，就是采样来求分布，比如求一个直径为 1 的圆的概率，我们可以用一个边长为 1 的正方形包住它，然后随机往里面扔豆子，扔 10000 个，看最后有多少落在了圆里面，那么除以 10000 就是圆的面积了。</p><p>而拒绝采样跟这类似，就是一个分布 $p(x)$ 形式比较复杂，累积分布函数不好求，所以不好采样。那么我们可以用一个标准分布 $q(x)$ 来近似它，并且用系数 $k$ 来控制 $q(x)$ 的大小，使得 $k \cdot q(x) \ge p(x)$ ，这就类似于上面的用正方形包住了圆形嘛。 然后 $q(x)$ 是好采样的嘛，所以根据 $q(x)$ 采样出一个 $x’$ ，然后再在 0 到 $k \cdot q(x’)$ 之间采样一个数 $t$，如果 $t$ 落在了 0 到 $p(x’)$ 之间，那就接受这个采样，否则就拒绝它，重新采样。这种方法采出来的 $x’$ 是服从分布 $p(x)$ 的，因为你采样得到 $x’$ 的概率是 $q(x’)$ ，而接受的概率是 $\frac{p(x’)}{k \cdot q(x’)}$ ，所以最终接受 $x’$ 的概率就是 $\frac{p(x’)}{k}$ 。因此 $k$ 要设置的尽量小，这样接受的概率才大，期望的采样次数才少。但是又不能设置太小，因为要满足 $k \cdot q(x) \ge p(x)$ 的前提条件才行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// The rand7() API is already defined for you.</span><span class="token comment" spellcheck="true">// int rand7();</span><span class="token comment" spellcheck="true">// @return a random integer in the range 1 to 7</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> num<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            r1 <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r2 <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            num <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">+</span> r2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题题目虽简单，背后的思想还是很有意思的，拒绝采样可以用在深度学习中的很多应用场景里，特别是你的分布很难进行采样的时候，就可以用拒绝采样来模拟。</p><p>当然这题还有其他采样方法可以缩小期望采样次数，比如如何利用这 9 个被拒绝的点呢？留给大家思考（其实是我懒得写了）。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 827】最大人工岛</title>
      <link href="/2020/01/17/leetcode-827/"/>
      <url>/2020/01/17/leetcode-827/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维地图上， 0 代表海洋， 1 代表陆地，我们最多只能将一格 0 海洋变成 1 变成陆地。</p><p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1, 0], [0, 1]]输出：3解释：将一格 0 变成 1 ，最终连通两个小岛得到面积为 3 的岛屿。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1, 1], [1, 0]]输出：4解释：将一格 0 变成 1 ，岛屿的面积扩大为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1, 1], [1, 1]]输出：4解释：没有 0 可以让我们变成 1 ，面积依然为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= grid.length = grid[0].length &lt;= 50</li><li>0 &lt;= grid[i][j] &lt;= 1</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>没有做过这种类型题目的强烈建议自己动手实现一遍，对提升代码能力有很大帮助。</strong></p><p>这题虽然是 hard 难度，但其实没有什么算法，只用到了 dfs 求连通块而已。我们只需要知道填充了一个 0 之后，它上下左右跟它相邻的 4 块连通块是多大。</p><p>首先普及一下什么是连通块，就是一块由 1 组成的区域，其中任意两块 1 都可以由一条 1 组成的路径走过去（只能上下左右走）。那么这题我们遍历所有的 0 ，把它四周的连通块大小加起来就是填充了这块 0 之后的连通块大小了。那么问题是怎么知道它周围连通块的大小呢？</p><p>首先我们得求出所有连通块的大小，然后存下来，这就得用到 dfs 了。</p><p>用二维数组 index （初始化为 -1）记录方块是否被搜索过。然后遍历所有的方块，如果是 1 ，并且 index 为 -1 （也就是没被搜索过），那么它的 index 设为 1 ，表示被搜索过了。然后从它开始向四周进行 dfs ，直到跟它相连的所有 1 的连通块都被搜索完毕。这时候整块连通块里面的 1 方块的 index 都被设成了 1 ，就算以后被遍历到了也不会被搜索了。那么大小怎么记录呢？只需要设置一个变量 cnt 初始为 1 ，然后 dfs 的时候遇到一个未被搜索的块就加 1 ，最后 cnt 就是当前连通块的大小了。</p><p>光知道了每个连通块的大小还不行，对于一个 0 块，四周的 1 方块万一属于同一个连通块怎么办？得区分它们，不然就会被重复计算。所以在上面的 dfs 之前，给那块连通块一个唯一的编号（从 0 开始），遇到下一个连通块就加 1 。这样 index 数组就可以用来存连通块的编号了，同时还能表示方块是否被搜索过。</p><p>具体的细节还得看代码，有很多实现的技巧，当然我写的还有一些优化余地。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> area<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">largestIsland</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>area<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> index<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    index<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                    area<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                            tmp <span class="token operator">+</span><span class="token operator">=</span> area<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> cnt<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> <span class="token operator">++</span>cnt<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>dfs 求连通块是常规操作，必须要学会，很考验代码功底，要细心，不然很容易写错。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 354】俄罗斯套娃信封问题</title>
      <link href="/2020/01/16/leetcode-354/"/>
      <url>/2020/01/16/leetcode-354/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>说明:</strong><br>不允许旋转信封。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目要求矩形一个套着一个，然后求出最多套多少个，而一个矩形能套在另一个矩形上面的条件是长宽都大于另一个。</p><p>那么我们可以按照长度从小到大排个序，这样只有排在后面的矩形可以套在前面的矩形上。但是宽度也有限制条件，也得大于前面的矩形，那么问题就转化成了，把宽度看成一个序列，找到一个最长的上升序列，序列的长度就是我们要的答案。但是这里有个问题，就是矩形如果是相同长度，它们的宽度按照什么来排序呢？如果也是从小到大排，那么可能会出现多个相同长度的矩形套在一起，这是不符合题意的。所以我们对相同长度的矩形采取宽度降序的方法排序，这样它们之中最多只会被选中一个了。</p><p>那么问题就变成了经典的<strong>最长上升子序列问题了</strong>。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>用 dp[i] 表示以第 i 个元素 a[i] 结尾的最长子序列的长度，那么我们可以遍历所有 a[i] 之前的元素 a[j] ，如果 a[j] 小于 a[i] ，那就说明 a[i] 可以加在 a[j] 后面，然后长度就变成了 dp[j] + 1 。所以遍历所有符合条件的 j ，找到长度最长的，然后更新 dp[i] = dp[j] + 1 。最后的答案就是 dp 数组中最大的值。</p><p>这种方法时间复杂度是 $O(n^2)$，如果序列太长会超时。本题中 c++ 没有超时，但是 python 超时了。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>那么有什么方法来优化呢？下面介绍一种二分优化方法。</p><p>这次假设 dp[len] 表示长度为 len 的上升子序列最后一个元素的最小值。这个值要尽量小，什么意思呢？也就是相同长度的上升序列，最后一个元素小的那个序列，后面可以加的元素可选择余地肯定更大。那么这个数组怎么更新呢？</p><p>初始的时候 len 就是 0 ，因为没有找到任何上升子序列。如果现在找到了长度为 len 的子序列，然后最后一个元素最小值是 dp[len] ，这时候来了一个新元素 a[i] ，如果它比 dp[len] 大，说明 a[i] 可以加在 dp[len] 后面，那么 len 就变成了 len + 1 ， 并且 dp[len + 1] 更新为 a[i]。那如果 a[i] 小于等于 dp[len] 呢？那就继续往前遍历，找到第一个 dp[l] &lt; a[i] &lt;= dp[l+1] 的位置，这个位置说明了什么呢？说明了 a[i] 可以加在 dp[l] 后面构成长度为 l + 1 的子序列，并且 dp[l+1] 可以变得更小，所以更新为 a[i] 。这样 a[i] 就处理完了，最后 len 就是答案。</p><p>但是这样看起来复杂度没有变啊，其实这里有一个很好的性质，因为长度越大的序列，最后一个元素的最小值一定是大于长度小的序列最后一个元素的，所以 dp 数组是单调递增的，这样我们就可以用二分来寻找 a[i] 适合插入的位置。时间复杂度降到了 $O(n\log n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1（c-）"><a href="#方法1（c-）" class="headerlink" title="方法1（c++）"></a>方法1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> envelopes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>envelopes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法1（python）"><a href="#方法1（python）" class="headerlink" title="方法1（python）"></a>方法1（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        arr<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（c-）"><a href="#方法2（c-）" class="headerlink" title="方法2（c++）"></a>方法2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> envelopes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            len <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（python）"><a href="#方法2（python）" class="headerlink" title="方法2（python）"></a>方法2（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> bisect <span class="token keyword">import</span> bisect_left<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        arr<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">=</span> bisect_left<span class="token punctuation">(</span>dp<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> idx <span class="token operator">==</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还有智障解法：就是两两遍历每一个矩形对，根据包含关系建立一个拓扑图，然后求图上的最长距离。没错，我刚开始就是这么想的，我是智障。这个方法没有错，还真能过这题，就是时间太慢了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1031】两个非重叠子数组的最大和</title>
      <link href="/2020/01/15/leetcode-1031/"/>
      <url>/2020/01/15/leetcode-1031/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2输出：20解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2输出：29解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3输出：31解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>L &gt;= 1</li><li>M &gt;= 1</li><li>L + M &lt;= A.length &lt;= 1000</li><li>0 &lt;= A[i] &lt;= 1000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题意思就是找到两段给定长度的、不重合的、连续的区间，使得两段区间和最大。</p><p>因为长度是给定的，所以我们只需要预处理好前缀和 sum ，然后给定区间右端点，就可以直接算出区间和。<br>那么如果枚举两段区间的右端点，时间复杂度也才 $O(n^2)$ ，极限情况下也就 1e6 左右，貌似也还可以接受。</p><p>那有没有更快的方法呢？试试动态规划！因为两段区间有前后顺序，我们不妨假设长度为 L 的区间在后面。<br>用 dpm[i] 表示前 i 个数中长度为 M 的区间和的最大值。<br>那么 dpm[i] = max{dpm[i-1], sum[i] - sum[i-M]} ，也就是要么取最后 M 个数，要么最后一个数不取，在前 i - 1 个数里面找答案。<br>然后 dpm 全部处理完之后，遍历数组，假设长度为 L 的区间以 A[i] 结束，那么我们只需要在 A[0] 到 A[i-L] 中间找长度为 M 的区间最大和就行了，那答案不就是上面求好的 dpm[i-L] 吗？这样最终时间复杂度就是 $O(n)$ 了。</p><p>结束了吗？并没有！空间还能不能优化呢？其实当我们遍历长度为 L 的区间时，长度为 M 的区间不用每次都重新遍历，可以重复利用之前的结果，每次向右移动直到和长度为 L 的区间衔接上为止。这样就等于用了两个指针，分别指向了两个区间的右端点，总共最多移动 2n 次就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dpl<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> dpm<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dpl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dpl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dpm<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dpm<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dpl<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span>        dpm<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dpl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dpm<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">+</span> dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（python）"><a href="#动态规划（python）" class="headerlink" title="动态规划（python）"></a>动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">:</span> int<span class="token punctuation">,</span> M<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        N <span class="token operator">=</span> <span class="token number">1010</span>        dpl <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        dpm <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        dpl<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>L<span class="token punctuation">]</span>        dpm<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>M<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> L<span class="token punctuation">:</span>                dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dpl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> M<span class="token punctuation">:</span>                dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dpm<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">+</span> dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针法（c-）"><a href="#指针法（c-）" class="headerlink" title="指针法（c++）"></a>指针法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token operator">+</span>M<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            lmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>lmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>mmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> lmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> mmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针法（python）"><a href="#指针法（python）" class="headerlink" title="指针法（python）"></a>指针法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">:</span> int<span class="token punctuation">,</span> M<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        N <span class="token operator">=</span> <span class="token number">1010</span>        sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        lmax <span class="token operator">=</span> mmax <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>L<span class="token operator">+</span>M<span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            lmax <span class="token operator">=</span> max<span class="token punctuation">(</span>lmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>            mmax <span class="token operator">=</span> max<span class="token punctuation">(</span>mmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> lmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> mmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>思考问题要从简单往困难思考，先想想暴力怎么做？再想想怎么优化它。就算做出来了，也不要拘泥于一种解法，还有代码上能否优化？变量、写法上能否更优美一点？</p><p>当然很熟练了之后这些都不用考虑了，上来像我一样直接一步到位就行了，嘻嘻。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 330】按要求补齐数组</title>
      <link href="/2020/01/15/leetcode-330/"/>
      <url>/2020/01/15/leetcode-330/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,3], n = 6输出：1解释：根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。所以我们最少需要添加一个数字。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,5,10], n = 20输出：2解释：我们需要添加 [2, 4]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,2,2], n = 5输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先这题没有说数据范围，根据正解的时间复杂度，推测出 nums.length 的大小在 1e5 左右，而 n 的大小在 int 的最大值左右。</p><p>而不考虑数据范围，我刚开始的想法是，首先考虑简化问题：<strong>用 nums 数组中的数字可以表示出多少个不同的正整数？</strong><br>这可以用动态规划来解决，令 dp[S][i] 表示用前 i 个数凑出和 S 是否可行，那么状态转移方程就是： dp[S][i] = dp[S-nums[i]][i-1] || dp[S][i-1] 。<br>然后遍历 dp[i][nums.length-1] ，如果发现等于 0 ，就说明 nums 数组无法凑出 i 这个和，于是新增加一个数 i ，并且将 [i, 2i)中的所有 dp 值都改成 1，直到 [1, n] 全部被覆盖了。<br>后来看了才发现，我弱智了，这样不仅没必要，而且 n 太大会炸裂。</p><p>正解很简单。首先题目中有个词“已排序”，其实不是很重要，没排序的话我排个序也不怎么耗时间。那排完序怎么办呢，思路还是刚刚的思路，只是不用动态规划了。</p><p>试想从最小的 1 开始，如果 1 不在数组里，那一定要补上一个 1 的，然后 [1, 2) 范围里的数都可以被表示出来了。然后看下一个数，如果大于 2 ，那么 2 是没有办法通过数组里的数表示出来的，因为比它小的数只能凑出 [1, 2) ，所以 2 也要补上。如果下一个数小于等于 2 ，那么我们可以利用目前的数凑出 [1, 4) 里面的数，然后继续往下遍历，直到能够凑出 [1, n+1) 里面的数。</p><p>一般情况下，如果遍历到 nums[i-1] 时，可以表示出 [1, S) 范围内的数，那么如果 nums[i] &gt; S ，那么需要补上 S ，并且可表示范围更新为 [1, 2S)，然后继续看 nums[i] ；否则的话可表示范围更新为 [1, S+nums[i]) ，然后看 nums[i+1] 就行了。</p><p>这样就比原来的思路简化了很多了，那么时间复杂度怎么样呢？<br>因为 S 每次更新有两种情况，要么乘以 2 ，要么加上了 nums[i] ，所以最终时间复杂度是 $O(m + \log n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPatches</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>                r <span class="token operator">+</span><span class="token operator">=</span> r<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minPatches</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        idx <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> idx <span class="token operator">&lt;</span> length <span class="token operator">and</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>                r <span class="token operator">+=</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>                idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> r        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5W2H | 关于写博客的七点反思</title>
      <link href="/2020/01/14/5w2h-godweiyang/"/>
      <url>/2020/01/14/5w2h-godweiyang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h2><p>第一次写博客是 2015 年了，在 CSDN 和博客园上面，当时写文章是为了记录 ACM 竞赛的题解，陆陆续续写了几十篇。但是最后还是没有坚持下去，主要还是因为 CSDN 和博客园的体验太差了，写起文章来很难受，又丑又慢。另一个原因是， CSDN 发个文章还需要审核，定制主题自由度也太差。</p><p>第二次就是 2017 年暑假了，当时自己建了个人博客，域名是：<a href="https://godweiyang.com/">godweiyang.com</a>。当时的想法是，个人博客好好看，有各种主题，如果会点前端知识，还能自己魔改。个人博客主要更新的就是自然语言处理的知识了，主要都是些论文的阅读赏析。另外还更新一些计算机相关的基础知识，主要考虑到绝大多数人并不会对枯燥又专业的自然语言处理感兴趣。算法题解的话最近也开始更新起来了，主要写一些 LeetCode上面的题解。</p><p>最后就是知乎专栏和微信公众号了，这两个平台是最近才搞的，主要把个人博客的文章同步更新过去，内容都差不多。微信公众号本来不想搞的，不支持 markdown ，写起来挺麻烦的。但是考虑到以后的发展，以及可能会有一些变现的操作，还是重操旧业了（其实我公众号两年前就注册过了，只是一直没有更新）。</p><h2 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h2><p>其实刚开始写博客，主要还是为了记录自己平时学到的一些东西，以后可能还能翻出来复习复习。但是现在看来，基本不会再去翻以前写的东西了。</p><p>另一个目的，也是我写博客最主要的目的，还是想分享我知道的一些东西，能够让更多的人因此受益。因为写博客，其实还是认识了不少天南地北的朋友的，有各个高校甚至初高中的学生，也有工作了很多年想学习学习编程的，也有国外一些名校的学生。不管是谁，我觉得都可以扩展我的人脉，现在微信好友人数上限扩展到了 5000 人了，而我才用了十分之一多一点，什么时候能达到上限也算是圆满了。</p><p>最后，有句话叫做：“不以盈利为目的的博客最后都死亡了”。因为如果不能因此获得任何的收入的话，极少有人有这个毅力坚持更新博客。虽然我也想因此获利，但是暂时我并不想因此改变了初衷，去写一些刻意迎合大众的水文，从而获得粉丝。</p><h2 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h2><p>主要都是与我相关的一些计算机相关知识。最主要的就是深度学习和自然语言处理了，但是因为我是做句法分析的，这个方向受众比较小，如果纯粹写这个方向的内容的话，看的人可能会很少。而如果写深度学习和自然语言处理的入门普及或者综合一点热门一点的方向的话，看得人应该会很多。但是这样又有一个弊端，非常的浪费我时间，因为过于基础的知识对我的提升微乎其微，只适合以后我面试前看看补补基础。而主要我现在重心还在发论文，继续搞学术，所以只能写一些结合我最近所学知识的文章。</p><p>还会写一些算法题解，现在主要在做 LeetCode 上面的中等和困难题目，然后每日一更。尽管网上各种 LeetCode 的题解已经太多了，但是我觉得，大多数的题解都非常的模糊，讲解的很不清楚，抄来抄去的有什么意思？而他们的代码风格，更是让我看不下去，最基本的美观都做不到，代码的简洁精炼就更不用谈了。所以我的目的还是尽量用美观精炼的代码来让更多人的算法思想和代码能力得到提升。</p><p>偶尔，我还会分享一些计算机基础知识，比如怎么搭博客（这是我阅读量最高的一篇博客了）、好用的软件、常用的一些软件的安装配置等等。其实讲道理，我是不愿意写这一类文章的，因为非常的费时费力，需要自己动手模拟一遍，确保能够正确完成才能写进文章。不然就会像很多网上的教程那样，抄来抄去一堆错误，根本没有自己动手实践过。但是这种文章其实对很多人帮助还挺大的，大家也乐意去看，如果你在知乎发的话，你会发现这类文章收藏量都挺高的。如果我以后用空了，我还是会经常把我平时的一些经验分享给大家的，比如 LaTeX 常用写作技巧之类的。</p><p>那么其他火的博客都写些什么呢？我觉得当代人闲暇时候、上厕所刷手机的时候，那些碎片时间是没办法好好学习一些知识的，最爱看的还是有趣的故事，例如 99 行代码做出冰雪奇缘特效、程序员脱发、程序员单身狗啦之类的。这些故事背后的技术可能是很深奥的，但是大多数人并不会去关心，只是会看完惊叹一句“卧槽”而已。其他的吸引人的内容还有资料下载、课程学习（当然基本都是广告）等等。不过我个人目前并不想写这些东西，首先这些新闻类的文章很多地方都有了，写来写去就那么些东西，同质化严重。而资料下载确实是个不错的主意，可以分享好东西给大家，但是我个人最近也没有太多值得珍藏的好资料，况且大多数网上都有现成的，我不赞同为了增加粉丝而不放出链接，把资料放在公众号后台的行为。</p><p>总之，不忘初心，粉丝什么的随缘吧。我非常佛系，即使没人看我也会日常更新，就当记日记不是吗？</p><h2 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h2><p>大多数看我博客的都是自然语言处理相关的学生。就拿我在知乎专栏的粉丝来看，大多数人是来看我的论文赏析的，而少部分人是看到了那篇博客搭建教程来的。至于算法题解，貌似并没有很多人看，可能这一类文章网上实在是太多了，没有什么独特的吸引力。而公众号粉丝，目前为止还很少，绝大多数还都是好友粉丝。主要原因还是公众号太封闭了，很难让好友之外的人知道并且关注你。一个方法可以在知乎等平台引流，但是现在这属于违规操作，最好还是不要干了。</p><p>其实我目标的受众群体还是包括但不仅限于计算机系的学生，像一些计算机基础知识，就算你是个小白，也可以从这里学到很多东西。甚至还有很多考研的学生来咨询我问题，虽然我是保研的，但是很多导师选取、学习方面的问题我还是愿意给出我自己的建议的。我这个人向来喜欢分享，也喜欢倾听，如果别人来问我问题，我基本是会耐心回答的。曾经有啥都不会的小白来问我怎么搭建博客，我得从最基本的命令行教他，讲道理这其实很烦，我都不想教，但我还是会尽量把关键点都告诉他。有人会觉得，我这样最后会得到什么呢？是的，也不赚钱，最多偶尔有些朋友会打赏个红包，我还浪费了大把时间（其实还好，白天工作的时候我都简单回复，晚上一般会详细点），但是认识的人多了，许多人还是多少知道我这个名字的，虽然没啥用，但是也算是种隐形财富吧，以后有什么用再说。</p><h2 id="Where？都在什么平台写博客呢？"><a href="#Where？都在什么平台写博客呢？" class="headerlink" title="Where？都在什么平台写博客呢？"></a>Where？都在什么平台写博客呢？</h2><p>这个其实上面都说过了，我现在文章主要更新在个人博客、知乎专栏、微信公众号和 CSDN 上面，我简要说一些这些平台的优缺点吧。</p><p>个人博客可以个性化定制主题，想怎么好看就怎么好看，还不用发文章审核，想发什么就发什么。但是缺点就是发文章麻烦一点的，步骤略多，并且搜索引擎收录很慢的。</p><p>知乎专栏是我比较喜欢的一个平台，主要是它支持markdown，还可以把公式变成矢量图片，还是挺不错的。但是发知乎文章要注意千万别带着营销、引流等内容，不然容易被人举报被删除甚至禁言。</p><p>微信公众号是我最近才开始运营的，相对而言，它的编辑界面是最不友好的一个，只支持富文本编辑，连markdown都没有。但是也有解决方法，比如我现在用<a href="https://mdnice.com/" target="_blank" rel="noopener">mdnice.com</a>这个网站，把markdown转换成微信公众号的富文本格式，还是非常好用的。公众号还有个缺点，太封闭了，很难宣传出去，刚开始只能亲朋好友关注关注，但是如果你真的做大了知名度，还是可以借助微信的优势，赚得不少广告钱的。</p><p>CSDN因为几年前被永久封过号，然后现在不知道为什么又被解封了，所以用的不是特别多，主要都是通过知乎专栏自动同步文章过去的。CSDN 好处就是流量大，很多人都在上面搜东西，百度搜出来也基本都是 CSDN ，但是排版是真的真的烂，不过现在好多了，也支持 markdown 了。但是还是谈不上喜欢，广告什么的都太多了，除非迫不得已，我一般不去 CSDN 看技术文章，我一般都是个人博客或者知乎看论文解读之类的。</p><h2 id="How？按照什么流程来写博客？"><a href="#How？按照什么流程来写博客？" class="headerlink" title="How？按照什么流程来写博客？"></a>How？按照什么流程来写博客？</h2><p>其实同时维护好几个平台还是挺累的，你得找到一个最佳的顺序来发布文章，这样才能事半功倍。我一般都是先在个人博客上写好 markdown 文章，然后发布完之后，打开<a href="https://mdnice.com/" target="_blank" rel="noopener">mdnice.com</a>在线编辑网站，把 markdown 粘贴进去，转成微信公众号和知乎专栏的格式，最后分别发布在两个地方就行了。 CSDN 就不用管了，它会每天自动同步知乎专栏的文章的，倒是为我省了不少事。markdown 写作也挺轻松的，完全不用管排版之类的问题，安安心心写内容就行了。</p><p>微信公众号现在设置的是每天早上 8:05 推送，其实稍微晚一点比较好，这样别人的都推送完了，你的就会置顶在最上面。而知乎专栏和个人博客我就随性发布了，想什么时候发就什么时候发，经常会前一天就写好内容，早早的发布出去了。</p><p>我个人现在来看，写一篇博客最累的是敲公式和找图片，当然像我这篇就一个公式和图都没有，是最最轻松的了。我这个人有强迫症，公式一定要手打 LaTeX 公式，然后转成矢量图才行，这样看着又清楚又舒服。遇到复杂的矩阵公式，能把我敲的头晕。这也是我为什么不喜欢 CSDN 的一个原因，上面很多文章公式全是截图，看的我头都大了。</p><h2 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h2><p>写博客挺花时间的，特别是现在还在为发论文而忙活的时候，可能论文截稿前那段时间甚至我会停更好久哈哈。不过现在放假了，还算比较闲，有功夫搞搞这些。我个人是倾向于白天还是老老实实学习吧，晚上把部分的游戏时间抽出来写会儿文章，更新一波。这样也不算太浪费时间，毕竟就算不写，时间也都用来打游戏了，游戏输了还坏了心情（我的亚索怎么会输？）。</p><p>那什么时候做 LeetCode 呢？我一般都是白天吃饭时，或者走在路上时，手机 app 上随机选一道题，然后吃个饭的时间就能想出个解法，回到实验室后敲一顿代码通过了就行了。这样看来也节约了不少时间嘛，还能和室友一起讨论讨论，帮他提高一波算法能力。</p><p>金钱的话就基本没有花销了，除了开了个素材设计网站的会员（我是真的睿智，用 PS 不就行了嘛，脑子瓦特了充钱了）以外，其他不需要啥了，偶尔还能吃点打赏钱，粉丝太少了，没有广告。</p><p>因为写文章这上面花时间比较多，写出好的文章、不水文章的话花的时间更多，所以很容易坚持不下去。而又要迎合大众的口味，众口难调嘛，又要坚持自己的初心，尽量写对自己提升大的内容，还是比较难以平衡的。特别是粉丝特别少，没有什么人看的时候，你会很想放弃。</p><p>但是，总会有人在你坚持不下去的时候，给你鼓励的目光，支持你继续走下去的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 124】二叉树中的最大路径和</title>
      <link href="/2020/01/13/leetcode-124/"/>
      <url>/2020/01/13/leetcode-124/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3]      1     / \    2   3输出：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[-10,9,20,null,null,15,7]     -10     / \    9  20      /  \     15   7输出：42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道<strong>树形 dp</strong> 入门题，也就是树上的动态规划。</p><p>首先要理解它这个输入什么意思，虽然写代码的时候不用你管，已经给你处理成结构体了。<br>输入是一个数组，其实是二叉树的层次遍历，也就是从第一层（根结点）开始，往下一层一层遍历结点，同一层从左往右遍历。</p><p>这题要求的是一条路径，路径上的数字之和要最大。<br>我们采用递归来做这题，<strong>假设<code>dfs(r)</code>表示以 r 为根结点的子树中最长路径的和，而左右子结点用 l 和 r 来表示</strong>。</p><p>那么有人可能会说，这不是很简单了嘛。<br>一共就下面几种情况：</p><ol><li>只取根结点：<code>r-&gt;val</code></li><li>只取左子树：<code>dfs(l)</code></li><li>只取右子树：<code>dfs(r)</code></li><li>取根结点和左子树：<code>r-&gt;val + dfs(l)</code></li><li>取根结点和右子树：<code>r-&gt;val + dfs(r)</code></li><li>取根结点和左子树和右子树：<code>r-&gt;val + dfs(l) + dfs(r)</code></li></ol><p>最后的答案就是<code>dfs(root)</code>。</p><p>然而这样对吗？其实是错的，刚开始我也犯了这样的错误（好久没做树形 dp 了，见笑了）。<br>为什么是错的呢？试想这么一种情况，万一左子树的最优解是不经过左子结点的话，怎么与根结点连接起来呢？<br>这种情况下你的计算就有问题了，所以我们必须加强一下之前的假设。</p><p>这次我们假设<code>dfs(r)</code>表示以 r 为根结点的子树中<strong>经过根结点 r</strong> 的最长路径的和。<br>现在继续分成上面的几种情况讨论，然而最后的<code>dfs(root)</code>意思变了，指的是必须经过根结点 root 的最优路径之和。<br>那怎么办呢？很好办，只需要用一个全局变量，每次递归的时候都更新一下最大值就行了，因为总有一个结点是最优路径所在子树的根结点。</p><p>分析到这里，貌似都对了，但是还有问题吗？<br>注意看上面的第<code>2、3、6</code>三种情况，如果最优情况是这三种，然后用它们更新<code>dfs(r)</code>，会出现什么情况？<br>情况<code>2、3</code>会导致回溯之后，在根结点 r 处断开了，也就是不经过 r 了，那再高层也就没法求解了。<br>而情况<code>6</code>会导致路径出现左右分叉，这也是不允许的。<br>所以递归的最后更新时，只能用其他三种情况更新。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l_max_sum <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r_max_sum <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> l_max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> r_max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> l_max_sum<span class="token punctuation">,</span> r_max_sum<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token operator">-</span>sys<span class="token punctuation">.</span>maxsize    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        l_max_sum <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        r_max_sum <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        sum <span class="token operator">=</span> root<span class="token punctuation">.</span>val        sum <span class="token operator">=</span> max<span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> l_max_sum<span class="token punctuation">)</span>        sum <span class="token operator">=</span> max<span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> r_max_sum<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l_max_sum<span class="token punctuation">,</span> r_max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题虽然是困难题，但是也是树形 dp 的入门题，思考起来和实现起来 trick 还是挺多的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 357】计算各个位数不同的数字个数</title>
      <link href="/2020/01/12/leetcode-357/"/>
      <url>/2020/01/12/leetcode-357/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数 n ，计算各位数字都不同的数字 x 的个数，其中 $0 \le x &lt; 10^n$ 。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：2输出：91解释：答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题要求所有数位数字都不相同的数字个数，那么我们可以将答案分成不同长度。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>对于长度为 n 的数字，第一位取值有 1<del>9 一共 9 种情况，而后面 n - 1 位可以从 0</del>9 中随机取出 n - 1 个不同数字，然后随机排列。因为要和第一位不同，所以后面的数字选择只有 9 种情况，所以方案数是排列数 $A_{9}^{n-1}$。</p><p>然后一直累和到长度为 1 的数字，最后还有个特例，就是 0 ，它是首位可以为 0 的唯一情况。</p><p>所以最终答案就是 $\sum_{i=0}^{n-1}{A_{9}^{i}} + 1$ 。具体实现的时候可以将阶乘预处理好，然后直接用就行了。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>因为 n 不会太大，所以我们可以本地将每个 n 对应的答案算出来，然后保存到数组里，提交的时候直接取答案就行了。这种方法非常投机取巧，适合直接做会超时，但是答案数量又不是太多的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1（c-）"><a href="#方法1（c-）" class="headerlink" title="方法1（c++）"></a>方法1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> fact<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">,</span> <span class="token number">5040</span><span class="token punctuation">,</span> <span class="token number">40320</span><span class="token punctuation">,</span> <span class="token number">362880</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">-</span>n<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>           res <span class="token operator">+</span><span class="token operator">=</span> fact<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">/</span> fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> res <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法1（python）"><a href="#方法1（python）" class="headerlink" title="方法1（python）"></a>方法1（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fact <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">,</span> <span class="token number">5040</span><span class="token punctuation">,</span> <span class="token number">40320</span><span class="token punctuation">,</span> <span class="token number">362880</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">-</span>n<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> int<span class="token punctuation">(</span>fact<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">/</span> fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（c-）"><a href="#方法2（c-）" class="headerlink" title="方法2（c++）"></a>方法2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> res<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">739</span><span class="token punctuation">,</span> <span class="token number">5275</span><span class="token punctuation">,</span> <span class="token number">32491</span><span class="token punctuation">,</span> <span class="token number">168571</span><span class="token punctuation">,</span> <span class="token number">712891</span><span class="token punctuation">,</span> <span class="token number">2345851</span><span class="token punctuation">,</span> <span class="token number">5611771</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> res<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（python）"><a href="#方法2（python）" class="headerlink" title="方法2（python）"></a>方法2（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">739</span><span class="token punctuation">,</span> <span class="token number">5275</span><span class="token punctuation">,</span> <span class="token number">32491</span><span class="token punctuation">,</span> <span class="token number">168571</span><span class="token punctuation">,</span> <span class="token number">712891</span><span class="token punctuation">,</span> <span class="token number">2345851</span><span class="token punctuation">,</span> <span class="token number">5611771</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还可以用递归、解出和式的通式等方法求解，本质上没有太大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 992】K个不同整数的子数组</title>
      <link href="/2020/01/11/leetcode-992/"/>
      <url>/2020/01/11/leetcode-992/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</p><p>返回 A 中好子数组的数目。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>1 &lt;= A[i] &lt;= A.length</li><li>1 &lt;= K &lt;= A.length</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题最暴力的方法就是用一个字典维护每个数出现的次数，然后遍历所有的区间，求出不同整数个数正好等于 K 的区间个数。<br>但是这种方法时间复杂度是 $O(n^2)$，一定会超时，所以考虑其他方法。</p><p>现在考虑右边界为 j 的情况，左边界 i 有什么规律呢？<br>我们可以证明，满足 [i, j] 正好包含 K 个不同整数的 i 的取值是一段连续的区间。<br>假设 [i, j]包含 K 个不同整数，同时 [i’, j] 也包含 K 个不同整数（i &lt; i’），因为从 i 移动到 i’ 每个数的数量是非增的，所以这过程中没有增加新的数，也没有任何一个数的数量降到了0。</p><p>有了这个性质之后，对于任意的 j ，我们只需要求出左边界 i 的取值范围就行了。同样这里还是不能暴力求，不然就和一开始没区别了嘛。<br>既然这样，想想如果 j 的左边界 i 的范围得到了，这时候我们继续求 j + 1 的左边界范围，能不能利用一下之前得到的结果？而不用重新计算。<br>很容易发现，如果 j 右移了， i 的取值范围也会右移，因为 j 右移有两种结果：一是引入了新的数，二是某个存在的数的数量加 1 。<br>第一种情况对左边界没有任何影响，因为不同整数数量没有变化，还是 K 。第二种情况不同整数数量变成 K + 1 了，这时候左边界一定要右移，删掉点数，才可能使区间符合题意。</p><p>有了上述的性质之后就好做了，因为左边界的取值范围也是不断右移的，所以我们只需要维护两个指针 l 和 r 就行了，一个保存取值范围的最小值，一个保存最大值。然后每次对于一个 j ，符合题意的子区间数量就是 r - l + 1 。而 j 右移一个数之后， l 需要右移，直到 [l, j] 中正好有 K 个不同整数， r 也继续右移，直到[r + 1, j] 中正好有 K - 1 个不同整数。</p><p>因为 l 和 r 最多只会移动 n 次，而 j 也只移动了 n 次，所以总体时间复杂度降到了 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">subarraysWithKDistinct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cl<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cr<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nl <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nl<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nl <span class="token operator">></span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nl<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nr<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nr <span class="token operator">>=</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nr<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">+</span><span class="token operator">=</span> r <span class="token operator">-</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraysWithKDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> K<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        cl <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        cr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        l <span class="token operator">=</span> r <span class="token operator">=</span> nl <span class="token operator">=</span> nr <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                nl <span class="token operator">+=</span> <span class="token number">1</span>            cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> nl <span class="token operator">></span> K<span class="token punctuation">:</span>                cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    nl <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                nr <span class="token operator">+=</span> <span class="token number">1</span>            cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> nr <span class="token operator">>=</span> K<span class="token punctuation">:</span>                cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    nr <span class="token operator">-=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">+=</span> r <span class="token operator">-</span> l        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实这题想起来可能好想，但是写起来容易写错，因为区间范围需要好好琢磨。这一类问题统称为“窗口滑动”问题，都是不特别难，想清楚了两个状态之间窗口如何滑动就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1250】检查「好数组」</title>
      <link href="/2020/01/10/leetcode-1250/"/>
      <url>/2020/01/10/leetcode-1250/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="https://godweiyang.com/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数数组 nums ，你需要从中任选一些子集，然后将子集中每一个数乘以一个任意整数，并求出他们的和。</p><p>假如该和结果为 1 ，那么原数组就是一个「好数组」，则返回 True ；否则请返回 False 。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [12,5,7,23]输出：true解释：挑选数字 5 和 7 。5*3 + 7*(-2) = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [29,6,10]输出：true解释： 挑选数字 29 , 6 和 10 。29*1 + 6*(-3) + 10*(-1) = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [3,6]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^9</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题名义上是困难难度，实际上只要知道一些数学知识，就非常的简单。</p><p>首先题目中要求挑选出一些数，然后给每个数分配整数系数，加权求和等于 1 。<br>仔细想一想就不对劲，全选不是一样嘛？有些数系数分配 0 就行了。</p><p>假设系数分别是 $x_1, x_2, \ldots, x_n$ ，那么问题就变成了求解下面的多元一次方程有整数解的条件：<br>$$<br>    a_1 x_1 + a_2 x_2 + \dots + a_n x_n = 1<br>$$<br>如果你数学基础不错的话，一眼就会发现条件就是<strong>所有非零数的最大公约数为 1</strong> ：<br>$$<br>    gcd(a_1, a_2, \ldots, a_n) = 1, a_i \neq 0<br>$$</p><p>证明参见 n 个数的<a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity," title="维基百科：裴蜀定理" target="_blank" rel="noopener">裴蜀定理</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isGoodArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">%</span>y <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token operator">%</span>y<span class="token punctuation">)</span> <span class="token operator">:</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后不管是用时还是空间消耗都超越了100%的用户。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1004】最大连续1的个数 III</title>
      <link href="/2020/01/09/leetcode-1004/"/>
      <url>/2020/01/09/leetcode-1004/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="https://godweiyang.com/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由若干 0 和 1 组成的数组 A ，我们最多可以将 K 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><p><strong>示例1</strong></p><pre><code>输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释：[1,1,1,0,0,1,1,1,1,1,1]A[5] 和 A[10] 从 0 翻转到 1，最长的子数组长度为 6。</code></pre><p><strong>示例2</strong></p><pre><code>输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3输出：10解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]A[4] 、A[5] 和 A[9] 从 0 翻转到 1，最长的子数组长度为 10。</code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>0 &lt;= K &lt;= A.length</li><li>A[i] 为 0 或 1 </li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题可以采用滑动窗口方法来求解。<br>也就是用头尾指针 l 和 r ，初始化都是 l = r = 0 ，然后向右移动指针 r 。<br>用变量 cnt0 记录 [l, r] 区间内有几个 0 ，用 res 保存答案。</p><p>如果 A[r] = 0 ，那就 0 的数量 cnt0 加 1 。<br>并且 0 的数量和 K 判断，如果 cnt0 &lt;= K ，那就说明 [l, r] 中间的 0 不多，可以用至多 K 次机会填充，那就继续向右移动 r 。<br>但是如果 cnt0 &gt; K ，那就说明 0 的数量太多了，得删掉点 0 了，这时候就得向右移动 l 。<br>这时候看情况，如果 A[l] = 0 ，就要减小 cnt0 ，直到 cnt0 &lt;= K 为止，不再移动 l 。<br>然后继续移动 r ，重复上面过程即可。过程中时刻更新最长的距离 res 。</p><p>因为 l 和 r 分别最多移动 n 次，所以最终的时间复杂度是 $O(n)$ 的。</p><p>那么为什么这样是正确的呢？不会漏掉正确答案所在的区间吗？<br>我们看看漏掉的是哪些区间。<br>对于一个固定的 r ，移动 l 直到 0 的数量小于等于 K （记为 l’ ）的过程中，漏掉的是 [&lt;l, r] 和 [&gt;l’, r] 这些区间。<br>前者 0 数量太多，不符合题意；后者长度更小，显然不是答案。<br>然后继续右移 r ，直到第一个 0 数量大于 K 的位置，漏掉了 [&lt;l, &gt;r] 和 [&gt;l, &gt;r] 区间。<br>前者 0 的数量一定大于 K ，为什么呢？因为右端点在 r 的时候， l 已经是最靠左使得 0 数量小于等于 K 的位置了，而现在 r 向右移动了， l 更不可能左移了；后者长度更小，不予考虑。<br>综上考虑，最优的区间一定被考虑充分了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestOnes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt0<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>cnt0 <span class="token operator">></span> K <span class="token operator">&amp;&amp;</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> cnt0<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析【EMNLP19】语言模型效果不好？也许你可以给它添加一点句法信息</title>
      <link href="/2020/01/09/emnlp19-palm/"/>
      <url>/2020/01/09/emnlp19-palm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="http://arxiv.org/abs/1909.02134" title="PaLM: A Hybrid Parser and Language Model" target="_blank" rel="noopener">PaLM: A Hybrid Parser and Language Model</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文介绍了如何将一个句法分析器融入到神经网络语言模型中，这样在利用了句法信息增强语言模型效果的同时，还可以去掉句法上的监督信号，用来无监督地生成句法树。</p><p>其实将句法信息加入到语言模型中地思想之前就有了，比如PRPN（<a href="http://arxiv.org/abs/1711.02013" title="Neural Language Modeling by Jointly Learning Syntax and Lexicon" target="_blank" rel="noopener">Shen et al.</a>）和ON-LSTM（<a href="http://arxiv.org/abs/1810.09536" title="Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks" target="_blank" rel="noopener">Shen et al.</a>）。而本文提出了一种新的融入句法信息的方法，相比于之前的两个模型，主要有如下优点：</p><ul><li>更加符合直觉、更加轻巧，不需要很复杂的解码算法。</li><li>在LSTM中加入的attention信息可以用句法信息来监督，可解释性更强，可以和语言模型联合训练。</li><li>如果没有句法信息监督也不要紧，模型可以无监督预测出句法树。</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="span-attention"><a href="#span-attention" class="headerlink" title="span attention"></a>span attention</h3><p>模型中的attention是怎么做的呢？在 $t$ 时刻，模型关注以 $t - 1$ 结尾的所有 span 。但是为了减少运算量，这里只考虑最短的 $m$ 个 span ，也就是 $\{[i, t - 1]\}_{i = t - m}^{t - 1}$ 。</p><p>首先采用普通的 RNN 来获得 $t$ 时刻的隐层表示 $h_t$，然后采用双向 WFSA-RRNN （<a href="https://arxiv.org/abs/1808.09357" title="Rational Recurrences" target="_blank" rel="noopener">Peng et al.</a>）进一步得到表示， WFSA-RRNN 的单元更新公式如下：<br>$$<br>    \begin{aligned}<br>        f_t &amp;= \sigma(W_f h_t) \\<br>        u_t &amp;= (1 - f_t) \odot \tanh(W_u h_t) \\<br>        c_t &amp;= f_t \odot c_{t-1} + u_t<br>    \end{aligned}<br>$$</p><p>然后 span $[i, j]$ 的表示 $c_{i, j}$ 可以计算为：<br>$$<br>    c_{i, j} = c_j - c_{i-1}\odot_{k=i}^{j}f_k<br>$$<br>这个式子其实是从下面这个式子推算而来的：<br>$$<br>    c_{i, j} = u_j + \sum_{k=i}^{j-1}{u_k \odot_{l=k+1}^{j}f_l}<br>$$<br>具体计算过程就不在这里看了，详见论文附录，其实就是用的 WSFA-RRNN 的单元更新公式化简得到的。</p><p><strong>注意上面向量都省略了前向箭头！</strong></p><p>下面就是计算所有 span 表示的算法伪代码：<br><img src="1.jpg" alt></p><p>可以看出复杂度还是挺高的，但是可以用 GPU 并行加速。</p><p>然后就是计算attention了。<br>首先令 $g([i, j])$ 为向量 $c_{ij}$前后向拼接得到，表示 span [i, j] 的最终向量表示。<br>那么在 $t + 1$ 时刻，上下文向量 $a_{t + 1}$ 可以表示为：<br>$$<br>    \begin{aligned}<br>        a_{t+1} &amp;= \sum_{i=0}^{m-1}{w_{t,i}g([t-i,t])} \\<br>        w_{t,i} &amp;= \frac{\exp{s_{t,i}}}{\sum_{j=0}^{m-1}{\exp{s_{t,j}}}}<br>    \end{aligned}<br>$$<br>其中 $s_{t, i}$ 定义为：<br>$$<br>    s_{t,i} = \text{MLP}(h_{t+1};g([t-i, t]))<br>$$<br>最后拼接 $h_{t+1}$ 和 $a_{t+1}$ 作为最后的隐层输出。</p><p>总结一下，计算步骤是这样的：</p><ul><li>首先用一个标准的RNN计算得到隐层表示 $h_t$ 。</li><li>然后将 $h_t$ 输入到一层的双向 WSFA-RRNN 中，得到表示 $c_t$ ，并且用上述算法进一步得到 span 的表示。</li><li>最后对所有以 $t$ 结尾的 span 表示加权求和，得到下一时刻的隐层表示，并预测下一个单词。</li></ul><h3 id="生成句法树"><a href="#生成句法树" class="headerlink" title="生成句法树"></a>生成句法树</h3><p>这就和以往自顶向下解码句法树的算法一样了，对于 span $[i, j]$，寻找使得右儿子得分最高的 split $k$ 即可：<br>$$<br>    k = \text{argmax}_{k \in \{0,\ldots,m-1\}}s_{j,k}<br>$$<br>而如果是有监督的话，对于每个位置 $t$ ，都会预测一个 attention $w_t$，并且有一个 gold 的左边界 $y_t$。<br>注意<strong>这里的 $y_t$ 不一定是 one-hot 的</strong>，因为在一棵句法树中，一个右端点可能对应着很多不同的左端点。<br>最终的损失函数为：<br>$$<br>    \mathcal{L} = \mathcal{L}_{\text{LM}}+\frac{\lambda}{N}\sum_{t=1}^{N}{\mathcal{H}(y_t, w_t)}<br>$$<br>而这里的句法树监督其实可以用现成的 parser ，或者直接用左右二叉树之类的就行了，主要目的是为了提升语言模型性能。</p><p>下图就是一个简单的例子：<br><img src="2.jpg" alt></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>这是一篇短文，所以实验就很简单了。</p><p>首先是PTB上的语言模型困惑度：<br><img src="3.jpg" alt></p><p>然后是WikiText2上的语言模型困惑度：<br><img src="4.jpg" alt></p><p>两个实验都可以看出加了句法树监督的语言模型效果更好，而无监督隐式的语言模型效果也还可以。注意这里的AWD-LSTM指的是之前提出的一种LSTM变体（<a href="https://arxiv.org/abs/1708.02182" title="Regularizing and Optimizing LSTM Language Models" target="_blank" rel="noopener">Merity et al.</a>）。看得出来这些模型参数量其实没多大差别，而如果句法信息乱加监督（比如用右二叉树），效果反而会变差。</p><p>接着是无监督句法分析的效果：<br><img src="5.jpg" alt></p><p>可以发现效果还是很差的，只比随机的二叉树好了那么一丢丢。比之前的 PRPN 差许多，和 DIROA 相比就更不用谈了（<a href="http://arxiv.org/abs/1904.02142" title="Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders" target="_blank" rel="noopener">Drozdov et al.</a>）。这也说明了对语言模型有用的句法信息可能并不符合 PTB 句法树结构。</p><p>最后还分析了左结合多还是右结合多：<br><img src="6.jpg" alt></p><p>可以看出，基本全部都是右结合，也就是attention基本都聚焦在了 span 的最左边的单词。具体原因作者也不知道，留着未来探索。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>其实这篇短文和我 ACL 的工作挺像的，着实让我惊了一身冷汗（<strong>希望 ACL 能中，加油！</strong>）。</p></blockquote><p>不过这篇还是有些小瑕疵的，比如最大考虑长度 $m$ ，这个值在语言模型的训练时用到了，但是分析无监督句法树的时候就去掉限制了，其实会影响无监督句法分析性能的。不过也不要紧，毕竟本文任务不是做句法分析。</p><p>再比如算 attention 是要对所有分数做归一化的，但是句法分析又采用了没有归一化的得分来解码，原因是因为一个右边界对应着多个左边界，所以不能用 attention 解码。但其实这个 attention 在做有监督句法信息的时候， gold 的就不是归一化的，也就是非 one-hot 的。总之这里做的挺粗糙的，也没有设计的很优雅。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 语言模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1053】交换一次的先前排列</title>
      <link href="/2020/01/09/leetcode-1053/"/>
      <url>/2020/01/09/leetcode-1053/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="https://godweiyang.com/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。</p><p>如果无法这么操作，就请返回原数组。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,1]输出：[3,1,2]解释：交换 2 和 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,1,5]输出：[1,1,5]解释： 这已经是最小排列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,9,4,6,7]输出：[1,7,4,6,9]解释：交换 9 和 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,1,3]输出：[1,3,1,3]解释：交换 1 和 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= A[i] &lt;= 10000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题主要出发点有以下几点：</p><ul><li>首先要求交换后的字典序变小，那么一定要<strong>大的和小的交换，并且大的在前</strong>。</li><li>其次要求交换后的字典序尽量大，那么在满足第一点的情况下，<strong>大的元素要尽量靠后</strong>。</li><li>最后<strong>小的元素要尽量大，并且靠左</strong>。</li></ul><p>满足这几点条件，也就是要从最右边开始往左寻找，找到<strong>第一个上升</strong>的数字 A[i]（从左往右看是下降，即 A[i] &gt; A[i+1]）。<br>这一点只为了保证上面的条件1，也就是 A[i] 右边存在比它小的元素。</p><p>然后在 A[i+1] 到 A[n-1] 之间所有比 A[i] 小的数字中找最大的那个就行了。如果最大的有多个相同的，取最左边的一个。</p><p>因为 A[i+1] 到 A[n-1] 子数组是单调递增的，所以不用全部遍历一遍，只需要从最右边开始往左找到第一个比 A[i] 小的数就行了。<br>然后从这个数开始，继续往左找和它相等的数，直到最左边一个相等的数 ，就是答案了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">prevPermOpt1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j<span class="token punctuation">;</span> k <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> A<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后不管是用时还是空间消耗都超越了100%的用户：<br><img src="1.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 315】计算右侧小于当前元素的个数</title>
      <link href="/2020/01/08/leetcode-315/"/>
      <url>/2020/01/08/leetcode-315/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[5,2,6,1]输出：[2,1,1,0]解释：5 的右侧有 2 个更小的元素 2 和 1 。2 的右侧仅有 1 个更小的元素 1 。6 的右侧有 1 个更小的元素 1 。1 的右侧有 0 个更小的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题没有给数据范围，但是用脚想也知道不能暴力做（ $O(n^2)$ ）。</p><p>这题其实有多种解法，这里简单介绍三种解法。</p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>如果你不熟悉这个数据结构的话，你只需要记住它的功能就行。</p><p>树状数组是一个数组，有两种操作。<br>一个是对某个位置的元素加值或减值，一个是查询第一个位置到某个位置的元素之和。<br>暴力的话每次查询操作复杂度都是 $O(n)$ ，而树状数组可以做到 $O(\log n)$ 。</p><p>具体细节不介绍了，有现成的模板，会用就行了。</p><p>有了这等好东西，就可以把问题这么转化了：<br>新建一个数组 bit ，其中 bit[i] 表示i这个数出现的次数。<br>从右边最后一个数开始向左遍历，每遇到一个数 nums[i] ，就把 bit[nums[i]] 加 1 ，表示这个数多了一个。<br>然后查询 bit[0] 到 bit[nums[i]-1] 中的所有次数之和，就表明了当前时刻有多少数比 nums[i] 小。<br>这一步查询操作正好用到树状数组，最后总的时间复杂度为 $O(n \log n)$ 。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序算法想必大家应该很熟悉了。<br>就是将数组划分为左右两个长度相等的子数组，然后分别递归排序，得到左右两个有序的子数组。<br>然后就是合并了，只要用两个头指针，分别指着两个子数组的开头，然后分别向右移动合并就行了。</p><p>那么在这题中怎么用呢？<br>假设左右两个子数组为 a[l], …, a[m] 和 a[m+1], …, a[r] ，头指针分别为 i = l 和 j = m + 1 。<br>然后开始合并，首先 j 向右移动，直到 a[j] &gt;= a[i] ，也就是在右半部分子数组中找到所有小于 a[i] 的数。<br>然后把这些数依次放入临时数组中，并得到结论：右半部分子数组中比 a[i] 小的数有 j - m - 1 个。<br>然后把 a[i] 也推进临时数组里，重复进行上述过程，直到 i &gt; m 。<br>最后如果右半部分数组还剩一些数，说明它们是最大的，推入临时数组就行了，最后把临时数组里的数复制进原数组，这部分就排好序了。</p><p>要注意的是排序后原来的下标会丢失，所以用一个 pair 类型保存每一个数和它原来的下标。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>这种方法也很显然。<br>从最右边一个数开始构建二叉搜索树，结点保存这个数和右边比它小的数的数量。<br>如果新插入一个数，就插入到二叉搜索树中，沿途记得要更新经过的每个结点的数量。<br>如果经过一个结点，并且插入的数比结点的数小，那么就在左子树中继续寻找插入位置，并且结点数量加 1 。<br>如果插入的数比结点的数大，那么就在右子树中寻找，并且插入的数对应的答案加上该结点的数量。</p><p>具体这里就不实现了，主要考察的是数据结构，不想写了。。。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSmaller</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">sort</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> y <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> y <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> y<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> y <span class="token operator">+</span> len<span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> x<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSmaller</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> cnt<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idl <span class="token operator">=</span> l<span class="token punctuation">,</span> idr <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idl <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>idr <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">[</span>idr<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">&lt;</span> x<span class="token punctuation">[</span>idl<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>                y<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>idr<span class="token punctuation">]</span><span class="token punctuation">;</span>                idr<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cnt<span class="token punctuation">[</span>x<span class="token punctuation">[</span>idl<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> idr <span class="token operator">-</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            y<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>idl<span class="token punctuation">]</span><span class="token punctuation">;</span>            idl<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idr<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些自用软件，学妹们用了都说好用！</title>
      <link href="/2020/01/07/software-share/"/>
      <url>/2020/01/07/software-share/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天我给大家分享一些我平时自用的软件，有学习的、编程的、娱乐的、工具类的等等。</p><p>有些软件是破解版的，去除了广告，都很实用！</p><h1 id="迅雷极速版"><a href="#迅雷极速版" class="headerlink" title="迅雷极速版"></a>迅雷极速版</h1><p>迅雷我一直用的是纯净版（极速版），相比于最新的迅雷9，这个版本没有广告和在线视频等没用的功能。</p><blockquote><p>注意会经常弹出来让你更新，千万别点确定，点取消就行了。</p></blockquote><p>界面看起来就很简洁：<br><img src="thunder.jpg" alt></p><p><strong>下载地址：</strong><br><a href="http://xiazai.zol.com.cn/detail/43/428424.shtml" target="_blank" rel="noopener">http://xiazai.zol.com.cn/detail/43/428424.shtml</a></p><h1 id="QQ影音"><a href="#QQ影音" class="headerlink" title="QQ影音"></a>QQ影音</h1><p>QQ影音是腾讯少有的几款良心软件了，没有任何广告，也不会流氓捆绑。</p><p>功能也够用了，比如视频转gif、转码、截取视频等常用功能都用了。</p><blockquote><p>QQ影音可以用来作为迅雷的边下边播的播放器，然后就可以舒舒服服看一些你喜欢看的电影了。</p></blockquote><p>界面：<br><img src="qqplayer.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://player.qq.com/" target="_blank" rel="noopener">https://player.qq.com/</a></p><h1 id="7zip"><a href="#7zip" class="headerlink" title="7zip"></a>7zip</h1><p>7zip是一款轻量的压缩软件，最开始用它是在学校的机房里。</p><p>安装包才1兆，常用的压缩格式都支持，速度也还不错，还不像国内某些压缩软件那么流氓。</p><blockquote><p>注意，下载完之后用到的运行程序是安装目录下的7zFM.exe，可以右键任意压缩包用此方式默认打开，以后就方便了。</p></blockquote><p>界面：<br><img src="7zip.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.7-zip.org/" target="_blank" rel="noopener">https://www.7-zip.org/</a></p><h1 id="SumatraPDF"><a href="#SumatraPDF" class="headerlink" title="SumatraPDF"></a>SumatraPDF</h1><p>SumatraPDF是一款轻量的pdf阅读器，没有任何功能，只能看pdf。</p><p>安装包只有几兆，功能比较单一，如果你喜欢做批注或者编辑pdf，那就不推荐用这个。<br>像我平时只需要看pdf，用这个再合适不过了，打开速度极快，不占用内存。</p><blockquote><p>这个软件有绿色版和安装版，如果你用ctex写论文，它自带的pdf阅读器就是SumatraPDF。</p></blockquote><p>界面：<br><img src="pdf.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.sumatrapdfreader.org/download-free-pdf-viewer.html" target="_blank" rel="noopener">https://www.sumatrapdfreader.org/download-free-pdf-viewer.html</a></p><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Typora是一款跨平台的markdown写作软件，可见即可得。</p><p>支持插入表格、图片，实时显示公式等功能，非常的方便。<br>另一大好处是可以导出pdf文档，提供了多种风格，我比较喜欢github风格。</p><blockquote><p>不过我已经很久没用了，我现在选择vscode直接写markdown，要啥实时预览嘛。</p></blockquote><p>界面：<br><img src="typora.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><h1 id="Zotero"><a href="#Zotero" class="headerlink" title="Zotero"></a>Zotero</h1><p>Zotero是一款跨平台的文献管理软件，对于经常看论文的同学很有用。</p><p>你是不是还在用文件夹分类保存论文呢？多麻烦哟，赶紧用Zotero吧。<br>Zotero支持实时同步pdf到云端服务器，还可以管理你喜欢的网页之类的。<br>Zotero还提供了浏览器插件，还可以自动识别论文的作者等信息，给你安排得明明白白。</p><blockquote><p>Zotero目前免费版云端只能保存300兆文件，一般也够用了。如果满了，支持第三方网盘保存。</p></blockquote><p>界面：<br><img src="zotero.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.zotero.org/" target="_blank" rel="noopener">https://www.zotero.org/</a></p><h1 id="Marp"><a href="#Marp" class="headerlink" title="Marp"></a>Marp</h1><p>Marp是一款跨平台的markdown制作ppt的软件，非常的方便快捷。</p><p>如果你不要求炫酷的动画，只是简简单单的做个组会报告的话，用Marp再合适不过了，做好整个ppt只需要几分钟。<br>Marp支持几乎所有markdown语法和部分html语法，还支持插入emoji，支持编辑公式。<br>最后支持导出为pdf、html和pptx。</p><blockquote><p>Marp是开源的免安装版，所以下载完直接打开运行程序就行，最好自己建一个快捷方式。</p></blockquote><p>界面：<br><img src="marp.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://marp.app/" target="_blank" rel="noopener">https://marp.app/</a></p><h1 id="Mathpix-Snipping-Tool"><a href="#Mathpix-Snipping-Tool" class="headerlink" title="Mathpix Snipping Tool"></a>Mathpix Snipping Tool</h1><p>这是一款跨平台的识别图片公式，并转化为latex公式的软件，准确率非常高。</p><p>但是每个月只有免费的50次识别，可以换不同邮箱注册。</p><blockquote><p>少用这种软件，好好练练latex公式语法，熟练了打的很快的。</p></blockquote><p>界面：<br><img src="mathpix.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://mathpix.com/" target="_blank" rel="noopener">https://mathpix.com/</a></p><blockquote><p>我平时常用的软件基本就是这些了，其他都是些大家比较熟悉的软件了，就不介绍了。<br>如果大家还有什么好用、提高效率的实用软件，欢迎评论留言！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 689】三个无重叠子数组的最大和</title>
      <link href="/2020/01/07/leetcode-689/"/>
      <url>/2020/01/07/leetcode-689/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组 $nums$ 由正整数组成，找到三个互不重叠的子数组的最大和。<br>每个子数组的长度为 $k$ ，我们要使这 $3k$ 个项的和最大化。<br>返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,1,2,6,7,5,1], 2输出：[0, 3, 5]解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$nums.length$ 的范围在[1, 20000]之间。</li><li>$nums[i]$ 的范围在[1, 65535]之间。</li><li>$k$ 的范围在 [1, floor(nums.legth / 3)]之间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先看数据范围，这题不能使用暴力，暴力时间复杂度是 $O(n^3)$ ，一定会超时，所以考虑使用动态规划求解。</p><p>下面考虑一般情况，也就是求解划分成 $N$ 个不重叠数组的最大和。</p><p>假设到第 $i$ 个元素为止，一共已经产生了 $j$ 个不重叠数组，那么令 $dp[i][j]$ 表示这$j$个不重叠数组的最大和。</p><p>然后就要寻找状态转移方程。对于第 $i$ 个元素，分为两种情况，可取可不取。</p><p>如果取，那就说明 $nums[i]$ 是第 $j$ 个子数组的最后一个元素，那么转移方程为：</p><p>$$<br>    dp[i][j] = dp[i-k][j-1] + nums_{i-k+1:i}<br>$$</p><p>也就是说，从 $i-k+1$ 到 $i$ ，这 $k$ 个元素构成了第 $j$ 个子数组，那我们只需要求到第 $i-k$ 个元素为止，产生 $j-1$ 个不重叠数组的最大和即可。</p><p>如果不取，那问题就变成了求到第 $i-1$ 个元素为止，产生 $j$ 个不重叠数组的最大和，那么转移方程为：</p><p>$$<br>    dp[i][j] = dp[i-1][j]<br>$$</p><p>当然这题还需要你还原出最大和的情况下，所有子数组的起始元素下标，所以需要另外用一个数组保存一下每一步的最优下标。</p><p>同样，假设到第 $i$ 个元素为止，一共已经产生了 $j$ 个不重叠数组，用 $path[i][j]$ 表示第 $j$ 个子数组的末尾元素下标。</p><p>那么按照上面的推断，如果取第 $i$ 个元素，那么 $path[i][j]=i$ ；否则的话 $path[i][j]=path[i-1][j]$ 。</p><p>最后就是根据 $path$ 数组还原答案了。</p><p>首先最后一个子数组的末尾元素下标一定是 $idx=path[len-1][N]$ ，那么它的起始元素下标就是 $idx-k+1$ ，然后前一个子数组末尾元素下标就是 $idx=path[idx-k][N-1]$ ，依次下去，直到第一个子数组被求解完毕。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSumOfThreeSubarrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> N <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sum<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        path<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> path<span class="token punctuation">[</span>len<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>idx <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            idx <span class="token operator">=</span> path<span class="token punctuation">[</span>idx<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>idx <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><img src="1.jpg" alt></p><p>可以看到，时间和空间还有提升的余地。想到的可能优化方法是类似于0-1背包那样，去掉动态规划数组的第二个维度，来优化空间复杂度。</p><p>但是这是有些问题的，暂时并没有想到不增加时间复杂度下减少空间开销的方法，欢迎大家提出自己的想法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[EMNLP19]如何在Transformer中融入句法树信息？这里给出了一种解决方案</title>
      <link href="/2020/01/06/emnlp19-tree-transformer/"/>
      <url>/2020/01/06/emnlp19-tree-transformer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/D19-1098.pdf" target="_blank" rel="noopener">Tree Transformer: Integrating Tree Structures into Self-Attention</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>之前其实有很多工作将句法信息融入到了RNN中，例如ON-LSTM和PRPN，用来隐式建模句法结构信息，同时提升语言模型的准确率。本文尝试将句法信息融入到Transformer中，用来赋予attention更好的解释性。同时可以无监督的预测出句子的句法树，并且相比于一般的Transformer，语言模型的性能有所提高。</p><h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><p><img src="1.jpg" alt><br>上面这张是模型结构，最主要的区别就是在multi-head attention操作基础上新增了一个成分的attention，用来表示一段span能否构成一个短语。<br>比如上图中，“cute dog”构成一个短语，所以第0层中这两个单词的attention较大。<br>而“the cute dog”构成了一个更大的短语，所以第1层中“the”和“dog”的attention较大。</p><p>回顾self-attention的操作，主要是计算两个单词的向量点积：<br>$$<br>    E = \text{softmax}(\frac{QK^{\top}}{d})<br>$$<br>这里$d$一般取$\sqrt{d_k}$。但是在本文中，新增加了一个成分先验$C$，其中$C_{i,j}$表示$w_i$和$w_j$在一个短语内的概率。<br>然后与原来的self-attention做元素乘即可：<br>$$<br>    E = C \odot \text{softmax}(\frac{QK^{\top}}{d})<br>$$<br>注意不同的head之间共享$C$。</p><p>那么这个成分先验$C$怎么算呢？<br>这里把它拆成若干相邻单词在同一短语内概率的乘积。<br>也就是定义$a_i$为单词$w_i$和$w_{i+1}$在同一短语内的概率，那么$C_{i,j}$就可以表示为：<br>$$<br>    C_{i, j} = \prod_{k=i}^{j-1}{a_k}<br>$$<br>这样只有$w_i$到$w_j$中所有单词都有较大概率在同一短语中，$C_{i, j}$取值才比较大。<br>当然在实现中会取对数，来避免数值太小。</p><p>那么问题又来了，$a$怎么算？<br>首先类似self-attention，计算相邻两个单词属于同一短语的得分：<br>$$<br>    s_{i, i+1} = \frac{q_i \cdot k_{i+1}}{d}<br>$$<br>这里$d$取$\frac{h \cdot d_k}{2}$，$h$是head数。</p><p>注意这里区分了方向，也就是还存在得分$s_{i+1, i}$，并且两者虽然意义是一样的，但是分数不一定相同。<br>为了防止出现一种问题，也就是所有得分全部相同，然后算出来概率全是1，那就没有意义了，所以要给得分加上限制，也就是归一化。<br>这里选择归一化一个单词和左右邻居两者的得分：<br>$$<br>    p_{i,i+1}, p_{i, i-1} = \text{softmax}(s_{i,i+1}, s_{i, i-1})<br>$$</p><p>然后由于$p_{i, i+1}$和$p_{i+1, i}$值不一样，所以取平均：<br>$$<br>    \hat{a}_i = \sqrt{p_{i, i+1} \times p_{i+1, i}}<br>$$<br>这样的话，如果两个相邻单词互相之间连接的概率很大，就会导致$\hat{a}_i$很大，也就说明了这两个单词大概率属于同一个短语。</p><p>从第一张模型图中可以看到，成分attention不只计算了一层。<br>低层可以用来表示两两相邻单词之间属于同一短语的概率，而高层可以表示属于更大的短语的概率。<br>注意还得满足一个性质，也就是如果两个单词在低层大概率属于同一个短语，那他们高层肯定更大概率属于一个更大的短语。<br>所以计算方式如下：<br>$$<br>    a_i^l = a_i^{l-1} + (1 - a_i^{l-1})\hat{a}_i^l<br>$$<br>初始化的时候$a_i^{-1}$都设为0。这样对于每一层都可以得到一个成分先验$C^l$。</p><h1 id="无监督句法分析"><a href="#无监督句法分析" class="headerlink" title="无监督句法分析"></a>无监督句法分析</h1><p><img src="2.jpg" alt><br>上图是句法树解码算法，类似于句法距离那篇论文的解码算法。<br>因为$a^l$表示的是相邻两个单词属于同一个短语的概率，所以首先找最小的$a_k^l$，然后从这里将短语划分为两个子短语，然后递归划分下去。<br>但是这样效果可能不是很好，因为单个一层表示的短语范围其实是有限的，并不能很好的囊括所有的短语。<br>所以像上图一样，从最高层开始递归开始解码。<br>首先找到最小值$a_b^l$，如果$a_b^l$大于阈值（实验中为0.8），那说明这个分割点不可信。<br>如果这时候已经到了第$m$层（实验中设为3），那没办法了，说明了这些单词没有分割点，全当作一个短语就行了。<br>如果还没到第$m$层，那就继续往下一层找分割点。<br>而如果小于阈值，说明分割点可信，那就这么划分下去好了。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>首先是在WSJ测试集上的无监督句法分析结果：<br><img src="3.jpg" alt><br>可以看到Tree-Transformer效果还是好于之前的ON-LSTM和PRPN的，虽然比在NLI上训练的DIORA略差，但也情有可原，毕竟人家训练集大，而且是全局解码，<br>甚至还达到了URNNG的效果。而层数选择10层是效果最好的。</p><p>然后是在WSJ10测试集上的无监督句法分析结果：<br><img src="4.jpg" alt><br>可以看到，长度很短的时候Tree-Transformer效果就甚至不如PRPN了，和ON-LSTM相比其实也半斤八两。<br>论文并没有分析原因，甚至都没有提这个。</p><p>然后是采用不同的层做出来的无监督句法分析结果：<br><img src="5.jpg" alt><br>可以看到，最小递归到第三层的时候结果最好，而看的层数越少，也就是只看高层的，效果非常的差。<br>只看单独一层的效果也不大行，这都说明了高层的表示更加的抽象，其实不大适宜句法信息的表示。<br>而低层又太接近单词层面了，都是表面信息。<br>这其实和最近的一篇解释bert中attention含义的论文结果一致，中间层的attention表示的是句法信息。</p><p>最后是语言模型的困惑度结果：<br><img src="6.jpg" alt><br>这里就只和普通的Transformer相比了，结果还是更好的。<br>因为这里得用masked LM做目标函数，所以没法和ON-LSTM、PRPN等语言模型相比。</p><p>其他关于attention解释性等讨论详见论文，我觉得没有多大意思，attention的可解释性最近争论一直很大，强行解释没有意义。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文提出的Tree Transformer用成分先验表示两个单词属于同一个短语的概率，然后和self-attention联合决定两个单词之间的attention。<br>并且提出了一种解码出句法树的算法，但是还存在着一些问题。</p><p>文中说尝试过用Transformer预训练Tree Transformer，这样loss下降的更低了，拟合的更好，但是解码出的句法树效果更差了。<br>这其实是有道理的，之前见过一篇分析论文，提到了语言模型训练的好，并不一定代表着句法树学的好，这两者不能划等号。<br>所以今后如何选择更好更合适的损失函数，值得研究。</p><p>这里面还有一些文章可以做，我总感觉本文模型的attention计算方式还是挺牵强的，特别是得分归一化那里，强行将单词左右邻居视为两种不同的角色。<br>下一步工作我可以在上面进行改进，换一种全新的attention计算方式试试，另外损失函数上面考虑到前一篇文章提到的乱序问题，可以尝试用还原词序作为目标任务。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 生成模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[TACL19]生成模型还在用自左向右的顺序？这篇论文教你如何自动推测最佳生成顺序</title>
      <link href="/2020/01/05/tacl19-indigo/"/>
      <url>/2020/01/05/tacl19-indigo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/abs/1902.01370" target="_blank" rel="noopener">Insertion-based Decoding with automatically Inferred Generation Order</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>大多数的生成模型（例如seq2seq模型），生成句子的顺序都是从左向右的，但是这不一定是最优的生成顺序。<br>可能有人要说，反正最终都是生成一个句子，跟生成顺序有啥关系？<br>但是大量实验确实表明了从左向右生成不一定是最好的，比如先生成句子中的核心词（出现词频最高的词，或者动词等）可能效果会更好。</p><p>于是这篇论文就提出了自动推测最佳的生成顺序，考虑所有顺序的概率，优化概率之和。<br>但是对于任意一个生成顺序，如何还原原本的句子呢？<br>本文又提出了一个相对位置编码的方案，并且融合到了Transformer里。</p><h1 id="传统序列生成模型"><a href="#传统序列生成模型" class="headerlink" title="传统序列生成模型"></a>传统序列生成模型</h1><p>给定一个输入句子$x$，生成的句子$y$的概率可以被建模为：<br>\[<br>        p_{\theta}(y | x) = \prod_{t=0}^{T}{p_{\theta}(y_{t+1}|y_{0:t}, x_{1:T’})}<br>\]<br>其中规定输出句子的首尾单词$y_{0}$和$y_{T+1}$是特殊记号。</p><p>那么模型最大化正确输出的概率就行了。<br>解码的时候在每个时刻取概率最大的输出单词就行了，当然也可以加上beam search等方法提高性能。</p><h1 id="InDIGO"><a href="#InDIGO" class="headerlink" title="InDIGO"></a>InDIGO</h1><p>本文将生成顺序看作隐变量$\pi$，那么对于一个输出句子$y$，他的隐变量可能取值是阶乘级别的。<br>我们取所有顺序的概率之和，作为输出$y$的概率：<br>\[<br>    p_{\theta}(y|x) = \sum_{\pi \in \mathcal{P}_{T}}{p_{\theta}(y_{\pi}|x)}<br>\]<br>而每个生成顺序的概率被定义为：<br>\[<br>    p_{\theta}(y_{\pi}|x) = p_{\theta}(y_{T+2}|y_{0:T+1}, z_{0:T+1}, x_{1:T’}) \cdot \prod_{t=1}^T{p_{\theta}(y_{t+1}, z_{t+1}|y_{0:t}, z_{0:t}, x_{1:T’})}<br>\]<br>这里多了一个变量$z$，用来表示生成的单词在原句子中的绝对位置。<br>还多了一项$y_{T+2}$，表示句子生成结束。<br>为什么要用这一项呢？因为原来的结束符号&lt; /s&gt;被当作第二项输入进序列了。</p><p>这里就会出现一个问题，在每一步预测的时候，都不知道最终句子长度是多少。<br>那么怎么知道绝对位置$z$是多少呢？所以要用相对位置$r$来进行编码。</p><p>假设在$t$时刻，对于第$i$个单词$w_i$，采用一个向量来表示它的相对位置，每个维度取值只有-1，0和1三种。<br>$r_{i,j}$定义为：如果$w_i$绝对位置在$w_j$的左边，就取-1；如果是一个词，就取0；如果在右边，就取1。<br>可以观察到这个时刻向量长度其实只有$t+1$，而且下个时刻长度就会加1。<br>将这些向量拼接成一个矩阵$R$，每一列表示一个单词的位置向量，这个矩阵关于主对角线对称的元素其实是相反数。</p><p>那么下一个时刻是不是这个矩阵得重算呢？不需要。<br>因为下一个单词无论插在哪里，都不会影响之前的单词的相对顺序，所以只要给这个矩阵$R$新增一行一列即可：<br><img src="1.jpg" alt></p><p>但是$r_{t+1}$不能随便取值，不然可能是非法的，没办法还原到绝对位置。<br>所以这里定义$r_{t+1,j}$这么算：<br>首先预测一个单词$y_{k}$，然后预测$y_{t+1}$插入到它的左边还是右边。<br>如果$j = k$，那么如果插入到左边，值取-1，插入到右边取1。<br>如果$j \neq k$，那么$y_{t+1}$和前面单词的相对顺序其实是和$y_k$和他们的相对顺序完全相同的，那么直接取$r_{k, j}$就行了。</p><p>伪代码如下：<br><img src="2.jpg" alt></p><p>最后得到了相对位置之后，怎么还原为绝对位置呢？<br>只需要用下面式子就行了：<br>\[<br>    z_i = \sum_{j}{\max\{0, r_{i, j}\}}<br>\]<br>也就是看每个单词前面有多少单词。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>本文只修改了Transformer的解码器部分，因为对于随机的生成顺序，解码的时候绝对位置未知，所以传统的绝对位置编码行不通。</p><p>稍稍修改attention的计算方式：<br>\[<br>    e_{i, j} = \frac{(u_i^{\top}Q)\cdot(u_j^{\top}K + A_{[r_{i,j}+1]})^{\top}}{\sqrt{d_{\text{model}}}}<br>\]<br>其中$u$是输出的隐层表示，$Q, K, A$是参数，$A$根据相对位置不同分为三个向量表示。</p><p>经过attention计算之后，得到了当前已预测词的表示矩阵$H$，那么下一个词和对应相对位置概率为：<br>\[<br>    p(y_{t+1}, r_{t+1}|H) = p(y_{t+1}|H)\cdot p(r_{t+1}|y_{t+1}, H)<br>\]<br>也就是先预测下一个单词是什么，再预测它的相对位置。当然也可以倒过来，只是实验效果不如这个。</p><p>预测单词的概率：<br>\[<br>    p_{\text{word}}(y|H) = \text{softmax}((h_t^{\top}F)\cdot W^{\top})<br>\]</p><p>预测下一个词应该插在哪个位置：<br>\[<br>    p_{\text{pointer}}(k|y_{t+1}, H) = \text{softmax}((h_t^{\top}E + W_{[y_{t+1}]})\cdot [H^{\top}C; H^{\top}D]^{\top})<br>\]<br>注意到这里不仅拼接上了下一个词的词向量，还区分了每个词左边和右边的隐层表示。</p><blockquote><p>其实这里有个问题，一个词在$w_i$的右边不就等价于在$w_{i+1}$的左边吗？那其实这两个预测结果都是对的。虽然最后的$r$向量都是一样的。</p></blockquote><h1 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h1><p>因为一个句子的可能排列顺序太多了，不可能一一枚举，所以这里最大化ELBO来代替最开始的概率之和。<br>对于输入$x$和生成$y$，首先定义一个生成顺序$\pi$的近似后验$q(\pi|x, y)$。<br>然后ELBO可以表示为：<br><img src="4.jpg" alt><br>注意这里如果近似后验训练中固定不变的话，第二项可以忽略。</p><p>然后就可以根据近似后验来进行采样，优化这个函数了，那么这个近似后验怎么定义呢？</p><p>第一种方法是定义为一个常见的确定的顺序，比如从左向右、从右向左等等，详见下表：<br><img src="5.jpg" alt><br>这种情况下，模型其实就变成了和普通的序列生成模型差不多了，只用最大化一个生成顺序的概率就行了，区别就是多了相对位置编码。</p><p>第二种方法是用beam search，这里称作Searched Adaptive Order (SAO)。<br>传统的序列生成模型其实也有beam search，不过那是在每个时刻解码概率最大那些子序列。<br>而这里的beam search空间更大，搜索的是整个排列的空间。<br>也就是在每个时刻，遍历所有的下一个单词和它的相对位置，找出最大的$B$个子序列。<br>最后的目标函数变为了：<br>\[<br>    \mathcal{L}_{\text{SAO}} = \frac{1}{B} \sum_{\pi \in \mathcal{B}}{\log{p_{\theta}(y_{\pi}|x)}}<br>\]<br>这里近似后验被定义为了：如果$\pi$在$\mathcal{B}$中，概率为$\frac{1}{B}$，否则为0。</p><p>还有一些小trick，比如beam search加入噪声，这样可能采样到概率比较小的那些排列。<br>还有位置预测模块收敛的比单词预测模块更快，这就会导致模型最后总是先预测出高频词或功能词（大雾。。。）。<br>解决方法是先用给定的顺序（例如从左向右）预训练一遍模型，然后再训练beam search模型。</p><p>最终解码还是用上面的伪代码，只是加入了beam search。<br>但是这里是先预测的单词，再预测的位置，和训练时的beam search略有不同。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>实验主要做了几组机器翻译、词序还原、代码生成和图像标签生成，这里就简单看一下机器翻译结果，其他的详见论文。</p><p>机器翻译结果如下：<br><img src="6.jpg" alt></p><p>可以看出beam search的提升还是挺大的，而用随机顺序生成序列效果很差，用句法树的遍历顺序生成也挺差的。</p><p>其他的实验细节和结果详见论文，这里就不展开分析了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇论文提出了考虑多种序列生成的顺序，以此提升最终生成的效果，实验证明还是有效的。<br>为了记住这种顺序，还提出了相对位置表示，用来解决原始Transformer无法表示随机排列的问题。</p><p>但是总感觉beam search和相对位置表示的矩阵不是很优雅，很繁琐。<br>后续工作也提到了直接预测排列，而不是用beam search。<br>还有这种相对位置表示能否用在其他任务上，比如做成通用的位置表示？<br>不过这种“打乱顺序”的思想倒是挺不错的，很多地方可以用，毕竟人类看句子第一眼可能也会看到核心关键词嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> TACL </tag>
            
            <tag> 生成模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信聊天记录深度分析，看看这一年你和谁最亲密</title>
      <link href="/2019/12/29/wechat-analysis/"/>
      <url>/2019/12/29/wechat-analysis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>2019年就要过去了，想知道你平时用的最多的词是什么吗？想知道你一天中哪个时间段聊天最多吗？想知道这一年谁和你聊的最多吗？<br>本文将会一步一步地教你如何导出微信聊天记录，并且对它们进行深入分析。</p></blockquote><h1 id="导出微信聊天数据"><a href="#导出微信聊天数据" class="headerlink" title="导出微信聊天数据"></a>导出微信聊天数据</h1><p>这一步是最为关键的，没有数据何谈分析？<br>在之前的教程中，我已经教过了如何导出微信聊天记录到电脑（仅限安卓）。<br>详见之前的博文：<a href="https://godweiyang.com/2019/08/09/wechat-explore/">https://godweiyang.com/2019/08/09/wechat-explore/</a>。</p><p>下载所需要的两个python处理脚本：<br><a href="https://github.com/godweiyang/wechat-analysis" target="_blank" rel="noopener">https://github.com/godweiyang/wechat-analysis</a></p><h1 id="表格结构分析"><a href="#表格结构分析" class="headerlink" title="表格结构分析"></a>表格结构分析</h1><p>在第9个步骤之后，你就会得到下面这样的一张excel表格：</p><p><img src="1.jpg" alt="微信聊天记录表格"></p><p>这个表格有很多列。<br><code>msgId</code>列表示消息的序号。<br><code>type</code>列表示消息的类型，我们这里只需要用到类型1。<br><code>isSend</code>列表示是发送（1）还是接收（0）的消息。<br><code>createTime</code>列表示消息的时间，不过这里用的是相对时间，单位是毫秒，所以计算的时候要特别注意。<br><code>talker</code>列表示聊天的对象，如果有后缀<code>@chatroom</code>就表示是群聊，如果有前缀<code>gh_</code>就表示是公众号消息，其他的全部都是私聊。<br><code>content</code>列表示消息内容。</p><p><strong>首先将<code>type</code>列只勾选1，因为其他信息都是我们不需要的。</strong></p><h1 id="这一年聊天出现最多的词是什么？"><a href="#这一年聊天出现最多的词是什么？" class="headerlink" title="这一年聊天出现最多的词是什么？"></a>这一年聊天出现最多的词是什么？</h1><p>这个部分我们细分为四个类型，分别是私聊发送的消息，私聊接收的消息，群聊发送的消息和群聊接收的消息。</p><p><strong>私聊发送的消息：</strong><br>第一行<code>isSend</code>列勾选1，<code>talker</code>列去掉所有后缀<code>@chatroom</code>和前缀<code>gh_</code>的勾。<br>然后得到如下的表格：</p><p><img src="2.jpg" alt="私聊发送消息汇总"></p><p>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_send_person_2019.txt</code>，并粘贴进去。<br><img src="3.jpg" alt="选中第I列"></p><p><strong>私聊接收的消息：</strong><br>第一行<code>isSend</code>列勾选0，<code>talker</code>列去掉所有后缀<code>@chatroom</code>和前缀<code>gh_</code>的勾。<br>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_receive_person_2019.txt</code>，并粘贴进去。</p><p><strong>群聊发送的消息：</strong><br>第一行<code>isSend</code>列勾选1，<code>talker</code>列勾选所有后缀<code>@chatroom</code>。<br>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_send_group_2019.txt</code>，并粘贴进去。</p><p><strong>群聊接收的消息：</strong><br>第一行<code>isSend</code>列勾选0，<code>talker</code>列勾选所有后缀<code>@chatroom</code>。<br>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_receive_group_2019.txt</code>，并粘贴进去。</p><p>然后这四个txt文件就可以分别生成词云了。<br>生成词云的方法请看我之前的教程：<a href="https://godweiyang.com/2019/07/27/wordcloud/">https://godweiyang.com/2019/07/27/wordcloud/</a>。</p><p>最终的效果图如下所示：<br><img src="4.jpg" alt="私聊发送消息词云"><br><img src="5.jpg" alt="私聊接收消息词云"><br><img src="6.jpg" alt="群聊发送消息词云"><br><img src="7.jpg" alt="群聊接收消息词云"></p><h1 id="你最喜欢在哪一个时间段发消息？"><a href="#你最喜欢在哪一个时间段发消息？" class="headerlink" title="你最喜欢在哪一个时间段发消息？"></a>你最喜欢在哪一个时间段发消息？</h1><p>首先<code>talker</code>列去掉前缀<code>gh_</code>的勾，其他全部勾选上。<br>然后注意到<code>createTime</code>列默认用的是科学计数法，所以修改一下。<br>选中G列，右键点<code>单元格格式-自定义</code>，<code>类型</code>一栏填写0，确认。<br>然后就会变成下面这样：<br><img src="10.jpg" alt="去除科学计数法"></p><p>然后选中G列，复制粘贴到新建的<code>wechat_send_all_time_2019.txt</code>。<br>注意要把第一行的列名去掉。</p><p>然后就是数据处理与画图部分了。</p><p>直接运行命令：<br><code>python3 process_time.py wechat_send_all_time_2019.txt</code></p><p>出来的效果图如下：<br><img src="8.jpg" alt="各个时间段发送消息数"></p><h1 id="这一年你和谁互动最多？"><a href="#这一年你和谁互动最多？" class="headerlink" title="这一年你和谁互动最多？"></a>这一年你和谁互动最多？</h1><p>首先<code>talker</code>列去掉后缀<code>@chatroom</code>和前缀<code>gh_</code>的勾，其他全部勾选上。<br>然后<code>isSend</code>列0和1都勾上。<br>然后选中H和I列，粘贴到新建的<code>people.txt</code>。</p><p>直接运行命令：<br><code>python3 process_people.py people.txt</code></p><p>出来的效果图如下：<br><img src="9.jpg" alt="和你互动最多的前10个人"></p><p>注意这里用户名并不会显示出来，只会显示微信的id，所以你需要去excel表格里一个个搜索看聊天内容，自己手动看是谁。</p><p>最后安利一下我的公众号，大家可以关注一下，不定期分享NLP专业知识和计算机知识：<br><img src="11.jpg" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[ACL18]一个句子向量表示究竟可以塞进多少语言性质？</title>
      <link href="/2019/12/25/acl18-probe/"/>
      <url>/2019/12/25/acl18-probe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/P18-1198/" target="_blank" rel="noopener">What you can cram into a single $&amp;!#* vector: Probing sentence embeddings for linguistic properties</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文主要探究了不同encoder在不同任务上训练得到的句子向量表示，是否蕴含了各种语言性质。</p><p><img src="1.png" alt></p><p>本文主要有三个贡献点：</p><ul><li>分析了三种类型的encoder，并在7个任务上预训练句向量。</li><li>提出了10种探测任务。</li><li>每个探测任务探究一种语言性质。</li></ul><h1 id="探测任务"><a href="#探测任务" class="headerlink" title="探测任务"></a>探测任务</h1><p>为了探测这些性质，作者提出了10种探测任务，并分成了三个类别，分别用来探测句子的表面信息、句法信息和语义信息。</p><p>这10种探测任务有一些共同点：</p><ul><li>数据集都是作者手工设计的，用来做分类任务。</li><li>数据集基于Toronto Book Corpus，句子长度只挑选了5到28的。</li><li>训练集大小100k，验证集和测试集都是10k。</li><li>数据集里的偏差都被人工去除了（例如对某个类别预测影响很大的单词）。</li></ul><p>探测任务全部采用MLP进行分类。</p><h2 id="表面信息"><a href="#表面信息" class="headerlink" title="表面信息"></a>表面信息</h2><p>第1个任务是预测句子长度（<strong>SentLen</strong>）。<br>这个任务将句子长度划分成了6个区间，预测长度落在哪个区间里，所以最后是一个6分类任务。<br>这个任务用来探索句向量能否保留句子长度的信息。</p><p>第2个任务是预测一个句子里含有哪个关键词（<strong>WC</strong>）。<br>这个任务挑选出了1000个频率比较高的单词，预测一个句子中含有哪个单词。<br>数据保证一个句子中不会同时出现两个关键词。<br>这个任务用来探索句向量能否保留单词的信息。</p><h2 id="句法信息"><a href="#句法信息" class="headerlink" title="句法信息"></a>句法信息</h2><p>第3个任务是预测句子对应句法树第二层的label（<strong>TopConst</strong>）。<br>这个任务将句法树第二层（也就是根节点S的子结点）所有label拼接成一个label（比如ADVP_NP_VP），<br>然后挑选出频率最高的19种label，其他的都归为第20个label。<br>这个任务用来探索句向量能否抽取出句子的句法结构信息。</p><p>第4个任务是预测句子词序是否正确（<strong>BShift</strong>）。<br>这个任务随机调换句子中任意两个相邻单词，然后做2分类，预测是否调换过顺序。<br>这个任务用来探索句向量对词序是否敏感。</p><p>第5个任务是预测句子对应句法树的深度（<strong>TreeDepth</strong>）。<br>在实际数据集中，句法树深度都在5到12之间，所以这是一个8分类任务。</p><h2 id="语义信息"><a href="#语义信息" class="headerlink" title="语义信息"></a>语义信息</h2><p>第6个任务是预测句子的时态（<strong>Tense</strong>）。</p><p>第7个任务是预测句子主语单复数（<strong>SubjNum</strong>）。</p><p>第8个任务是预测句子宾语单复数（<strong>ObjNum</strong>）。</p><p>第9个任务是预测句子中名词或动词是否被替换过（<strong>SOMO</strong>）。<br>这个任务随机将句子中名词或者动词替换为其他名词或动词，然后2分类预测是否做过替换。<br>替换保证换过之后单词前后的bigram出现频次还是相似的。</p><p>第10个任务是预测一个带有从句的句子前后关系是否正确（<strong>CoordInv</strong>）。<br>比如“今天下雨了，因为我没出门。”这句话前后转折关系就反过来了。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>10种探测任务上的表现如下：</p><p><img src="2.jpg" alt></p><p>vote结果是随机的。<br>然后是人类分析结果，句法和语义信息也不能保证是100%正确。<br>Length是只用长度作为输入，可以看出只有SentLen预测正确了，其他都等于随机猜。<br>朴素贝叶斯方法对词信息比较敏感，WC任务效果很好。<br>BoV方法因为不包含词序信息，所以BShift任务很差，等于随机猜。</p><p>再看几种不同的编码器。<br>首先是用LSTM最后一个时刻隐层输出作为句向量。然后是每个维度用不同时刻的最大值作为句向量。最后是门卷积网络编码器。<br>采用的预训练任务有随机初始化，自编码器，机器翻译（三种语言），Seq2Tree，SkipThought（预测下一个句子）和NLI。<br>可以看出Seq2Tree训练出来的句向量在对句法敏感的几种性质上都取得了最好的结果。<br>比较两个LSTM编码器，可以发现采用max的向量表示效果更好。</p><p><img src="3.png" alt><br>上面这个图显示了不同的下游任务和10种语言性质之间的相关度，蓝色表示相关度高，红色表示低。<br>可以发现几乎所有的任务对于句子长度信息都不是很敏感，或者句子长度并不能有效地提升任务的性能。<br>再如SST2任务，情感分类任务的话对于单复数和句法结构信息可能也不是很敏感。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这篇论文主要就是提出了10种探测任务，用来探索模型的10种性质。<br>但是这篇论文里的方法其实还是有点问题的，就如上一篇control task所讲的那样，probe task的准确率并不一定能反应语言性质学习的好坏。<br>但是无妨，这些探测任务还是可以用在我们编码器或者预训练语言模型的分析中的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 可解释性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[EMNLP19]Designing and Interpreting Probes with Control Tasks</title>
      <link href="/2019/12/19/emnlp19-probe/"/>
      <url>/2019/12/19/emnlp19-probe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/D19-1275.pdf" target="_blank" rel="noopener">Designing and Interpreting Probes with Control Tasks</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>NLP任务都存在着一个常见的问题：<strong>我的神经网络有没有学到某个性质$Y$？</strong><br>所以我们需要构造出一种方法，来告诉我们模型是否真的学到了某些性质。</p><p>例如对于ELMo，我们想知道它是否学到了POS tag信息，所以我们需要设计一种探测任务（probe task）。</p><p><img src="1.jpg" alt></p><p>如上图所示，我们将句子输入到ELMo中，得到每个单词的上下文表示。<br>然后用probe函数（一般是MLP或者linear）进行分类，得到每个单词的POS tag。</p><p>注意到这里的ELMo是不进行fine-tune的，也就是固定住不变的，模型参数只有probe参数。</p><p>但是我们能否说，POS tag效果好，那么ELMo学的就好呢？<br>其实是不行的，因为有三点因素可能影响到最终的tag准确率：</p><ul><li>ELMo真的学到了POS tag信息。</li><li>probe函数设计的比较复杂，可以很好的拟合出POS tag分布。</li><li>POS tag任务的监督信息加的比较多。</li></ul><p>所以本文主要研究了如下三个问题：</p><ul><li>高的探测准确率是否意味着表示真的学到了某种性质？</li><li>探测方法对结果有着什么样的影响？</li><li>上面提到的三点影响因素对探测结论是否有影响？</li></ul><p>下面我们一一关注这三个问题。</p><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>首先答案是否定的，探测任务上准确率越高，并不能代表着表示学到了你想要的性质。</p><p><img src="2.jpg" alt></p><p>还是用ELMo和POS tag举例子，上面这个模型用1000隐层维度的MLP作为probe函数，最终取得了97.3的高准确率。<br>但是我们不能说EMLo能够很好的学到了POS tag信息，因为可能是MLP很好的拟合出了POS tag分布。</p><p>所以我们提出了<strong>控制任务（control task）</strong>的概念，也就是用同样的模型去预测一个随机任务。<br>例如对于POS tag任务，PTB数据集里一共有45个tag，我们给每个单词重新随机分配一个tag，然后用探测模型预测句子的随机tag。<br>这样其实有个小问题，就是消除了单词的一词多义问题，一个单词在所有语境下tag都是一样的了。</p><p><img src="3.jpg" alt></p><p>测试下来结果如上图所示。<br>可以看到MLP和linear对POS tag结果基本没有影响，都非常的高。<br>但是对control任务也就是随机tag影响很大，MLP并没有降低很多（92.8），但是linear降低了很多（71.2）。<br>于是我们将这个差值叫做<strong>selectivity</strong>。如果selectivity越大，说明probe函数影响越小，可能不是probe函数拟合出来的结果。<br>如果selectivity越小，说明不管是gold的label还是随机的label，准确率都很高，这就可能是probe函数拟合出来的结果了，而不是表示学出来的。</p><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>显然linear的学习能力明显不如MLP，那么不同的参数设置对最终结果是否有影响呢？</p><p><img src="4.jpg" alt></p><p>上图举了两个例子，分别是dropout和隐层维度对结果的影响。<br>可以看出简单的正则化对selectivity影响不是很大，但是隐层维度影响特别大。</p><p><img src="5.jpg" alt></p><p>具体的参数影响如上图所示，最终选取了使得准确率比较高，selectivity相对大的参数配置。</p><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><p>答案也是肯定的。</p><p><img src="6.jpg" alt></p><p>比如上面这个例子，一般认为ELMo第1层POS tag效果是要好于第2层的，probe测试下来也是这样。<br>但是可以发现，第2层的selectivity更大，说明其实第2层才更好的学到了POS tag信息。<br>那为什么第1层效果更好呢？可能是因为它更靠近单词层，所以保留了更多单词的信息。<br>这也说明了selectivity方法可能也不是完美的，可能通过聚类预测POS tag，第2层效果会更好。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>具体的实验细节和分析就不说了，大体就是这么个思想。<br>这篇主要就是说明了，光靠准确率并不能说明一个encoder的表示学到了某种性质，而可能是模型拟合的结果。<br>所以他们提出了control task，同时预测一个随机输出，如果准确率差距较大，则验证了表示学到了性质。<br>当然这个方法还有一些问题，比如probe函数的挑选，还有文中依存句法分析的control task的设计是有瑕疵的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 可解释性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一九年终总结</title>
      <link href="/2019/12/13/2019-conclusion/"/>
      <url>/2019/12/13/2019-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>2019年还有十几天就要过去了。<br>这一年依然是，忙忙碌碌，碌碌无为。<br>人老了，话也少了，今年不想写太多，学着敷衍一下吧。</p></blockquote><p>觉得《葡萄成熟时》歌词写的挺好的：</p><blockquote><p>但见旁人谈情何引诱<br>问到何时葡萄先熟透<br>你要静候再静候<br>就算失收始终要守</p></blockquote><h1 id="学术经历"><a href="#学术经历" class="headerlink" title="学术经历"></a>学术经历</h1><h2 id="论文投稿"><a href="#论文投稿" class="headerlink" title="论文投稿"></a>论文投稿</h2><p>都已经研二过去一半了，论文还是没发出来，还是在为毕业担忧。</p><p>研一一直搞得东西没啥新意，不大靠谱，自己都觉得很辣鸡。<br>果不其然，ACL 2019和CoNLL 2019都被拒了。<br>事实证明了，有监督的成分句法分析没有什么空间给你搞了，还是无监督的香。</p><p>最近的话又投了一下ACL 2020，换了一个完全不同的方法。<br>感觉上比上一篇靠谱很多，具体结果怎么样听天命吧。<br>顺便吐槽一下审稿的时间太长了吧，4月份才出结果。</p><p><img src="acl2020.png" alt="ACL 2020"></p><p>今年有幸和实验室大家一起去了杭州和香港参加了两次会议。</p><h2 id="AIS-2019"><a href="#AIS-2019" class="headerlink" title="AIS 2019"></a>AIS 2019</h2><p><img src="ais2019.jpg" alt="AIS 2019"><br>第一次是5月份去杭州参加的AIS 2019论文分享会。<br>虽然自己论文没中，但是能见到这么多的大佬还是很开心的。</p><p><img src="ais2019-gnn.jpg" alt="师兄纪焘会上做报告"><br>上面这张是牌面带师兄焘博对他的ACL 2019论文做报告。<br>什么时候站在台上的人能是我呀~~</p><p><img src="hangzhou1.jpg" alt="西湖"><br><img src="hangzhou2.jpg" alt="西湖"><br>上面两张是第一天过去时去西湖游玩的时候拍的。<br>小米8的自动修图是真的🐂🍺，拍出来就是这么美。</p><p><img src="hangzhou3.jpg" alt="音乐酒吧"><br>这是最后一天去酒吧喝酒玩剧本杀时候拍的，小哥唱歌不错。<br>以后能过上这样的生活多好呀，有酒，有歌，有个爱自己的她。</p><h2 id="EMNLP-2019"><a href="#EMNLP-2019" class="headerlink" title="EMNLP 2019"></a>EMNLP 2019</h2><p>第二次是去香港参加的EMNLP 2019国际会议，主要是沾了ypdu论文的光。</p><p><img src="emnlp1.jpg" alt="Manning"><br>有幸见到了好几位大佬，比如manning、eisner等等。<br>还看了很多的poster，和大牛们用蹩脚的英文交流了一下。</p><p><img src="emnlp2.jpg" alt="太平山顶"><br>这是在太平山顶俯瞰香港市中心。<br>亲眼看到了港片里才能看到的风景，虽然最近很乱，但还是很繁华啊。</p><p><img src="ypdu.jpg" alt="ypdu"><br>怎么能少了我们的主角呢？还是oral哦。<br>我也不求oral了，能不能让我做一回主角？</p><h2 id="IALP-2019"><a href="#IALP-2019" class="headerlink" title="IALP 2019"></a>IALP 2019</h2><p>我们学校今年还组织了一次学术会议，IALP 2019。<br>我负责网站的维护，当然也去现场听了两天的报告。</p><p><img src="ialp.jpg" alt="IALP 2019"><br>虽然没学到啥东西，不过还是面基了一下之前认识的妹子哈哈哈。<br>虽然妹子都不是单身的QAQ，但还是聊的很开心哈哈（强颜欢笑）。</p><h1 id="校园故事"><a href="#校园故事" class="headerlink" title="校园故事"></a>校园故事</h1><h2 id="勇哥毕业"><a href="#勇哥毕业" class="headerlink" title="勇哥毕业"></a>勇哥毕业</h2><p><img src="yongge.jpg" alt="晋西北铁三角"><br>勇哥毕业回他的老家去了，以后吃饭洗澡又少了一个人陪了。<br>但是召唤师峡谷还是常常能遇见，不知道多少年后还能再聚一回。</p><h2 id="带师兄毕业"><a href="#带师兄毕业" class="headerlink" title="带师兄毕业"></a>带师兄毕业</h2><p><img src="czsun.jpg" alt="czsun"><br>AntNLP最🐂🍺的带师兄czsun也毕业了，这儿的第一位博士。<br>和他相识也算是很早了，大一就加上好友了，就是没聊过。<br>虽然他也很憨憨，虽然王者农药是王者还菜的一笔，但不妨碍他的学术🐂🍺。</p><h2 id="猫君也走了"><a href="#猫君也走了" class="headerlink" title="猫君也走了"></a>猫君也走了</h2><p><img src="hcc.png" alt="CC"><br>czsun曾经的室友，大学第一个认识的研究生，和我一样也是水群达人。<br>我们有着共同的特点，我们都很强。<br>现在去了广州，一线城市里幸福感最高的城市，想想毕业后我要是能去也不错。<br>要是我中了论文，还得请他一顿烧烤，但愿能够兑现。</p><h2 id="温柔的男人像火苗"><a href="#温柔的男人像火苗" class="headerlink" title="温柔的男人像火苗"></a>温柔的男人像火苗</h2><p><img src="zgp.jpg" alt="🔥🔥🔥🔥🔥"><br>就让我来守护上面这个笑容⑧。<br>他有很多一起放鞭炮的炮友，还有一堆一起跑步的跑友。<br>他喜欢游走于各个实验室之间，虽然他亚索从来不游走，对线炸穿。<br>对了，有喜欢的妹子可以找我要他的vx，他很寂寞。</p><h2 id="兄弟团聚"><a href="#兄弟团聚" class="headerlink" title="兄弟团聚"></a>兄弟团聚</h2><p><img src="xiongdi.jpg" alt="撸串儿"><br>曾经一起打游戏的兄弟们也都去工作了，都在996为了生活卖命。<br>虽然在一个城市，也很少有机会团聚了。<br>依然记得上次去找钺哥小杰请我吃的饭，等工作了再约一波。</p><h2 id="14届入学5周年"><a href="#14届入学5周年" class="headerlink" title="14届入学5周年"></a>14届入学5周年</h2><p><img src="5years.jpg" alt="礼堂"><br>不知道入学五周年有什么好纪念的哈哈，莫名的喜感。</p><p><img src="5years-1.jpg" alt="聚餐"><br>虽然很多人都不是特别的熟悉，但还是回到了几年前的感觉。<br>不过还是缺了几位曾经洗澡的兄弟（昶臻），爷孙没能团聚还是遗憾。</p><h2 id="回闵行"><a href="#回闵行" class="headerlink" title="回闵行"></a>回闵行</h2><p><img src="minhang.jpg" alt="闵行图书馆"><br>因为办在读证明又回了一次闵行，又是一年半没回去过了，还是熟悉的回忆。<br>闵行还是那么的幽静，周围更加的繁华了，只是当时的人已经不在了。</p><h1 id="游戏人生"><a href="#游戏人生" class="headerlink" title="游戏人生"></a>游戏人生</h1><h2 id="小改改"><a href="#小改改" class="headerlink" title="小改改"></a>小改改</h2><p><img src="lol.jpg" alt="亚索手办"><br>因为搭建博客相识，因为爱打英雄联盟有了共同语言。<br>上面是小改改送的手办，非常的感动，甚至有点慌，有机会一定要见一见哈哈。<br>小改改技术还是非常棒的，就是太贪玩了啊。<br>希望你工作顺利，考研顺利，能找到一个爱自己的npy嘿嘿。<br>安利一下小改改的博客<a href="https://milyyy.github.io/" target="_blank" rel="noopener">https://milyyy.github.io/</a>，她是做前端的，很厉害哟。</p><h2 id="菜的离谱"><a href="#菜的离谱" class="headerlink" title="菜的离谱"></a>菜的离谱</h2><p><img src="zhanji.jpg" alt="艾欧尼亚战绩"><br>这一年技术也没有突飞猛进，顺手的时候战绩就像上面这样，逆风的时候，菜的就像czsun一样。<br>因为写论文也好久没玩了，列表里很多人也不上线了，有的工作了，有的弃坑了，大家都忙了。</p><h1 id="情感八卦"><a href="#情感八卦" class="headerlink" title="情感八卦"></a>情感八卦</h1><p>这一年，无心妹子，所以我没有八卦，让大家失望了。<br>在发出论文前，应该不会再找了，当然如果有合适的，还是会顺其自然的。</p><p>不过作为一个八卦收割机，我还是知道别人的很多八卦的。<br>不知道为什么，自己置身于感情之中，我就是一个失败者。<br>但是作为旁观者，我却能捕捉到许多别人观察不到的细节，道理更是一堆一堆的。</p><p>杭州AIS那会儿，我就观察到了一些细节，回来后再几件事情结合验证，果然成了。<br>香港EMNLP那会儿，还没发现什么，回来后通过各类细节大胆猜想，最后也得到了验证。<br>刚开始说给酸菜鱼我的猜想时，他说我在说胡话，不可能的事，是我真的猜错了吗？<br>后来的一件件事说明了我是对的，大家更是搬出了一件件证据印证我的猜想。<br>这也说明了一个科学实验的方法：大胆猜想，小心求证。</p><p><img src="film.jpg" alt="让我留在你身边"></p><p>希望有一天，我能够不再旁观别人的故事，创造自己的故事。<br>希望到时候，我不会因为置身事中而做出变形的操作。<br>《摆渡人》里面说过，时间一直走，没有尽头，只有路口。<br>希望下一个她，能陪我走到时间的尽头，能让我为之拼命。</p><blockquote><p>日后尽量别教今天的泪白流<br>留低击伤你的石头<br>从错误里吸收<br>也许丰收月份尚未到你也得接受<br>或者要到你将爱酿成醇酒<br>时机先至熟透</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成分句法分析综述（第二版）</title>
      <link href="/2019/08/15/con-parsing-summary-v2/"/>
      <url>/2019/08/15/con-parsing-summary-v2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>本文对成分句法分析近年来的进展做了一个比较完善的总结。分析了多种不同类型的成分句法分析模型（基于转移，动态规划和序列到序列等），比较了它们之间的优缺点，并总结了一些提升它们性能的技巧。最后，本文对成分句法分析的未来发展趋势表明了自己的一些看法。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>成分句法分析近年来取得了飞速的发展，特别是深度学习兴起之后，神经句法分析器的效果得到了巨大的提升。一般来说，句法分析器都可以分为编码模型和解码模型两个部分。编码模型用来获取句子中每个单词的上下文表示，随着表示学习的快速发展，编码模型也由最初的LSTM逐渐进化为了表示能力更强的Transformer （<a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">VaswaniSPUJGKP17</a>）。而解码模型方面，也诞生了许多不同类型的解码算法，比如基于<strong>转移系统</strong>（transition-based）的解码算法（<a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">WatanabeS15</a>, <a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">CrossH16</a>, <a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">LiuZ17a</a>），基于<strong>动态规划</strong>（chart-based）的解码算法（<a href="https://doi.org/10.18653/v1/P17-1076" target="_blank" rel="noopener">SternAK17</a>, <a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">KleinK18</a>）和基于<strong>序列到序列</strong>（sequence-to-sequence）的解码算法（<a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">BengioSCJLS18</a>, <a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">Gomez-Rodriguez18</a>）等等。</p><p>基于转移系统的句法分析模型主要通过预测生成句法树的动作序列来还原出一棵句法树。按照遍历树的顺序，具体还可以分为自底向上（bottom-up）的转移统（<a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">CrossH16</a>），自顶向下（top-down）的转移系统（<a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">WatanabeS15</a>）和基于中序遍历（in-order）（<a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">LiuZ17a</a>）的转移系统。基于转移系统的句法分析模型优点是速度快，因为它解码的时间复杂度是线性的。而缺点就是在解码的时候无法考虑短语的边界信息，这会导致解码的精度上相比于基于动态规划的模型稍微差一点。</p><p>基于动态规划的句法分析模型主要通过递归地预测每个短语得分最高的子短语，最后回溯还原出最优句法树。优点就是可以枚举出搜索空间中的所有句法树，解码效果比较好。但是动态规划算法时间消耗较大，复杂度是句子长度的平方级别的。所以针对这个缺点，又提出了近似的自顶向下的贪心解码算法（<a href="https://doi.org/10.18653/v1/P17-1076" target="_blank" rel="noopener">SternAK17</a>），按照句法树的前序遍历顺序进行搜索，在不损失太多性能的前提下，能大大加快解码的速度。</p><p>基于序列到序列的句法分析模型主要思想就是将句法树映射为一个唯一对应的序列表示，然后通过序列标注（<a href="https://aclanthology.info/papers/D18-1162/d18-1162" target="_blank" rel="noopener">Gomez-Rodriguez18</a>）或者序列生成（<a href="http://papers.nips.cc/paper/5635-grammar-as-a-foreign-language" target="_blank" rel="noopener">VinyalsKKPSH15</a>）的方式来预测出这个序列。根据句法树序列化的不同定义方式，模型也有许多不同的变体。这一类模型的优点就是速度极快，因为时间复杂度也是线性的，并且模型参数量比基于转移系统的模型少了很多。缺点也是显而易见的，由于预测出的序列需要有很强的约束，不然不能保证可以还原出一棵完整的句法树，所以最终的效果也没有前面两种模型理想。</p><p>此外还有许多其他类型的解码算法，比如直接利用神经网络来预测语法产生式的概率，模拟上下文无关文法，最后再利用传统的CKY算法来进行解码（<a href="https://aclanthology.info/papers/C18-1011/c18-1011" target="_blank" rel="noopener">TengZ18</a>）。该模型最终也取得了非常不错的效果，在单模型上的结果超过了之前的几种模型。</p><p>成分句法分析可以应用到许多下游任务中去，比如情感分析任务中，可以采用树状LSTM（Tree-LSTM）来对句子的句法树进行建模，从而分析出句子的情感（<a href="http://arxiv.org/abs/1503.04881" target="_blank" rel="noopener">ZhuSG15</a>）。也可以应用到其他基础任务中去，比如可以将训练好的成分句法树根据规则转化为依存句法树，从而提升依存句法分析的准确率（<a href="http://www.aclweb.org/anthology/W04-3228" target="_blank" rel="noopener">Gildea04</a>）。</p><h2 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h2><p>成分句法分析是自然语言处理中的一个基础任务，它的任务是给定一个长度为$n$的句子$(w_0, w_1, \ldots, w_{n-1})$，分析出句子的短语结构句法树$T$。例如给定句子“The little boy likes red tomatoes .”，它的成分句法树如图1所示。</p><p><img src="syntactic_tree.png" alt="图1：句子“The little boy likes red tomatoes .”对应的句法树。"></p><p>对于句法树$T$，有多种方式来对它进行表示。目前比较常用的是基于跨度（span）的表示（<a href="http://aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">CrossH16</a>），也就是将句法树表示成组成它的所有短语的集合。而对于每个短语，可以用三元组$(i, j, \ell)$来表示它，其中$i$和$j$表示这个短语的范围是从单词$w_i$到$w_j$，而$\ell$表示这个短语的非终结符标签。这样句法树$T$就可以表示为三元组$(i, j, \ell)$的集合：<br>$$<br>    T = \{(i, j, \ell) | (i, j, \ell) \in T\}.<br>$$<br>这样预测句法树的任务就可以转化为预测三元组$(i, j, \ell)$集合了。</p><p>当然一般还存在两个小问题，一是如果存在一元产生式怎么办？一种解决方法就是将一元产生式上面的所有非终结符全部拼接成一个新的非终结符，这样整个一元产生式就可以看成一个非终结符了。另一个问题是句法树不一定是二叉树，那么解码的时候就会增加许多搜索的复杂度。解决方法就是新增一个空的非终结符$\varnothing$，将非二叉产生式全部转化为多个二叉产生式，其中新增加的临时结点的非终结符全部定义为这个空的非终结符$\varnothing$，在还原句法树的时候直接忽略它就行了。</p><h2 id="编码模型"><a href="#编码模型" class="headerlink" title="编码模型"></a>编码模型</h2><p>给定句子$(w_0, w_1, \ldots, w_{n-1})$，编码模型的目的就是获得每个单词的上下文表示，并进一步计算出每个短语的向量表示。在实际实现中，一般将单词$x_i$的输入向量分为三部分。首先是它对应的随机初始化的嵌入向量$e_i$。然后是这个单词的词性对应的随机初始化的嵌入向量$p_i$，一般它的词性可以通过外部词性标注器来得到。最后是这个单词的字符级别表示$c_i$，这个一般可以通过字符级别的CNN或者LSTM来得到。最后将三部分向量拼接得到最终的输入向量$x_i$：<br>$$<br>    x_i = [e_i; p_i; c_i].<br>$$</p><p>然后将输入向量送入编码器，得到每个单词的上下文表示。而根据采用的编码器的不同，又可以将编码模型分为以下几种主要类型。</p><h3 id="LSTM编码"><a href="#LSTM编码" class="headerlink" title="LSTM编码"></a>LSTM编码</h3><p>这是最为常用的一种编码方式了，首先将所有$x_i$输入到双向LSTM中，得到每个位置的前向隐层表示$\mathord{\buildrel{\hbox{$\scriptscriptstyle\rightarrow$}}\over{h}}_i$和后向隐层表示$\mathord{\buildrel{\hbox{$\scriptscriptstyle\leftarrow$}}\over{h}}_i$。然后对于短语$(i, j)$，它可以表示为：<br>$$<br>    s_{ij} = [\mathord{\buildrel{\hbox{$\scriptscriptstyle\rightarrow$}}\over{h}}_j - \mathord{\buildrel{\hbox{$\scriptscriptstyle\rightarrow$}}\over{h}}_i; \mathord{\buildrel{\hbox{$\scriptscriptstyle\leftarrow$}}\over{h}}_i - \mathord{\buildrel{\hbox{$\scriptscriptstyle\leftarrow$}}\over{h}}_j].<br>$$<br>这样就得到了短语$(i, j)$的向量表示$s_{ij}$，接着就可以计算出它的得分，然后利用解码模型解码出最优的句法树。</p><h3 id="Transformer编码"><a href="#Transformer编码" class="headerlink" title="Transformer编码"></a>Transformer编码</h3><p>虽然LSTM编码用的最多，但是要问最近这段时间最火的模型是什么，那当然是<strong>Transformer</strong>了（<a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">VaswaniSPUJGKP17</a>）。它可以充分利用GPU的并行计算优势，加快计算速度。还可以利用注意力机制，增强对句子的表示能力。</p><p><img src="multi_headed_attention.jpg" alt="图2：Transformer结构。"></p><p>Transformer的输入有三个，查询（query）向量矩阵$Q$，键（key）向量矩阵$K$和值（value）向量矩阵$V$。<br>输出就是查询向量对每个键向量的注意力，然后对值向量加权求和的结果。用矩阵形式表示就是：<br>$$<br>    {\rm Attention}(Q, K, V) = {\rm softmax}(\frac{QK^{\top}}{\sqrt{d_k}})V.<br>$$<br>当然还可以加入多头（multi-head）注意力机制，增强表示能力，具体这里不再赘述，可以参看原论文。最后将输出乘以参数矩阵${\bf W}_O$映射回需要的输出维度，得到最终的输出矩阵$H$，具体结构如图2所示。</p><p>在本文中，$Q$，$K$和$V$三个矩阵都是通过对句子的输入向量拼接而成的矩阵$X$，分别乘以参数矩阵${\bf W}_Q$，${\bf W}_K$和${\bf W}_V$得到的。但是要注意的一点是，在此前的输入向量$x_i$的基础之上，还得再拼接上每个单词的位置向量$p_i$，不然矩阵运算会丢失单词的位置信息。</p><p>得到输出矩阵之后，接下来计算短语的表示方法和LSTM编码是类似的。</p><h3 id="递归神经网络编码"><a href="#递归神经网络编码" class="headerlink" title="递归神经网络编码"></a>递归神经网络编码</h3><p>递归神经网络在自然语言处理中的应用最早是在（<a href="http://aclweb.org/anthology/P/P13/P13-1045.pdf" target="_blank" rel="noopener">SocherBMN13</a>）中提出的。虽然当时取得了不错的效果，但是近些年来递归神经网络已经很少有人使用了，主要因为它存在梯度消失，需要句法树等问题，并且它的初衷（编码树结构信息）由循环神经网络LSTM基本也可以学到，所以没有必要用这种不能并行的网络结构。</p><p>对于短语$(i, j)$，如果它的两个儿子结点是$(i, k)$和$(k, j)$，那么$s_{ij}$就可以由$s_{ik}$和$s_{kj}$计算得到：<br>$$<br>    s_{ij} = f({\bf W}[s_{ik};s_{kj}]+{\bf b}),<br>$$<br>其中，$f$是激活函数，一般可以取${\rm tanh}$。</p><p>当然这种结构现在已经很少使用了，现在用的较多的递归结构是树状LSTM，网络结构和递归神经网络基本相同，唯一的区别就是将计算单元$f$替换成LSTM中的隐层单元，这样可以有效地解决梯度消失和长距离依赖的问题。</p><h3 id="得分计算"><a href="#得分计算" class="headerlink" title="得分计算"></a>得分计算</h3><p>采用以上几种编码模型得到了每个短语的向量表示之后，接下来可以用两层前馈神经网络计算出它的得分：<br>$$<br>    \begin{aligned}<br>        s_{\rm{label}}(i, j, \ell) &amp; = {\bf v}_{\ell}^{\top}f({\bf W}_{\ell}^2f({\bf W}_{\ell}^1s_{ij} + {\bf b}_{\ell}^1) + {\bf b}_{\ell}^2), \\<br>        s_{\rm{span}}(i, j)        &amp; = {\bf v}_s^{\top}f({\bf W}_{s}^2f({\bf W}_{s}^1s_{ij} + {\bf b}_{s}^1) + {\bf b}_{s}^2),<br>    \end{aligned}<br>    \tag{1}<br>$$<br>其中$f$是激活函数，这里通常取${\rm ReLU}$。这里我们将短语$(i, j)$的得分分成了两部分，一部分是它的非终结符$\ell$的得分$s_{\rm{label}}(i, j, \ell)$，一部分是跨度的得分$s_{\rm{span}}(i, j)$。</p><p>最后，定义一棵句法树的总得分为它包含的所有短语的标签得分与跨度得分之和：<br>$$<br>    s_{\rm tree}(T) = \sum\limits_{(i, j, \ell) \in T}{s_{\rm{label}}(i, j, \ell) + s_{\rm{span}}(i, j)}.<br>$$<br>而接下来要介绍的解码模型的任务，就是去寻找一棵句法树，使得它的得分最高。</p><h2 id="基于转移系统的解码算法"><a href="#基于转移系统的解码算法" class="headerlink" title="基于转移系统的解码算法"></a>基于转移系统的解码算法</h2><p>基于转移系统的解码模型主要分为三种。第一种是自底向上的转移系统，第二种是自顶向下的转移系统，最后一种是基于中序遍历的转移系统。这些转移系统的共同点是都包含两个组成成分，一个是栈（stack），用来存放已分析的句法结构，另一个是缓存（buffer），用来存放待分析的句子。而预测句法树结构就转化为了预测转移系统每一个时刻应该采取的动作（action）序列。下面我们分别介绍几种不同的转移系统，我们用三元组$[S, B, T]$来表示转移系统每一个时刻的状态，分别代表栈顶元素、缓存的第一个单词和句法分析结束标志。</p><h3 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h3><p>自底向上的转移系统是根据句法树的后序遍历（post-order）顺序进行句法分析的，首先将缓存中的单词移进栈里，然后将栈顶的若干个单词归约为它们的父结点，直至最后缓存为空并且栈里只有一个根节点。</p><p><img src="bottom_up.png" alt="图3：自底向上的转移系统动作定义。"></p><p>自底向上转移系统的动作形式化定义如图3所示，其中移进（SHIFT）动作就是将缓存里面的第一个单词移进栈里。归约（REDUCE-L/R-X）动作就是将栈顶的两个元素出栈，并且归约为它们的父结点X，然后再将父结点入栈，而L和R就是用来区分左儿子和右儿子谁是头结点。一元（Unary-X）动作就是将栈顶元素出栈，并且归约为父结点X，这个动作是用来预测一元产生式的。最后完成（FINISH）动作用来判断句法分析是否结束。</p><p>注意到这里有一个问题，自底向上转移系统一般要提前对句法树进行二叉化。主要原因是因为自底向上系统有个弊端，就是在不停地移进之后，你不仅要预测哪一步开始归约，还得预测归约的话要归约栈顶的多少个元素，这样预测的状态数就大大增加，导致训练时间也增加了许多。而二叉化后每次预测就只需要预测哪一步归约就行了，每次归约只归约栈顶的两个元素。</p><p><img src="bottom_up_example.png" alt="图4：自底向上的转移系统的一个例子。"></p><p>对于图1中的句法树，用自底向上转移系统分析的过程如图4所示。</p><p>自底向上转移系统的优点就是可以充分利用已经生成的子树信息，来帮助父结点的非终结符预测。但是缺点也很显然，因为无法知道父结点以及再上层的父结点信息，所以丢失了许多有用的全局信息。另一个缺点就是需要提前进行二叉化，虽然二叉化加入了头结点（head）信息，事实证明是很有用的，但是头结点的标注需要许多语义学知识，非常的耗时耗力。一个较为简洁的做法就是，用空结点$\varnothing$来作为句法分析中临时结合两个子结点而产生出的，但是在正确句法树中不存在的结点。在还原树结构的时候忽略这种空结点，这样就可以隐式地进行二叉化操作了。</p><h3 id="自顶向下的转移系统"><a href="#自顶向下的转移系统" class="headerlink" title="自顶向下的转移系统"></a>自顶向下的转移系统</h3><p>自顶向下的转移系统利用的是句法树的前序遍历（pre-order）序列，首先将父结点入栈，然后不断操作直到它的子结点全部入栈，这时将父结点连同所有子结点全部归约为一个结点，也就是这个父结点自身。</p><p><img src="top_down.png" alt="图5：自顶向下的转移系统动作定义。"></p><p>自顶向下转移系统的动作形式化定义如图5所示，其中移进动作和之前一样，都是将缓存的第一个单词入栈。而非终结符（NT-X）动作就是将非终结符X入栈，也就是接下来的子树的父结点就是X。归约动作就是将栈顶若干个元素，一直到之前移进的那个父结点为止都出栈，然后归约为一个结点，再次入栈。注意到这里不同于自底向上转移系统的地方是没有完成动作，因为自底向上系统存在一元动作，所以最后根节点可能会无限归约下去，因此需要通过完成动作来提前终止分析。当然其实转移系统的动作定义并没有严格的要求，不同论文定义的也都不一样，但是都大同小异，也就是都存在移进和归约这两个动作，所以这些转移系统又可以叫做移进-归约系统。</p><p>对于图1中的句法树，用自顶向下系统分析的过程如图6所示。</p><p><img src="top_down_example.png" alt="图6：自顶向下的转移系统的一个例子。"></p><p>自顶向下转移系统的优缺点和自底向上转移系统恰好互补。优点就是可以充分利用全局信息，例如父结点的信息，并且不需要提前进行二叉化，因为归约的时候只要找到栈里第一个非终结符就行了。而缺点就是无法利用局部信息，也就是已经分析好的子树信息，同样非终结符动作也可能会出现无限多次执行的情况，所以要加上一些限制条件。</p><h3 id="基于中序遍历的转移系统"><a href="#基于中序遍历的转移系统" class="headerlink" title="基于中序遍历的转移系统"></a>基于中序遍历的转移系统</h3><p>基于中序遍历的转移系统利用的是句法树的中序遍历（in-order）序列，首先将最左边的子结点移进栈里，然后将父结点入栈，再不断操作直到该父结点的剩余子结点全部入栈，然后对它们进行归约。</p><p><img src="in_order.png" alt="图7：基于中序遍历的转移系统动作定义。"></p><p>基于中序遍历的转移系统的动作形式化定义如图7所示，其中移进动作和之前一样，都是将缓存的第一个单词入栈。映射非终结符（PJ-X）动作是预测出当前栈顶的元素的父结点X。归约动作就是将栈顶的若干个元素归约为最里面倒数第二个元素，也就是它们的父结点。</p><p><img src="in_order_example.png" alt="图8：基于中序遍历的转移系统的一个例子。"></p><p>对于图1中的句法树，用基于中序遍历的系统分析的过程如图8所示。</p><p>根据经验，当我们读一个短语时，我们通常会注意到它的第一个单词，然后我们可以根据观察到的词推断出短语的类型。例如，当我们读到“likes”这个词时，我们可以假设紧跟着这个词的是一个动词短语。而后面的单词“red tomotoes”只是这个动词短语的宾语。与自顶向下的转移系统相比，“likes”中的局部信息对于识别这是一个动词短语可能至关重要。此外，动词短语（VP）中的全局信息也有利于之后的预测。</p><p>基于中序遍历的转移系统的优点恰好结合了前面两种转移系统，既可以考虑到局部信息，又可以考虑到全局信息。</p><h3 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h3><p>之前介绍的三种转移系统都属于判别式模型，而基于自顶向下转移系统，又诞生出了一种生成式模型——<strong>循环神经网络文法</strong>（RNNG）。循环神经网络文法本质上就是自顶向下的转移系统，动作定义和章节<strong>自顶向下的转移系统</strong>介绍的基本一致。只是之前介绍的自顶向下的转移系统是判别式模型，每次移进的单词都是缓存中给定正确的单词。而循环神经网络文法每次移进的单词需要通过动作生成（GEN-X）预测得出，最终模型对预测出来的句子分析出句法树。</p><p>正式定义就是，对于句子$x$和对应的句法树$y$，判别式模型是对条件概率$p(y | x)$进行建模，而生成式模型是对联合概率$p(x, y)$进行建模。</p><p>而循环神经网络文法的另一个重要应用是语言模型（language model），也就是建模$p(x)$。因为$p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}$，所以只需要枚举出所有可能的句法树$y$即可，但是这是指数级别的，显然不现实，这时候就需要用到“<strong>重要性采样</strong>（importance sampling）” （<a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=B2EBD814B4E07636745536DCB26F96CA?doi=10.1.1.157.772&rep=rep1&type=pdf" target="_blank" rel="noopener">doucet2009tutorial</a>）。</p><p>令$q(y | x)$为循环神经网络文法作为判别式模型的时候产生句子$y$的条件概率，那么$p(x)$可以改写为<br>$$<br>    \begin{aligned}<br>        p(x) &amp; = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}       \\<br>             &amp; = \sum\nolimits_{y \in \mathcal{Y}(x)} {q(y|x)w(x,y)} \\<br>             &amp; = {\mathbb {E}_{q(y|x)}}w(x,y),<br>    \end{aligned}<br>$$<br>其中$w(x,y)=p(x,y)/q(y|x)$。然后就可以采用蒙特卡罗方法进行采样了，从分布$q(y | x)$中采样$N$个样本：<br>$$<br>    {y^{(i)}} \sim q(y|x),i = 1,2, \ldots ,N.<br>$$<br>那么$p(x)$就可以近似表示为：<br>$$<br>    \begin{aligned}<br>        p(x) &amp; = {\mathbb{E}_{q(y|x)}}w(x,y)                                                                \\<br>             &amp; \mathop \approx \limits^{\rm MC} \frac{1}{N}\sum\limits_{i = 1}^N {w(x,{y^{(i)}})}.<br>    \end{aligned}<br>$$</p><p>在实验效果上，生成模型的效果要明显好于判别模型，因为它不仅对句法树的概率进行了建模，还对整个句子的语言模型概率也进行了建模。当然在实现上也稍微复杂了一些，主要采样这个操作耗时比较多，因此采样数量不能太多，通常个位数就够了，程序运行时间会成倍增加。</p><h2 id="基于动态规划的解码算法及其变体"><a href="#基于动态规划的解码算法及其变体" class="headerlink" title="基于动态规划的解码算法及其变体"></a>基于动态规划的解码算法及其变体</h2><p><img src="chart_based.png" alt="图9：基于动态规划解码算法的句法分析模型图。"></p><p>这一类解码算法是由传统的CKY算法启发而来的（<a href="http://cds.cern.ch/record/102654" target="_blank" rel="noopener">cocke1970programming</a>）。传统的CKY算法是通过枚举每一个结点处的产生式来状态转移到下一个子结点，然后寻找出概率最大的那一个产生式。而这里的基于动态规划的解码算法是采用神经网络，计算出每个短语的得分，然后枚举它的所有子短语，计算出总得分最高的那棵子树。图9是这一类解码算法加上编码模型整体的模型结构。</p><h3 id="动态规划解码"><a href="#动态规划解码" class="headerlink" title="动态规划解码"></a>动态规划解码</h3><p>解码算法的初衷是求出得分最高的那棵子树，但是状态空间太大了，不可能枚举所有的句法树，所以就只能用动态规划算法求解了。</p><p>对于任意一个跨度$(i, j)$，我们利用公式1计算所有它所有非终结符的得分。直接取得分最高的那一个非终结符$\hat \ell_{ij}$作为最优的非终结符。</p><p>而对于子短语，我们只需要预测出$(i, j)$的最优分割点即可。遍历所有的分割点$k$，取两个子结点$(i,k)$，$(k,j)$与结点$(i, j)$得分之和最高的那个分割点即可：<br>$$<br>    \begin{aligned}<br>        s_{\rm split}(i, j, k) &amp; = s_{\rm label}(i, j, \hat \ell_{ij})                                        \\<br>                               &amp; + s_{\rm label}(i, k, \hat \ell_{ik}) + s_{\rm label}(k, j, \hat \ell_{kj}).<br>    \end{aligned}<br>$$<br>注意这里计算得分取了非终结符的得分$s_{\rm label}(i, j, \ell)$，并没有取跨度的得分$s_{\rm span}(i, j)$。因为在实际实现中，发现加不加这部分得分影响不大，所以为了简化运算，去掉了这项得分。</p><p>动态规划解码算法的时间复杂度是$O(n^3)$的，所以对于稍长一点的句子，运行起来还是挺慢的。但是好处是可以搜索到所有的状态空间，所以准确率上比较高。</p><h3 id="自顶向下贪心解码"><a href="#自顶向下贪心解码" class="headerlink" title="自顶向下贪心解码"></a>自顶向下贪心解码</h3><p>因为动态规划解码算法时间复杂度太高了，所以可以用贪心解码来近似求解最优句法树。思路是自顶向下、贪心地去选择每一个跨度$(i,j)$的最优分割点和最优非终结符$\hat \ell_{ij}$，这样时间复杂度将降到$O(n^2)$。</p><p>具体实现如下，首先从根结点也就是$(0, n)$开始，选择一个分割点$\hat k$，使得两个子结点$(0, \hat k)$，$(\hat k, n)$与根结点$(0, n)$的得分之和最高，而非终结符还是像之前那样直接通过短语的向量表示计算得出。具体公式为：<br>$$<br>    \begin{array}{l}<br>        \hat \ell = \mathop {\arg \max }\limits_l [{s_{\rm label}}(i,j,\ell)] \\<br>        \hat k = \mathop {\arg \max }\limits_k [{s_{\rm split}}(i,j,k)].<br>    \end{array}<br>$$</p><p>自顶向下贪心解码时间复杂度低，而且实际运行中并没有损失太多精度，所以可以很好地近似动态规划解码算法。而由转移系统的三种遍历顺序，自然而然还可以想到，这里也能推广到自底向上和中序遍历的贪心解码，但是由于这里预测的时候只利用到了局部的短语特征，所以仅仅更改遍历的顺序是没有效果的，还得充分利用到预测的历史信息才行。</p><h2 id="基于序列到序列的解码算法"><a href="#基于序列到序列的解码算法" class="headerlink" title="基于序列到序列的解码算法"></a>基于序列到序列的解码算法</h2><p>前面几个章节都是将句法树视为若干跨度的集合，并预测这个集合，最后还原出句法树。这个章节将要介绍的方法都是基于序列的，也就是将句法树序列化，通过预测句法树对应的序列，然后还原出句法树。</p><h3 id="基于括号表达式"><a href="#基于括号表达式" class="headerlink" title="基于括号表达式"></a>基于括号表达式</h3><p><img src="linearization.png" alt="图10：句子“John has a dog .”对应的句法树及其括号表达式。"></p><p>括号表达式是句法树最为常见的一种序列化方法，图10展示了句子“John has a dog .”对应的括号表达式。可以证明，括号表达式和句法树是一一对应的，所以只要预测出了括号表达式，就可以唯一映射到一棵句法树。这样句法分析任务就转化为了输入一个句子，输出一个括号表达式序列，这可以用常见的序列到序列模型来解决（<a href="http://papers.nips.cc/paper/5635-grammar-as-a-foreign-language" target="_blank" rel="noopener">VinyalsKKPSH15</a>)。类比到机器翻译任务，可以把输入句子当成源语言，输出的括号表达式当做目标语言，这就转化为了一个翻译任务。</p><p>但是这种序列化方法存在一个较大的问题，就是限制性太强了，必须要满足输出的序列是一个合法的括号表达式，这就大大增加了预测的难度。所以一般这种序列化方法都是用来重排序的，也就是先用现成的句法分析器预测出概率最大的若干棵句法树，然后预测这几棵句法树对应的括号表达式的语言模型概率，挑选出概率最高的一棵作为最终的模型输出。</p><h3 id="基于句法距离"><a href="#基于句法距离" class="headerlink" title="基于句法距离"></a>基于句法距离</h3><p><img src="syntactic_distance_example.jpg" alt="图11：句子“She enjoys playing tennis .”对应的句法树及其句法距离序列。"></p><p><strong>句法距离</strong>（syntactic distance）是由（<a href="https://openreview.net/forum?id=rkgOLb-0W" target="_blank" rel="noopener">ShenLHC18</a>)首次提出的新概念，句子中相邻两个单词的句法距离定义为它们俩的最近公共祖先的高度。图11展示了句子“She enjoys playing tennis .”的句法距离序列，对于长度为$n$的句子，它的句法距离序列长度为$n - 1$，并且满足如下条件：对于任意两个相邻的单词对，它们的最近公共祖先高度越高，那么它们俩的句法距离就越大（<a href="https://openreview.net/forum?id=rkgOLb-0W" target="_blank" rel="noopener">BengioSCJLS18</a>）。</p><p>以图11为例，“She”和“enjoys”的最近公共祖先是“S”，所以高度最高，对应的句法距离也最大。“enjoys”和“playing”的最近公共祖先是“VP”，高度排第三，所以对应的句法距离大小也是排第三。依次类推，剩下的句法距离也满足这个性质。可以证明，这个数字序列和句法树是一一对应的。更进一步可以发现，这个序列其实就是“中序遍历的结点的高度”，原文中将其称为句法距离。</p><p>当然实际实现中，句法距离并不一定要和结点高度完全对应，甚至不需要是整数，只需要反映出彼此之间的大小关系就行了。预测这个序列也很简单，原文中并没有使用传统的双向LSTM序列标注的模型结构，而是首先将句子输入到一个双向LSTM，然后将每相邻两个单词的隐层输出做一次卷积操作（因为要预测相邻两个单词的最近公共祖先的高度），然后再将卷积输出送到一个双向LSTM中去，最后通过一个前馈神经网络得到每相邻两个单词的句法距离。</p><p>解码过程十分简单，对于一个句法距离序列$d_1, d_2, \ldots, d_n$，首先找出序列中最大的元素$d_i$，然后下标小于$i$的句子构成了左子树，大于等于$i$的部分构成了右子树，即句法树的括号表达式为$((x_{&lt;i})(x_{\ge i}))$。而对于左右两棵子树，只需要递归解码下去就行了。</p><p>当然这种解码方式仍然存在一个问题，就是句法距离序列并不一定能唯一映射回句法树。例如对于序列$(1, 1, 1, 1)$，当出现相同句法距离时，最大的句法距离并不唯一，这时候选谁做根节点都有可能，所以这个句法距离序列可以对应到任意一棵二叉树。当然在实际运行中，因为预测结果都是浮点数，所以几乎不会出现这种情况。</p><h2 id="其他解码算法"><a href="#其他解码算法" class="headerlink" title="其他解码算法"></a>其他解码算法</h2><p>除了以上介绍的基于转移系统的、基于动态规划的和基于序列预测的解码算法以外，还有一些其他的解码算法。</p><p>比如（<a href="https://aclanthology.info/papers/C18-1011/c18-1011" target="_blank" rel="noopener">TengZ18</a>）提出了两种局部模型。一种是直接预测每个跨度$(i, j)$属于句法树的概率，然后使用CKY算法来进行解码。另一种是预测产生式$(i, j) \to (i, k) (k, j)$的概率，然后还是使用CKY算法来进行解码。这两种模型都取得了非常高的F1值。</p><p>再比如（<a href="https://aclanthology.info/papers/P18-1109/p18-1109" target="_blank" rel="noopener">TuZZ18</a>）提出了高斯混合隐向量文法（GM-LVeGs），来学习产生式的向量表示，最终的效果也是要好于之前的组合向量文法（CVG）（<a href="http://aclweb.org/anthology/P/P13/P13-1045.pdf" target="_blank" rel="noopener">SocherBMN13</a>）。</p><h2 id="若干改进"><a href="#若干改进" class="headerlink" title="若干改进"></a>若干改进</h2><p>上面介绍的几种经典的句法分析模型或多或少都有一些问题，有些解码速度很慢，有些效果不是很理想，有些实现起来比较麻烦，对于不同模型要做出不同的设计调整，因此许多工作针对这些模型提出了许多优化，下面选取两个典型的优化来详细说明。</p><h3 id="动态指导"><a href="#动态指导" class="headerlink" title="动态指导"></a>动态指导</h3><p>在基于转移系统的模型和动态规划模型的自顶向下近似解码模中，都使用到了贪心的解码算法。这样就会出现一个问题，就是训练的时候因为有标准的句法树，所以不论你解码到哪一步，都可以继续按照正确的结果走下去。但是如果在测试阶段，如果你预测出了一个从来没有在训练阶段出现过的状态，那模型可能就无法知道下一步该往哪走了。这时候就要采用<strong>动态指导</strong>（dynamic oracle），来告诉模型在错误的状态该往哪走。</p><p>这里只简单说明一下动态规划模型的自顶向下近似解码中动态指导的定义，基于转移系统的模型的动态指导类似。</p><p>假设现在模型预测出了一个跨度$(i, j)$，那么下面就要预测它的非终结符和分割点。</p><p>首先对于非终结符，如果$(i, j)$在标准的句法树中，那么它的非终结符就是标准的非终结符，否则的话就定义为空集$\varnothing$。</p><p>然后对于分割点，如果$(i, j)$在标准的句法树中，那么分割点就是标准的分割点。否则的话就在标准的句法树中寻找包含$(i, j)$的最小的跨度$(i’, j’)$，然后找出$(i’, j’)$的所有分割点中，位于$(i, j)$之间的分割点，任意取一个都可以作为动态指导。在实际实现中，取满足条件的最左边一个分割点。不同的分割点对应了不同的二叉化方式，其实无关紧要。在（<a href="http://aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">CrossH16</a>）中有关于动态指导详细的证明过程。</p><h3 id="策略梯度"><a href="#策略梯度" class="headerlink" title="策略梯度"></a>策略梯度</h3><p>除了动态指导解决的问题之外，贪心解码还存在一个问题，就是它只针对当前时刻来进行优化，而不是针对全局优化，所以得到的并非是全局最优解。此外动态指导针对不同的模型要进行单独的设计，这就比较麻烦，所以可以采用强化学习中的<strong>策略梯度</strong>（policy gradient）来替代它（<a href="https://aclanthology.info/papers/P18-2075/p18-2075" target="_blank" rel="noopener">FriedK18</a>）。</p><p>首先用<strong>风险函数</strong>（risk objective）来作为模型的损失函数：<br>$$<br>    \mathcal{R}(\theta ) = \sum\limits_{i = 1}^N {\sum\limits_y {p(y|{x^{(i)}};\theta )\Delta (y,{y^{(i)}})} },<br>$$<br>其中$(x^{(i)}, y^{(i)})$是训练集中的标准数据。可以看出，风险函数其实就是所有可能的句法树和标准树的差异${\Delta (y,{y^{(i)}})}$的期望，训练的目的就是最小化所有句法树和标准树的差异，这样就解决了之前提到的两个问题。</p><p>但是显然不可能枚举所有可能的句法树，这就得用到<strong>重要性采样</strong>（important sampling）方法。但是不能直接对风险函数进行重要性采样，不然采样后的函数$\theta$消失了，就没有办法对其求导了，所以要先对风险函数求导得到：<br>$$<br>    \nabla \mathcal{R}(\theta ) \approx \sum\limits_{i = 1}^N {\sum\limits_{y \in \mathcal{Y}({x^{(i)}})} {\Delta (y,{y^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )} },<br>$$<br>这里的$y$是根据分布$p(y|x^{(i)})$采样得到的结果。具体实现中可以将标准树也加入到采样结果中，可以提升准确率。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>成分句法分析使用最为广泛的英文数据集是华尔街日报的PTB数据集，其中第2~21章节划分为了训练集，22章节为验证集，23章节为测试集。中文数据集为CTB数据集，目前已经有5.0，6.0以及8.0等多个版本，但是使用最为广泛的还是5.0版本。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="results.jpg" alt="表1：不同模型在PTB测试集上的最终结果，其中$^*$代表生成式模型。"></p><p>表1列举了一些句法分析模型的测试结果，分为了单模型和非单模型两部分。其中单模型就是不使用任何外部知识及重排序等操作的模型，而非单模型则使用了外部语料、预训练模型、模型融合和重排序等各种方法。目前单模型最好的结果来自于（<a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">KleinK18</a>），他们采用了Transformer作为编码器，使其结果得到了大大提升。由此可见，目前成分句法分析领域编码器的影响要远远大于解码器。而非单模型领域最好结果则来自于相同团队的工作（<a href="http://arxiv.org/abs/1812.11760" target="_blank" rel="noopener">abs-1812-11760</a>），这里他们使用了更为强大的预训练模型BERT，使结果上升到了一个难以逾越的高度。</p><h2 id="总结与未来展望"><a href="#总结与未来展望" class="headerlink" title="总结与未来展望"></a>总结与未来展望</h2><p>本文介绍了成分句法分析领域近些年来的进展，列举了几种不同类型的成分句法分析模型（基于转移系统、基于动态规划、基于序列到序列），并对比分析了它们之间的优缺点，最后提出了几种常见的改进。</p><p>可以预见，未来成分句法分析的研究方向将会是在编码模型方面，因为解码模型对性能的提升已经到了瓶颈期，而编码模型不仅可以大大提升模型效果，还可以运用在无监督成分句法分析上。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>Attention is All you Need</li><li>Transition-based Neural Constituent Parsing</li><li>Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles</li><li>In-Order Transition-based Constituent Parsing</li><li>A Minimal Span-Based Neural Constituency Parser</li><li>Constituency Parsing with a Self-Attentive Encoder</li><li>Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</li><li>Constituent Parsing as Sequence Labeling</li><li>Grammar as a Foreign Language</li><li>Two Local Models for Neural Constituent Parsing</li><li>Long Short-Term Memory Over Tree Structures</li><li>Dependencies vs. Constituents for Tree-Based Alignment</li><li>A tutorial on particle filtering and smoothing: Fifteen years later</li><li>Programming languages and their compilers: Preliminary notes</li><li>Parsing with Compositional Vector Grammars</li><li>Policy Gradient as a Proxy for Dynamic Oracles in Constituency Parsing</li><li>Multilingual Constituency Parsing with Self-Attention and Pre-Training</li><li>Fast and Accurate Shift-Reduce Constituent Parsing</li><li>Shift-Reduce Constituent Parsing with Neural Lookahead Features</li><li>Linear-time Constituency Parsing with RNNs and Dynamic Programming</li><li>Recurrent Neural Network Grammars</li><li>Effective Inference for Generative Neural Parsing</li><li>Parsing as Language Modeling</li><li>Extending a Parser to Distant Domains Using a Few Dozen Partially Annotated Examples</li><li>Improving Neural Parsing by Disentangling Model Combination and Reranking Effects</li><li>Neural Language Modeling by Jointly Learning Syntax and Lexicon</li><li>Gaussian Mixture Latent Vector Grammars</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信聊天记录导出为电脑txt文件教程</title>
      <link href="/2019/08/09/wechat-explore/"/>
      <url>/2019/08/09/wechat-explore/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>本文的最终目的是将手机微信的聊天记录导出到电脑里，变成txt文本文件，然后对其进行分析。</p></blockquote><p>网上有一些工具也可以完成这个功能，但是基本都是付费的。手动操作的话，找了很多的博客，基本没有完全有效的。最终找到一篇很靠谱的教程：<a href="https://github.com/Heyxk/notes/issues/1" target="_blank" rel="noopener">传送门</a>，本文基本参考这篇进行整理。</p><p>首先上我的github把所有需要的文件下载下来：<a href="https://github.com/godweiyang/wechat-explore" target="_blank" rel="noopener">地址</a>，用法稍后说明。</p><h1 id="导出手机微信数据库"><a href="#导出手机微信数据库" class="headerlink" title="导出手机微信数据库"></a>导出手机微信数据库</h1><p>首先要做的第一步就是将手机端的微信数据库<code>.db</code>文件导出到电脑上。</p><h2 id="小米手机"><a href="#小米手机" class="headerlink" title="小米手机"></a>小米手机</h2><p>小米的话做法很简单，不需要进行root。</p><ol><li><p>首先进入手机的<code>设置-更多设置-备份和重置-本地备份</code>，输入密码，点击<code>新建备份</code>，把两个勾去掉，点击软件程序右边的尖括号，选择微信，点击确定，点击开始备份，等待完成就行了。<br><img src="1.png" alt></p></li><li><p>然后将手机连接电脑，打开手机目录下的<code>MIUI/backup/AllBackup/yyyymmdd_xxxxxx/</code>文件夹，将<code>.bak</code>文件拷贝到电脑上，我这里重命名为了<code>com.tencent.mm.bak</code>。<br><img src="2.jpg" alt></p></li><li><p>然后用任意一种压缩包软件（我用的是7zip）打开这个<code>com.tencent.mm.bak</code>文件，并且将<code>apps\com.tencent.mm\r\MicroMsg\systemInfo.cfg</code>、<code>apps\com.tencent.mm\r\MicroMsg\CompatibleInfo.cfg</code>和<code>apps\com.tencent.mm\r\MicroMsg\xxxx\EnMicroMsg.db</code>三个文件解压到电脑上。这里xxxx是一串随机的字母，代表你的微信用户，每个人不一样，一般是最大的那个文件夹，我这里是下图所示文件夹：<br><img src="3.jpg" alt></p></li></ol><h2 id="其他手机通用做法"><a href="#其他手机通用做法" class="headerlink" title="其他手机通用做法"></a>其他手机通用做法</h2><p>其他手机可能没有这么方便，一种办法是root之后去<code>/data/data/com.tencent.mm/MicroMsg</code>下面找这三个文件，但是很多人是不会去root的，所以介绍另一种方法。</p><p>首先电脑上安装一款安卓模拟器，然后里面下载手机微信并登录，最重要的一步就是<strong>将手机端聊天记录备份到电脑端微信，然后将电脑端聊天记录恢复到安卓虚拟器里的微信</strong>，这个功能是微信自带的，应该没有什么难度。</p><p>然后对安卓虚拟器进行root，这个也是设置里就有的，最后就能把三个文件都拷贝到电脑上了。</p><h1 id="破解数据库密码"><a href="#破解数据库密码" class="headerlink" title="破解数据库密码"></a>破解数据库密码</h1><ol start="4"><li><p>将上面的所有文件全部放在一个目录下。<br><img src="4.jpg" alt></p></li><li><p>然后命令行运行如下代码：</p><pre><code>javac IMEI.javajava IMEI systemInfo.cfg CompatibleInfo.cfg</code></pre><p>第三行就是数据库的密码了。<br><img src="5.jpg" alt></p></li></ol><h1 id="导出聊天记录"><a href="#导出聊天记录" class="headerlink" title="导出聊天记录"></a>导出聊天记录</h1><ol start="6"><li><p>然后打开<code>sqlcipher.exe</code>软件，用它打开<code>EnMicroMsg.db</code>数据库，输入第五步得到的密码。<br><img src="6.jpg" alt><br><img src="7.jpg" alt></p></li><li><p>这时候会显示出很多的表格，点击菜单栏的<code>File-Export-Table as CSV file</code>，选择<code>message</code>表，并导出。<br><img src="8.jpg" alt></p></li><li><p>如果直接用excel打开这个表格，可能会显示乱码。所以新建一个excel表格，点击<code>数据-来自文本</code>，然后导入这个<code>.csv</code>文件。<br><img src="9.jpg" alt></p></li><li><p>弹出的框里，第一个下拉框选择<code>GB2312</code>，然后载入，这时候就不乱码了。<br><img src="10.jpg" alt></p></li><li><p>然后在<code>talker</code>一列选择你想要筛选的聊天对象，单击<code>content</code>列并复制到<code>message.txt</code>文本中。<br><img src="11.jpg" alt></p></li><li><p>最后命令行运行下面代码去除无效信息：</p><pre><code>python3 process_wechat.py message.txt</code></pre><p>这时候会产生一个<code>__message.txt</code>，就是处理完的聊天记录了。</p></li></ol><h1 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h1><p>这个上一篇博客已经讲过了，可以去看看：<a href="https://godweiyang.com/2019/07/27/wordcloud/">地址</a></p><p>最后的效果如图所示<br><img src="12.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Do latent tree learning models identify meaningful structure in sentences?</title>
      <link href="/2019/08/05/tacl18-williams/"/>
      <url>/2019/08/05/tacl18-williams/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://aclweb.org/anthology/papers/Q/Q18/Q18-1019/" target="_blank" rel="noopener">Do latent tree learning models identify meaningful structure in sentences?</a></p><p>本文是一篇分析类论文，主要对近年来几种无监督句法分析模型（RL-SPINN和ST-Gumbel）进行了分析，得出了如下三个结论：</p><ul><li>在句子分类任务上，只有一种模型效果好于传统的树结构模型。</li><li>这些模型随机性很大，初始化不同，结果也都差距很大。</li><li>这些模型产生的句法树的平均深度比PTB数据集的平均深度浅。</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>最近有很多工作都是利用Tree-RNN来生成句子的隐式句法树，然后利用下游任务来提供监督，这样就不需要句法树的标注了。利用上隐式句法树的信息之后，下游任务的效果的确能变好，但是几乎没有文章分析过，为什么效果会变好？这个隐式句法树真的学的很不错吗？真的学到了语法吗？如果真的学到了语法，那这对句法和语义学研究者帮助很大。如果没有学到语法，那为什么对下游任务也有帮助呢？这是值得深思的问题。</p><p>理解任何自然语言，首先都要识别出它的句子中，哪些单词组合出的短语是有意义的。而对于下面这种句子：“I saw the man with the telescope”，就会产生两种语义。一种是“with the telescope”修饰“the man”，另一种是修饰“saw”。而直接给出这句话，是基本没有办法判断属于哪种语义的，所以还是得依赖上下文来判断。</p><p>这篇论文分析了四个问题：</p><ul><li>隐式句法树提升下游任务性能的程度。</li><li>隐式句法树模型对于不同的随机初始化，能学到相似句法树的程度。</li><li>模型学到的语法和PTB语法相似的程度。</li><li>模型学到的语法和任何可识别的语法规则相近的程度。</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>这篇论文主要分析了两种模型：SPINN模型及其变体，ST-Gumbel模型。</p><h2 id="SPINN模型及其变体"><a href="#SPINN模型及其变体" class="headerlink" title="SPINN模型及其变体"></a>SPINN模型及其变体</h2><p><img src="1.png" alt="SPINN模型图。"><br><strong>SPINN模型</strong>如图1所示，其实它也是基于转移系统的，没有太大区别。唯一区别就是它提出来不是用来做句法分析的，而是用来对句子编码，来产生句子的向量表示。模型的转移系统的句法监督来自于斯坦福的PCFG Parser，所以不一定完全准确，但是对于下游任务性能提升够用了。</p><p>然后是<strong>RL-SPINN</strong>，和SPINN模型基本完全一样。最大的区别就是转移系统不是用现成的parser来提供监督了，而是用下游任务准确率作为得分来做强化学习进行优化。</p><p>还有<strong>SPINN-NC</strong>（No Connection），取消了tracking模块和composition模块的连接，也就是句法树的表示不依赖buffer里的单词了，这样SPINN模型就退化为了Tree-LSTM了，完全等价。这个变体主要用来和ST-Gumbel模型进行对比，因为ST-Gumbel也是用的Tree-LSTM作为composition模块。</p><p>最后一个变体是<strong>SPINN-PI-NT</strong>（Parsed Input, No Tracking），这个变体模型移除了Tracking模块，同时依赖它的两个模块之间的连接也移除了。这个模型的转移系统就没法预测了，只能根据现成的句法树直接转移。这个变体主要用来对比，用现成的parser和训练出来的parser影响有多大。</p><h2 id="ST-Gumbel模型"><a href="#ST-Gumbel模型" class="headerlink" title="ST-Gumbel模型"></a>ST-Gumbel模型</h2><p><img src="2.png" alt="ST-Gumbel模型图。"><br>这个模型其实就是使用Tree-RNN来计算任意相邻两个结点的得分，然后合并得分最高的两个结点，最后直到只剩一个根节点。如果是有监督学习的话，这样是可行的。但是现在是无监督，所以中间过程的两个结点的得分是没法直接加入到损失函数里的，而中间过程的决策又是离散的，没法计算梯度。所以提出了用ST Gumbel-Softmax来代替传统的softmax，这样就能估计出反向传播的梯度了，而不用强化学习方法了。</p><h2 id="其他对比模型"><a href="#其他对比模型" class="headerlink" title="其他对比模型"></a>其他对比模型</h2><p>第一个是<strong>单向LSTM和RNN</strong>。</p><p>第二个还是<strong>SPINN-PI-NT</strong>，但是转移序列是随机的，不是正确的。</p><p>第三个也是<strong>SPINN-PI-NT</strong>，但是转移序列对应的是最大深度的句法树和平衡二叉树。</p><blockquote><p>这里对几种模型做一个说明。无句法监督的模型只有RL-SPINN和ST-Gumbel两种。单向LSTM和RNN是和句法树没有任何关系的，只用来学习句子的表示。剩下的SPINN，SPINN-NC和SPINN-PI-NT都是需要句法监督的。</p></blockquote><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>采用了三个数据集，PTB，SNLI和MultiNLI，并且提前都做了二叉化。更多的实验细节就不说了，直接去看论文吧。</p><h1 id="隐式句法树对句子理解有帮助吗？"><a href="#隐式句法树对句子理解有帮助吗？" class="headerlink" title="隐式句法树对句子理解有帮助吗？"></a>隐式句法树对句子理解有帮助吗？</h1><p><img src="3.png" alt="表1：测试集对比结果。"><br>表1是各种模型在SNLI数据集和MultiNLI数据集上的对比结果，其中SNLI是只在SNLI上训练，而MultiNLI是在两个数据集上共同训练。</p><p>从表1中可以得出几个结论：</p><ul><li>首先看Prior Work: Baselines，LSTM和BiLSTM是不学习句法树的，Tree-LSTM和SPINN是监督学习句法树的，SPINN-PI-NT是不学习句法树的，直接根据正确句法树转移。可以看出，SPINN-PI-NT的效果略好于LSTM，不如BiLSTM，所以<strong>正确句法树对下游任务的提升是微乎其微的，至少用Tree-LSTM作为composition函数和在NLI数据集上是这样</strong>。</li><li>再看This Work，SPINN-NC是等价于Tree-LSTM的，但是效果比ST-Gumbel差，并且SPINN-NC需要句法监督。这说明了<strong>隐式句法树的学习对句子的理解的确有帮助，不管它学到的句法树有没有实际上的意义</strong>。</li><li>观察This Work: Baselines，可以看出来SPINN-PI-NT的几个结果都是和其他模型差不多的，也就是不管你用正确句法树还是用随机或者平衡句法树给模型转移，效果都不行。这说明了<strong>影响模型性能的瓶颈并不在parsing策略这一块，parsing的好坏对下游句子理解的影响不大</strong>。而RL-SPINN和ST-Gumbel效果略好，但是他们学到的句法树可能是错的。这和第一点结论是一致的，所以今后可以在composition函数上做改进，正确句法树有了，怎么得到它的好的表示是个问题。</li><li>尽管上面所有模型都没有达到SOTA，但是也很接近了，说明隐式句法树学习的确有效果，还是值得我们去分析的。</li></ul><blockquote><p>结论：隐式句法树对句子理解的确有帮助。</p></blockquote><h1 id="这些模型得出的句法树结果一致吗？"><a href="#这些模型得出的句法树结果一致吗？" class="headerlink" title="这些模型得出的句法树结果一致吗？"></a>这些模型得出的句法树结果一致吗？</h1><p><img src="4.png" alt="表2：在MultiNLI验证集上，5轮运行得出的平均准确率和最高准确率。Self F1表示每轮结果和其它4轮结果的一致程度。"><br>表2是两个句法监督模型，两个无监督模型和两种固定的句法树的对比结果。</p><p>从这个结果可以得出两个结论：</p><ul><li>除了不带Leaf GRU的ST-Gumbel准确率方差有异常，其他的方差都差不多。这说明了超参数和随机初始化对模型性能影响不是很大。</li><li>Self F1方面，两个句法监督模型都在70%左右，而ST-Gumbel模型虽然准确率很高，但是一致性只有50%不到。RL-SPINN的一致性就非常高了，有98%左右，这说明了它可能真的学到了某种语法（事实上并不是的，后面章节会讲）。</li></ul><blockquote><p>结论：除了ST-Gumbel模型，其他模型运行多次结果还是基本一致的。</p></blockquote><h1 id="这些模型学到了PTB语法吗？"><a href="#这些模型学到了PTB语法吗？" class="headerlink" title="这些模型学到了PTB语法吗？"></a>这些模型学到了PTB语法吗？</h1><p><img src="5.png" alt="表3：在整个PTB数据集上的测试结果，训练是在SNLI和MultiNLI上的。"></p><p>表3显示了在SNLI和MultiNLI上训练后的模型，在PTB上测试的结果。</p><p>首先可以看出，两个句法监督模型在PTB上的F1也很低，只有四五十左右，但是两个无监督模型更差，甚至不如随机生成的句法树好。这说明了<strong>这些模型根本没有学到PTB语法信息</strong>。而不同类别的准确率也印证了这一点。</p><p><img src="6.png" alt="表4：不同模型在MultiNLI验证集上关于左二叉树、右二叉树、斯坦福句法分析器产生的句法树的F1值，以及产生的句法树的深度对比结果。"></p><p>而从表4中可以看出，两个句法监督模型在MultiNLI数据集上的表现也不错，能有六七十左右的F1值，并且模型偏向于预测出右二叉树。而无监督模型效果就很差了，甚至还不如随机生成的句法树和平衡树，并且RL-SPINN模型输出基本都是左二叉树。而根据语言学知识，右二叉树是更符合语法的。</p><p>最后一列是不同模型产生出的句法树的深度。可以看出RL-SPINN的深度最大，ST-Gumbel深度最小，和随机生成的差不多。而ST-Gumbel对下游任务提升是最大的，所以可以猜测，<strong>深度比较浅，单词的信息可以更好地保留到根节点，句子的编码可能更好</strong>。另一篇论文做过实验验证过这件事，他们用句子的平衡树跑Tree-LSTM得到表示来做SNLI，效果很好。</p><blockquote><p>结论：这些无监督模型基本没有学到PTB语法，但是学到的深度较浅的句法树反而对句子理解任务有帮助。</p></blockquote><h1 id="句法树分析"><a href="#句法树分析" class="headerlink" title="句法树分析"></a>句法树分析</h1><p>前面几个章节分析出了无监督模型产生的句法树不符合语法规则，但是对下游任务的确有帮助。那这个章节就拿出一些特例，来看看它们到底学出了什么语法规则。</p><p>从前面实验可以看出，ST-Gumbel模型学到的语法随机性更大，更值得分析，所以下面只分析这个模型。这个章节分析的篇幅较多，我就直接说结论了：</p><ul><li><strong>更容易结合头两个单词和最后两个单词</strong>。常识上来说，合并最后两个单词没有意义，因为最后一个单词一般是标点符号。但是合并头两个单词还是有意义的，因为一般句子的前两个单词是限定词和名词。</li><li><strong>更容易结合否定词和紧跟后面的一个词</strong>。这个其实有时候符合语法，比如“not”后面紧跟一个形容词，但是比如“not at all”这种就不对了。</li><li><strong>对于功能词和修饰词，模型结果随机性很大</strong>。这一点其实会导致很多短语都分析错了，比如“the”和介词都没有和后面的名词动词合并起来，但神奇的还是对下游任务效果很好。</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这篇文章得出的结论是：<strong>对下游任务有提升的模型，产生出的句法树不一定是最合乎语法的</strong>。</p><p>那么为什么它们还能提升效果呢？这篇文章并没有给出解释，未来的工作还是要设计出新的编码结构，来利用本文提出的几种句法树特征。</p><p>另一种猜想是，PTB语法规则对于NLI任务不一定是最好的，那么问题是NLI任务需要什么样的语法规则呢？这些模型也没有得出好的结论，因为随机性也很大，提升也不是很大。</p><p>最后就是一个工程问题了，如果的确还是PTB语法规则对于提升下游任务性能有帮助，那么怎么提取这种结构呢？现在的几种模型都不能很好的提取出名词短语和介词短语这种结构。</p><blockquote><p>无监督句法分析的前景还是很开阔的，有很多东西值得去探索，ACL 2019的一篇tutorial就是关于自然语言处理中的隐式结构模型的，叫<a href="https://github.com/deep-spin/tutorial" target="_blank" rel="noopener">Latent Structure Models for NLP</a>，如果大家有什么好的想法也欢迎和我交流。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> TACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python生成词云教程（附带QQ聊天记录生成词云实战）</title>
      <link href="/2019/07/27/wordcloud/"/>
      <url>/2019/07/27/wordcloud/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>很多同学对词云很感兴趣，就是给一段文本，然后根据它的词频，生成出好看的词云，就像下面这张图一样：<br><img src="1.png" alt></p><p>生成这个其实很简单，python代码我已经放在github上面了，大家下载下来就能直接用：<a href="https://github.com/godweiyang/wordcloud" target="_blank" rel="noopener">地址</a></p><p>下面我讲讲怎么使用这个代码。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>首先需要python3环境，推荐使用Anaconda安装。</p><p>然后需要<code>jieba</code>和<code>wordcloud</code>库，所以运行下面两条命令安装两个库：<br><code>pip3 install jieba</code><br><code>pip3 install wordcloud</code></p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>这个代码文件夹是如下结构：</p><ul><li>data<ul><li>templates<br>  这个文件夹下放所有你词云想要的样式图片，背景色最好简单一点。</li><li><code>stopwords.txt</code><br>  这是停止词文件，对于你不想在词云中出现的词，你都可以添加到这个文件中过滤掉它。</li></ul></li><li>fonts<br>  这个文件夹下放词云中显示的字体。</li><li><code>create_word_cloud.py</code><br>  这是词云的主代码。</li><li><code>preprocess.py</code><br>  这是用来预处理QQ聊天记录的。</li></ul><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>对于一般的文本文件，直接运行<code>python3 create_word_cloud.py filename.txt</code>就能生成词云了，效果如下：<br><img src="2.jpg" alt></p><h1 id="生成QQ聊天记录词云"><a href="#生成QQ聊天记录词云" class="headerlink" title="生成QQ聊天记录词云"></a>生成QQ聊天记录词云</h1><p>首先打开消息记录，点击下方的消息管理器：<br><img src="3.jpg" alt><br>然后在需要导出的聊天对象上面右键点击导出消息记录：<br><img src="4.jpg" alt><br>然后保存类型选择<code>txt</code>，点保存，并将文件保存在<code>wordcloud</code>根目录下：<br><img src="5.jpg" alt><br>然后打开命令行运行<code>python3 preprocess.py filename.txt</code>，用来去掉聊天记录中的昵称和时间等信息：</p><p>最后运行<code>python3 create_word_cloud.py __filename.txt</code>就能生成词云了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders</title>
      <link href="/2019/07/25/diora/"/>
      <url>/2019/07/25/diora/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="http://arxiv.org/abs/1904.02142" target="_blank" rel="noopener">Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders</a><br><strong>代码地址：</strong><a href="https://github.com/iesl/diora" target="_blank" rel="noopener">github</a></p><blockquote><p>今天要分享的这篇论文来自NAACL2019，主要利用inside-outside算法推理出给定句子的句法树，不需要任何的监督，也不需要下游任务作为目标函数，只需要masked语言模型就行了。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>无监督句法分析是现在比较热门，也有很多东西可做的方向。有监督的已经做得非常好了，感觉做不下去了，所以做一做无监督的试试。</p><p>这篇论文主要用inside-outside算法算出每个span的表示和分数，然后最大化每个叶子结点的分数，类似于bert的masked语言模型。不用像之前的工作那样，需要最后得到句子和短语的表示，然后用来做下游任务。</p><p>本文模型简称叫DIORA，也就是Deep Inside-Outside Recursive Autoencoders。inside步骤其实类似chart parser的前向过程，outside步骤用来重构每个单词。</p><p>DIORA在好几个数据集上都取得了非常大的提升。</p><p>为了理解这篇论文，推荐先去看一下inside-outside算法：<a href="https://godweiyang.com/2018/04/19/inside-outside/">传送门</a>。</p><h1 id="DIORA"><a href="#DIORA" class="headerlink" title="DIORA"></a>DIORA</h1><p>这篇论文的符号定义有点奇怪，以往都是用span的左右边界$(i, j)$来表示的，但是这篇论文只用几个数字$i$来表示，顺序是按照chart表自底向上，从左向右。也就是按照span长度从小到大排序，相同长度的按照左边界从小到大排序，然后依次给上标号。</p><p>首先给定长度为$T$的句子$x_0, x_1, \ldots, x_{T-1}$，每个单词$x_i$都有一个预训练的词向量$v_i$。本文中只讨论二叉树，所以预先将句法树进行了二叉化。</p><p>对于短语$k$，定义它的inside向量为$\bar a(k)$，outside向量为$\bar b(k)$，inside分数为$\bar e(k)$，outside分数为$\bar f(k)$。定义它的儿子结点对的短语集合为$\{k\}$，例如$i, j$两个短语可以结合成短语$k$，那么$i, j \in \{k\}$。</p><h2 id="Inside过程"><a href="#Inside过程" class="headerlink" title="Inside过程"></a>Inside过程</h2><p>首先对于叶子结点，用一个线性变换算出它的向量表示和得分：<br>\[<br>    \begin{align}<br>        \left[ \begin{array}{c} x \\ o \\ u \end{array} \right] &amp;= \left[ \begin{array}{c} \sigma \\ \sigma \\ \tanh \end{array} \right] (U_{\psi}v_k + b) \\<br>        \bar a(k) &amp;= o + \tanh (x \odot u) \\<br>        \bar e(k) &amp;= 0<br>    \end{align}<br>\]<br>其实这就类似于Tree-LSTM的结点函数，因为叶子结点肯定存在的，所以所有叶子结点得分都初始化为0。</p><p>然后对于任意一个高层的结点$k$，它的儿子结点对的集合为$\{k\}$。对于其中的任意一对结点$i, j$，定义它俩组合的分数为：<br>\[<br>    \hat e(i, j) = \phi (\bar a(i), \bar a(j); S_{\alpha})+ \bar e(i) + \bar e(j)<br>\]<br>其中$\phi$函数是一个双线性函数：<br>\[<br>    \phi (u, v; W) = u^T Wv<br>\]<br>然后用<code>softmax</code>函数算出每一对$i, j$的权重：<br>\[<br>    e(i, j) = \frac{\exp(\hat e(i, j))}{\sum_{\hat i, \hat j \in \{k\}} {\exp(\hat e (\hat i, \hat j))}}<br>\]<br>最后加权求和求出短语$k$的inside得分：<br>\[<br>    \bar e(k) = \sum_{i, j \in \{k\}} {e(i, j)\hat e(i, j)}<br>\]</p><p>下面就是计算短语$k$的inside向量了，首先用TreeLSTM或者两层MLP算出结点对$i, j$的向量表示：<br>\[<br>    a(i, j) = {\rm Compose}_{\alpha} (\bar a(i), \bar a(j))<br>\]<br>然后根据刚刚算出的权重进行加权求和得到inside向量表示：<br>\[<br>    \bar a(k) = \sum_{i, j \in \{k\}} {e(i, j) a(i, j)}<br>\]</p><h2 id="Outside过程"><a href="#Outside过程" class="headerlink" title="Outside过程"></a>Outside过程</h2><p>outside其实计算方法和inside很类似，只是不是通过短语$k$的两个儿子来计算了，而是通过它的父亲结点和兄弟结点计算。</p><p>首先看一下下面这张模型图：<br><img src="1.jpg" alt="左边是inside过程，右边是outside过程"><br>左半部分inside过程很好理解，右半部分注意的是$k$表示的是当前要求的结点，$j$表示的是它的父结点，$i$表示的是它的兄弟结点。</p><p>类比inside过程，首先初始化根结点，注意本文中根节点并没有用inside得到的根结点表示，而是随机初始化的。然后对于下层的结点$k$，计算它的某个父结点$j$和兄弟结点$i$的配对得分：<br>\[<br>    \hat f(i, j) = \phi (\bar a(i), \bar b(j); S_{\beta})+ \bar e(i) + \bar f(j)<br>\]<br>然后还是用<code>softmax</code>函数算出每一对$i, j$的权重：<br>\[<br>    f(i, j) = \frac{\exp(\hat f(i, j))}{\sum_{\hat i, \hat j \in \{k\}} {\exp(\hat f (\hat i, \hat j))}}<br>\]<br>注意这里的$\{k\}$其实表示的是短语$k$的父结点和兄弟结点配对的集合了，和inside过程不一样，但是论文里并没有说。</p><p>然后加权求和求出短语$k$的outside得分：<br>\[<br>    \bar f(k) = \sum_{i, j \in \{k\}} {f(i, j)\hat f(i, j)}<br>\]<br>下面和inside过程一样，计算向量表示了：<br>\[<br>    \begin{align}<br>    b(i, j) &amp;= {\rm Compose}_{\beta} (\bar a(i), \bar b(j)) \\<br>    \bar b(k) &amp;= \sum_{i, j \in \{k\}} {f(i, j) b(i, j)}<br>    \end{align}<br>\]</p><p>在本文中这个${\rm Compose}$函数和inside过程中的是用的同一套参数。</p><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>因为是无监督语料，所以最后的监督只能回到每个单词上面来，用语言模型来训练。对于单词$x_i$，用$\bar b(i) \cdot \bar a(i)$来表示包含这个单词的所有可能的句法树的得分总和。这里采用margin-loss来作为损失函数：<br>\[<br>     L_x = \sum_{i=0}^{T-1}\sum_{i^*=0}^{N-1} {\max(0, 1-\bar b(i)\cdot \bar a(i) + \bar b(i)\cdot \bar a(i^*))}<br>\]<br>其中$N$是采样的负样本数量，当然这里符号写的感觉也有一点小问题，首先没有写出$i^* \neq i$，其次$i^*$是随机采样的，并不是从0到$N-1$，范围其实也在0到$T-1$。不过意思懂了就行，采样是根据词频。</p><h2 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h2><p>预测阶段要解码出句法树，这就很简单了，用的是传统的CKY算法，只需要使用到inside得分$e(i, j)$就行了，下面是伪代码：<br><img src="2.jpg" alt="CKY解码算法"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="无监督成分句法分析"><a href="#无监督成分句法分析" class="headerlink" title="无监督成分句法分析"></a>无监督成分句法分析</h2><p>首先是在<strong>二叉化后的PTB</strong>和<strong>MultiNLI</strong>数据集上的结果：<br><img src="3.jpg" alt="PTB测试集结果"><br><img src="4.jpg" alt="MultiNLI结果"><br>+PP表示做了后处理，也就是预测的时候去掉标点，最后直接把标点连接到根结点，这样效果会好很多。</p><p>从PTB数据集结果可以看出，DIORA+PP的提升是最大的（ON-LSTM由于论文发表时没有出代码，所以没有实现），而其他几个模型提升很小甚至还有下降（PRPN-LM）。</p><p>并且DIORA产生出的句法树的平均深度是最深的，这也是由于这个模型和前两个模型（PRPN、ON-LSTM）的区别导致的，前两个模型并没有显式地对句法结构进行建模，没有办法得到没有短语结构的表示，而DIORA是按照常规的句法分析的框架来做的，可以显式地得到每个短语的表示与得分。</p><p>MultiNLI结果类似，但是有个区别就是，这个数据集的句法树不是标准的，而是通过斯坦福的parser生成的，所以不一定对。所以这个数据集其实考量的是模型对另一个已知模型的拟合能力。</p><p>然后是<strong>WSJ-10</strong>和<strong>WSJ-40</strong>上面的结果，也就是PTB中长度不超过10和40的句子组成的数据集：<br><img src="5.jpg" alt="WSJ-10和WSJ-40结果"><br>这里为了和之前的论文统一，没有进行二叉化，所以预测出来的句法树F1值有个上限，就是上表中的UB值。可以看出WSJ-40效果还是不错的，但是在WSJ-10上面没有一个神经网络方法能超过之前的传统方法（CCM和PRLG），说明句子长度过短，神经网络的学习能力还有待提高。</p><h2 id="无监督短语分割"><a href="#无监督短语分割" class="headerlink" title="无监督短语分割"></a>无监督短语分割</h2><p>这个任务就是看模型识别出了句子中有多少个短语，其实包含在刚刚的句法树结构中了。数据集还是用的PTB，结果如下：<br><img src="6.jpg" alt="PTB短语分割召回率"><br>可以看出除了两个短语类型，其他短语类型识别出的召回率还是很高的。</p><h2 id="短语相似度"><a href="#短语相似度" class="headerlink" title="短语相似度"></a>短语相似度</h2><p>短语相似度任务是这样的，首先用DIORA算出每个短语的表示，然后两两短语之间算cos相似度，对于一个短语，如果与它最相似的K个短语的label和它一样，那么这个短语就预测对了。下表是在CoNLL2000和CoNLL2012数据集上的准确率：<br><img src="7.jpg" alt="短语相似度结果"><br>其中ELMo分为三种设置，CI表示只输入短语的每个单词然后取平均得到短语表示，SI表示输入一整个短语，最后一个就是输入整个句子了。DIORA的话用短语的inside和outside表示拼接得到。</p><p>结果表明，CoNLL2000中DIORA效果最好，但是CoNLL2012的话ELMo效果最好，这也说明了DIORA在细粒度的语料上还有提升空间。还有一点奇怪的就是，在CoNLL2012上，ELMo-CI的效果竟然比ELMo-SI还要好，这也是没法解释的。</p><p>最后就是一些模型设置，比如TreeLSTM和MLP对效果的影响，这些部分就去看论文吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>未来工作主要放在</p><ul><li>提升细粒度语料准确度。</li><li>训练更大语料，增加额外的目标函数</li><li>跨领域、跨语言。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法编程小白机试指南（大佬勿进）</title>
      <link href="/2019/07/12/algorithm-code-tricks/"/>
      <url>/2019/07/12/algorithm-code-tricks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>大佬就不用往下看了，这篇文章没有任何逻辑，没有任何进阶的指导意义，纯粹为了应付各种机试（夏令营机试、保研机试、程序设计实践考试等等），对正经编程竞赛没有任何帮助。我就想到哪写到哪了，不定期想到新的在更新。</p></blockquote><h1 id="暴力打表法"><a href="#暴力打表法" class="headerlink" title="暴力打表法"></a>暴力打表法</h1><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>给定$n$个数字$1, 2, \ldots, n$，求任意取一个排列，任意第$i$个位置上的元素都不等于$i$的概率是多少？</p><p>如果知道结论的话，这就是一道普通的错位排列题，常规做法是求出递推式<br>\[f(n) = (n-1)(f(n-1)+f(n-2))\]<br>然后除以全排列的数量$n!$就行了，这里就不讲怎么求的了，百度有很多。这里讲讲如果不会求怎么办？</p><p>首先想到的暴力方法就是暴力枚举所有排列，然后看看有多少排列满足题目中的错位的条件。C++中的库函数<code>next_permutation</code>正好可以帮助我们枚举全排列，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL a<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> flag<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以跑出$n \le 12$的结果，但是再大就跑不出来了，因为全排列数量太多了，跑得太慢了。但是不用管，因为题目要求的不是错位排列的数量，而是除以全排列数量之后的概率，巧的是，$n &gt; 12$之后概率保留两位小数的结果是完全相同的，所以直接取$n = 12$的概率就行了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL p<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>LL a<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">265</span><span class="token punctuation">,</span> <span class="token number">1854</span><span class="token punctuation">,</span> <span class="token number">14833</span><span class="token punctuation">,</span> <span class="token number">133496</span><span class="token punctuation">,</span> <span class="token number">1334961</span><span class="token punctuation">,</span> <span class="token number">14684570</span><span class="token punctuation">,</span> <span class="token number">176214841</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">/</span> p<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100.0</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f%%\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样即使你完全不会计算，也可以100分通过这题啦。</p><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><a href="https://acm.ecnu.edu.cn/problem/3337/" target="_blank" rel="noopener">原题链接</a></p><p>这题其实就是给你$n$个数组，计算任意两个指定数组相同元素的个数。</p><p>首先想到的最暴力的方法就是，两层循环遍历两个数组咯，看有多少一样的元素就行了。那我们试试：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">40000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3337-1.jpg" alt></p><p>结果已经不错了，过了大多数样例了，这时你实在不想做了，拿了这点分数也可以做下一题了。</p><p>但是你稍微动点脑子，就可以发现，可以把所有数组提前排个序啊，然后遍历的时候就不需要每次都从头找起了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">40000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">++</span>cnt<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3337-2.jpg" alt></p><p>然后你就会发现，结果并没有任何变化。。。不过理论上来说是会快一点的，这里数据可能比较小。</p><p>所以这里应该想不到啥优化的好方法了，不会做的话就下一题吧，分数够了，下面是正确代码，用<code>bitset</code>实现的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">40000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>bitset<span class="token operator">&lt;</span>MAXN<span class="token operator">></span> G<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">&amp;</span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="猜答案"><a href="#猜答案" class="headerlink" title="猜答案"></a>猜答案</h1><p><a href="https://acm.ecnu.edu.cn/problem/2819/" target="_blank" rel="noopener">原题链接</a><br>看到这题，首先想到的就是算啊，这是一道数学题，结果可能算半天还是没有推出来结果，还浪费时间。</p><p>所以如果形式很简单的话，先猜答案看看。看这三组样例，先猜一个答案等于$\left\lfloor\frac{3n-1}{2}\right\rfloor$，别问我怎么猜到的，因为我已经算出来了。。好开个玩笑，代入发现都是对的，当然这就是正确结果。那这是怎么猜到的呢？可以这么想，一块钱可以买一块糖，得到一张糖纸，而一张糖纸相当于$\frac{1}{3}$块糖，那么如此继续下去，一块钱一共可以买到$1+\frac{1}{3}+\frac{1}{3^2}+\cdots$块糖，算出来就是$\left\lfloor\frac{3n}{2}\right\rfloor$。但是代进数据发现会差个常数1，所以稍稍修改就得到正确结果了。下面是实现代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span> ans<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然要是猜不出来也没事，可以直接用暴力方法求解，我就模拟换糖的过程就行了，刚开始得到了$n$块糖纸，换到了$\left\lfloor\frac{n}{3}\right\rfloor$块糖，现在还剩下$\left\lfloor\frac{n}{3}\right\rfloor + n % 3$块糖纸，依次模拟下去就行了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>            n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsupervised Recurrent Neural Network Grammars</title>
      <link href="/2019/04/20/naacl19-urnng/"/>
      <url>/2019/04/20/naacl19-urnng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="http://arxiv.org/abs/1904.03746" target="_blank" rel="noopener">Unsupervised Recurrent Neural Network Grammars</a><br><strong>代码地址：</strong><a href="https://github.com/harvardnlp/urnng" target="_blank" rel="noopener">github</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇是新鲜出炉的NAACL19的关于无监督循环神经网络文法（URNNG）的论文，在语言模型和无监督成分句法分析上都取得了非常不错的结果，主要采用了变分推理和RNNG。本文公式量较大，因此我也推了好久，算法也挺多的，首先上一张我推导的公式笔记：<br><img src="1.jpg" alt></p><p>我这篇博客就不按照论文的顺序来讲了，就按照我上面这张笔记讲一讲我的理解吧，很多细节可能会忽略，请参见原文吧。</p><p>首先对于无监督成分句法分析，常规做法就是学习一个生成模型$p_{\theta}(x, z)$，就比如RNNG就是一个生成模型，但是缺少句法树$z$的监督信号怎么办呢？现在给你的输入只有句子$x$，那么只能用语言模型$p_{\theta}(x)$来做监督了。习惯上我们喜欢取对数，也就是：<br>\[<br>\log p_{\theta}(x) = \log \sum_z p_{\theta}(x, z)<br>\]<br>这里就存在几个问题，比如$z$的状态空间太大了，不可能穷举所有的，所以接下来按步骤讲解如何求解。</p><h1 id="URNNG模型"><a href="#URNNG模型" class="headerlink" title="URNNG模型"></a>URNNG模型</h1><hr><p>先上一张模型图，让大家对整体模型有个大概的认知：<br><img src="2.png" alt><br>左边是一个推理网络（Inference Network），用来根据输入$x$推理出隐变量也就是句法树$z$的概率分布$q_{\phi}(z | x)$。右边是一个生成模型（Generative Model），用来计算从推理网络中采样出来的句法树$z$的联合概率$p_{\theta}(x, z)$，最后根据上面语言模型算出句子的概率，最大化这个概率即可。</p><p>接下来分别讲解这两个部分和具体的优化方法。</p><h2 id="Inference-Network-q-phi-z-x"><a href="#Inference-Network-q-phi-z-x" class="headerlink" title="Inference Network $q_{\phi}(z | x)$"></a>Inference Network $q_{\phi}(z | x)$</h2><p>首先将词向量$e_i$和位置向量$p_i$拼接，作为推理网络LSTM的输入：<br>\[<br>f_i, b_i = {\rm BiLSTM}([e_i, p_i])<br>\]<br>然后算出span $(i, j)$的得分，计算方式和以往一样，用BiLSTM前后向输出做差，然后通过一个前馈神经网络得到分数：<br>\[<br>s_{ij} = {\rm MLP}([f_{j+1} - f_i; b_{i-1} - b_j])<br>\]<br>接下来就需要计算句法树的概率分布了，这里不直接计算句法树$z$，而是计算它的邻接矩阵$B$的概率分布，这个邻接矩阵意思就是如果span $(i, j)$存在，那么$B_{ij} = 1$，否则的话$B_{ij} = 0$。然后就可以用CRF计算出邻接矩阵$B$对应的概率：<br>\[<br>q_{\phi}(B | x) = \frac{1}{Z_T(x)}\exp(\sum_{i \le j} B_{ij}s_{ij})<br>\]<br>其中$Z_T(x)$是配分函数，也就是用来将概率归约到0到1之间的：<br>\[<br>Z_T(x) = \sum_{B’ \in \mathcal B_T} \exp(\sum_{i \le j} B’_{ij}s_{ij})<br>\]<br>注意这里的$\mathcal B_T$并不是所有的01矩阵集合，而是必须满足能产生合法句法树的矩阵，而这情况也很多，不能穷举求解，在这里采用经典的inside算法来求解这个配分函数：<br><img src="3.jpg" alt><br>不过我觉得这里是错的！就是这里的两处$s_{ij}$应该改成$\exp(s_{ij})$。不过具体代码实现的时候并没有这么做，初始值一样都是$\beta[i,i]=s_{ii}$，但是递推的时候采用了如下式子：<br>\[<br>\beta[i, j] = \log\sum_{k=i}^{j-1}\exp(s_{ij}+\beta[i,k]+\beta[k+1,j])<br>\]<br>其实就是用$e^{\beta}$来取代$\beta$了，化简后就是代码实现这个式子，应该是为了防止数值溢出。</p><p>然后就是采样了，推理网络目的就是计算出句法树的概率分布，然后根据这个分布采样出若干个句法树，那么现在给定一棵句法树可以根据上面的算法计算出它的概率了，那怎么采样呢？其实还是可以通过刚刚计算得出的$\beta$数组来采样，采样算法如下:<br><img src="4.jpg" alt><br>其实就是自顶向下的根据概率分布来采样每个span的split，用一个队列来保存所有还没有采样出split的span，然后把所有采样出的span在邻接矩阵中的对应值标为1。</p><p>最后推理网络采样出了若干个句法树$z$，然后根据CRF计算出每个句法树的概率$q_{\phi}(z | x)$，后面的事情就交给生成网络了。</p><h2 id="Generative-Model-p-theta-x-z"><a href="#Generative-Model-p-theta-x-z" class="headerlink" title="Generative Model $p_{\theta}(x, z)$"></a>Generative Model $p_{\theta}(x, z)$</h2><p>上面的推理网络采样出了若干个句法树$z$，生成网络的目的就是计算它的联合概率$p_{\theta}(x, z)$。这个其实不难，在之前的RNNG论文笔记中，我已经大致讲过了，可以去复习一下：<a href="https://godweiyang.com/2018/09/02/RNNG/">Recurrent Neural Network Grammars</a>，这里稍稍做了一些改进。</p><p>首先需要定义一个栈用来存放转移的历史状态，这里定义栈里放的元素为二元组$(h, g)$，一个是stack-LSTM编码的输出，一个是子树的结构表示。首先需要预测下一步的action是什么，所以取出栈顶的元素$(h_{prev}, g_{prev})$，预测action的时候只要用到隐含层输出：<br>\[<br>p_t = \sigma(w^T h_{prev} + b)<br>\]<br>然后根据这个概率预测action是SHIFT还是REDUCE，下面分两种情况讨论。</p><p>如果是SHIFT，那么因为是生成模型，所以需要预测下一个移进的单词是什么：<br>\[<br>x  \sim  softmax(Wh_{prev} + b)<br>\]<br>然后将单词$x$的词向量输入到stack-LSTM中得到下一个时刻的隐含层输出：<br>\[<br>h_{next} = {\rm LSTM}(e_x, h_{prev})<br>\]<br>最后将$(h_{next}, e_x)$推进栈里。</p><p>如果是REDUCE，那么首先需要取出栈顶的两个元素$(h_r, g_r)$和$(h_l, g_l)$，然后用TreeLSTM计算出两个子结点合并后的子树的表示：<br>\[<br>g_{new} = {\rm TreeLSTM}(g_l, g_r)<br>\]<br>接着还是计算stack-LSTM下一个时刻的隐含层输出：<br>\[<br>h_{new} = {\rm LSTM}(g_{new}, h_{prev})<br>\]<br>最后将$(h_{new}, g_{new})$推进栈里。</p><p>为了防止数值溢出，常规上我们计算联合概率的对数：<br>\[<br>\log p_{\theta}(x, z) = \sum_{t=1}^T \log p_{\theta}(x_t | x_{&lt; t}, z_{&lt; n(t)}) + \sum_{j=1}^{2T-1} \log p_{\theta}(z_j | x_{&lt; m(j)}, z_{&lt; j})<br>\]<br>从这个式子可以看出，联合概率定义为所有给定某段单词和action预测下一个单词和给定某段单词和action预测下一个action的概率之积。</p><p>如果是监督任务比如RNNG，那么只需要最大化这个联合概率就足够了，但是现在要做无监督，没有$z$，注意别搞混了，推理网络采样出的$z$可不能用来监督哦，因为那本来就不是正确的，所以接下来要采用语言模型来作为最终的目标函数。</p><h2 id="Variational-Inference"><a href="#Variational-Inference" class="headerlink" title="Variational Inference"></a>Variational Inference</h2><p>句子$x$的对数概率定义为：<br>\[<br>\log p_{\theta}(x) = \log \sum_{z \in {\mathcal Z}_T} {p_{\theta}(x, z)}<br>\]<br>其中${\mathcal Z}_T$是所有合法句法树的集合，但是这里不可能穷举所有的句法树，所以就要用到变分推理，具体的理论知识不仔细介绍了，可以去查阅变分推理相关知识，下面直接推导。<br>\[<br>\begin{array}{l}\log {p_\theta }(x) = \log \sum\limits_{z \in {\mathcal{Z}_T}} { {p_\theta }(x,z)} \\ = \log\sum\limits_{z \in {\mathcal{Z}_T}} { {q_\phi }(z|x)\frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \\ = \log { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \right]\\ \ge { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \right]\end{array}<br>\]<br>其中最后一行叫做先验$\log p_{\theta}(x)$的证据下界（ELBO），要想最大化先验，可以最大化这个ELBO，如果我们对这个ELBO变化一下形式可以得到：<br>\[<br>\begin{array}{l}{\rm ELBO} = { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \right]\\ = { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {p_\theta }(z|x){p_\theta }(x)}}{ { {q_\phi }(z|x)}}} \right]\\ = { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x)} \right] - { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {q_\phi }(z|x)}}{ { {p_\theta }(z|x)}}} \right]\\ = \log {p_\theta }(x) - {\rm KL}({q_\phi }(z|x)\parallel {p_\theta }(z|x))\end{array}<br>\]<br>所以这个ELBO和先验就相差了一个KL散度，最大化ELBO的话等价于最小化KL散度，也就是使推理网络产生句法树的概率分布和生成模型尽量接近。</p><p>但是这个ELBO还是不好算，尽管它把$\log$移到了求和符号也就是期望里面，所以转换一下形式：<br>\[<br>{\rm ELBO} = {\mathbb E}_{q_{\phi}(z|x)}\left[ \log p_{\theta}(x,z) \right] - {\mathbb H} \left[ q_{\phi}(z|x) \right]<br>\]<br>因为模型一共有两组参数，一个是推理网络的参数$\phi$，一个是生成网络的参数$\theta$，所以下面分别对两个参数求导。</p><p>首先对$\theta$求偏导，因为只有第一项有这个参数，所以偏导为：<br>\[<br>\nabla_{\theta}{\rm ELBO} = {\mathbb E}_{q_{\phi}(z|x)}\left[ \nabla_{\theta} \log p_{\theta}(x,z) \right]<br>\]<br>这个偏导可以按照概率$q_{\phi}(z|x)$采样得到：<br>\[<br>\nabla_{\theta}{\rm ELBO} \approx \frac{1}{K}\sum_{k=1}^{K} {\nabla_{\theta} \log p_{\theta}(x,z_k)}<br>\]</p><p>然后对$\phi$求偏导，因为有两项含有这个参数，分别求偏导。第二项是熵，它的值其实可以用之前的$\beta$数组算出来，算法如下：<br><img src="5.jpg" alt><br>然后偏导可以交给深度学习库的自动微分，就不用你自己求啦。</p><p>至于第一项的偏导可以用类似于策略梯度的方法解决：<br>\[<br>\begin{array}{l}{\nabla _\phi }{\mathbb{E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x,z)} \right]\\ = {\nabla _\phi }\sum\limits_z { {q_\phi }(z|x)\log {p_\theta }(x,z)} \\ = \sum\limits_z {\log {p_\theta }(x,z){\nabla _\phi }{q_\phi }(z|x)} \\ = \sum\limits_z { {q_\phi }(z|x)\log {p_\theta }(x,z){\nabla _\phi }\log {q_\phi }(z|x)} \\ = {\mathbb{E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x,z){\nabla _\phi }\log {q_\phi }(z|x)} \right]\\ \approx \frac{1}{K}\sum\limits_{k = 1}^K {\log {p_\theta }(x,{z_k}){\nabla _\phi }\log {q_\phi }({z_k}|x)} \end{array}<br>\]<br>这里最后也是转化为了采样，和策略梯度做法类似，这里加入baseline来提升性能：<br>\[<br>\begin{array}{l}{\nabla _\phi }{\mathbb{E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x,z)} \right]\\ \approx \frac{1}{K}\sum\limits_{k = 1}^K {\log {p_\theta }(x,{z_k}){\nabla _\phi }\log {q_\phi }({z_k}|x)} \\ \approx \frac{1}{K}\sum\limits_{k = 1}^K {(\log {p_\theta }(x,{z_k}) - {r_k}){\nabla _\phi }\log {q_\phi }({z_k}|x)} \end{array}<br>\]<br>其中$r_k$定义为所有其他的对数联合概率的均值：<br>\[<br>r_k = \frac{1}{K-1} \sum_{j \ne k} \log p_{\theta}(x, z_j)<br>\]</p><p>至此所有偏导都已求出来了，两个通过采样得到，一个通过inside算法结果自动微分得到，所以去掉导数符号并相加就得到了最终的损失函数：<br>\[<br>{\mathcal L}(\phi, \theta) \approx \frac{1}{K} \sum_{k=1}^K {\left[ \log p_{\theta}(x, z_k) + (\log p_{\theta}(x, z_k) - r_k)\log q_{\phi}(z_k|x) \right]} - {\mathbb H}\left[ q_{\phi}(z|x) \right]<br>\]<br>一定要注意，这里的$\log p_{\theta}(x, z_k) - r_k$在代码实现的时候不能传入梯度，不然的话对$\theta$的偏导就会多出这一项的偏导了！</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验结果这里就不多说了，细节具体看论文吧，就贴两个结果，一个是语言模型：<br><img src="6.jpg" alt><br>可以看出在标准的PTB数据集上，URNNG效果只比监督学习的RNNG和用URNNG损失函数微调后的RNNG效果略差一点，但是在大数据集上，URNNG的优势就体现出来了。</p><p>另一个是无监督成分句法分析，这里是用的全部长度的测试集：<br><img src="7.jpg" alt><br>这个任务上URNNG效果是最好的。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><hr><p>和之前两篇语言模型做无监督成分句法分析类似，这篇论文用推理网络学习句法树的概率分布并采样句法树，再用生成网络计算这些句法树和句子的联合概率，最后用变分推理最大化句子的概率，也就是学习出一个好的语言模型。</p><p>这篇论文的工作还是挺令人惊叹的，融合了inside算法、RNNG、变分推理等等知识。本来我变分推理听老师讲了好几次了都云里雾里的，看了这篇论文后总算弄懂了一点了，不过所了解的还是很少，EM算法、VAE之类的高级境界根本不会。。。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Language Modeling by Jointly Learning Syntax and Lexicon</title>
      <link href="/2019/03/31/iclr18-prpn/"/>
      <url>/2019/03/31/iclr18-prpn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/abs/1711.02013" target="_blank" rel="noopener">Neural Language Modeling by Jointly Learning Syntax and Lexicon</a><br><strong>代码地址：</strong><a href="https://github.com/yikangshen/PRPN" target="_blank" rel="noopener">github</a></p><blockquote><p>最近开始转向去看看一些无监督的成分句法分析论文，看看能否有一些启发QAQ。这篇博客摸鱼划水写了整整四天才写完，好累啊啊啊。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>一般来说，自然语言是由词汇和句法组成的，但是标准的语言模型一般都只用RNN对词汇进行建模，句法信息都是隐式的学习到的，没有办法显式地拿出来使用。所以本文提出的语言模型的变体可以结合结构上的attention，在中间过程中学习到结构信息，然后这层结构信息可以拿来生成句法树，用来做无监督的句法分析。</p><p>那么为什么要做无监督的句法分析呢？主要原因还是一些小语种标注语料太少了甚至没有，不能用监督句法分析来做。而且无监督句法分析学到的信息还可以用来增强语言模型或者更为下游的任务的性能，使它们能更好的融合句法结构信息。</p><p>本文提出的模型（PRPN）主要有如下三个组成部分：</p><ul><li><strong>可微分的Parsing Network</strong>。主要用来学习句子的句法距离（syntactic distance，这个在之前的博客中有讲到，是同一个组做的工作，链接：<a href="https://godweiyang.com/2018/07/19/ConParsing-Syntactic-Distance/">Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</a>），然后产生出门函数（gate function），也就是句子中每个词的权重，这样跑RNN的时候就没有必要考虑之前的所有信息了，只需要考虑句法距离最近的，也就是同一个短语中的信息。这里可微分后面会详细讲到，也就是不能直接预测离散的序列，不然梯度没办法反向传播，所以预测的是一个分布。</li><li><strong>Reading Network</strong>。这个部分就和普通的RNN差不多，区别就是利用了上面的attention，然后每个时刻的输入不仅仅是上一个时刻的隐含层状态，还包括了历史所有相关的隐含层状态。</li><li><strong>Predict Network</strong>。最后预测下一个词也不是直接采用当前时刻的隐含层输出，而是采用所有attention后的历史隐含层信息。</li></ul><p>最后模型训练好之后，用Parsing Network学习到的句法距离就可以产生出无监督的句法树，当然这里只能产生unlabeled的句法树，也就是说，无监督的成分句法分析都是只评测unlabeled F1值，因为nonterminal信息实在是无法无监督的预测出来，除非结合外部标注器或者人工制定规则？</p><p><strong>由于我觉得这篇论文写作有点粗糙，很多地方写的很乱，甚至还有公式变量和图片不对应，所以下面的公式我有些自行修改过了，如果觉得有疑问的，可以参考原文，并且告诉我。</strong></p><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><hr><p>下图是一个输入句子及其对应的句法树示例：<br><img src="1.png" alt><br>其中实线表示成分句法树的结构，而虚线表示同一棵子树的若干个子结点之间的联系。我们用$(x_0, x_1, \ldots, x_n)$表示输入句子，用$y_i$表示句法树中的某一个结点，用$r$表示根结点。定义$y_i$所表示的短语范围是$(l(y_i), r(y_i))$，例如在上图中$y_1$表示的范围是$(2, 6)$，所以有$l(y_1) = 2$和$r(y_1) = 6$。</p><p>下图是模型的Reading Network和Predict Network大致框架：<br><img src="2.png" alt><br>其中实线表示Reading Network中RNN每个时刻的输入依赖于之前的哪些时刻，虚线表示Predict Network中预测下一个词时需要考虑哪些时刻的隐含层输出(<strong>这里有个小错误，图中最上面一行函数参数从$m_3$开始，但实际上虚线表明应该从$m_2$开始</strong>)。</p><p>首先是Parsing Network。这种和之前状态的连接在这里被叫做“跨越连接”（skip connection），而具体和哪些状态连接，就要用到门$g_i^t$，表示当前处在$t$时刻，和之前的第$i$时刻有没有关联，有就是1，没有就是0。在这里先定义变量$l_t$为$x_t$和之前最远到哪个位置的单词有关联，分成两种情况：</p><ul><li>如果$x_t$不是某个子树最左边的叶子结点，那么$l_t$就定义为它的父结点的最左边那个叶子结点，也就是$x_t$最左边那个兄弟结点。比如上图中的$x_4$，因为它在子树中位于中间，所以$l_4 = 3$，也就是说它最远和$x_3$有一定关联，而再往前的单词由于不在同一个短语里，关联就不大了。</li><li>如果$x_t$是某一个子树$y_i$最左边的子结点，那么$l_t$就定义为$y_i$最左边那个兄弟结点的最左边的叶子结点。比如上图中$l_3 = 2$，因为$x_3$是$y_3$的最左边的子结点，而$y_2$是$y_3$最左边的兄弟结点，$x_2$又是$y_2$最左边的叶子结点，也就是说$x_3$最远和之前的$x_2$有关联，它们共同组成了更大的短语$y_1$。（<strong>这里定义又不是很严谨，例如对于上面那个例子，$x_2$既是$y_1$又是$y_2$的最左子结点，这种情况下不能按照$y_2$来计算，因为它没有最左的兄弟结点！所以按照$y_1$来算的话得到$l_2 = 0$。</strong>）</li></ul><p>根据这个$l_t$就可以将$g_i^t$定义为：<br>\[<br>g_i^t = \left\{ {\begin{array}{}{1,{l_t} \le i &lt; t}\\{0,0 &lt; i &lt; {l_t}}\end{array}} \right.<br>\]<br>但是因为这是离散的决策，没法传递梯度，所以之后会介绍用概率来替代这里的0和1。</p><p>然后是Reading Network。得到了gates之后，就可以修改RNN，用下面公式计算$t$时刻的隐含层状态：<br>\[<br>m_t = h(x_t, m_0, \ldots, m_{t-1}, g_0^t, \ldots, g_{t-1}^t)<br>\]<br>具体是怎么使用这个gates的，后面再具体介绍，反正只要知道多考虑了很多个历史状态就行了，每个状态都有一个权重，表示考虑了多少。</p><p>最后就是Predict Network，用来预测下一个单词$x_{t+1}$，用到的是历史多个隐含层状态信息：<br>\[<br>p(x_{t+1} | x_0, \ldots, x_t) \approx p(x_{t+1} ; f(m_0, \ldots, m_t, g_0^{t+1}, \ldots, g_t^{t+1}))<br>\]<br>这里后面也会具体讲到。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p><strong>这里我不按照论文上的顺序讲，论文是倒序，变量定义都得看完整篇论文才出来，实在是看的太杂乱了。。。</strong></p><h2 id="Parsing-Network"><a href="#Parsing-Network" class="headerlink" title="Parsing Network"></a>Parsing Network</h2><p><strong>第1步：</strong><br>首先第一步要预测出相邻两个单词的句法距离，用宽度为$L+1$的卷积核来对单词进行卷积。例如要预测$x_i$和$x_{i-1}$的句法距离，那么就对$x_{i-L}, x_{i-L+1}, \ldots, x_i$进行卷积（其实就是两层前馈神经网络），得到如下输出（<strong>注意原文中这一段里的词向量$e$应该都是$x$，有误</strong>）：<br>\[<br>\begin{array}{}{h_i = {\rm ReLU}(W_c \left[ {\begin{array}{*{20}{c}}e_{i-L}\\e_{i-L+1}\\ \cdots\\ e_i \end{array}} \right] + b_c)} \\ {d_i = {\rm ReLU}(W_dh_i+b_d)}\end{array}<br>\]<br>当然了，第二行也可以看做是窗口大小为1的卷积核，第一个单词之前要补上$L-1$个0。</p><p>最后得到的句法距离反映出了相邻两个词之间的语义相关程度，如果距离比较大，说明两个词可能位于两个不同的短语中，否则就位于同一个短语。一个形象化的句法距离就是相邻两个单词的最近公共祖先的高度。</p><p>下面这个图就是一个例子，卷积核窗口宽度为2：<br><img src="3.png" alt></p><p><strong>第2步：</strong><br>然后就可以根据句法距离，求出$x_t$最远到哪个位置有联系。用$\alpha_j^t$来衡量$x_t$与$x_j$的分别与前一个单词的句法距离的差距：<br>\[<br>\alpha_j^t = \frac{ {\rm hardtanh}((d_t - d_j) \cdot \tau) + 1}{2}<br>\]<br>这里的${\rm hardtanh}$就是当输入大于1或者小于-1时，截取掉，给它限制在-1到1这个范围内，所以最后$\alpha$的范围就是0到1。可以看出，如果$\alpha_j^t$很大，那么$d_t$就大于$d_j$，否则的话$d_t$就小于$d_j$。这也很合乎直观上的认知，如果$d_t$大于$d_j$，那么说明$x_j$和$x_{j-1}$的最近公共祖先的高度比较低，那么说明$x_j$和$x_t$在同一棵子树中，差值自然大，反之的话$x_j$是当前子树的最左边的子结点，差值就很小。</p><p>所以模型只需要一步步往左寻找第一个$\alpha_j^t$最接近0的点，也就是之前提到过的$l_t$。为了实现这个目标，可以定义$l_t = i$的概率为：<br>\[<br>p(l_t = i | x_0, \ldots, x_t) = (1 - \alpha_i^t) \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>为什么这么设计呢？其实还是很有道理的。概率越大的话，说明$\alpha_i^t$越小，而其他的$\alpha_j^t$越大，这就印证了上面提出的观点。而如果取$l_t &gt; i$的话，$1 - \alpha_i^t$一定很小，会拉低概率；反之取$l_t &lt; i$的话，会乘上一个很小的项$\alpha_i^t$，也会拉低概率。所以取$l_t = i$就是最优的。</p><p><strong>第3步：</strong><br>我们的最终目的是求出门$g_i^t$，也就是$x_t$与$x_i$的相关度。在之前的动机中，直接将$l_t$之后的设为1，之前的设为0，但是这样是离散序列，无法传播梯度，所以这里采用另一种方法来求。注意到只有$p(l_t = i | x_0, \ldots, x_t)$接近于1，而其他的概率都接近于0，所以只需要用概率密度函数来作为$g_i^t$就行了：<br>\[<br>g_i^t = P(l_t \le i) = \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>注意到这个概率密度函数在$i &lt; l_t$时值基本很小接近于0，而大于等于它时很大，越来越接近于1。这和设计的初衷已经很像了，所以可以近似用来作为$g_i^t$。</p><p><strong>这里要提几点证明，可看可不看。</strong></p><p><strong>证明开始</strong></p><hr><p>首先这个概率$p(l_t = i | x_0, \ldots, x_t)$的形式其实是一个狄利克雷过程，有两个特殊值要定义一下，一个是$l_t = t-1$时，概率为：<br>\[<br>p(l_t = t - 1 | x_0, \ldots, x_t) = (1 - \alpha_{t - 1}^t)<br>\]<br>还有就是当$l_t = 0$时，因为$d_0$实际不存在，所以定义为句法距离无穷大，那么$\alpha_0^t$定义为0，所以概率为：<br>\[<br>p(l_t = 0 | x_0, \ldots, x_t) = \prod_{j=1}^{t-1} {\alpha_j^t}<br>\]<br>然后可以求出$g_i^t$的期望（<strong>这里论文中又写的一塌糊涂，符号定义都不统一。。。</strong>）：<br>\[<br>\mathbb E(g_i^t) = \prod_{j=1}^{t-1} {\alpha_j^t} + (1 - \alpha_1^t)\prod_{j=2}^{t-1} {\alpha_j^t} + \ldots + (1 - \alpha_i^t)\prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>进一步可以写为：<br>\[<br>\mathbb E(g_i^t) = \sum_{j=0}^i {p(l_t = j | x_0, \dots, x_t)} = P(l_t \le i)<br>\]<br>上面的求和裂项相消可以得到：<br>\[<br>P(l_t \le i) = \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>这里也可以验证出$P(l_t &lt; t) = 1$，所以最终得到下面的门是正确的：<br>\[<br>g_i^t = \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]</p><p>然后要证明的就是根据这个策略求出的两个单词的关联区间没有交叉（但是可以完全覆盖）。首先放宽一下条件，证明当$\alpha_j^t$只取0或者1时，性质成立，也就是定义（<strong>这里原文又打错了。。。</strong>）：<br>\[<br>\alpha_j^t = \frac{ {\rm sign}(d_t - d_j) + 1}{2}<br>\]<br>也就是在原来的定义中令$\tau$为正无穷。这样的话如果$d_t &gt; d_j$，那么$\alpha_j^t$就是1，否则就是0。放宽了条件之后，$g_i^t$取值就只有1和0了，所以求出的$l_t$一定是满足句法距离$d_i &gt; d_t$所有位置中最右边的一个。而对于所有的$l_t &lt; i &lt; t$，都满足$d_i &lt; d_t$。证明也很简单，假设存在两个单词$x_v$和$x_n$，其中$v &lt; n$，它俩的关联区间交叉了，那么假设$x_v$的$l_t$为$u$，而$x_n$的$l_t$为$m$，所以$u &lt; m &lt; v &lt; n$。那么根据定义，有：<br>\[<br>\begin{array}{} {d_u &gt; d_v &gt; d_m \\ d_m &gt; d_n &gt; d_v} \end{array}<br>\]<br>这两个式子显然矛盾，所以证明了在宽松的条件下，这个不交叉的性质是成立的。</p><p>另一个极端是令$\tau = 0$，这种情况下$\alpha_j^t = \frac{1}{2}$，最终算下来$g_i^t$是一个首项为$\frac{1}{2^{t-1}}$公比为2的等比数列。这里的话论文里说最终会形成一棵所有叶子结点都直接连接在根结点上面的句法树，但是我是没看出来为什么，首先这种情况下句法距离$d$对最终的损失函数没有影响了，所以梯度无法传播回来，句法距离$d$应该只受到词向量影响了，最终就是一个普通的语言模型，句法距离最终会是什么样子谁也不知道。</p><p>在具体实现时，将$\tau$设为一个中间值，但是这样会产生交叉的关联区间，所以测试的时候再将其设为正无穷。</p><p><strong>证明结束</strong></p><hr><h2 id="Reading-Network"><a href="#Reading-Network" class="headerlink" title="Reading Network"></a>Reading Network</h2><p>上面的Parsing Network求了半天就是为了得到这个gates $g_j^t$，然后怎么使用呢？既然是语言模型，下面当然要用LSTM来对句子进行编码了。众所周知，在LSTM中有两个隐含层状态$h$和$c$，所以在这里不直接使用上一个时刻传过来的状态，而是用历史所有时刻的状态信息，再与gates加权后输入到下一时刻。在论文中并没有直接使用gates作为权重，而是计算了一个新的权重，这里称作结构化attention：<br>\[<br>\begin{array}{} {k_t = W_h h_{t-1} + W_x x_t \\ \tilde s_i^t = {\rm softmax}(\frac{h_i k_t^{T}}{\sqrt {\delta_k}})} \end{array}<br>\]<br>当然这还不是最终的权重，再通过加入gates，定义一个新的结构化intra-attention：<br>\[<br>s_i^t = \frac{g_i^t \tilde s_i^t}{\sum_i g_i^t}<br>\]<br>上面两个式子我也不是很清楚怎么解释，反正最后就用这个权重来对历史状态进行编码：<br>\[<br>\left[ \begin{array}{*{c}}{\tilde h_t \\ \tilde c_t}\end{array} \right] = \sum_{i=1}^{t-1} {s_i^t \cdot m_i} = \sum_{i=1}^{t-1} {s_i^t \cdot \left[ \begin{array}{*{c}}{h_i \\ c_i}\end{array} \right]}<br>\]<br>最后将加权求和后的隐含层状态作为下一个时刻的隐含层输入，得到新的隐含层表示。</p><h2 id="Predict-Network"><a href="#Predict-Network" class="headerlink" title="Predict Network"></a>Predict Network</h2><p>最后就是预测下一个单词是什么了，这里并没有直接用下一时刻$t + 1$的隐含层输出来预测，还是采用了attention，但是存在一个问题，$g_j^{t+1}$的值依赖于$d_{t+1}$，也就是依赖于$x_{t+1}$，但是这是我们需要预测的，那怎么办呢？论文中就直接用另一套参数直接预测出一个临时的$d_{t+1}’$：<br>\[<br>d_{t+1}’ = {\rm ReLU}(W_d’h_t + b_d’)<br>\]<br>最后对历史状态加权求和，然后用一个前馈神经网络预测下一个单词：<br>\[<br>f(m_0, \ldots, m_t, g_0^{t+1}, \ldots, g_t^{t+1}) = \hat f([h_{l:t-1}, h_t])<br>\]</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>具体实验设置啥的去看论文吧，这里就贴几个结果图解释一下。</p><p><img src="4.jpg" alt><br>上面这个是字符级别的语言模型的结果，PRPN取得了SOTA的结果。</p><p><img src="5.jpg" alt><br>上面这个是词级别的语言模型的结果，除了那个用了4层LSTM和跨越连接的模型（参数多）外，PRPN效果是最好的。</p><p>当然我最关心的还是无监督成分句法分析上面的结果：<br><img src="6.jpg" alt><br>目前为止，无监督成分句法分析的标准做法还是用WSJ10数据集（也就是长度小于等于10的句子），然后用unlabeled F1评测。可以看到，PRPN效果只能说一般般，不是很好。</p><p>其实我也很疑惑，这里的无监督句法分析全靠Parsing Network产生的句法距离来产生，但是一个关键问题是句法距离并没有监督，唯一的监督信号来自于最后Predict Network的语言模型，那么这个句法距离真的能够学习到真实的句法距离吗？我比较怀疑，不过效果证明，这个对语言模型还是有帮助的，对无监督成分句法分析的话不好说。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文几个review都给出了还算不错的评价，思想是不错的，但是和其中一个review观点一样，我觉得文章写得太烂了，一堆的笔误，逻辑很混乱，即使这已经是review后修改过的版本了，还是有一堆错误。</p><p>过两天再看一篇ICLR2019的还是这个组的PRPN的改进版本，看看到底有何改进。不过真要搞无监督句法分析的话，还是老老实实去做聚类吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> ICLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Better, Faster, Stronger Sequence Tagging Constituent Parsers</title>
      <link href="/2019/03/11/naacl19-conparsing/"/>
      <url>/2019/03/11/naacl19-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>为了看懂论文里的策略梯度，又去把强化学习看了一遍。。。</p></blockquote><p><strong>论文地址：</strong><a href="https://arxiv.org/abs/1902.10985" target="_blank" rel="noopener">Better, Faster, Stronger Sequence Tagging Constituent Parsers</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇论文主要是在之前的那篇论文<a href="https://godweiyang.com/2019/03/11/ConParSeqLab/">Constituent Parsing as Sequence Labeling</a>基础上解决了如下三个问题：</p><ul><li>太长的短语预测错误率高。</li><li>输出空间太大导致label稀疏性。</li><li>贪心解码导致的错误传播。</li></ul><p>本文提出的解决方法分别是：</p><ul><li>采用融合了相对编码和绝对编码的动态编码。</li><li>将预测任务分解为多个子任务。</li><li>采用辅助任务和策略梯度。</li></ul><h1 id="三大问题以及解决方法"><a href="#三大问题以及解决方法" class="headerlink" title="三大问题以及解决方法"></a>三大问题以及解决方法</h1><hr><h2 id="过长短语预测的高错误率"><a href="#过长短语预测的高错误率" class="headerlink" title="过长短语预测的高错误率"></a>过长短语预测的高错误率</h2><p>由下面这张图可以看出，当$n_i$太小时，准确率就会大幅下降。这个问题主要体现在过长短语的闭合上，右括号的预测尤其困难。其实这也跟数据稀疏性有很大关系，训练集中过长短语毕竟占少数。<br><img src="1.jpg" alt></p><p>解决方法就是采用动态编码，如下图所示：<br><img src="2.jpg" alt><br>第一行是相对值编码，第二行是绝对值编码，之前文章都已经解释过了。第三行是结合了上面两种编码的动态编码，具体取值情况是大多数时候都还采用相对值编码，因为毕竟相对值编码空间比较小，可以适当缓解数据稀疏性。但是当满足如下两种情况的时候，就采用绝对值编码：</p><ul><li>绝对值$n_t’ \leq 3$，也就是说CA的个数不能超过3个，这样也是为了降低数据的稀疏性。</li><li>相对值$n_t \leq -2$，也就是说将上图中准确率比较低的那些负数值全部用绝对值替代了，在句法树中表现为$w_{t+1}$所在的子树比$w_t$低两层以上。</li></ul><h2 id="输出空间太大导致label稀疏性"><a href="#输出空间太大导致label稀疏性" class="headerlink" title="输出空间太大导致label稀疏性"></a>输出空间太大导致label稀疏性</h2><p>这个问题主要是由于三元组$(n_t, c_t, u_t)$太稀疏了导致的。假设$n_t \in N, c_t \in C, u_t \in U$，那么这个三元组的状态空间是$\left| N \right| \times \left| C \right| \times \left| U \right|$，可以通过将三元组分解为三个不同的子任务将复杂度降低为$\left| N \right| + \left| C \right| + \left| U \right|$。最后的损失函数定义为三个子任务的损失之和：<br>\[<br>\mathcal{L} = \mathcal{L}_n + \mathcal{L}_c + \mathcal{L}_u<br>\]<br>具体实现上，可以将任务$U$的输出给任务$N$和$C$作为输入。</p><h2 id="贪心解码导致的错误传播"><a href="#贪心解码导致的错误传播" class="headerlink" title="贪心解码导致的错误传播"></a>贪心解码导致的错误传播</h2><p>这个问题在基于贪心的方法中基本都存在，也就是所谓的一步错步步错，这里主要提出了两种解决方法。</p><p><strong>辅助任务</strong> 辅助任务主要就是用来帮助主任务学习到一些不太容易学到的信息。这里才用了两个辅助任务，一个是在预测$n_t$的同时再预测一个$n_{t+1}$，这样就能往后多预测一步，适当的减少了贪心的影响。另一个方法就是将之前博客写到的句法距离（syntactic distances）加入到模型中一起预测：<br><img src="3.jpg" alt><br>对于不同的辅助任务，最后将他们的损失求和加到最终的损失函数中去：<br>\[<br>\mathcal{L} = \mathcal{L}_n + \mathcal{L}_c + \mathcal{L}_u + \beta \sum_a \mathcal{L}_a<br>\]</p><p><strong>策略梯度</strong> 这个方法可以从全局的角度来对模型进行优化。假设模型在$t$时刻的状态为$s_t$，输出标签为$l_t = (n_t, c_t, u_t)$，那么模型选择$l_t$的概率定义为策略$\pi$，模型最终可以获得的奖励为$\mathcal R_{tree}$，定义为句法树的F1值。</p><p>定义句法树的概率为每一步决策的概率之积：<br>\[<br>p(tree) = \prod\limits_{t = 1}^T {\pi ({l_t}|{s_t};\theta )}<br>\]<br>所以模型最终就是要最大化如下的奖励：<br>\[<br>\mathcal R = \sum\limits_{tree} { {\mathcal R_{tree}}p(tree)}<br>\]<br>按照梯度上升的方向更新参数$\theta$，求梯度可得：<br>\[<br>\begin{array}{l}\Delta \mathcal R = \sum\limits_{tree} { {\mathcal R_{tree}}\Delta p(tree)} \\ = \sum\limits_{tree} {p(tree){\mathcal R_{tree}}\frac{ {\Delta p(tree)}}{ {p(tree)}}} \\ = \sum\limits_{tree} {p(tree){\mathcal R_{tree}}\Delta \log p(tree)} \\ = {\mathbb{E}_{tree \sim p}}({\mathcal R_{tree}}\Delta \log p(tree))\end{array}<br>\]<br>将$p(tree)$代入可得：<br>\[<br>\begin{array}{l}\Delta \mathcal R = {\mathbb{E}_{tree \sim p}}({\mathcal R_{tree}}\Delta \log p(tree))\\ = {\mathbb{E}_{tree \sim p}}({\mathcal R_{tree}}\Delta \log \prod\limits_{t = 1}^T {\pi ({l_t}|{s_t};\theta )} )\\ = {\mathbb{E}_{tree \sim p}}(\sum\limits_{t = 1}^T { {\mathcal R_{tree}}\Delta \log \pi ({l_t}|{s_t};\theta )} )\\ \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\mathcal R_{i}\Delta \log \pi ({l_t}|{s_t};\theta )} } \end{array}<br>\]<br>其中$\mathcal R_{i}$是根据分布$p$采样出来的$N$棵句法树的奖励。</p><p>具体实现的时候有好几个小Tips。</p><p>第一个就是要将奖励减去一个baseline，这里定义为模型直接根据贪心求得的句法树的F1值：<br>\[<br>\Delta \mathcal R \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\Delta \log \pi ({l_t}|{s_t};\theta )({\mathcal R_i} - {B_i})} }<br>\]<br>这么做的目的就是为了让奖励有正有负，不然全部都是正数的话，因为采样不可能全部采样到，可能会导致高概率的样本概率越来越高，而没有采样到的低概率样本可能奖励非常高，却因此概率越来越低。</p><p>第二个Tip就是加入熵作为正则项：<br>\[<br>\Delta \mathcal R \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\Delta \log \pi ({l_t}|{s_t};\theta )({\mathcal R_i} - {B_i}) + \beta \Delta H(\pi ({l_t}|{s_t};\theta ))} }<br>\]<br>目的就是使概率尽量不要太小，不然的话采样数不够的话就有可能造成采样不到小概率的样本。</p><p>还有就是给策略加入噪声：<br>\[<br>\Delta \mathcal R \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\Delta (\log \pi ({l_t}|{s_t};\theta ) + N)({\mathcal R_i} - {B_i}) + \beta \Delta H(\pi ({l_t}|{s_t};\theta ) + N)} }<br>\]<br>目的同样是加大概率，防止概率太接近于0，当然这个可加可不加。。。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>首先测试了不同设置的影响：<br><img src="4.jpg" alt><br>可以看出上面提到的几种方法对性能都有提升，其中采用动态编码、多任务（也就是减少输出空间）、辅助任务（主要是预测前一个$n_{t-1}$）还有策略梯度可以获得最好的结果。</p><p>最终模型在测试集上取得了90.6的F1值，虽然不是很高，但比之前的序列标注模型提升还是不少。<br><img src="5.jpg" alt></p><p>最后再来看一下模型在负数预测上的准确率，可以看出有了非常大的提升：<br><img src="6.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文提出了不少的小Tips来提升序列模型的准确率，但是效果却还是远远低于syntactic distances那篇论文（F1值91.8），具体原因我也不得而知，我猜测跟树到序列映射编码关系可能不是特别大，可能还是跟序列建模有关，那篇论文的序列采用了两次LSTM，中间还夹杂了一次CNN卷积操作。所以编码器的好坏还是直接决定了最后性能的好坏，怪不得Elmo和Bert的效果那么的突出。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Constituent Parsing as Sequence Labeling</title>
      <link href="/2019/03/11/conparseqlab/"/>
      <url>/2019/03/11/conparseqlab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>貌似已经有好几个月没怎么看过论文了，之前一直在写论文，一直没空更新博客，最近闲下来把最后几篇没看完的论文看了。</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/D18-1162" target="_blank" rel="noopener">Constituent Parsing as Sequence Labeling</a></p><p><strong>代码地址：</strong><a href="https://github.com/aghie/tree2labels" target="_blank" rel="noopener">Code</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>本文定义了一种新的树的序列化方法，将树结构预测问题转化为了序列预测问题。该序列用相邻两个结点的<strong>公共祖先（CA）数量</strong>和<strong>最近公共祖先（LCA）的label</strong>来表示一棵树，并且证明了这个树到序列的映射是单射但不是满射的，但是提出了一系列方法来解决这个问题。</p><p>相比于之前的序列方法，比如<a href="http://www.aclweb.org/anthology/D16-1257" target="_blank" rel="noopener">Parsing as Language Modeling</a>，本文的序列化有所不同，主要体现在之前的方法都是seq2seq的，也就是输入句子，直接输出树的括号表达式序列。但是这种方法输出不是定长的，所以结果可能会比较差。本文的方法将输出长度固定在了句子长度减1上（只针对不存在一元产生式的句法树，这种情况之后讨论），所以可以将每个预测分配到每个单词上，然后用序列标注的方法来解决。</p><h1 id="树的序列化"><a href="#树的序列化" class="headerlink" title="树的序列化"></a>树的序列化</h1><hr><h2 id="记号和基础知识"><a href="#记号和基础知识" class="headerlink" title="记号和基础知识"></a>记号和基础知识</h2><p>记输入句子为$\textbf{w} = [w_1, w_2, \ldots, w_N]$，其中$w_i \in V$。$T_N$为拥有$N$个叶子结点的不含有一元产生式的句法树集合。句法分析的任务就是将输入句子$\textbf{w}$映射到句法树$T_N$。</p><p>为了将句法分析转化为序列标注任务，需要定义一个树的序列化方法：$\Phi_N : T_N \to L^{N - 1}$，也就是将一棵有$N$个叶子结点的句法树转化为长度为$N - 1$的序列。并且该映射函数还得满足一定的条件，首先它一定得是一个<strong>函数</strong>（<em>也就是对于所有的句法树，都得找到一个对应的序列</em>），然后这个函数还得有<strong>单射性</strong>（<em>也就是句法树和序列要一一对应，不能存在两个句法树对应同一个序列，否则的话预测出来一个序列可能解码出两棵句法树，那就尴尬了</em>），当然要是还满足<strong>满射性</strong>就最好了（<em>也就是对于每一个序列，最好都能找到一棵句法树与之对应，不然预测出一个序列无法找到对应的句法树也很尴尬</em>），当然找不到也没事，后文有解决方法。</p><p>然后需要定义一个函数，将句子映射为序列：$F_{N, \theta} : V^N \to L^{N - 1}$。这个映射就通过序列标注的LSTM来实现了，$\theta$就是LSTM的参数。</p><p>最后通过函数$F_{N, \theta} \circ \Phi_N^{-1}$将输入句子转化为对应的句法树。那么$F_{N, \theta}$没什么好说的，就是一个序列标注模型，下面重点就是介绍如何设计函数$\Phi_N$。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>之前说到了将一棵有$N$个叶子结点的句法树转化为长度为$N - 1$的序列，这个序列是这样生成的：对于单词$w_i$，分配给它一个二元label $l_i = (n_i, c_i)$，其中$n_i$为单词$w_i$和$w_{i + 1}$的CA数量，$c_i$为它俩的LCA的label。</p><p><img src="1.jpg" alt></p><p>如上图所示，这个序列的$n_i$有两种表示方法。一种就表示成CA的绝对数量，如图中第一行所示。还有一种表示成后一个数与前一个数的差值，这样能减少元组的数量，但是会出现负数。当然在这个例子中貌似并不能看出数量减少了。。。</p><p><strong>$k$叉树编码：</strong>如果句法树所有产生式全部是$k$叉的，那么还可以将编码进一步简化，具体做法就是将所有的负数$n_i$统一为一个负数就行。为什么这里就不需要对负数进行区分了呢？这还得从句法树的解码说起，我们看一看是怎么从序列解码成句法树的。</p><p>当遇到一个负数$n_i$的时候，说明${\rm LCA}(w_{i}, w_{i+1})$到根结点路径的长度比${\rm LCA}(w_{i-1}, w_i)$到根结点路径长度少$-n_i$个结点。大致结构如下图所示（图画的丑，不要介意）：</p><p><img src="2.jpg" alt></p><p>可以看出，$w_{i+1}$这棵子树接在了从$w_i$到根结点路径上的第$-n_i + 2$个结点上。但是$w_{i+1}$具体在哪还无法确定，只能确定它的子树根结点位置。另外需要解释的是，为什么这里是常数2？因为$w_i$到$w_{i-1}$与$w_i$的LCA的距离一定是2，如果不是的话，中间就一定会有其他结点，那么就一定存在结点位于$w_{i-1}$与$w_i$之间，这显然不可能。最后可以注意到，这种情况下，</p><p>如果$n_i$是正数的话，说明${\rm LCA}(w_{i}, w_{i+1})$到根结点路径的长度比${\rm LCA}(w_{i-1}, w_i)$到根结点路径长度多$n_i$个结点。大致结构如下图所示：</p><p><img src="3.jpg" alt></p><p>这种情况下，$w_{i+1}$这棵子树接在了从${\rm LCA}(w_{i-1}, w_i)$到$w_i$路径上的第$n_i + 1$个结点处。同样也无法确定它的准确位置，但是它所在的子树确定了从这分叉出去的。</p><p>回到正题，之前说到了对于$k$叉树，所有负数都可以统一起来，为什么呢？继续看上面$n_i$负数那张图，对于$w_{i+1}$所在子树，需要在从$w_i$到根结点这条路径上寻找一个分叉点，也就是它俩的LCA。如果这是一个$k$叉树，那么这个分叉点就一定是第一个孩子数不满$k$个的结点。因为如果再往下的话，孩子数都满了，再加子树孩子数一定大于$k$。再往上的话，就会导致这第一个结点孩子数小于$k$，因为从左到右遍历的，子树之间不会交叉，以后都不会有子树插入到这个结点处了。</p><p>下图就是简化序列化后的二叉树例子，第三行将所有的负数都用一个负号替代了：</p><p><img src="4.jpg" alt></p><p>我尝试过了按照这个序列构建出一棵树的过程，画了个草图给大家看看，可能有点乱（参照的是上面那个非二叉树的图）：<br><img src="5.jpg" alt></p><p>还有一个小trick就是对于有些直接连到根结点的叶子，用$({\rm ROOT}, c_i)$作为它们的label。</p><h2 id="理论证明"><a href="#理论证明" class="headerlink" title="理论证明"></a>理论证明</h2><p>主要证明两个性质，一个就是充分性（即每个句法树都能映射为一个序列），另一个就是单射性（即每个序列只能唯一对应一个句法树）。</p><p><strong>充分性：</strong><br>这个显而易见，对于每个句法树，相邻两个单词一定存在唯一的LCA，且它的label也是唯一的，所以充分性肯定能保证的。</p><p><strong>单射性：</strong><br>为了简便，首先证明不包含非终结符的树结构映射的单射性，再证明加上非终结符也是单射的。</p><p>如果用$(\bullet_i)$表示第$i$个叶子结点，那么句法树可以表示成如下的括号表达式：<br>\[<br>\alpha_0 (\bullet_1) \alpha_1 (\bullet_2) \ldots \alpha_{\left| w \right| - 1} (\bullet_{\left| w \right|}) \alpha_{\left| w \right|}<br>\]<br>更进一步，每个$\alpha_i$形式肯定是$[)]^*[(X]^*$，因为如果存在一个闭合的括号对，那么中间肯定还存在着一个叶子结点，这显然不可能。所以我们可以用$\alpha_{i)}$来替代$[)]^*$，用$\alpha_{i(}$来替代$[(X]^*$，将$\alpha_i$改写为$\alpha_{i)} \alpha_{i(}$，括号表达式可以重写为：<br>\[<br>\alpha_{0)} \alpha_{0(} (\bullet_1) \alpha_{1)} \alpha_{1(} (\bullet_2) \ldots (\bullet_{\left| w \right|}) \alpha_{\left| w \right|)} \alpha_{\left| w \right|(}<br>\]<br>注意到首尾两个元素一定是空的，接下来用$\beta_i$替换$\alpha_{i-1(}(\bullet_i)\alpha_{i)}$，得到序列：<br>\[<br>\beta_1 \beta_2 \ldots \beta_{\left| w \right|}<br>\]<br>更进一步，可以证明$\beta_i$一定只含有$[(X]^*(\bullet_i)$和$(\bullet_i)[)]^*$中的一个。因为如果两个都含有的话，说明存在$(X(\bullet_i))$这种一元产生式，但是因为一元产生式都提前处理过了，所以不可能存在。</p><p>接下来可以给每个$\beta_i$分配一个值$\delta(\beta_i)$，如果$\beta_i$左右两边都没有括号，那这个值就是0，如果左边有$k$个括号，那值就是$+k$，如果右边有$k$个括号，那值就是$-k$。如果将这些值写成序列：<br>\[<br>\delta(\beta_1)\delta(\beta_2)\ldots\delta(\beta_{\left|w\right| - 1})<br>\]<br>这个序列正好对应了之前的第二种编码，也就是编码成LCA的个数之差。这是为什么呢？可以看出，一直到$\beta_i$结束，没有闭合的括号数量正好就是$w_i$和$w_{i+1}$的LCA数量。所以$\delta(\beta_i)$就是$w_i$和$w_{i+1}$的LCA数量与$w_{i-1}$和$w_{i}$的LCA数量的差值。</p><p>最后这就验证了括号序列和之前的编码是一一对应的，单射性得证。解码的时候只需要将数字直接转化成对应的括号序列就行了。</p><p>而加上了非终结符之后，单射性不会受到影响。因为虽然两棵相同结构但是拥有不同非终结符的句法树，转化成括号序列后是相同的。但是因为之前的定义中，还有一个变量$c_i$来表示这个非终结符了，所以还是能够唯一对应过去的。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>上面定义的序列化函数有两个缺点：一是非满射，二是不能处理一元产生式，下面介绍一下解决方法。</p><p><strong>对于一元产生式：</strong><br>有两种一元产生式，一种是中间结点，还有一种是叶子结点的label。</p><p>对于中间结点，直接将一条链上的label合并成一个新的label就行了，方法和之前文章介绍的一样。</p><p>而对于叶子结点的label，一个方法是在解码之前先用一个函数预测一下每个叶子结点的label，如果为空，说明没有label，否则就加上这个label，然后再进行正常的解码。另一个方法是将之前的序列化的二元组扩展为三元组$(n_i, c_i, u_i)$，其中第三个元素就是每个叶子结点的label。</p><p><strong>非满射：</strong><br>非满射会导致的问题就是产生出来的序列可能无法映射到某一棵句法树。根据文中所说，一共有两种无法映射的情况。</p><p>一种情况是对于多叉树，相邻两对叶子结点的LCA的label预测不同。比如在最上面一张图中，“the red toy”如果预测为两个不同的label，那么就会产生矛盾。这种情况很好解决，只要在解码的时候只取第一个label，忽略后一个就行了。</p><p>另一种情况是序列可能会产生一元产生式，如下图所示：</p><p><img src="6.jpg" alt></p><p>根据图中序列，会产生下面那棵句法树，一元结点X并没有预测到。但其实因为一元结点已经提前合并了，所以如果预测到了一元结点，直接删掉不要就行了。</p><h1 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h1><hr><p>这里就不细讲了，用的就是基本的BiLSTM + CRF序列标注模型，具体可以看这篇论文：<a href="https://arxiv.org/abs/1603.01354" target="_blank" rel="noopener">End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF</a>。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>这篇论文最大的卖点不是效果，而是速度快，下面是和其他模型的速度对比，可以看出，速度的确快了不少，达到了大几百句每秒。但是还是存在序列标注模型的老毛病，效果并不好，虽然比之前的高了，但是还是只有90%的F1。</p><p><img src="7.jpg" alt></p><h1 id="结论与展望"><a href="#结论与展望" class="headerlink" title="结论与展望"></a>结论与展望</h1><hr><p>这篇论文定义了一种新的句法树序列化方法，将句法树序列化为长度减1的序列，其中每个值就是相邻两个单词的CA个数和LCA的label。</p><p>看完这篇，我仔细想了想，其实之前的chart-based方法也都可以转化成序列，只不过都得特别处理一下一元产生式和多叉树，比较麻烦。以后可以考虑在这方面有所突破，速度快还是很nice的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> EMNLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex撰写论文常用技巧总结</title>
      <link href="/2019/01/13/latex-pdf/"/>
      <url>/2019/01/13/latex-pdf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这篇博文专门用来记录Latex写论文过程中遇到的一些技巧与心得。</p><h1 id="插入矢量图片"><a href="#插入矢量图片" class="headerlink" title="插入矢量图片"></a>插入矢量图片</h1><hr><p>首先在Office PowerPoint中画好模型图，然后有两种方法在Latex中插入矢量图。<br><img src="1.jpg" alt><br><strong>方法一：</strong><br>直接另存为pdf，例如存为<code>figure.pdf</code>。<br><img src="2.jpg" alt><br>注意到pdf打开来左右两个侧边栏有较大的空余空间，所以最好在ppt中绘制模型图的时候就调整好。<br>然后在Latex中使用如下代码插入pdf图片即可：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span> Model. <span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">fig::model</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中参数<code>width=\textwidth</code>是用来调整图片宽度，使得图片占满整个论文，效果如下：<br><img src="3.jpg" alt><br>注意到这里左右两个侧边栏间距的确有点大了，没有占满整个页面。<br>如果想要图片只显示在一半的页面上，那么只需要用如下代码即可：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\linewidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span> Model. <span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">fig::model</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：<br><img src="4.jpg" alt></p><p><strong>2019.1.14更新：</strong><br>关于生成出来的模型图pdf侧边距过大的问题，可以下载“迅捷pdf编辑器”，使用它强大的页面裁剪功能。当然非会员会留下水印，只需要修改水印透明度为0即可。</p><p><strong>方法二：</strong><br>ppt绘制好的模型图右键另存为<code>emf</code>格式，这是一种Windows的矢量图格式，然后下载一款软件叫<code>Metafile to EPS Converter</code><a href="http://wiki.lyx.org/uploads/Windows/metafile2eps/metafile2eps.exe" target="_blank" rel="noopener">地址</a>，将图片转为Latex支持的<code>eps</code>格式，例如命名为<code>figure.eps</code>。</p><p>最后在Latex使用相同的代码插入图片即可，效果如下：<br><img src="5.jpg" alt><br>可以看出两侧间距比原来小了很多。</p><p><strong>2019.3.6更新：</strong></p><h1 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h1><hr><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">CJK</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">CJK*</span><span class="token punctuation">}</span><span class="token punctuation">{</span>GBK<span class="token punctuation">}</span><span class="token punctuation">{</span>song<span class="token punctuation">}</span><span class="token comment" spellcheck="true">% 正文</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">CJK*</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><hr><p><strong>单幅图片：</strong></p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\linewidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span>xxxxx.<span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:xxxxx</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跨双栏的话把<code>figure</code>改成<code>figure*</code>，<code>htbp</code>控制位置，自己看着调。</p><p>难点是跨双栏图片置顶，一般情况下会自动跑到下一页去，找了半天才找到解决方法：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\twocolumn</span><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token function selector">\renewcommand</span><span class="token function selector">\twocolumn</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>#1<span class="token punctuation">}</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span>        <span class="token function selector">\centering</span>        <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>        <span class="token function selector">\captionof</span><span class="token punctuation">{</span>xxxxx.<span class="token punctuation">}</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点是无法添加<code>label</code>，正文只能手动加引用了。</p><p><strong>两幅图片同一行显示：</strong></p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\subfigure</span><span class="token punctuation">[</span>fig1.<span class="token punctuation">]</span><span class="token punctuation">{</span>        <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">{</span>0.58<span class="token function selector">\textwidth</span><span class="token punctuation">}</span>        <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure1.pdf<span class="token punctuation">}</span>        <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span>        <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:fig1a</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function selector">\subfigure</span><span class="token punctuation">[</span>fig2.<span class="token punctuation">]</span><span class="token punctuation">{</span>        <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">{</span>0.34<span class="token function selector">\textwidth</span><span class="token punctuation">}</span>        <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure2.pdf<span class="token punctuation">}</span>        <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span>        <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:fig1b</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span>xxxxx.<span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:fig1</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意的是，两个图片宽度之和<code>0.58 + 0.34 = 0.92</code>要尽量小于1，不然会显示出问题。</p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><hr><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\renewcommand</span><span class="token punctuation">{</span><span class="token function selector">\algorithmicrequire</span><span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token function selector">\textbf</span><span class="token punctuation">{</span>Input:<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function selector">\renewcommand</span><span class="token punctuation">{</span><span class="token function selector">\algorithmicensure</span><span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token function selector">\textbf</span><span class="token punctuation">{</span>Output:<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">algorithm</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span> alg1. <span class="token punctuation">}</span><span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Alg:Alg1</span><span class="token punctuation">}</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">algorithmic</span><span class="token punctuation">}</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>        <span class="token function selector">\Require</span>            <span class="token comment" spellcheck="true">% 输入</span>        <span class="token function selector">\Ensure</span>            <span class="token comment" spellcheck="true">% 输出</span>        <span class="token comment" spellcheck="true">% 过程</span>        <span class="token function selector">\Function</span> <span class="token punctuation">{</span>xxxxxx<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token equation string">$i, j$</span><span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">% 函数体</span>        <span class="token function selector">\EndFunction</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">algorithmic</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">algorithm</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><hr><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\newcommand</span><span class="token punctuation">{</span><span class="token function selector">\tabincell</span><span class="token punctuation">}</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>@<span class="token punctuation">{</span><span class="token punctuation">}</span>#1@<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>#2<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token function selector">\normalsize</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>l|l|ccc<span class="token punctuation">}</span><span class="token function selector">\hline</span><span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c|<span class="token punctuation">}</span><span class="token punctuation">{</span>Model<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> LR <span class="token punctuation">&amp;</span> LP <span class="token punctuation">&amp;</span> F1<span class="token function selector">\\</span><span class="token function selector">\hline</span><span class="token function selector">\hline</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span><span class="token function selector">\caption</span><span class="token punctuation">{</span> xxxxx.<span class="token punctuation">}</span><span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Tab:CompDiffConfig</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个难点，一个是合并同一行的单元格，用<code>\multicolumn{cols}{pos}{text}</code>。</p><p>一个是合并同一列的单元格，用：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>|c|c|c|c|<span class="token punctuation">}</span>        <span class="token function selector">\hline</span>        <span class="token function selector">\multirow</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span>*<span class="token punctuation">{</span>合并两行一列<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> 二 <span class="token punctuation">&amp;</span> 三 <span class="token punctuation">&amp;</span> 四 <span class="token function selector">\\</span>        ~ <span class="token punctuation">&amp;</span> 2 <span class="token punctuation">&amp;</span> 3 <span class="token punctuation">&amp;</span> 4 <span class="token function selector">\\</span>        <span class="token function selector">\hline</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意第二行第一列要用<code>~</code>补上空位。用<code>\cline{start-end}</code>来代替<code>\hline</code>划线。</p><p><strong>暂时就想到这些了，等想到了再更吧，祝我paper顺利。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一八年终总结</title>
      <link href="/2018/12/31/2018-conclusion/"/>
      <url>/2018/12/31/2018-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>某天，你无端想起了一个人，她曾让你对明天有所期许，但是却完全没有出现在你的明天里。</p></blockquote><p>2017年好像还历历在目，2018年却要过去了，貌似这一年并没有发生什么特别值得纪念的事情吧，平平淡淡，淡的就像一杯白开水。</p><p>细数这一年发生的事，前半年写毕业论文，送走了一个又一个熟悉的面孔，略有感伤；后半年荒废，偶尔看看论文偶尔写两行代码，仍然时常因为一些无关紧要的事情而感伤。</p><ul><li>毕业</li><li>炼丹</li><li>想开</li></ul><h1 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h1><hr><p>整个上半年差不多都在忙着读论文、改代码、写毕设吧。虽然当时的眼光有限，看的论文还都是几年前的传统方法，例如CKY算法，模型也基本都是基于Grammar的，在现在看来效率实在是低下，效果也不尽人意。幸好论文写得马马虎虎，也算是萌混过关吧QAQ，最后也混了个并没有什么卵用的优秀毕业论文。</p><p>毕业论文封面：<br><img src="1.jpg" alt></p><p>忙完了毕业论文，接下来就是毕业典礼了吧，也是个忧伤的时期吧。还记得毕业典礼那天大家一起去了闵行，自从两年前搬来中北后，就再也没有回去过了吧。闵行的校园，闭着眼睛也能知道走到哪了吧，毕竟曾经都一起走过，到处都留下了回忆。那天天气非常的好，又把校园都走了一遍吧，只是没有去曾经的三舍看看，略有遗憾，当年去四舍帮忙搬家的情景又浮现在了眼前。也许是回忆过多，没有久留，一伙曾经玩的最好的朋友们一起在宝龙广场吃了饭唱了歌，就当做是散伙饭了吧。</p><p>之后就是暑假了吧，有人升学到了其他学校，有人开始了工作生涯，也有人继续和我一样留在了本校，继续做了室友。特别值得一提的是永日至秦吧，那个打游戏打的我心态爆炸的选手。暑假每天一起半夜出来跑了最后的步，还一起骑着单车骑到了外滩，再上一次去那看夜景还是不知几年前和她去的了吧，换了个人去，别有一番滋味。现在永日至秦也一个人去了北京，不知何时再能见到，希望下次见到李院士的时候你不是一个人（此处貌似有歧义）。</p><p>最后附上孙子临走前的美照一张，有意向勾搭的找我要联系方式：<br><img src="2.jpg" alt></p><h1 id="炼丹生涯开始"><a href="#炼丹生涯开始" class="headerlink" title="炼丹生涯开始"></a>炼丹生涯开始</h1><hr><p>送走了所有人之后，暑假搬了宿舍，就正式开始了研究僧的炼丹生涯（划水混毕业）了吧。一整个暑假都在看论文，补基础，也差不多看完了成分句法分析近几年来的所有深度学习方法了吧，基本对此有了一个初步的认识。还开通了<a href="https://zhuanlan.zhihu.com/godweiyang" target="_blank" rel="noopener">知乎专栏：自然语言处理与深度学习</a>，经营到现在也才900不到的粉丝吧，希望有一天能像大佬们那样几万的粉丝，在这个领域做出自己的贡献吧。通过看论文，写博客，也认识了许多志同道合的人吧，还和大佬们有所交流。</p><p><img src="4.jpg" alt></p><p>其实写博客也是很累的，从刚开始计划的paper daily到后来的paper weekly，再到现在的paper randomly。有时候一篇论文真的要精读好久才能读懂，有时候实在读不懂了，就直接开写，在写的过程中，逐渐的就把自己说服懂了。其实这也和讲presentation一样，我也是比较喜欢做presentation的，一个原因是我确实喜欢和别人分享各种好的paper，好的思想，另一个原因是在讲的过程中，有些我一直不懂的问题可能讲着讲着我就懂了，也可以和台下的老师同学们自由讨论，理解得更加透彻。</p><p>可能会有人问我，你写了没人看，哪里有成就感？确实，刚开始时只有寥寥无几的老同学们来捧个场子，而且他们也都看不懂，只是点个赞。但是如果只是为了出名，那就不要写博客了吧，写博客是主要是为了提升自己，记录自己的点点滴滴，然后是和别人分享，同时自己也能获得进步。至于成就感的话，慢慢就有了，最起码每次写完一篇博客，看着整理的满满当当的博文，自己就会有一种成就感，不需要别人来证明。现在每天看着知乎多了新粉丝，偶尔会有新评论和私信，询问学术方面的问题，还是会有小小的欣慰的。</p><p>现在论文看的不如以前多了，看来还是得去补补基础，或者去看看其他方面的论文，涉猎广一点，有些东西是通用的，可以拿来为之所用。代码的话之前写的也不多，一直都是面向过程，写的代码都不堪入目。直到开学才拿了伯克利的优质代码，重构了一下，整合了比较流行的几种模型，在上面进行了修改，最近也一直在跑。虽然现在没有对象，但是面向对象的思想还是要有的，不然以后代码维护起来都很困难的。</p><p>开学了课虽然不多，但是事情还是挺繁杂的吧。周二要给大三的操作系统实践做助教，每周都要改作业，还是挺麻烦的，混学分不容易。周四一天满课，知识分析课每周都要抄作业度日，其他几门课也都没怎么听，现在担忧期末考试怎么办，本科认真学习的劲头不知道都去哪里了，可能现在只要不挂科就行了吧，心态变了。而且现在想找个能一起学习的朋友都很难了。</p><h1 id="庸人自扰"><a href="#庸人自扰" class="headerlink" title="庸人自扰"></a>庸人自扰</h1><hr><p>并没有遇到什么在意的人吧，就说说我一直以来的心路历程吧。</p><p>一个人好过歹过也已经有一年半多了，在旁人看来这么久了，也早该忘得一干二净了，但是毕竟这是初恋吧，被义务教育压榨了这么多年后的第一次解脱，很难忘记。而且我也不是一个很随便的人，没那么容易忘。直到一个多月前吧，她终于遇到了对她真正好的人了，我想我也该彻底释怀了，知道消息时也没多大的情绪波动，一切都在意料之中，早晚会来临的。</p><p>可能会有人觉得我喜欢撩妹吧，学妹加了挺多。的确，是加了不少，都是每年开学水新生群加的吧，但绝大多数都安静地躺尸在了好友列表里。偶尔会有一些“慕名前来”问问题的人，以前我还能认真回答回答，毕竟我一直喜欢帮助别人，分享自己的经验。但是现在我改变了这些想法，二十三年了，第一次在这方面感到累了，也许自闭才是最好的解决方法吧，帮助别人到最后什么都得不到吧，还是照顾好自己。既然喜欢的人不可得，那就安心学习吧，对自己好才是最重要的。如果对任何人都这么有求必应，可能真的变成了小太阳了吧。</p><p>以前的我也跟小标题一样，时常庸人自扰，无病呻吟吧，可能是我想太多了吧，总是被一些无关痛痒的事影响，每天都是唉声叹气的。现在我想开了，真的没必要为这些琐事担忧烦心，放任它去吧。每当再遇到了困扰的事，出去散散心倒是最好的解决方式，虽然找不到最合适的人一起散心，但是能呼吸一下外面透心凉的空气，心里的结也能一下子解开了。见的多了自然而然就不会为一些事而感到郁郁寡欢了，从前每次遇到不顺心的事总会连着影响几天，饭也吃不好觉也睡不着，学习也没有任何的动力。现在想开了，努力练就一颗强大的内心吧，虽然铁石心肠不好，但是还是要坚强呀。你已经是个大人了，要学着自己控制情绪了，不要再做一个幼稚的小孩了，成熟点吧。<br><img src="3.jpg" alt></p><h1 id="2019畅想"><a href="#2019畅想" class="headerlink" title="2019畅想"></a>2019畅想</h1><hr><p>关于下一年，首先把课混过去，然后好好看论文敲代码做实验吧，但愿能有个不错的想法和实验效果，让我能在明年就安然毕业。至于发A什么的，就先想想吧，朝着这方面努力，希望我的微信名可以早日改掉。</p><p>情感方面，就准备单着三年吧，除非天上掉馅饼了，好好做学术才是正道。</p><p>多出去走走吧，本科四年都呆在学校了，三点一线式的类高中生活，谈的也是高中式恋爱吧，累了累了。</p><p>其他没啥好想的了，鄙人不善幻想，只喜欢晚上做梦，最后送上泰戈尔的一句名言吧，与君共勉：</p><blockquote><p>有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；<br>有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Oracles for Top-Down and In-Order Shift-Reduce Constituent Parsing</title>
      <link href="/2018/11/07/emnlp18-dynamic-oracle/"/>
      <url>/2018/11/07/emnlp18-dynamic-oracle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>有一句话，宾语是你。“吉下两点一口，又有欠字相依。”</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/D18-1161" target="_blank" rel="noopener">Dynamic Oracles for Top-Down and In-Order Shift-Reduce Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/danifg/Dynamic-InOrderParser" target="_blank" rel="noopener">github</a></p><p>本文是发表在EMNLP18上的一篇关于Dynamic Oracle的论文，主要介绍了针对自顶向下和中序两种移进归约成分句法分析模型的Dynamic Oracles。在PTB数据集上，取得了单模型最高的F1值92.0（截至论文发稿时是最高的，张岳TACL18的论文已经取得了92.4的最高F1值）。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>Dynamic Oracle是用在转移系统中，防止错误传播的一种手段。而转移系统主要有分为三种：bottom-up、top-down和in-order的转移系统。</p><p>其中bottom-up转移系统的Dynamic Oracle在<a href="http://aclweb.org/anthology/D16-1001" target="_blank" rel="noopener">Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles</a>中有很详细的证明，也可以参看我之前的博客<a href="https://godweiyang.com/2018/08/03/dynamic-oracles/">Deep Understanding of Dynamic Oracle in Constituent Parsing</a>。</p><p>而本文就提出了另外两种转移系统的Dynamic Oracle，其中top-down转移系统主要基于<a href="http://aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a>，in-order转移系统主要基于<a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a>。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><hr><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>bottom-up的转移系统这里就不讨论了，这里主要讨论另外两种转移系统。转移系统的状态用五元组$c = \left\langle {\sum ,i,f,\gamma ,\alpha } \right\rangle $表示，五元组内元素分别表示stack、buffer第一个单词的下标、in-order转移系统中结束标记、已经生成的短语成分集合、stack中非终结符集合。</p><p>每个短语成分用三元组$(X, l, r)$表示，其中X是非终结符，l和r是短语的边界下标。而非终结符用二元组$(X, j)$表示，其中j表示X入栈后下一个入栈的单词的下标。</p><p><img src="1.jpg" alt></p><p>例如对于上图中的句法树，它的gold短语成分集合是<br>\[(S,0,6),(NP,0,2),(VP,2,5),(ADVP,3,4),(ADJP,4,5)\]如果采用top-down的转移系统，非终结符入栈的顺序为<br>\[(S, 0), (NP, 0), (VP, 2), (ADVP, 3), (ADJP, 4)\]如果采用in-order的转移系统，非终结符入栈的顺序为<br>\[(NP, 1), (S, 2), (VP, 3), (ADVP, 4), (ADJP, 5)\]<br>正如之前所说，top-down中非终结符的下标就是短语的第一个单词的下标，但是in-order不是的，因为短语的第一个子结点已经在非终结符入栈之前形成了，所以它的下标是第二个子结点表示的短语的第一个单词的下标。</p><p>之前的top-down和in-order转移系统中并没有用到预测的短语集合$\gamma$和stack里的非终结符集合$\alpha$，但是在本文的转移系统中需要用到，因为本文要用它来改进loss函数，以此来实现Dynamic Oracle。</p><h2 id="top-down转移系统"><a href="#top-down转移系统" class="headerlink" title="top-down转移系统"></a>top-down转移系统</h2><p><img src="2.jpg" alt><br><img src="3.jpg" alt></p><p>上面两张图分别是top-down转移系统的转移过程和具体的转移示例。注意到REDUCE动作会将新的短语加入到$\gamma$集合中，并且从非终结符集合$\alpha$中删去该非终结符。而NT-X动作会将新的非终结符X加入到非终结符集合$\alpha$中。</p><h2 id="in-order转移系统"><a href="#in-order转移系统" class="headerlink" title="in-order转移系统"></a>in-order转移系统</h2><p><img src="4.jpg" alt><br><img src="5.jpg" alt></p><p>上面两张图分别是in-order转移系统的转移过程和具体的转移示例，大致细节和top-down转移系统类似。</p><h2 id="Dynamic-Oracles简介"><a href="#Dynamic-Oracles简介" class="headerlink" title="Dynamic Oracles简介"></a>Dynamic Oracles简介</h2><p>最后再解释一下Dynamic Oracle是干嘛用的，传统的Static Oracle就是在转移的每一步按照标准转移序列中的action进行转移，但是这样会有一个问题，如果预测的时候某一步预测错了，遇到了一个训练阶段没有出现过的状态，那么该怎么进行转移呢？这时候就要用到Dynamic Oracle，用来针对不同的错误情况进行动态的指导，引导它转移到正确的状态中去。另外在训练时可以手动加入一些错误状态，来训练模型，不然的话遇到的错误状态还是太少了，不足以训练好模型。</p><h1 id="Dynamic-Oracles"><a href="#Dynamic-Oracles" class="headerlink" title="Dynamic Oracles"></a>Dynamic Oracles</h1><hr><p>Goldberg (2012)证明了Dynamic Oracle可以通过定义一个损失函数来直接实现，而这个损失函数可以用来衡量当前状态可以产生的最优句法树和标准句法树的距离。最小化这个距离就会使得错误状态也会转移到最终错误最少的状态。而这个损失函数就要和当前状态c挂钩了，这样才能达到和传统的Dynamic Oracle类似的效果。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>传统的损失函数定义为预测短语成分集合和标准短语成分集合不相交的元素数量，即：<br>\[\mathcal{l}(c) = \min_{\gamma | c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| { {\gamma _G}\backslash \gamma } \right| + \left| {\gamma \backslash {\gamma _G}} \right|\]</p><p>根据<a href="https://godweiyang.com/2018/11/06/arxiv-18-SR-CP-bottom-up/">上一篇博文</a>的推导，该损失函数可以计算为<br>\[\mathcal{l}(c) = \min_{\gamma | c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| \mathcal{U}(c, \gamma_G) \right| + \left| {\gamma_c \backslash {\gamma _G}} \right|\]</p><p>上面的损失函数是上一篇论文中介绍的bottom-up的转移系统的Dynamic Oracle，但是本文主要讨论top-down和in-order的转移系统，因为转移系统多了non-terminal，所以需要新加入两项损失，用来衡量当前状态可以产生的最优句法树与标准句法树之间的汉明损失。</p><p>这两项新加的损失分别是：</p><ul><li>当前栈中已经生成的non-terminal集合$\alpha_c$中不包含在标准non-terminal集合$\alpha_G$中的non-terminal数量，即$\left| \alpha_c \backslash \alpha_G \right|$。</li><li>当前栈中违反了标准树中non-terminal顺序的non-terminal数量。</li></ul><p>所以最终的损失函数为：<br>\[\mathcal{l}(c) = \min_{\gamma | c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| \mathcal{U}(c, \gamma_G) \right| + \left| {\gamma_c \backslash {\gamma _G}} \right| + \left| \alpha_c \backslash \alpha_G \right| + out \_ of \_ order(\alpha_c, \alpha_G)\]</p><p>前面三项都很容易求得，至于最后一项，可以通过计算栈里的gold non-terminal序列的最长上升子序列来得到，而序列中每个non-terminal的标号就是它在标准树转移序列的non-terminal顺序标号。</p><h2 id="短语的可达性"><a href="#短语的可达性" class="headerlink" title="短语的可达性"></a>短语的可达性</h2><p>在这里用短语集合${(X, l, r)}$来表示一棵句法树，我们假设状态c的短语集合为$\sum = [(Y_p, i_p, i_{p-1}) \cdots (Y_2, i_2, i_1)|(Y_1, i_1, j)]$，那么我们说，标准句法树中的一个短语$(X, l, r) \in \gamma_G$当且仅当满足如下三个条件之一时，称它是“各自可达短语”：</p><p>对于top-down转移系统：</p><ul><li>$(X, l, r) \in \gamma_c$（因为短语已经包含在了状态c已生成的短语集合里，那么它当然是可达的）。</li><li>$j \le l &lt; r \wedge (X, l) \notin \alpha_c$（因为短语还在buffer中，并且短语的non-terminal还没有入栈，所以可以通过入栈$(X, l)$，再不断SHIFT然后REDUCE得到）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r \wedge (X, l) \in \alpha_c$（这种情况表明了短语的左端点恰好位于栈里某个短语的边界处，而右端点又还在buffer里，所以还可以通过不断SHUFT然后REDUCE得到短语。但是如果左端点不是栈里短语的边界，那说明产生了交叉，自然不会可达了。而如果右端点已经在栈里了，那之后也不会得到了，因为转移系统每次都是REDUCE栈顶的短语，不可能从栈里面开始REDUCE的，当然这些前提条件当然是non-terminal$(X, l)$已经在栈里了）。</li></ul><p>对于in-order转移系统：</p><ul><li>$(X, l, r) \in \gamma_c$（因为短语已经包含在了状态c已生成的短语集合里，那么它当然是可达的）。</li><li>$j \le l &lt; r$（因为短语还在buffer中，所以可以通过入栈第一个左儿子，再入栈$(X, m)$，再不断SHIFT然后REDUCE得到）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r \wedge (X, m) \notin \alpha_c$（这种情况表明了第一个左儿子已经生成了一部分或者完全生成了，并且根结点non-terminal还没有入栈，所以依然可以生成）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r \wedge (X, m) \in \alpha_c \wedge \exists (Y,l,m) \in \sum $（这种情况表明了第一个左儿子已经完全生成了，并且根结点non-terminal在栈里，所以依然可以生成）。</li></ul><p>枚举标准树中的所有短语，根据以上规则可以得到可达短语集合$\mathcal{R}(c, \gamma_G)$，然后从标准短语集合中排除掉这部分短语，剩下的就是不可达短语集合$\mathcal{U}(c, \gamma_G) = \gamma_G \backslash \mathcal{R}(c, \gamma_G)$。这部分短语就是不论采取何种动作序列，最后都不可能生成的短语集合。</p><p>关于这两个Dynamic Oracles的正确性，这里就不再证明了，证明过程和上一篇bottom-up的差不多。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>本文和基础的几个转移系统做了对比，代码也是在他们基础上进行修改的，结果如下：<br><img src="5.jpg" alt><br>可以发现，加了Dynamic Oracles之后，结果还是有略微提高的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> EMNLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster Shift-Reduce Constituent Parsing with a Non-Binary, Bottom-Up Strategy</title>
      <link href="/2018/11/06/arxiv-18-sr-cp-bottom-up/"/>
      <url>/2018/11/06/arxiv-18-sr-cp-bottom-up/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文地址：<a href="http://arxiv.org/abs/1804.07961" target="_blank" rel="noopener">Faster Shift-Reduce Constituent Parsing with a Non-Binary, Bottom-Up Strategy</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇论文提出了一种非二叉化、自底向上的转移系统，并且针对它提出了一种Dynamic Oracle，用损失函数的形式来实现它。</p><p>之前的模型针对多叉树的处理都是采用head规则进行二叉化，或者采用空结点作为临时结点来进行隐式二叉化。但是本文将REDUCE动作扩展为REDUCE-k动作，从而可以对k叉树进行预测，这样减少了很多二叉树预测的中间过程，降低了模型的训练时间。并且为了提升准确率，还提出了一种用损失函数实现的Dynamic Oracle。</p><p>自底向上的转移系统就不详细介绍了，之前都已经介绍过了，这里只说明一下之后要用到的记号。</p><p>转移系统由一个stack和buffer组成，每个时刻的状态通常表示为$c = \left\langle {\sum ,i,f,\gamma} \right\rangle $，四个元素分别表示stack、buffer第一个单词的单词下标、分析结束标记、已经生成的短语成分的集合。</p><h1 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h1><hr><p>传统的转移系统REDUCE操作都只是将栈顶的两个元素归约为一个结点，而本文提出的转移系统将REDUCE扩展为REDUCE-X#k动作，归约栈顶概率最大的k个结点为结点X。举个例子，对于产生式$VP \to is \ ADVP \ ADJP$，使用的动作为REDUCE-VP#3，表示归约栈顶的三个结点。</p><p><img src="1.jpg" alt><br><img src="2.jpg" alt><br>具体的转移系统和例子如上图所示，为了区分具有不同数量儿子的结点X，将结点的label细化为X#k，表示具有k个儿子。例如对于VP结点，如果有两个儿子，那么它的label就是VP#2，如果有三个儿子就是VP#3。</p><h1 id="Dynamic-Oracle"><a href="#Dynamic-Oracle" class="headerlink" title="Dynamic Oracle"></a>Dynamic Oracle</h1><hr><p>本文采用的Dynamic Oracle是用损失函数来实现的，损失函数衡量的是状态c可以产生的最优句法树和标准句法树之间的距离，这样就可以计算出采取每一个动作之后下一个状态的损失函数值，选择损失函数值最小的动作。</p><p>对于状态c，损失函数$l(c)$定义为状态c可以产生的最终的句法树t和标准句法树$t_G$之间的最小汉明距离，即：<br>\[l(c) = \min_{t|c \to t} \mathcal{L}(t, t_G)\]<br>一个训练正确的Dynamic Oracle应当使得预测的下一个状态$\tau(c)$不会增加损失函数值，即<br>\[l(\tau(c)) - l(c) = 0\]<br>这个最小汉明损失可以定义为$\left| { {t_G}\backslash t} \right| + \left| {t\backslash {t_G}} \right|$，下面就将讨论这两部分怎么计算，主要用到短语的可达性和可分解性。</p><h2 id="短语的可达性"><a href="#短语的可达性" class="headerlink" title="短语的可达性"></a>短语的可达性</h2><p>在这里用短语集合${(X, l, r)}$来表示一棵句法树，我们假设状态c的短语集合为$\sum = [(Y_p, i_p, i_{p-1}) \cdots (Y_2, i_2, i_1)|(Y_1, i_1, j)]$，那么我们说，标准句法树中的一个短语$(X, l, r) \in \gamma_G$当且仅当满足如下三个条件之一时，称它是“各自可达短语”：</p><ul><li>$(X, l, r) \in \gamma_c$（因为短语已经包含在了状态c已生成的短语集合里，那么它当然是可达的）。</li><li>$j \le l &lt; r$（因为短语还在buffer中，所以可以通过不断SHIFT然后REDUCE得到）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r$（这种情况表明了短语的左端点恰好位于栈里某个短语的边界处，而右端点又还在buffer里，所以还可以通过不断SHUFT然后REDUCE得到短语。但是如果左端点不是栈里短语的边界，那说明产生了交叉，自然不会可达了。而如果右端点已经在栈里了，那之后也不会得到了，因为转移系统每次都是REDUCE栈顶的短语，不可能从栈里面开始REDUCE的）。</li></ul><p>枚举标准树中的所有短语，根据以上规则可以得到可达短语集合$\mathcal{R}(c, \gamma_G)$，然后从标准短语集合中排除掉这部分短语，剩下的就是不可达短语集合$\mathcal{U}(c, \gamma_G) = \gamma_G \backslash \mathcal{R}(c, \gamma_G)$。这部分短语就是不论采取何种动作序列，最后都不可能生成的短语集合。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>对于每一个状态c，可以定义它的损失函数为<br>\[l(c) = \min_{\gamma |c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| { \mathcal{U}(c, \gamma_G)} \right| + \left| {\gamma_c \backslash {\gamma_G}} \right|\]<br>其中第一个因子惩罚的是False Negative短语，也就是漏报的短语，即正确的但是不可能被生成的短语。第二个因子惩罚的是False Positive短语，也就是误报的短语，即已经生成的但是是错的短语。</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>那么我们如何证明，按照这个最小的损失函数值走下去，一定能得到最优的句法树呢？也就是要证明，这个状态c的损失函数，的确就是从状态c能得到的最优句法树和标准树的汉明损失。<br>\[\min_{\gamma |c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| { \mathcal{U}(c, \gamma_G)} \right| + \left| {\gamma_c \backslash {\gamma_G}} \right|\]<br>首先证明这个损失函数是<strong>短语可分解</strong>的，也就是证明，对于一个标准树中的短语集合，如果其中的每一个短语都是各自可达的，那么整个集合中的短语可以同时生成。</p><p>证明这个性质要用到数学归纳法。首先$m = 1$时显然成立，然后假设集合元素个数为$m, (m &gt; 1)$时性质成立，下面证明集合T元素个数为$m + 1$时性质也成立。</p><p>令$(X, l, r)$表示集合T中偏序最小的短语，即l是最小的，如果l有相等的，就再取r最小的。根据假设，$(X, l, r)$是从状态c可到达的gold短语。令$T’ = T \backslash (X, l, r)$，所以集合T’有m个元素，根据递归定义，整个集合都是从状态c可达的。</p><p>如果短语的可达性条件中第一种情况满足，那么$(X, l, r)$已经存在于状态c已生成短语集合中了，那么整个T集合当然是可达的。</p><p>如果第二种情况满足，即$j \le l &lt; r$，那么可以通过不断SHIFT再一个REDUCE来得到短语$(X, l, r)$。那么T’集合又如何能全部生成呢？可以发现T’集合中的短语，要么是左边界等于l并且右边界大于r的（根据定义），这种可以继续SHUFT再REDUCE得到（满足条件3）。要么是左边界大于等于r的（因为都是标准树中的短语，所以不会有边界交叉），这种满足条件2，也可达。<strong>论文中就说了这两种情况，是否还存在一种左边界大于等于l，右边界小于等于r的情况呢？当然这种情况满足条件1，因为在生成$(X, l, r)$的时候就已经生成了。</strong>所以最终T集合还是全部可达的。</p><p>如果第三种情况满足，即l是栈里某个短语的边界，而r大于等于j，那么这种情况依然可以通过不断SHIFT再REDUCE得到，而T集合仍然可以全部可达，原因和上一种情况类似。</p><p>所以可以证得，从状态c开始，存在某个转移序列，使得所有可达短语全部生成，那么只有不可达的短语会被错过，即：<br>\[\min_{\gamma |c \to \gamma} \left| {\gamma_G \backslash {\gamma}} \right| = \left| { \mathcal{U}(c, \gamma_G)} \right|\]</p><p>最后一步就是证明另一项$\left| {\gamma \backslash {\gamma_G}} \right|$等于$\left| {\gamma_c \backslash {\gamma_G}} \right|$。首先因为前者肯定包含了后者，因为随着转移的进行，预测错误的短语只会增加，不会减少。然后证明最优句法树不会再增加新的错误短语，即从状态c开始的最优句法树一定是$\mathcal{R}(c, \gamma_G) \cup \left| {\gamma_c \backslash {\gamma_G}} \right|$。这里不是很好想，可以想象从包含当前栈顶短语的最小的标准短语开始，一步步的进行转移，按照<a href="https://www.aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">James and Huang</a>中的Dynamic Oracle。</p><p>至此已经证明了，这个损失函数可以保证每一步都按照最优的策略来进行转移。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验采用的转移模型都是基于<a href="http://aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Dyer et al.</a>，并且也采用了<a href="https://www.aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">James and Huang</a>中的exploration策略来增加错误状态，提高Dynamic Oracle的准确率。</p><p>在PTB上的实验结果如下：<br><img src="3.jpg" alt></p><p>结果其实也不是很高，现在来看算低的了，本文只和其他的转移系统结果进行了比较，可以说在转移系统上还算比较高的吧，虽然今年转移系统也做到了92.0了。在运行速度上，本文的模型也比其他转移系统略有提升，我感觉虽然不需要二叉化了，但是REDUCE#k动作的增加同样会增加复杂度，这是自底向上转移系统的一个固有的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文提出了一个非二叉化的自底向上的转移系统，主要有如下几个贡献点吧：</p><ul><li>非二叉化预测，采用REDUCE#k动作。</li><li>采用损失函数来实现Dynamic Oracle。</li><li>准确率上超过了除了in-order的大多数转移系统。</li><li>训练速度上是所有转移系统中最快的。</li></ul><p>看完这篇，我准备在chart-based的top-down模型上面也搞一个这种Dynamic Oracle试试，需要改变的就是每个状态的损失函数，现在的F1还只有91.87，希望能有所突破吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meta Multi-Task Learning for Sequence Modeling</title>
      <link href="/2018/10/25/metamtl/"/>
      <url>/2018/10/25/metamtl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>这篇文章是知识分析课准备讲的论文，随便拿来看一看了，简单介绍一下吧，论文是复旦邱锡鹏老师组写的。</p></blockquote><p><strong>论文地址：</strong><a href="https://arxiv.org/pdf/1802.08969.pdf" target="_blank" rel="noopener">Meta Multi-Task Learning for Sequence Modeling</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>多任务学习一般的模型是共享特征表示层，也就是最底层的特征表示层是共享的，上层的神经网络都是随具体任务而不同的。但是这有个问题，比如用LSTM对句子进行建模的时候，不同的短语的组合函数是一样的，比如动词+名词、形容词+名词。但是组合函数应该定义成不同的比较好，于是这篇文章提出了针对不同的任务，不同的时刻产生不同的参数矩阵的动态参数生成方法。</p><p>本文主要有如下三个贡献点：</p><ul><li>不同于以往的特征层的共享，本文模型提出了函数层的共享，也就是针对不同任务动态的生成不同的组合函数。</li><li>不仅对于多任务，Meta-LSTM对于单任务也有提升，因为是动态生成参数，所以每个时刻的参数都不一样，可以更好地表示不同的短语语义。</li><li>模型还可以被用作迁移学习，Meta-LSTM在训练完成后可以直接被用于新任务上面作为先验知识，而任务特定的LSTM就作为后验知识。</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>本文主要在序列标注和文本分类两个任务上面做实验，而且是多任务的，序列标注包括NER和POS tagging，文本分类包括多个不同领域的文本分类。</p><h2 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h2><p>传统的多任务模型共享一个私有LSTM特征表示层，用这个私有LSTM学习出句子的表示，然后和词向量拼接共同输入到任务特定的公有LSTM去。具体结构如下图所示：<br><img src="1.jpg" alt><br>输出层每个任务都是不共享的，和一般的模型一样，这里就不介绍了。最终的损失函数为所有任务的损失函数加权之和。</p><p>多任务模型的训练策略如下所示：</p><ul><li>首先随机选择一个任务。</li><li>然后从这个任务的数据集中随机选择一个mini-batch。</li><li>然后用这个任务的mini-batch数据去训练并更新参数。</li><li>不断重复以上三个过程。</li></ul><p>这样就可以训练出一个适用于所有任务的多任务模型。</p><h2 id="元多任务学习"><a href="#元多任务学习" class="headerlink" title="元多任务学习"></a>元多任务学习</h2><p>传统模型只共享了特征表示层，也就是共享了私有LSTM。本文的模型创新就是通过Meta-LSTM动态生成针对每个任务、每个时刻不同的参数，然后用每个任务特定的Basic-LSTM进行编码。具体结构如下图所示：<br><img src="2.jpg" alt><br>其中Basic-LSTM的结构和普通的LSTM基本一样，唯一区别就是每个时刻的参数W和b是通过Meta-LSTM动态生成的，形式化定义如下：<br><img src="3.jpg" alt><br>因为W维度过大，计算复杂度太高，并且也容易导致过拟合，所以这里采用了SVD分解：<br><img src="4.jpg" alt><br>而这里的$z_t$就是通过Meta-LSTM动态生成的，形式化定义如下：<br><img src="5.jpg" alt><br>如果精简的表示出这个LSTM之间的关系，可以写成如下形式：<br><img src="6.jpg" alt><br>概括起来就是：<strong>Basic-LSTM上一个时刻的输出$h_{t - 1}$、Meta-LSTM上一个时刻的输出$\hat h_{t - 1}$和当前时刻的单词表示$x_t$作为Meta-LSTM当前时刻的输入，产生的输出$z_t$用来产生Basic-LSTM当前时刻的参数矩阵。</strong></p><p>Meta-LSTM主要有如下两个优点：</p><ul><li>一个就是每个时刻的参数动态生成。</li><li>另一个就是比普通的LSTM参数数量更少，因为有SVD分解。</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><h2 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h2><p>文本分类任务是在16个购物网站评论数据集上做的，数据集大小如下所示：<br><img src="7.jpg" alt><br>最后在大多数数据集上，Meta-LSTM都能做到最好结果，具体结果如下：<br><img src="8.jpg" alt></p><h2 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h2><hr><p>序列标注任务是在三个数据集上面做的，两个是NER数据集，一个是POS tagging数据集，具体结果如下：<br><img src="9.jpg" alt><br>只能说比最基础的LSTM+CRF模型高了那么一丢丢吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文提出了一种function-level的多任务共享机制，即使用Meta-LSTM来动态产生Basic-LSTM每个时刻的参数矩阵。</p><blockquote><p>看完后我在想，这个动态参数生成的机制能不能用在成分句法分析上面，例如对于top-down的chart-based模型，可以自顶向下通过Tree-LSTM动态产生每一个树结点的参数矩阵，然后用这个参数矩阵来预测结点的label和split。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 迁移学习 </tag>
            
            <tag> AAAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Local Models for Neural Constituent Parsing</title>
      <link href="/2018/10/18/coling18-2localmodels/"/>
      <url>/2018/10/18/coling18-2localmodels/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>我们究竟是活了365天，还是活了1天，重复了364遍。</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/C18-1011" target="_blank" rel="noopener">Two Local Models for Neural Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/zeeeyang/two-local-neural-conparsers" target="_blank" rel="noopener">github</a></p><p>今天要介绍的论文来自COLING 2018，本文主要探讨了局部特征对成分句法分析到底有多大的影响，并同时提出了两种局部特征模型，在PTB上面取得了92.4的F1值。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>对于传统句法分析模型，需要使用大量的全局特征来指导每一步的决策。同时全局的损失函数也是必不可少的，可以用来避免预测偏差的问题，也就是loss mismatch问题。但是随着神经网络的加入，越来越多的模型使用了局部的特征来进行句法分析，主要原因是可以采用双向LSTM预先对句子进行编码，从而捕获全部特征。</p><p>因此本文主要探讨局部特征对句法分析的影响，顺带提出了两个句法分析模型。模型是chart-based的，但是将结构预测和标签预测分成了两个模型，首先通过双仿射模型来产生一棵无标签的句法树，然后再上面跑一遍Tree-LSTM来产生每一个结点的label。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>模型分为两部分，第一部分是无标签模型，用来预测不带label的句法树，第二部分是标签模型，用来在无标签模型预测出来的句法树上预测出每一个结点的label。</p><p>对于无标签模型，有两种方法来生成句法树，第一种叫做span模型，预测任意span是否属于标准树，也就是二分类。第二种叫做rule模型，也就是普通的chart-based方法，类似于CKY算法，预测每个span的得分最高的split。</p><p>对于标签模型，在生成的句法树上跑一遍Tree-LSTM，计算出每个结点的向量表示，这是Encoder部分。然后对于每个结点，运行一遍Decoder，也就是一个LSTM，解码出该结点处的label，如果label只有一个，那么就解码出“X - &lt;\L&gt;”，其中&lt;\L&gt;是结束符，而如果label不止一个，也就是一元产生式，那么就会解码出一系列非终结符。</p><p>下面我们一个个介绍编码和解码模型，我尽量不使用太多的公式来解释模型，一是因为本质上模型也都是很老的了，二是因为公式太多了我也懒得打嘻嘻。</p><h2 id="Span模型"><a href="#Span模型" class="headerlink" title="Span模型"></a>Span模型</h2><p>主要思想就是对于句子的每一个可能的span，预测它是否属于标准树，属于标签就是1，不属于就是0。因为一共有$n(n + 1) / 2$个span，所以时间复杂度为$O(n^2)$。在代码实现中，因为长度为1和长度为n的span一定属于标准树，所以不考虑这两种span。</p><p>模型通过一个双向LSTM来对短语进行编码，这个之前的文章已经说过很多次了，可以用来捕获全局信息。span$(i, j)$的向量表示和之前略有不同，这里不是用两端的差值，而是改用直接拼接得到：<br>\[v[i, j] = [f_{i + 1}; r_i; f_{j + 1}; r_j]\]<br>然后将每个span的表示输入到一个两层的前馈神经网络中，最后通过一个softmax进行二分类：<br>\[\begin{array}{l}o[i,j] = \tanh ({W_o}v[i,j] + {b_o})\\\\u[i,j] = {W_u}o[i,j] + {b_u}\\\\P({Y_{[i,j]}}|S,\Theta ) = softmax(u[i,j])\end{array}\]<br>其中$Y_{[i, j]}$可以取值1或者0，最终要使得正确span标签为1的概率与错误span标签为0的概率之和最高。</p><p>训练完毕之后，在预测阶段，使用CKY算法求解最优的句法树。注意这里不能直接采用$Y_{[i, j]} = 1$概率比较大的那些span组成句法树，因为可能根本就是一棵不合法的句法树。对于span$(i, j)$，它的split为k的概率为：<br>\[P(r|S, \Theta) = P(Y_{[i, k]} = 1|S, \Theta)P(Y_{[k + 1, j]} = 1|S, \Theta)\]</p><p>模型还有个扩展版本，就是在softmax层改二分类为预测每个label的概率。然后损失函数也稍做修改，对于每个标准树中的span，对所有label求和（求和主要针对的是一元产生式的多个label），使概率之和最大。在预测阶段解码时，依然使用CKY算法，只不过span的概率要修改为：$Y_{[i, j]} = 1$的概率为label不为终结符的概率之和，$Y_{[i, j]} = 0$的概率为label是终结符的概率。</p><h2 id="Rule模型"><a href="#Rule模型" class="headerlink" title="Rule模型"></a>Rule模型</h2><p>span模型是训练出每个span属于标准树的概率，然后预测时计算出产生式的概率。而rule模型就直接训练每个产生式的概率，对于span$(i, j)$，假设它的split为k的分数为$ps_k$，那么产生式的概率就为：<br>\[P([i, j] \to [i, k][k + 1, j] | S, \Theta) = \frac{\exp (ps_k)}{\sum\nolimits_{k’ = i}^{j - 1} {\exp (p{s_{k’}})} }\]<br>最终的损失函数就是标准树中所有产生式概率的负对数之和。解码依然使用CKY算法，只是这里产生式概率直接得到了，所以直接计算即可。</p><p>这种方法本质上其实就是用神经网络来拟合PCFG，得到和它类似的效果，最后再用CKY算法解码出句法树。</p><p>而上面的$ps_k$是怎么得到的呢？这里首先还是用双向LSTM的边界差值作为span的表示（我也不知道这里为什么又突然用这个表示了）：<br>\[s[i, j] = [f_{j + 1} - f_i; r_i - r_{j + 1}]\]<br>然后将span之前和span和span之后三部分的表示拼接起来：<br>\[sr[i, j] = [s[0, i - 1]; s[i, j]; s[j + 1, n - 1]]\]<br>然后将它输入到一个单层前馈神经网络：<br>\[r[i, j] = \phi (W_r^M sr[i, j] + b_r^M)\]<br>注意到这里的W和b是分为三种：父结点、左儿子、右儿子。</p><p>然后就是最后一步了，终于可以得到最终的span表示了。。。这里又有两种方法，一种是线性模型，直接对左右儿子的r向量加权求和。另一种是双仿射模型，这个方法也可以解决span长度不一导致的类别数可变的多分类问题，双仿射模型得分首先在父结点和左儿子向量上进行操作：<br>\[lps_k = {[r[i,j];1]^T}{W_{pl}}[r[i,k];1]\]<br>然后在父结点和右儿子向量上进行类似操作得到$rps_k$，最后相加得到最终的split得分：<br>\[ps_k = lps_k + rps_k\]</p><h2 id="标签生成模型"><a href="#标签生成模型" class="headerlink" title="标签生成模型"></a>标签生成模型</h2><p>首先用Tree-LSTM得到每个span的向量表示，然后再通过一个LSTM依次得到span的一个或者若干个label，这个就不详细解释了。</p><h2 id="联合训练"><a href="#联合训练" class="headerlink" title="联合训练"></a>联合训练</h2><p>整个模型总的损失函数是无标签模型损失加上标签生成模型的损失，其中无标签模型分为三种：二分类、多分类、rule模型。</p><p>整个模型的流程如下图所示：<br><img src="1.jpg" alt><br>span模型和rule模型的span得分计算如下图所示：<br><img src="2.jpg" alt></p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>几种模型在PTB上的F1值如下：<br><img src="3.jpg" alt><br>可以看出对于二分类span模型，用$v[i, j]$作为span表示效果最好，而对于rule模型，采用的是双仿射，那么用$sr[i, j]$，也就是拼接上span左右的span效果更好。总体来说，多分类的span模型F1值是最高的。</p><p>而和其他模型的比较如下表所示：<br><img src="4.jpg" alt><br>左侧是多模型融合的结果，右侧是单模型，本文的几个模型结果都是最高的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文模型和变体有点多，其实仔细分析下来可以发现本质上也还是那么些东西，在这里简单总结一下几种模型：<br>首先是结构预测：</p><ul><li>二分类span模型：预测每个span属于标准树的概率，测试阶段使用CKY算法解码，通过span正确的概率计算得到产生式概率。</li><li>多分类span模型：在二分类的基础上，预测每个span是每个label的概率，最后求和得到它属于标准树的概率，测试过程和二分类相同。</li><li>线性组合rule模型：通过split的得分直接预测每个产生式的概率，采用线性组合计算概率，解码采用CKY算法。</li><li>双仿射rule模型：除了概率计算采用双仿射，其他部分和线性组合rule模型完全相同。</li></ul><p>然后是标签预测：<br>都是采用Tree-LSTM产生每个结点的编码，然后创新地使用LSTM来预测label，而不是用传统的label列表。</p><p>这篇论文可借鉴的地方还挺多的，结构和标签分开预测，span特征继续堆叠，双仿射变换等等。准备之后在以往模型上加上去试试，然后可以想想神经网络训练PCFG这类点子，其实本质上和chart-based的没啥大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> COLING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear-Time Constituency Parsing with RNNs and Dynamic Programming</title>
      <link href="/2018/10/15/acl18-beamspanparser/"/>
      <url>/2018/10/15/acl18-beamspanparser/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>好像已经很久没有看论文了呢，开学了一堆事情，以后还是要抽空阅读论文，保持一定的阅读量，并且不能光看最新的论文，还得去前人传统的方法中去寻找有没有能应用于深度学习的东西，说不定就发ACL了呢（手动滑稽）。</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/P18-2076" target="_blank" rel="noopener">Linear-Time Constituency Parsing with RNNs and Dynamic Programming</a><br><strong>代码地址：</strong><a href="https://github.com/junekihong/beam-span-parser" target="_blank" rel="noopener">github</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这次要介绍的论文是huang liang发表在ACL18的一篇短文，提出了一个基于转移系统的线性时间句法分析器。本文的主要贡献点主要有如下几点：</p><ul><li>传统的基于转移的句法分析模型都是贪心解码，不能考虑到所有的状态空间，所以本文的模型采用beam search将状态空间提升到了指数级别。</li><li>首次采用cube pruning将分析的时间复杂度降低到了$O(nb \log b)$。</li><li>采用max-violation损失函数代替原来的求和的损失函数，并且对cross-span的span进行了惩罚。</li><li>在单模型上取得了最高的F1值。</li><li>采用图结构的栈（GSS）代替了原来的stack，这样不需要时刻保存历史信息。</li></ul><h1 id="模型基础"><a href="#模型基础" class="headerlink" title="模型基础"></a>模型基础</h1><hr><h2 id="基于span的转移系统"><a href="#基于span的转移系统" class="headerlink" title="基于span的转移系统"></a>基于span的转移系统</h2><p>这个我已经在之前的文章<a href="https://godweiyang.com/2018/09/26/constituent-parsing-summary/#系统改进">成分句法分析综述</a>中详细阐述过了。核心思想就是stack里面保存的不再是短语结构树，而是span的左右边界下标$(i, j)$，初始时stack里面是$(0, 0)$，终止状态栈里是$(0, n)$，SHIFT之后栈顶变为$(j, j + 1)$，REDUCE之后栈顶变为$(k, j)$（假设之前栈顶两个元素是$(k, i)$和$(i, j)$）。</p><h2 id="Bi-LSTM特征"><a href="#Bi-LSTM特征" class="headerlink" title="Bi-LSTM特征"></a>Bi-LSTM特征</h2><p>状态转移时用双向LSTM两端的差值计算每个span的表示，然后计算出得分，用来预测action。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr><h2 id="句法树得分"><a href="#句法树得分" class="headerlink" title="句法树得分"></a>句法树得分</h2><p>还是和之前chart-based模型一样，用每个span的label得分之和作为句法树的总得分。</p><h2 id="图结构栈（Graph-Struct-Stack-GSS）"><a href="#图结构栈（Graph-Struct-Stack-GSS）" class="headerlink" title="图结构栈（Graph-Struct Stack, GSS）"></a>图结构栈（Graph-Struct Stack, GSS）</h2><p>因为要采用动态规划来枚举每个时刻所有的状态，不是用普通的stack，使用GSS来保存每个时刻的状态。GSS每个时刻只需要保存栈顶的span就行了，假设为$(i, j)$。如果action是SHIFT，那么下一步就变成了$(j, j + 1)$，如果action是REDUCE，那么还需要知道栈顶第二个元素是什么。因为考虑到了所有的状态空间，所以所有的$(k, i)$都是有可能的。</p><p>GSS的具体结构如下图所示：<br><img src="1.jpg" alt><br>每个时刻的状态仅用一个span表示，在具体实现的时候，每个span还保存了一个span指针数组，指向它前面所有可能的span，还保存了当前span以及之前所有span的分数之和$c$和当前span子树的分数之和$v$。每个状态还保存了一个时刻标记$l$，易知一共有$2n - 1$个时刻。</p><p>当采取SHIFT动作时，状态变为了$(j, j + 1)$，并且新的span$(j, j + 1)$的指针数组中新增加一个span也就是$(i, j)$。prefix分数变为$c + \xi$，其中$\xi$是span$(j, j + 1)$的最高label得分，而inside分数就是span$(j, j + 1)$的分数$\xi$。</p><p>当采取REDUCE动作时，枚举span$(i, j)$指针数组中所有的前一个span$(k, i)$，然后合并成一个span$(k, j)$，prefix分数变为$c’ + v + \sigma$，其中$\sigma$就是span$(k, j)$的最高label得分，inside分数变为了$v’ + v + \sigma$。实际代码实现中，REDUCE完了后，span$(k, j)$的指针数组要更新为span$(k, i)$的指针数组。</p><h2 id="Beam-Search和Cube-Pruning"><a href="#Beam-Search和Cube-Pruning" class="headerlink" title="Beam Search和Cube Pruning"></a>Beam Search和Cube Pruning</h2><p>在每个时刻，只保存prefix得分最高的前b个span状态，这样时间复杂度可以降为$nb^2$，但是$b^2$相对于句子长度来说还是太大了，所以采用cube pruning继续降到$nb \log b$。</p><p>cube pruning原理是这样的：普通的beam search每个时刻枚举至多b个span，每个span和之前的至多b个span结合，所以一共最多产生$b^2$个span。</p><p>而cube pruning在每个时刻都建立一个堆，首先用上一个时刻的beam里的b个span，来产生b个SHIFT的span，送入堆里。理论上来说还应该产生至多$b^2$个REDUCE的span，但是在这里对于每个span，只取它的指针数组里得分最高的那个span，来和它结合产生新的span，送入堆里。然后在产生好的堆里，每次取出得分最高的span，出堆，如果它是REDUCE得到的span，那么就继续按照它的指针数组得分从高到低顺序产生一个span，REDUCE完之后送入堆里。依次下去，直到出栈了b个span为止。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><hr><p>还是使用max-margin loss来训练，但是有几点小小的改进。</p><h2 id="cross-span损失"><a href="#cross-span损失" class="headerlink" title="cross-span损失"></a>cross-span损失</h2><p>以往的损失函数里有个$\Delta (t,t’)$，衡量的是预测树和标准树不同的span的数量。但是这有个问题，因为用了隐式二叉化，所以在预测树里存在label为空的情况。如果这个span在标准树中label也是空，那么原来的损失就不惩罚这一项了，但是要考虑到如果这个span在标准树中与某个标准的span产生了交叉，那么它根本就不可能是对的，也得进行惩罚。</p><h2 id="max-violation-updates"><a href="#max-violation-updates" class="headerlink" title="max violation updates"></a>max violation updates</h2><p>这是huang liang在2012提出来的，其实就是计算出每个时刻预测得分和标准得分的差距，然后取差距最大的那个时刻的得分差距作为最终的损失函数，之前都是用每个时刻得分差距之和来作为损失函数的。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>下图是不同的beam大小对不同长度句子分析速度的影响：<br><img src="2.jpg" alt><br>最终综合考虑速度和准确率，选择beam大小为20。</p><p>最后是beam-span模型在PTB测试集上的准确率，在单模型上取得了最好的结果：<br><img src="3.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文是短论文，所以相比之下创新没有那么的大吧，主要还是速度上比chart-based有了提升，准确率上比普通的转移系统有了提升，另外还提出了几点小的改进吧，例如cross-span问题、max-violation损失之类的，转移系统也改成了适合用来进行beam search的GSS，为了进一步加快速度，还用了cube剪枝。</p><p>这么多改进其实个人感觉也是影响不大的，不是很通用，cross-span和max-violation损失可以考虑拿来用一下。下一步的工作还是考虑如何增加特征表示、加入头结点之类的吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给python新手的一些建议</title>
      <link href="/2018/10/11/python-advice/"/>
      <url>/2018/10/11/python-advice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>首先很荣幸被邀请给大一新入学的学弟学妹们谈谈编程入门经验，尤其是他们正在学的python语言。我就随便谈谈我大一时是如何编程入门的，以及怎么才能学好python编程，其他语言类似，都是相通的。最后再回答一下大家问的比较多的一些问题。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><hr><p>大多数人应该和我刚上大学时一样，完全没有接触过编程，所以在上python课的时候可能是一脸懵逼，完全不知道代码的原理是什么，为什么写出来就能运行，也不知道如何熟练地写出一段完整的代码。这都很正常，我大学之前也是对计算机一窍不通的，但是高中毕业的那个暑假，刚刚接触电脑、用上互联网的我，用了一个月自学了谭浩强的《C语言程序设计》，从此打开了新世界的大门。因此我下面结合我自身的经历给大家一些编程学习的经验，当然很多都要结合你自身的喜好和习惯，不用完全按我的来。</p><h1 id="一个称手的代码编辑器"><a href="#一个称手的代码编辑器" class="headerlink" title="一个称手的代码编辑器"></a>一个称手的代码编辑器</h1><hr><p>要想代码写的舒服，首先得用一个称手的代码编辑器，最常用的python IDE是pycharm，如果你刚入门很依赖调试的话，可以使用这款IDE。当然不能过于依赖IDE的调试功能，要练就肉眼调试的本领，这样能极大的提高你的代码能力。所以我熟练了之后换上了sublime代码编辑器，这是一款十分漂亮的编辑器，个人觉得比pycharm好看到不知哪里去了。而具体的安装与python环境配置，去看看我的教程就行了：<a href="https://godweiyang.com/2017/10/02/sublime/">Sublime Text安装与配置教程</a>。</p><h1 id="多练-gt-多看"><a href="#多练-gt-多看" class="headerlink" title="多练&gt;多看"></a>多练&gt;多看</h1><hr><p>很多人还以为和高中一样，上课听听就完事了，课后也就不花时间去写代码了。其实不然，要想学好python，光课上听是没什么用的，还需要课后不停的找题目练习，只有试了才知道自己可能会踩到什么坑，才能不断总结出许多代码编写的经验。我刚开始也是一个劲看书，觉得语法都看的差不多了，以为自己都懂了，但是真正自己写起来才发现有很多的问题。</p><p>课本首先得看熟了，上面的例子都要自己敲过去，还有布置的编程作业都得认真做完。推荐大家一个在线编程网站：<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">Python 基础教程 | 菜鸟教程</a>，上面可以边学边练习，可以一定程度上提高你的学习积极性。</p><h1 id="善于使用EOJ"><a href="#善于使用EOJ" class="headerlink" title="善于使用EOJ"></a>善于使用EOJ</h1><hr><p>有很多同学学到最后都不知道有EOJ这个东西，这是我们学校的在线刷题网站，现在已经做得十分精美了。如果让你干巴巴的去写书上的代码，可能没多久你也没什么兴趣写了，但是如果让你用python做出来一道道的编程题，那么依旧会获得难以描述的快感，这能极大的提升你的积极性和代码能力。</p><p>首先去<a href="http://acm.ecnu.edu.cn/" target="_blank" rel="noopener">EOJ</a>注册一个账号，然后去做过的人多的简单题，很多题首先考察的不是代码能力，而是你的算法，下面我还会讲到算法的重要性。做题需要注意输入输出格式，注意题目中的各种坑点，代码不是自然语言，和数学题一样容不得半点差错。</p><h1 id="程序-算法-数据结构"><a href="#程序-算法-数据结构" class="headerlink" title="程序=算法+数据结构"></a>程序=算法+数据结构</h1><hr><p>光会写几行代码没用，还要学会使用基本的数据结构和算法，这样才能写出高效率高质量的代码。比如python中的列表<code>list</code>、元组<code>tuple</code>、字典<code>dict</code>等等，熟练使用它们将会大大减轻你的工作量。算法也是非常重要的，比如要对若干个数进行排序，如果暴力的话速度会很慢很慢，这时候你就要学会用快速排序算法，就能立即得到结果啦。</p><h1 id="学会查阅资料"><a href="#学会查阅资料" class="headerlink" title="学会查阅资料"></a>学会查阅资料</h1><hr><p>很多人遇到什么函数不会用了，使用报错了都不知道怎么办，到处问人，其实可以直接去<a href="https://docs.python.org/3/" target="_blank" rel="noopener">python官网</a>查看文档，里面都有各个函数的用法说明。遇到错误也可以百度错误内容，会有很多人写博客说明解决方法的，实在找不到推荐一个网站：<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>，这是国外的一个问答网站，上面有超多编程相关问题，只要你提问了基本都有人替你解答。</p><h1 id="良好的编码风格"><a href="#良好的编码风格" class="headerlink" title="良好的编码风格"></a>良好的编码风格</h1><hr><p>很多同学刚开始写的代码风格都很丑，我自己也是，要尽快形成自己的代码风格，python相比c语言好很多，强制了缩进，不然编译都不给你通过，但是还是有很多地方需要你自己注意，比如表达式运算符两边要加空格、变量命名要可以直接看出用途等等。推荐大家去读一读google的<a href="https://www.runoob.com/w3cnote/google-python-styleguide.html" target="_blank" rel="noopener">python编程规范</a>，写出美观的代码，以后也便于维护。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><hr><ul><li><p><strong>Q: python相对于其他语言有哪些优势和区别？</strong></p></li><li><p><em>A:*</em> 首先python语言最大的优势就是简单，非常适合没有编程基础的人入门，它去除了c语言繁琐的指针类型，而且代码也很容易读懂，与人类语言有点类似。python也支持面向对象，并且不像c++和java那样繁琐，保持了它的简洁性。因为它是开源的，所以有很多很多的第三方库可以调用，很多功能根本不需要你自己动手写，别人都帮你写好封装好了，你直接调用一个函数就解决了。但是python也有缺点，一大缺点就是相比于c++和java这种较为底层的语言，python的运行速度非常慢，当然可以选择使用cython来加速python。并且python的格式要求非常严格，强制代码缩进，两条语句不能写在同一行等等。</p></li><li><p><strong>Q: 老师上课提到“面向对象”和“面向过程”，是什么意思？</strong></p></li><li><p><em>A:*</em> 简单来说，面向过程就是按照解决问题的顺序，一步步的编写代码、调用函数。而面向对象就是将你要处理的事物分解为一个个对象（也就是类），每个对象有很多属性，编写代码时只要生成这些类，并且调用它们的类方法就好了。面向对象的一大好处就是可维护性好，比如如果你要对两个相同的对象进行操作，如果用面向过程，那你就要写两段相同的代码，如果改了一段，还得同时修改另一段；而面向对象就很简单了，因为你的两个对象都封装在了一个类里，所以只要改一下类就好啦。</p></li><li><p><strong>Q: 拿到一个问题应该如何思考？如何解决？步骤是什么？</strong></p></li><li><p><em>A:*</em> 拿到一个问题（比如编程题），不要直接下手写代码，先想想该用什么方法解决？方法的时间复杂度和空间复杂度能否承受？要用到哪些函数？总体框架应该写成什么样子？然后再一个个模块编写，不要写一步想一步。</p></li><li><p><strong>Q: 什么是递归思维？有什么好处？</strong></p></li><li><p><em>A:*</em> 递归思想也就是递归算法是经常用到的一种算法，可以将规模很大的问题化解为一个个的小问题，便于求解也增加了可读性。举个例子吧，求解阶乘，常规方法是从$f(1)$开始逐项计算，而用递归思想就是要计算$f(n)$，就先计算出$f(n - 1)$然后乘以$n$，而$f(n - 1)$继续递归算下去就行了。</p></li><li><p><strong>Q: 对于萌新，基础薄弱，学长有什么好的方法？推荐一下有用的参考资料</strong></p></li><li><p><em>A:*</em> 基础薄弱那就先把书上的语法看懂了，边看边敲了自己试一试怎么用，不要光看不写。资料的话看再多不如自己敲来的记忆深刻，推荐《python简明教程》吧，最方便的还是不会的用法直接百度或者谷歌，看博客讲解。</p></li><li><p><strong>Q: 如何避免语法符号规范的错误？</strong></p></li><li><p><em>A:*</em> 语法错误很正常，我也经常遇到，特别是没怎么用过的函数，这个只能靠查文档，然后用多了自然就记得怎么用了。规范之类的上面说过了，去看google的python编码规范，养成一个好的编码习惯，既是为了别人能看懂你的代码，也是为了你自己今后还能看懂你自己的代码。</p></li><li><p><strong>Q: 如何判断什么时候该用什么函数？</strong></p></li><li><p><em>A:*</em> 这个就根据你要实现的功能啊，比如你要切分一个句子变成若干个单词，那么自然而然想到要用<code>string.split()</code>函数。当然刚开始你可能根本就不知道有哪些函数可以给你用，那么你就需要百度“python切分一个句子变成若干个单词”，然后就会告诉你要用什么方法了，多查多记以后就会用了。</p></li><li><p><strong>Q: OJ系统是什么？我们如何利用它？</strong></p></li><li><p><em>A:*</em> OJ全称是Online Judge，是一个在线评测系统，上面有很多很多编程题，你可以写代码实现它，然后提交给OJ运行，它会告诉你你的代码是否正确。大家可以利用我们学校自己的EOJ来进行编程训练，先从简单的题开始做起，记住，不要一遇到不会做的题就去百度找题解，一定要自己思考，自己想出了方法收获才是最大的，切记。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成分句法分析综述</title>
      <link href="/2018/09/26/constituent-parsing-summary/"/>
      <url>/2018/09/26/constituent-parsing-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>本文不再更新，请移步最新第二版综述。</strong><br><a href="https://godweiyang.com/2018/09/26/con-parsing-summary-v2/">成分句法分析综述（第二版）</a></p><blockquote><p>一直以来想对保研到现在一年多看过的论文进行一个总结，正好赶上下周二要讲组会，所以将自己看过的成分句法分析相关的论文梳理一下，写一个粗略的综述。可能有很多细节还不是很懂，理解有误，还请大家指正。</p></blockquote><p><strong>PPT地址：</strong><a href="https://github.com/godweiyang/files-backup/tree/master/lecture/ppt1" target="_blank" rel="noopener">A Summary of Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/godweiyang/ConstituentParsing" target="_blank" rel="noopener">Constituent Parsing</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>成分句法分析（constituent parsing）是自然语言处理中的一个基础任务，它的任务是给定一个句子，分析出句子的短语结构句法树。例如给定句子“The little boy likes red tomatoes .”，它的成分句法树如下图所示：<br><img src="syntactic_tree.png" alt><br>成分句法分析可以利用到许多下游任务中去，比如情感分析可以利用句子的成分句法树来进行递归神经网络建模，从而分析出句子的情感。也可以利用在其他基础任务中去，比如可以将训练好的成分句法树直接转为依存句法树，从而提升依存句法分析的准确率。</p><p>传统的成分句法分析方法主要是规则（grammar）和统计的，比如结合两者的概率上下文无关文法（PCFG），在此基础上产生了应用广泛的CKY解码算法。CKY算法本质上是一种动态规划算法，本文之后要讲到的chart-based模型的解码算法也是基于动态规划算法的，和CKY算法十分地相似。</p><p>Socher在2013年又提出了组合向量文法（CVG），将递归神经网络应用到了成分句法分析中，给每个短语结构赋予了向量表示。但是这种方法还是需要用到规则，采用CKY算法解码，时间效率比较低。还有一种基于CRF的神经网络句法分析方法，将离散的特征转化为了连续的特征表示。</p><p>不过，上面这些方法统统都不在本文的讨论范围之内。本文讨论近两年来研究最热门的几种模型，主要包括基于转移系统（transition-based）的模型、基于动态规划（chart-based）解码的模型、基于自顶向下贪心（greedy top-down）解码的模型和一些将预测树结构转化为预测序列（sequence to sequence）的模型。</p><h1 id="基于转移系统的模型"><a href="#基于转移系统的模型" class="headerlink" title="基于转移系统的模型"></a>基于转移系统的模型</h1><hr><p>基于转移系统的模型主要分为三大类。第一种是自底向上（bottom-up）的系统，代表性论文有Transition-based Neural Constituent Parsing等。第二种是自顶向下（top-down）的系统，代表性论文有Recurrent Neural Network Grammars和Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles等。最后一种是2017年提出的基于中序遍历（in-order）的系统，代表性论文有In-Order Transition-based Constituent Parsing等。</p><p>在这三类系统的基础之上，许多人又做了非常多的改进。例如提出了动态指导（dynamic oracle）技术，来解决序列预测中的exposure bias问题（具体含义之后会讲到）。还有使用强化学习中的policy gradient来代替dynamic oracle，解决了针对不同转移系统需要设计不同的dynamic oracle的问题。</p><p>基于转移的句法分析系统主要包含两个组成成分，一个是栈（stack），用来存放已分析的句法结构，另一个是缓存（buffer），用来存放待分析的句子。而预测句法树结构就转化为了预测转移系统每一个时刻应该采取的动作（action）序列。下面我们分别介绍几种不同的转移系统，我们用三元组$[S, B, T]$来表示转移系统每一个时刻的状态，分别代表栈、buffer的第一个单词下标、句法分析结束标志。</p><h2 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h2><p>自底向上的转移系统是根据句法树的后序遍历（post-order）顺序进行句法分析的，首先将buffer中的单词移进栈里，然后将栈顶的若干个单词归约为它们的父结点，直至最后buffer为空并且栈里只有一个根节点。</p><p>在句法分析之前，首先要对句法树进行二叉化，这一点在传统的CKY算法中也会用到。例如对于之前的那棵句法树，二叉化后就变成了下图所示：<br><img src="binarized_syntactic_tree.png" alt></p><p>自底向上转移系统的action形式化定义如下：<br><img src="bottom_up.jpg" alt><br>其中SHIFT动作就是将buffer里面的第一个单词移进栈里。REDUCE-L/R-X动作就是将栈顶的两个元素出栈，并且归约为它们的父结点X，然后再将父结点入栈，而L和R就是用来区分左儿子和右儿子谁是头结点（head branch）。Unary-X动作就是将栈顶元素出栈，并且归约为父结点X，这个动作是用来预测一元产生式的。最后FINISH动作用来判断句法分析是否结束。</p><p>注意到这里有一个问题：为什么这里一定要提前对句法树进行二叉化？主要原因是因为自底向上系统有个弊端，就是在不停地SHIFT之后，你不仅要预测哪一步开始REDUCE，还得预测REDUCE的话要REDUCE栈顶的多少个元素，这样预测的状态数就大大增加，导致训练时间也增加了许多。而二叉化后每次预测就只需要预测哪一步REDUCE就行了，每次REDUCE只REDUCE栈顶的两个元素。</p><p>对于上面的句法树，用自底向上系统分析的过程如下图所示：<br><img src="bottom_up_example.jpg" alt><br>自底向上转移系统的优点就是可以充分利用已经生成的子树信息，来辅助后面的子树预测。</p><p>但是缺点也很显然，因为无法知道父结点以及再上层的父结点信息，所以丢失了许多有用的全局信息，这也有点类似于CKY算法的弊端了，同样只能根据局部的子树信息预测当前子树。</p><p>另一个缺点就是需要提前进行二叉化，虽然二叉化加入了head结点信息，事实证明是很有用的，但是head结点的标注需要许多语义学知识，也可以用神经网络来自己学习到head结点，但是二叉化总归是比较麻烦的。一个较为简洁的做法就是，用空结点$\emptyset$来作为本不应该归约的两个结点的临时结点，在还原树结构的时候忽略这种空结点，这样就可以隐式地进行二叉化操作了。</p><h2 id="自顶向下的转移系统"><a href="#自顶向下的转移系统" class="headerlink" title="自顶向下的转移系统"></a>自顶向下的转移系统</h2><p>自顶向下的转移系统利用的是句法树的前序遍历（pre-order）序列，首先将父结点入栈，然后不断操作直到它的子结点全部入栈，这时将父结点连同所有子结点全部归约为上一层的父结点。</p><p>自顶向下转移系统的action形式化定义如下：<br><img src="top_down.jpg" alt><br>其中SHIFT动作和之前一样，都是将buffer的第一个单词入栈。而NT-X动作就是将父结点X入栈。REDUCE动作就是将栈顶若干个元素直到它们的第一个父结点为止都出栈，然后归约为一个结点，再次入栈。注意到这里不同于自底向上系统的地方是没有FINISH动作，笔者也没有找到相关解释，猜测可能是因为自底向上系统存在一元动作Unary-X，所以最后根节点可能会无限归约下去，需要通过FINISH来提前终止分析。当然其实转移系统的动作定义并没有严格的要求，不同论文定义的也都不一样，但是都大同小异，也就是都存在SHIFT-REDUCE动作。</p><p>对于上面的句法树，用自顶向下系统分析的过程如下图所示：<br><img src="top_down_example.jpg" alt></p><p>自顶向下系统的优缺点和自底向上系统恰好互补。优点就是可以充分利用全局信息，例如父结点的信息，并且不需要进行二叉化，因为REDUCE的时候只要往栈里找到第一个父结点就行了。而缺点就是无法利用局部信息，也就是子树信息，同样NT-X动作也可能会出现无限多次执行的情况，所以要加上一些限制条件。</p><h2 id="In-order转移系统"><a href="#In-order转移系统" class="headerlink" title="In-order转移系统"></a>In-order转移系统</h2><p>Zhang和Liu两人在2017年提出了in-order转移系统，它利用的是句法树的中序遍历（in-order）序列，首先将一个子结点SHIFT入栈，然后将父结点入栈，再不断操作直到该父结点的剩余子结点全部入栈，然后对它们进行归约。</p><p>in-order转移系统的action形式化定义如下：<br><img src="in_order.jpg" alt><br>其中SHIFT动作和之前一样，都是将buffer的第一个单词入栈。PJ-X动作是预测出当前栈顶的元素的父结点X。REDUCE动作就是将栈顶的若干个元素归约为最里面倒数第二个元素，也就是它们的父结点。</p><p>对于上面的句法树，用in-order系统分析的过程如下图所示：<br><img src="in_order_example.jpg" alt></p><p>in-order转移系统提出的动机也很符合人类的直觉，在你读一个句子的时候，如果你第一个看到的单词是“The”，那么你脑海中可能会想到后面紧跟着的可能是个名词短语NP，然后你继续往后看，果然验证了你的猜想，后面的单词序列是“red tomatoes”。</p><p>in-order转移系统的优点恰好结合了前面两种转移系统，既可以考虑到局部信息，又可以考虑到全局信息。</p><p><strong>模型变体：</strong>in-order系统就是在自顶向下系统的基础上，在父结点入栈之前先入栈了1个子结点。那么如果稍加修改，还可以提前入栈两个、三个等等。假设在父结点入栈之前先入栈了$k$个子结点，那么称这种转移系统为k-in-order系统。特别地，如果$k = 0$，那么这就是自顶向下转移系统；如果$k = 1$，那么这就是in-order转移系统；$k = \infty$，那么这就是自底向上转移系统。</p><h2 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h2><p>上面说到的三种基于转移的句法分析系统，都可以概括为预测每一个时刻的action，那么每一个时刻的状态如何表示就是最重要的问题。在每一个时刻，最重要的组成部分有三个，分别是当前栈的状态、当前buffer的状态、当前已生成的action序列的状态。</p><p>当前状态的表示通过下图所示的三个LSTM得到：<br><img src="transition_framework.png" alt><br>其中栈和buffer的编码使用的是stack-LSTM，而action的编码使用的是普通的LSTM。最后将三种LSTM输出拼接到一起，用softmax预测出正确的action。</p><p>另一个问题就是如何编码栈里的短语。在以前都是通过递归神经网络或者树状LSTM来编码树状结构短语的，而在这里的话直接将父结点和子结点合为一个序列，送入到双向LSTM中就行了，具体形式如下图所示：<br><img src="composition.png" alt></p><h2 id="系统改进"><a href="#系统改进" class="headerlink" title="系统改进"></a>系统改进</h2><p><strong>基于span的自底向上的转移系统</strong><br>黄亮在2016年论文里提出了转移系统的栈里用span的左右边界数值来代替分析出来的子树，并且将REDUCE动作和预测label分开来进行，他们的转移系统action形式化定义如下：<br><img src="span_based_bottom_up.png" alt><br>可以看出，在第偶数个时刻，只预测结构化动作sh和comb(对应于之前转移系统的SHIFT和REDUCE)，sh动作从buffer中移进栈里一个单词$w_{j+1}$，栈顶的span就变为了$span(j, j+1)$。而comb动作就是将栈顶的两个span归约为一个span。在第奇数个时刻，只预测栈顶span的label，如果这个span的确能构成一个短语，那么就预测它的label，否则的话说明只是个临时结点，就预测为空结点，这一点在之前就已经提到过了。</p><p>论文里给出了一个具体的例子：<br><img src="span_based_bottom_up_tree.png" alt><br><img src="span_based_bottom_up_example.png" alt></p><p>文章开头提供的代码也是基于这个转移系统的，一个好处是用span来表示的话比较方便，代码也好写。另一个好处就是每一个时刻的状态可以不再用三个LSTM动态地算出来了，而是可以提前用双向LSTM对句子进行编码，然后用两个单词输出的差值作为单词之间span的表示，最后用它来计算转移状态的向量表示。</p><p>例如在某个时刻，栈首元素为$(i, k, j)$，那么结构化预测就采用四个span特征：$span(0, i), span(i, k), span(k, j), span(j, n)$，为什么要用这四个呢？因为comb动作涉及到栈首的两个span，而之前已经生成的$span(0, i)$也可以作为局部信息指导预测，buffer中的$span(j, n)$也要考虑到，因为可能预测为sh动作，同时也可以作为全局信息参考。</p><p>而label预测就只要用到三个span特征：$span(0, k), span(k, j), span(j, n)$，因为label动作只需要对栈首的span进行预测，所以三个特征就足够了。</p><p><strong>生成模型RNNG</strong><br>RNNG是2016年提出的一种文法，全称叫做“Recurrent Neural Network Grammar”，是一种生成式模型。RNNG本质上就是自顶向下的转移系统，动作定义和之前介绍的基本一致。只是之前介绍的自顶向下的转移系统是判别式模型，每次SHIFT的单词都是buffer中给定的。而RNNG每次SHIFT的单词需要通过动作GEN(x)预测得出，最终模型对预测出来的句子分析出句法树。</p><p>正式一点就是，对于句子$x$和对应的句法树$y$，判别式模型是对条件概率$p(y | x)$进行建模，而生成式模型是对联合概率$p(x, y)$进行建模。</p><p>而RNNG的另一个重要应用是语言模型（language model），也就是建模$p(x)$。因为$p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}$，所以只需要枚举出所有可能的句法树$y$即可，但是这是指数级别的，显然不现实，这时候就需要用到“重要性采样（importance sampling）”。</p><p>令$q(y | x)$为RNNG作为判别式模型的时候产生句子$y$的条件概率，那么$p(x)$可以改写为<br>\[p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}  = \sum\nolimits_{y \in \mathcal{Y}(x)} {q(y|x)w(x,y)}  = {E_{q(y|x)}}w(x,y)\]<br>然后就可以采用蒙特卡罗方法进行采样了，从分布$q(y | x)$中采样$N$个样本：<br>\[{y^{(i)}} \sim q(y|x),i = 1,2, \ldots ,N\]<br>那么$p(x)$就可以近似表示为：<br>\[p(x) = {E_{q(y|x)}}w(x,y)\mathop  \approx \limits^{MC} \frac{1}{N}\sum\limits_{i = 1}^N {w(x,{y^{(i)}})} \]</p><p><strong>Dynamic Oracle</strong><br>文章开头提到了一个转移系统会遇到的问题：“exposure bias问题”，这个问题意思就是训练的时候转移系统的每个时刻都是按照标准的action来进行训练的，但是如果测试的时候遇到了一个训练时从来没有遇见过的状态，这时候该怎么预测？如果预测错了，那么之后的时刻可能错的越来越离谱，偏差越来越大。</p><p>解决的方法就是采用Dynamic Oracle技术，在预测错误的时候，按照标准树的结构指导转移系统向着错误尽可能小的状态进行转移。但是比较麻烦的是，对于每一个转移系统，可能大家定义的状态都不尽相同，所以Dynamic Oracle要针对特定的转移系统单独设计，一个解决方法就是之后要提到的Policy Gradient方法。</p><p>这里举一个针对上面的“基于span的自底向上的转移系统”的Dynamic Oracle例子。</p><p>首先是结构化oracle，如果当前的栈首span是$span(i, j)$，那么就在标准树中寻找所有包含$span(i, j)$并且最小的span，记为$span(p, q)$，那么下一步可以采取的动作定义如下：<br><img src="structural_oracle.png" alt><br>也就是说，如果$span(p, q)$比$span(i, j)$右边界多出一部分，那么为了向着标准span靠近，就只能sh单词入栈；否则如果左边界多出一部分，那么就必须先comb之前的两个span，扩大span左边的边界；否则的话左右两边都有空出，那就随机预测一个动作就行了。</p><p>然后是label oracle，这个就很简单了，如果当前的栈首span是$span(i, j)$，只需要在标准树中寻找是否存在$span(i, j)$，如果存在，那么就给他正常预测label就行了；如果不存在，那么直接预测为空结点。oracle定义如下:<br><img src="label_oracle.png" alt><br>而关于这个Dynamic Oracle的证明和更加深入的理解，参见我之前写过的一篇博客：<a href="https://godweiyang.com/2018/08/03/dynamic-oracles/">深入理解成分句法分析中的Dynamic Oracle</a>。</p><p>但是如果直接按照这个Dynamic Oracle来实现代码的话，效果不会有什么提升，原因就是训练的时候遇到的错误情形还是太少了，不足以应付所有的测试阶段遇到的未知情形。所以要在训练阶段加上exploration操作，也就是转移的每一个时刻，不要总是预测概率最大的action，而是以一定的概率随机选择一个action，诱导系统进入一个错误的状态，这样系统就能学到更多错误状态下的回正技巧了。</p><p><strong>Policy Gradient</strong><br>序列预测存在着两个问题：一个就是之前提到的exposure bias问题，另一个就是loss mismatch问题，意思就是在每一个状态的loss累和得到最终整个序列的loss，但是因为是贪心解码，并没有考虑到之后的结果，所以某一个状态的loss其实并不能代表整个序列的loss。</p><p>Dynamic Oracle可以解决第一个问题，如果修改一下也可以解决第二个问题，但是Dynamic Oracle需要针对特定的转移系统单独设计，不能通用，所以这里引入了强化学习中的Policy Gradient来解决这个问题。</p><p>首先用风险函数（risk objective）代替原来的损失函数：<br>\[\mathcal{R}(\theta ) = \sum\limits_{i = 1}^N {\sum\limits_y {p(y|{x^{(i)}};\theta )\Delta (y,{y^{(i)}})} } \]<br>其中$(x^{(i)}, y^{(i)})$是训练集中的标准数据。可以看出，风险函数其实就是所有可能的句法树和标准树的差异${\Delta (y,{y^{(i)}})}$的期望，训练的目的就是最小化所有句法树和标准树的差异，这样就消除了之前提到的两个问题。</p><p>但是可以发现，显然不可能枚举所有可能的句法树，这时候想到了之前用到的重要性采样方法。</p><p>但是不能直接对风险函数进行重要性采样，不然就会发现采样后的函数$\theta$消失了！那就没办法求导了。所以先对风险函数求导：<br>\[\begin{array}{l}\nabla \mathcal{R}(\theta ) = \sum\limits_{i = 1}^N {\sum\limits_y {p(y|{x^{(i)}})\Delta (y,{y^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )} } \\ \approx \sum\limits_{i = 1}^N {\sum\limits_{y \in \mathcal{Y}({x^{(i)}})} {\Delta (y,{y^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )} } \end{array}\]<br>这里的$y$是根据分布${p(y|{x^{(i)}})}$采样得到的结果。实验中可以将标准树也加入到采样结果中，可以提升准确率。<br>至于$\log$项是怎么来的，可以如下推导得来：<br>\[\nabla p(y|{x^{(i)}};\theta ) = p(y|{x^{(i)}})\frac{ {\nabla p(y|{x^{(i)}};\theta )}}{ {p(y|{x^{(i)}};\theta )}} = p(y|{x^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )\]</p><h1 id="编码解码模型"><a href="#编码解码模型" class="headerlink" title="编码解码模型"></a>编码解码模型</h1><hr><p>上面介绍完了基于转移的句法分析系统，下面开始介绍编码解码（Encoder-Decoder）模型。</p><p>模型的大致框架如下图所示：<br><img src="chart_based.png" alt><br>首先通过编码器将句子编码成向量，然后用解码器对向量操作，解码出句法树。</p><h2 id="编码器（Encoder）"><a href="#编码器（Encoder）" class="headerlink" title="编码器（Encoder）"></a>编码器（Encoder）</h2><p>编码器的主要目的是将每个短语编码成语义向量，用来给解码器预测splits和labels。</p><p>编码器主要有两种，一种是简单的双向LSTM编码，下图是一个用双向LSTM对句子进行编码的示例：<br><img src="bi_lstm.jpg" alt><br>例如要编码“played soccer in”这个短语，那么就用“in”处的前向LSTM输出减去“She”处的前向LSTM输出，得到了短语的前向LSTM表示。类似的，用“played”处的反向LSTM输出减去“the”处的反向LSTM输出，得到了短语的反向LSTM表示。</p><p>另一种是multi-headed self-attention编码。Attention是谷歌在“Attention is all you need”中提出的一种方法，严格来说它并不能算作一种模型，只能说是一种机制。具体原理在这里就不细讲了，可以直接去看一下原文。</p><p>大体框架就是，每个单词的词向量经过三个不同的$W$矩阵变换之后得到了三个不同的向量表示$q, k, v$，分别拼接起来组成了矩阵$Q, K, V$，其中$Q, K$相乘就得到了任意两个单词之间的相似度矩阵，然后对矩阵每一行进行softmax就得到了每一个单词对于其他所有单词的权重。再乘上矩阵$V$就得到了它对其他所有单词的加权求和，以此来作为它的向量表示。</p><p>下图就是self-attention的框架图：<br><img src="single_attention.jpg" alt><br>形式化定义就是：<br>\[S(X) = \left[ { {\rm{softmax}}\left( {\frac{ {Q{K^{\rm{T}}}}}{ {\sqrt { {d_k}} }}} \right)V} \right]{W_O}\]<br>其中$Q = XW_Q, K = XW_K, V = XW_V$，$d_k$是向量$q, k$的维度，用它作为分母是为了防止数值太大溢出。最后的矩阵$W_O$是为了将输出映射到与输入相同的维度。</p><p>而multi-headed self-attention就是将刚刚的attention计算8次，并且相加：<br>\[M(X) = \sum\limits_{i = 1}^8 {S(X)} \]<br>注意这8个attention的参数矩阵是不共享的，也可以不相加，改为直接拼接。</p><p>最终的编码器模型如下图所示：<br><img src="multi_headed_attention.jpg" alt><br>也就是说，将刚刚的multi-headed self-attention经过一层layernorm之后再经过一层前馈神经网络，最后再经过一层layernorm得到输出。将上述模型复制8份，首尾拼接，即前面的输出作为后面的输入，即可得到编码器最终的输出，也就是每个单词最终的向量表示。</p><p>至于每个短语的表示，和双向LSTM编码一样，用短语边界两个单词向量的差值作为短语的表示。只是这里没有前向后向的概念，所以要将每个单词向量一分为二，前一半作为前向向量，后一半作为后向向量。当然在实际实现中，将单数维度提取出来作为前向表示，双数维度提取出来作为后向表示。</p><h2 id="解码器（Decoder）"><a href="#解码器（Decoder）" class="headerlink" title="解码器（Decoder）"></a>解码器（Decoder）</h2><p>得到了每个短语的向量表示之后，就需要对它们进行解码，得到最终的句法树，解码的方法主要有两种。<br><strong>基于动态规划解码的模型</strong><br>这种方法在论文中被叫做“chart-based model”，正如其名，就是利用一个数组来进行动态规划，求出每个span的最优split和最优label。</p><p>定义一棵句法树的分数为所有子结点的label分数之和，即：<br>\[{s_{tree}}(T) = \sum\limits_{(l,(i,j)) \in T} { {s_{label}}(i,j,l)} \]<br>其实原本论文中的定义还多了一项span的分数，但是由于具体实现中去掉这一项并没有什么影响，所以为了简便我就只算label分数了。</p><p>要使得句法树分数最大，不可能枚举所有的句法树，那就只能用动态规划算法求解了。对于任意一个$span(i, j)$，我们将它通过编码器产生的表示$s_{ij}$输入到前馈神经网络中，直接取得分最高的那一维作为最优label，即：<br>\[s_{label}(i, j, l) = [Vg(Ws_{ij}+b)]_l\]<br>而对于split，遍历所有的split，取两个子结点与自己结点得分之和最高的那个split即可：<br>\[s_{split}(i, j, k) = s_{label}(i, j, l_{ij}) + s_{label}(i, k, l_{ik}) + s_{label}(k, j, l_{kj})\]</p><p>最后的训练过程和以往一样，采用max-margin训练方法，即使得标准树的得分比预测树的得分至少高一个margin，在这里margin大小定义为两棵树不同短语的数量，最终的损失函数定义为：<br>\[\mathcal{L}(\theta ) = \max \left( {0,\Delta (\hat T,T) - {s_{tree}}(T) + {s_{tree}}(\hat T)} \right)\]</p><p><strong>基于自顶向下贪心解码的模型</strong><br>基于动态规划的解码算法时间复杂度为$O(n^3)$，对于长度大一点的句子来说还是有点不可接受的。但是如果采用自顶向下、贪心地去选择每一个span的最优split和最优label，那么时间复杂度将降到$O(n^2)$。具体操作过程如下，首先从根节点也就是$span(0, n)$开始，选择一个split，使得两个子结点与自己结点得分之和最高，而label还是向之前那样直接通过短语的向量计算得出。具体公式为：<br>\[\begin{array}{l}\hat l = \mathop {\arg \max }\limits_l [{s_{label}}(i,j,l)]\\\hat k = \mathop {\arg \max }\limits_k [{s_{split}}(i,k,l)]\end{array}\]<br>而由于贪心解码和转移系统action预测一样，在预测阶段可能会遇到训练阶段没有碰到过的状态，所以也需要用到Dynamic Oracle。同样也需要用到exploration，来增加训练阶段遇到的错误状态数。</p><h1 id="Sequence-to-Sequence模型"><a href="#Sequence-to-Sequence模型" class="headerlink" title="Sequence to Sequence模型"></a>Sequence to Sequence模型</h1><hr><p>上面最主流的两大模型：转移系统和编码解码模型都已经介绍完了，下面介绍几种比较新颖的方法。</p><p>大家都知道句法树和某些序列存在一一对应关系，句法树可以唯一转换成序列，序列也可以唯一转换成句法树，所以预测句法树的问题就转变为了预测序列问题，下面几种方法都是将句法树转换为了某种序列来进行预测。</p><h2 id="树结构转化为括号序列"><a href="#树结构转化为括号序列" class="headerlink" title="树结构转化为括号序列"></a>树结构转化为括号序列</h2><p>这种方法思路特别简单，因为训练集里原始数据的表示形式就是括号序列嘛，所以就采用语言模型直接预测出括号序列的概率。</p><p>但是不可能枚举出所有的句法树括号序列，所以最终还是只对其他句法分析器预测出来的最好的若干棵树进行预测概率，然后重排序选出概率最高的一棵树。</p><h2 id="句法距离（Syntactic-Distance）"><a href="#句法距离（Syntactic-Distance）" class="headerlink" title="句法距离（Syntactic Distance）"></a>句法距离（Syntactic Distance）</h2><p>这个方法就很新颖了，本质上也是将树结构转换成了唯一对应的序列。<br><img src="syntactic_distance_example.jpg" alt><br>首先看上面一张图，对于长度为$n$的句子，存在一个长度为$n - 1$的数字序列，满足如下条件：$n$个单词存在$n - 1$个两两相邻的单词对，而两个相邻的单词的最近公共祖先（LCA）在句法树中有一个高度，所以这$n - 1$个数的大小关系恰好对应了从左向右任意两个相邻单词对的LCA的高度的大小关系。</p><p>拿上面那张图为例，“She”和“enjoys”的最近公共祖先是“S”，所以高度最高，对应的数字也最大。“enjoys”和“playing”的最近公共祖先是“VP”，高度排第三，所以对应的数字大小也是排第三。依次类推，剩下的数也满足这个性质。可以证明，这个数字序列和句法树是一一对应的。更进一步可以发现，这个序列其实就是“中序遍历的结点的高度”，文中将其称为句法距离。</p><p>预测这个序列也很简单，通过一个双向LSTM，然后将每相邻两个单词的输出做一次卷积操作（因为要预测相邻两个单词的LCA高度嘛），然后再将输出送到一个双向LSTM中去，最后通过一个前馈神经网络得到每相邻两个单词的数字。</p><p>而从树到序列和从序列到树的算法都很简单，这里就不详述了，可以直接去看论文。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>下面列出了成分句法分析领域目前为止最好的一些结果：<br><img src="results.jpg" alt><br>最好的是采用self-attention编码器+外部预训练词向量ELMo的模型，第二是模型融合+重排序之后的结果，之后的模型也基本都是本文介绍过的，最厉害的就是最后一个2006年的模型，十几年了依然如此强悍。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>虽然看起来貌似已经看了不少的成分句法分析相关的工作了，但是其实还有很多细节性的工作还没有去了解。前两年ACL等顶会成分句法分析的论文都很少，但是18年又好像多了起来，但终究还是伯克利Dan Klein、斯坦福Socher、黄亮等一批大佬在做这个，想在巨人的肩膀上面做出点东西还是很有挑战性的。</p><p>目前能想到的工作只有在编码器上面做文章，学习出语义更加丰富的短语表示。或者可以采用失传多年的递归神经网络，解码时对句法树进行建模，但是随便试了一下，速度很慢而且存在梯度消失的问题，效果也不是很好。转移系统的话暂时也想不出什么好的点子，序列预测的话如果能再想出个新颖的一一对应的序列就好了。</p><p>前路还很长，说长也不长了，只有三年不到的时间了，做不出东西就要延毕了。但愿能在有限的三年时间里做出点成果，提高自己的代码能力，对这个领域也有更加深入的理解！</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr><p>[ACL15] Transition-based Neural Constituent Parsing<br>[NAACL16] Recurrent Neural Network Grammars<br>[EMNLP16] Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles<br>[TACL17] In-Order Transition-based Constituent Parsing<br>[EMNLP17] Effective Inference for Generative Neural Parsing<br>[ACL18] Policy Gradient as a Proxy for Dynamic Oracles in Constituency Parsing<br>[ACL17] A Minimal Span-Based Neural Constituency Parser<br>[ACL18] Constituency Parsing with a Self-Attentive Encoder<br>[EMNLP16] Parsing as Language Modeling<br>[ACL18] Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recurrent Neural Network Grammars</title>
      <link href="/2018/09/02/rnng/"/>
      <url>/2018/09/02/rnng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/N/N16/N16-1024.pdf" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a><br><strong>代码地址：</strong><a href="https://github.com/clab/rnng" target="_blank" rel="noopener">github</a></p><p>今天要介绍的这篇论文是来自NAACL16的Recurrent Neural Network Grammars，主要贡献点就是提出了一种新的文法RNNG，不同于传统的PCFG之类的文法，RNNG使用RNN来对句子和它的句法树的联合概率进行建模，因此它是一个生成模型。但是稍稍修改就可以改为判别模型，也就是大家熟悉的基于转移的成分句法分析系统，并且转移系统是采用top-down方法的，也就是利用了句法树的前序遍历。</p><p>RNNG在语言模型任务上取得了当时的state-of-the-art结果，成分句法分析任务上，生成模型取得了媲美最好结果的F1值，而判别模型就差了点。本文最大的贡献点就是提出了生成式模型RNNG，说明了在数据量不是很大的时候，利用生成式模型可以提高成分句法分析的准确率。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>RNN在语言模型和其他许多NLP任务上面都已经取得了非常不错的效果，但是RNN只能捕捉到句子的序列特征，例如句子的句法结构等递归嵌套的结构信息无法用RNN捕捉到。</p><p>因此本文提出了一种利用RNN建模出来的全新文法RNNG，建立在句子的句法结构之上，消除了PCFG的上下文无关假设。并提出了两种变体，一种是生成模型，可以用来句法分析和训练语言模型，另一种是判别模型，可以用来句法分析。</p><p>RNNG建立在top-down转移系统之上，top-down转移系统相比于bottom-up转移系统有一个好处，就是不需要二叉化，因为如果bottom-up转移系统不二叉化的话，REDUCE的状态就会有很多种可能，不知道到底归约栈里的几个结点。而top-down转移系统就不存在这个问题，直接归约到第一个父结点为止就行了。本文应该也是第一个提出用RNN来实现top-down转移系统的，之前的方法都是用top-down的文法，或者是bottom-up的，例如Sochar2013的CVG，也是用二叉化后的RNN学习结点的语义表示。</p><h1 id="RNN文法"><a href="#RNN文法" class="headerlink" title="RNN文法"></a>RNN文法</h1><hr><p>RNNG定义为三元组$(N, \Sigma, \Theta)$，其中$N$是非终结符集合，$\Sigma$是终结符集合，并且$N \cap \Sigma = \emptyset$，$\Theta$就是神经网络的参数集合。RNNG和传统的PCFG的一个明显区别就是它没有显式地指出语法规则是什么，而是蕴含在了神经网络中，在句法转移的时候动态的生成。</p><h1 id="Top-down句法分析和生成"><a href="#Top-down句法分析和生成" class="headerlink" title="Top-down句法分析和生成"></a>Top-down句法分析和生成</h1><p>这部分主要介绍RNNG的两个变体，一个是top-down的句法分析系统，还有一个是稍稍修改后的生成系统。</p><h2 id="判别式系统"><a href="#判别式系统" class="headerlink" title="判别式系统"></a>判别式系统</h2><p>这个判别式模型之前也已经介绍过很多次了，和普通的基于转移的句法分析系统一样，输入是一个句子$x$，输出是它的句法分析树$y$。主要组成部分有句法树栈、句子单词buffer、动作集合，每一步的动作有三种：</p><ul><li>NT(X)： 将一个父结点X移进栈里。</li><li>SHIFT： 从buffer中移一个单词到栈里。</li><li>REDUCE： 将栈顶的若干个结点归约为它们的父结点，并且出栈。</li></ul><p>图1就是每个动作的状态变化过程，图2是判别式模型进行句法分析的示例：<br><img src="1.jpg" alt></p><p>当然得给动作添加一些限制，首先记当前状态为三元组$(B, S, n)$，分别表示buffer、栈、当前栈里未归约的父结点数量，这个之前的博客没有提及过：</p><ul><li>NT(X)动作只有当buffer不为空并且$n &lt; 100$的时候才能进行。因为buffer空了的话就没有单词了，此时不可能移进新的非终结符了，并且要限制$n &lt; 100$防止一元产生式无限生成下去。</li><li>SHIFT动作只有当buffer不为空并且$n \ge 1$时才能进行。前者不用解释了，后者的话因为是top-down的，所以栈里至少要有一个父结点才能移进新的单词。</li><li>REDUCE只有当栈顶不是没有归约的父结点才能进行。</li><li>REDUCE只有当$n \ge 2$或者buffer为空时才能进行。<strong>这里要解释一下为什么$n \ge 2$，因为如果buffer不为空同时$n = 1$，那么这时候如果REDUCE的话，栈里就只剩一个非终结符了，只可能是根节点S，而buffer里还有单词，所以这是不可能的。</strong></li></ul><p>记当前状态的可能动作集合为$\mathcal{A}_D(B, S, n)$。</p><h2 id="生成式系统"><a href="#生成式系统" class="headerlink" title="生成式系统"></a>生成式系统</h2><p>将上面的top-down转移系统稍稍修改即可得到生成式系统。区别有两点：</p><ul><li>首先没有了输入的buffer，取而代之的是输出的buffer $T$。</li><li>其次因为没有输入单词了，所以在需要输入单词的时候采用GEN(x)动作来产生一个新的单词$x$，然后移进栈里，取代SHIFT动作。</li></ul><p>图3就是每个动作的状态变化过程，图4是生成式模型进行句法分析的示例：<br><img src="2.jpg" alt></p><p>同样也要对其采取一些限制：</p><ul><li>GEN(x)动作只有当$n \ge 1$时才能进行，上面SHIFT限制已经解释过了。</li><li>REDUCE只有当$n \ge 1$或者buffer为空时才能进行。<strong>这里再次解释一下，上面判别式模型限制条件是$n \ge 2$，为什么这里就变成了$n \ge 1$？因为生成模型没有输入buffer，所以即使$n = 1$时REDUCE了，以后不要再GEN(x)即可，直接结束分析</strong></li></ul><p>记当前状态的可能动作集合为$\mathcal{A}_G(T, S, n)$。</p><h2 id="转移序列"><a href="#转移序列" class="headerlink" title="转移序列"></a>转移序列</h2><p>因为一棵句法树的前序遍历是唯一的，所以不管用判别式模型还是生成式模型，得到的动作序列也都是唯一的。对于句子$x$和句法树$y$，记生成式模型动作序列为$a(x, y)$，判别式模型动作序列为$b(x, y)$。</p><h1 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h1><hr><p>本文最重要的就是上面提到的生成式模型，因为GEN(x)动作的存在，所以模型同时对句子$x$和句法树$y$的联合分布进行了建模。记当前状态的向量表示为$u_t$，那么联合分布可以表示为：<br>\[p(x,y) = \prod\limits_{t = 1}^{\left| {a(x,y)} \right|} {p({a_t}|{a_{ &lt; t}})}  = \prod\limits_{t = 1}^{\left| {a(x,y)} \right|} {\frac{ {\exp r_{ {a_t}}^T{u_t} + {b_{ {a_t}}}}}{ {\sum\nolimits_{a’ \in {\mathcal{A}_G}({T_t},{S_t},{n_t})} {\exp r_{a’}^T{u_t} + {b_{a’}}} }}} \]<br>其中$r_a$表示动作$a$的向量表示，$b$表示偏移向量，都包含在了RNNG参数集合$\Theta$里面，通过训练得到。</p><p>而当前状态的向量表示$u_t$由三部分得到，输出buffer的LSTM输出$o_t$、栈的LSTM输出$s_t$、历史动作序列的LSTM输出$h_t$，然后经过一个前馈神经网络得到：<br>\[u_t = \tanh (W[o_t; s_t; h_t] + c)\]<br>$W$和$c$同样也包含在了RNNG参数集合$\Theta$里面，下图是三个LSTM的示例图：<br><img src="3.jpg" alt></p><h2 id="句法成分组合"><a href="#句法成分组合" class="headerlink" title="句法成分组合"></a>句法成分组合</h2><p>在REDUCE操作时，需要将若干个子结点归约为一个父结点，为了得到父结点的向量表示，再次利用一个LSTM对子结点序列进行编码，同时在首尾加上父结点，结构图如下所示：<br><img src="4.jpg" alt></p><h2 id="单词生成"><a href="#单词生成" class="headerlink" title="单词生成"></a>单词生成</h2><p>单词生成采用softmax寻找概率最大的单词，但是单词数量可能十分巨大，所以采用分层softmax的思想，首先预测当前动作是不是GEN，如果是GEN，记单词总数为${\left| { \sum  } \right|}$，再将单词平均分成${\sqrt {\left| \sum  \right|} }$个类别，用softmax预测属于哪个类别，然后在那个类别里再用softmax预测输出哪个单词。这样时间复杂度就从$O\left( {\left| \sum  \right|} \right)$降到了$O\left( {\sqrt {\left| \sum  \right|} } \right)$。</p><h2 id="参数训练和判别式模型"><a href="#参数训练和判别式模型" class="headerlink" title="参数训练和判别式模型"></a>参数训练和判别式模型</h2><p>模型最终训练目的就是使得联合概率最大。</p><p>而只需要将输出buffer改为输入buffer，GEN动作改为SHIFT动作，然后重新训练，就可以将模型变为判别式模型了，输出给定输入句子下概率最大的句法树。</p><h1 id="通过重要性采样进行推理"><a href="#通过重要性采样进行推理" class="headerlink" title="通过重要性采样进行推理"></a>通过重要性采样进行推理</h1><hr><p>本文的生成式模型另一大作用是训练语言模型$p(x)$，根据边际分布公式<br>\[p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)} \]<br>可以直接得到$p(x)$，但是一句话的句法树可能性是指数级别的，不可能一一枚举，这时候就要用到重要性采样算法。</p><p>首先定义一个比较容易得到的条件分布$q(y | x)$，它满足如下性质：</p><ul><li>$p(y | x) &gt; 0$可以推出$q(y | x) &gt; 0$。</li><li>服从分布的样本很容易得到。</li><li>$q(y | x)$可以直接计算得到。</li></ul><p>可以发现，上面的判别式模型得到的条件分布符合上面的性质，所以这里直接用判别式模型来进行采样。</p><p>这样$p(x)$就变为了：<br>\[p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}  = \sum\nolimits_{y \in \mathcal{Y}(x)} {q(y|x)w(x,y)}  = {E_{q(y|x)}}w(x,y)\]<br>其中重要性权重$w(x,y) = p(x,y)/q(y|x)$。</p><p>最后如果根据分布$q(y | x)$采样得到了$N$个句法树样本，那么用蒙特卡罗方法就可以估计出$p(x)$了：<br>\[{E_{q(y|x)}}w(x,y) \approx \frac{1}{N}\sum\limits_{i = 1}^N {w(x,{y_i})} \]</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验部分主要说一下PTB上的句法分析和语言模型吧，下面两张图分别是句法分析和语言模型的结果：<br><img src="5.jpg" alt><br><img src="6.jpg" alt><br>句法分析方面可以看出，生成模型效果要远远好于判别模型，生成模型效果也接近了当时的最好结果。一个合理的解释是在小数据集上面，生成模型效果要更好，而在大数据集上，判别模型效果可以赶上生成模型。</p><p><strong>这里要提到的一点是，判别式模型就是每一个状态直接贪心argmax找到概率最大的动作，然后生成句法树。而生成式模型是利用判别式模型采样出100个概率比较高的句法树，然后用生成式模型计算它们的联合概率，重排序选择概率最高的句法树。</strong></p><p>语言模型方面，结果要比最好结果高了一点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>RNNG这个文法是个生成式模型，建模了句子和句法树的联合分布，稍稍修改即可应用到句法分析和语言模型中，效果也非常的好。</p><p>最后，我再简要梳理一遍RNNG的主要训练过程，因为这篇论文也看了整整两天，还是看的头大，一些细节可能还是没完全搞清。</p><p>首先利用生成式模型对每句话进行训练，在每个状态计算正确的动作的概率，然后训练使得概率之积最大。</p><p>然后应用到句法分析中，只需要修改为判别式模型即可。</p><p>最后应用到语言模型中，由于需要用到重要性采样，所以直接利用判别式模型生成若干样本，然后根据算得的条件概率计算语言模型句子的概率。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>In-Order Transition-based Constituent Parsing</title>
      <link href="/2018/08/28/tacl17-conparsing/"/>
      <url>/2018/08/28/tacl17-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/Q/Q17/Q17-1029.pdf" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/LeonCrashCode/InOrderParser" target="_blank" rel="noopener">github</a></p><p>今天要介绍的这篇论文是成分句法分析领域目前的第三名，结果最高的几篇paper可以参见ruder在github整理的列表：<a href="https://github.com/sebastianruder/NLP-progress/blob/master/constituency_parsing.md" target="_blank" rel="noopener">github</a>。<br>下面就是成分句法分析目前排名：</p><table><thead><tr><th>Model</th><th align="center">F1 score</th><th>Paper / Source</th></tr></thead><tbody><tr><td>Self-attentive encoder + ELMo (Kitaev and Klein, 2018)</td><td align="center">95.13</td><td><a href="https://arxiv.org/abs/1805.01052" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a></td></tr><tr><td>Model combination (Fried et al., 2017)</td><td align="center">94.66</td><td><a href="https://arxiv.org/abs/1707.03058" target="_blank" rel="noopener">Improving Neural Parsing by Disentangling Model Combination and Reranking Effects</a></td></tr><tr><td>In-order (Liu and Zhang, 2017)</td><td align="center">94.2</td><td><a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a></td></tr><tr><td>Semi-supervised LSTM-LM (Choe and Charniak, 2016)</td><td align="center">93.8</td><td><a href="http://www.aclweb.org/anthology/D16-1257" target="_blank" rel="noopener">Parsing as Language Modeling</a></td></tr><tr><td>Stack-only RNNG (Kuncoro et al., 2017)</td><td align="center">93.6</td><td><a href="https://arxiv.org/abs/1611.05774" target="_blank" rel="noopener">What Do Recurrent Neural Network Grammars Learn About Syntax?</a></td></tr><tr><td>RNN Grammar (Dyer et al., 2016)</td><td align="center">93.3</td><td><a href="https://www.aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a></td></tr><tr><td>Transformer (Vaswani et al., 2017)</td><td align="center">92.7</td><td><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a></td></tr><tr><td>Semi-supervised LSTM (Vinyals et al., 2015)</td><td align="center">92.1</td><td><a href="https://papers.nips.cc/paper/5635-grammar-as-a-foreign-language.pdf" target="_blank" rel="noopener">Grammar as a Foreign Language</a></td></tr><tr><td>Self-trained parser (McClosky et al., 2006)</td><td align="center">92.1</td><td><a href="https://pdfs.semanticscholar.org/6f0f/64f0dab74295e5eb139c160ed79ff262558a.pdf" target="_blank" rel="noopener">Effective Self-Training for Parsing</a></td></tr></tbody></table><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>基于转移的成分句法分析主要分为两种：</p><ul><li>一种是自顶向下（top-down）的方法，按照前序遍历（pre-order）的顺序生成句法树。这种方法可以更好地利用全局信息，但是需要一个强大的编码器来对每个短语成分进行编码。</li><li>一种是自底向上（bottom-up）的方法，按照后序遍历（post-order）的顺序生成句法树。这种方法可以充分利用子树的特征来进行分析，但是却无法利用全局信息。</li></ul><p>本文的模型就对这两种方法进行了改进，采用中序遍历（in-order）的顺序来生成句法树。单模型最终取得了91.8的F1值（貌似也不是特别高？），采用监督重排序之后F1值提升到了93.6，采用半监督重排序之后F1值提升到了94.2。所以看起来还是重排序起了很大的作用。</p><h1 id="基于转移的成分句法分析"><a href="#基于转移的成分句法分析" class="headerlink" title="基于转移的成分句法分析"></a>基于转移的成分句法分析</h1><hr><p>首先简要介绍一下这三种基于转移的句法分析方法。</p><h2 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h2><p>自底向上的转移系统是基于后序遍历的，例如对于下图这棵句法树，算法产生结点的顺序为3、4、5、2、7、9、10、8、6、11、1。<br><img src="1.jpg" alt><br>a图是未经二叉化的句法树，b图是二叉化之后的句法树，二叉化之后的结点要用l和r来区分头结点。其实不二叉化也是可以的，伯克利一帮人的做法就是用$\emptyset $来作为临时结点，构造树的时候去掉就行了。</p><p>句法分析系统如下：<br><img src="2.jpg" alt><br>每个时刻的状态用三元组$[\sigma ,i,f]$来表示，分别表示栈中元素、buffer的第一个元素在句子中的下标、句法分析结束标记。系统一共有四个操作：</p><ul><li>SHIFT： 从buffer中移进一个单词到栈里。</li><li>REDUCE-L/R-X：将栈顶两个结点归约为一个父结点X。</li><li>UNARY-X：将栈顶元素归约为一元结点X。</li><li>FINISH：句法分析结束。</li></ul><p>上面那个句法树按照该模型分析的话过程如下：<br><img src="3.jpg" alt><br>优缺点很显然，可以充分利用已生成的子树来对父结点的预测进行分析，但是不能利用全局信息（也就是其他子树、父结点等信息），并且需要提前进行二叉化（这点可以用临时结点标记来规避）。</p><h2 id="自顶向下的转移系统"><a href="#自顶向下的转移系统" class="headerlink" title="自顶向下的转移系统"></a>自顶向下的转移系统</h2><p>自顶向下的转移系统是基于前序遍历的，例如对于之前那棵句法树，算法产生结点的顺序为1、2、3、4、5、6、7、8、9、10、11。</p><p>句法分析系统如下：<br><img src="4.jpg" alt><br>系统一共有三个操作：</p><ul><li>SHIFT： 从buffer中移进一个单词到栈里。</li><li>NT-X：对一个父结点生成出它的一个子结点X。</li><li>REDUCE：将栈顶的若干个结点归约为一个结点，并且全部出栈，注意它们的父结点这时已经在栈顶了。</li></ul><p>上面那个句法树按照该模型分析的话过程如下：<br><img src="5.jpg" alt><br>优缺点也很显然，可以充分利用全局信息，但是因为预测子树的时候，子树还没有生成，所以无法利用子树的特征来进行分析，所以需要提前对句子的每个短语进行编码。</p><h2 id="采用中序遍历的转移系统"><a href="#采用中序遍历的转移系统" class="headerlink" title="采用中序遍历的转移系统"></a>采用中序遍历的转移系统</h2><p>为了协调上面的两种问题，本文提出了一种基于中序遍历的转移系统。</p><p>其实采用中序遍历也符合人们的直觉判断，比如你读到一个单词“like”，脑子里首先就会想到，这个可能和下面短语共同组成了动词短语VP，然后接着往下看，果然印证了你的猜想。</p><p>中序遍历就是采用这种思想的，例如对于之前那棵句法树，算法产生结点的顺序为3、2、4、5、1、7、6、9、8、10。</p><p>句法分析系统如下：<br><img src="6.jpg" alt><br>系统一共有四个操作：</p><ul><li>SHIFT： 从buffer中移进一个单词到栈里。</li><li>PJ-X：向栈里移进父结点X，来作为栈顶结点的父结点。</li><li>REDUCE：将栈顶的若干个结点归约为一个结点，并且全部出栈，注意它们的父结点在出栈元素的倒数第二个。然后再将父结点入栈。</li><li>FINISH：句法分析结束。</li></ul><p>上面那个句法树按照该模型分析的话过程如下：<br><img src="7.jpg" alt></p><p>该转移系统还有很多变体。对于短语(S, a, b, c, d)，可以令它在栈中S结点之前的子结点个数为$k$，例如对于上面的中序转移系统，栈里存放顺序是“a S b c d”，那么$k = 1$，如果栈里存放顺序是“a b S c d”，那么$k = 2$。而对于自底向上的转移系统，$k$就是正无穷，对于自顶向下的转移系统，$k$就是0。</p><h1 id="句法分析模型"><a href="#句法分析模型" class="headerlink" title="句法分析模型"></a>句法分析模型</h1><hr><p>对于每一个状态，模型采用三个LSTM来预测当前步动作，结构如下图所示：<br><img src="8.jpg" alt><br>一个LSTM用来对栈顶元素进行编码，一个LSTM用来对buffer中所有元素进行编码，一个LSTM用来对之前预测完毕的所有动作进行编码。</p><h2 id="单词表示"><a href="#单词表示" class="headerlink" title="单词表示"></a>单词表示</h2><p>对于每个单词，用预训练词向量、随机初始化词向量、POS向量拼接起来，然后经过一个前馈神经网络来作为最终的单词表示：<br>\[{x_i} = f({W_{input}}[{e_{ {p_i}}};{\bar e_{ {w_i}}};{e_{ {w_i}}}] + {b_{input}})\]<br>其中${e_{ {p_i}}}$表示POS为$p_i$的向量，${\bar e_{ {w_i}}}$表示单词$w_i$的预训练词向量，${e_{ {w_i}}}$表示单词$w_i$的随机初始化词向量。$f$函数通常取ReLU。</p><h2 id="栈里的短语表示"><a href="#栈里的短语表示" class="headerlink" title="栈里的短语表示"></a>栈里的短语表示</h2><p>对于自顶向下和in-order的转移系统，由于不需要二叉化，所以采用如下图所示的LSTM来对栈里的短语进行编码：<br><img src="9.jpg" alt><br>具体的短语表示为：<br>\[{s_{comp}} = (LST{M_f}[{e_{nt}},{s_0}, \ldots ,{s_m}];LST{M_b}[{e_{nt}},{s_m}, \ldots ,{s_0}])\]<br>其中${e_{nt}}$是父结点的向量表示，其他都是子结点的短语表示。</p><p>而作为对比实验，自底向上的转移系统因为是二叉树，所以LSTM略有不同，结构图如下所示：<br><img src="12.jpg" alt><br>唯一的区别就是不管你短语的单词顺序如何，都要把中心词也就是头结点放在前面。</p><h2 id="贪心动作预测"><a href="#贪心动作预测" class="headerlink" title="贪心动作预测"></a>贪心动作预测</h2><p>上面的两个小节将buffer和栈里的元素都进行了编码，最后就要对当前状态进行动作预测了。</p><p>假设第$k$个状态为$[{s_j}, \ldots ,{s_0},i,false]$，那么当前状态每个动作的概率为：<br>\[p = SOFTMAX(W[{h_{stk}};{h_{buf}};{h_{ah}}] + b)\]<br>其中${h_{stk}}$是栈里的LSTM编码结果：<br>\[{h_{stk}} = LSTM[{s_0}, \ldots ,{s_j}]\]<br>${h_{buf}}$是buffer里的LSTM编码结果：<br>\[{h_{buf}} = LSTM[{x_i}, \ldots ,{x_n}]\]<br>${h_{ah}}$是之前动作序列的LSTM编码结果：<br>\[{h_{ah}} = LSTM[{e_{ac{t_k}}}, \ldots ,{e_{ac{t_0}}}]\]</p><p>最终的损失函数采用交叉熵：<br>\[L(\theta ) =  - \sum\limits_i {\sum\limits_j {\log {p_{ {a_{ij}}}}} }  + \frac{\lambda }{2}{\Vert \theta  \Vert ^2}\]</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验的超参数设置如下：<br><img src="10.jpg" alt><br>经过对比实验可以发现，结果比自底向上和自顶向下的转移系统都要略高一点，就算加上了重排序，还是略高一点。单模型的话，和2017年之前的结果相比的确是最高的，但是91.8的F1值现在看来不是特别高了，毕竟伯克利基于CKY算法的chart-parser都已经到了92多甚至93了。</p><p>详细结果如下表：<br><img src="11.jpg" alt><br>模型在依存句法分析和CTB上的表现也都很不错。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文提出了一种基于中序遍历转移系统的成分句法分析模型，主要的动机还是基于人类阅读时的直觉，该模型协调了自底向上和自顶向下转移系统的优缺点，在采用重排序之后，结果达到了非常高的水准。</p><p>当然我个人认为模型也存在一些改进的地方：</p><ul><li>单词的表示可以加上Char-LSTM。</li><li>预测阶段可以采用之前文章提到的Dynamic Oracle技术，来减少预测错误的发生。详见之前的文章：<a href="https://godweiyang.com/2018/08/03/dynamic-oracles/">地址</a>。不过这里的Dynamic Oracle要重新设计了，设计好了说不定又可以发一篇论文了？（手动滑稽）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> TACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-bandit Algorithm</title>
      <link href="/2018/08/05/k-bandit/"/>
      <url>/2018/08/05/k-bandit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><hr><p>有$K$个赌博机，每个赌博机有一定概率$P$吐出硬币，但是我们不知道这个概率是多少，每个赌博机吐出的硬币价值$V$也是不一样的，现在有$T$次机会选择赌博机，怎么选才能使得到的硬币总价值最大？</p><p>在下面的不同算法实现中，统一设定<br>\[\begin{array}{l}K = 5 \\ P = [0.1,0.9,0.3,0.2,0.7] \\ V = [5,3,1,7,4] \\ T = 1000000\end{array}\]<br>可以计算出，这种情况下：</p><ol><li>如果每次都选期望价值最高的4号赌博机，可以获得的最高总价值为2800000。</li><li>如果每次都选期望价值最低的2号赌博机，可以获得的最低总价值为300000。</li><li>如果随机选取赌博机，可以获得的期望总价值为1540000。</li></ol><h1 id="探索与利用算法"><a href="#探索与利用算法" class="headerlink" title="探索与利用算法"></a>探索与利用算法</h1><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>“仅探索”（exploration-only）算法就是将机会平均分配给每一个赌博机，随机挑选赌博机。<br>“仅利用”（exploitation-only）算法就是选取当前平均价值最高的那台赌博机。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">R</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> V<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">exploration_bandit</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> K <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        v <span class="token operator">=</span> R<span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span>        r <span class="token operator">+=</span> v    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> <span class="token number">5</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    V <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    T <span class="token operator">=</span> <span class="token number">1000000</span>    <span class="token keyword">print</span> exploration_bandit<span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行结果为：获得总价值1538893。</p><h1 id="varepsilon-贪心算法"><a href="#varepsilon-贪心算法" class="headerlink" title="$\varepsilon $贪心算法"></a>$\varepsilon $贪心算法</h1><hr><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">R</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> V<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">eplison_bandit</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token number">0</span>    Q <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    count <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        eplison <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> eplison<span class="token punctuation">:</span>            k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> K <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            k <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>Q<span class="token punctuation">)</span>        v <span class="token operator">=</span> R<span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span>        r <span class="token operator">+=</span> v        Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>v <span class="token operator">-</span> Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> <span class="token number">5</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    V <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    T <span class="token operator">=</span> <span class="token number">1000000</span>    <span class="token keyword">print</span> eplison_bandit<span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行结果为：获得总价值2795546。</p><h1 id="Softmax算法"><a href="#Softmax算法" class="headerlink" title="Softmax算法"></a>Softmax算法</h1><hr><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">R</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> V<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">eplison_bandit</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">,</span> tau<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token number">0</span>    Q <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    count <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> softmax<span class="token punctuation">(</span>Q <span class="token operator">/</span> tau<span class="token punctuation">)</span>        rand <span class="token operator">=</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>        total <span class="token operator">=</span> <span class="token number">0.0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>            total <span class="token operator">+=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> total <span class="token operator">>=</span> rand<span class="token punctuation">:</span>                k <span class="token operator">=</span> i                <span class="token keyword">break</span>        v <span class="token operator">=</span> R<span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span>        r <span class="token operator">+=</span> v        Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>v <span class="token operator">-</span> Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> <span class="token number">5</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    V <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    T <span class="token operator">=</span> <span class="token number">1000000</span>    tau <span class="token operator">=</span> <span class="token number">0.1</span>    <span class="token keyword">print</span> eplison_bandit<span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">,</span> tau<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行结果为：$tau=0.01$时，获得总价值1397795。$tau=0.1$时，获得总价值2798372。当然随机性很大，每次运行结果都会不同</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Understanding of Dynamic Oracle in Constituent Parsing</title>
      <link href="/2018/08/03/dynamic-oracles/"/>
      <url>/2018/08/03/dynamic-oracles/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>本文将从定义到证明，一步步理清成分句法分析中用到的Dynamic Oracle函数。参考了James Cross在2016年发表在EMNLP上面的论文：<a href="https://www.aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">论文地址</a>，该论文还是当年的best paper。</p><h1 id="成分句法分析系统"><a href="#成分句法分析系统" class="headerlink" title="成分句法分析系统"></a>成分句法分析系统</h1><hr><p>首先本文用到的成分句法分析系统是基于span-based的转移系统，在这里只做简略介绍，详见<a href="http://ir.library.oregonstate.edu/downloads/0g354j52q" target="_blank" rel="noopener">Parsing with Recurrent Neural Networks</a>。<br><img src="1.png" alt><br>上图展示了该转移系统的转移过程，其中结构化预测只用到了shift(sh)和combine(comb)两种动作，因为stack中存放的是span的左右边界下标，所以comb动作不需要区分左右，这与另一种转移系统的reduce动作不同。而对于label的预测，如果栈首的span不构成短语结点，那么就预测为nolabel，否则就预测为$_i{X_j}$。</p><p>每个时刻的状态用三元组$\left\langle {z,\sigma ,t} \right\rangle $表示，分别表示第几个动作、栈（span的split序列）、当前已生成的结点$_i{X_j}$集合。注意到对于长度为$n$的句子，只需要用$4n-2$个动作就可以分析出句法树了，并且第偶数个动作做结构预测（sh和comb），第奇数个动作做label预测。<br><img src="2.png" alt><br>上图是一个转移的具体例子，下面将全部以这个句子为例进行介绍。注意到多叉树隐式的转化为了二叉树，临时结点预测为nolabel。</p><h1 id="Dynamic-Oracle"><a href="#Dynamic-Oracle" class="headerlink" title="Dynamic Oracle"></a>Dynamic Oracle</h1><hr><p>Dynamic Oracle是Goldberg和Nivre在2013年总结出来的，发表在TACL上面：<a href="https://www.aclweb.org/anthology/Q/Q13/Q13-1033.pdf" target="_blank" rel="noopener">Training Deterministic Parsers with Non-Deterministic Oracles</a>。</p><p>提出的动机就是为了解决测试阶段贪心预测错误导致误差越来越大的问题。在训练的时候，原来的静态Oracle方法就是每一步都严格按照标准树的动作来进行预测，最终拟合得和标准树动作序列相同，但是测试的时候没有标准树了，如果某一步预测错误，可能会到达一个训练中没有出现过的状态，那就会导致之后的预测越来越错。所以就提出了Dynamic Oracle的技巧，在训练过程中的每一步预测，不再局限于标准树中的一个动作，而扩展为一个动作集合，只要采取集合中的动作，那么最终得到的动作序列一定也是最优的。</p><p>这种方法主要用于贪心的预测方法，例如本文的转移系统就是在每一步贪心的预测当前动作，再如之前介绍过的成分句法分析top-down模型<a href="https://www.aclweb.org/anthology/P/P17/P17-1076.pdf" target="_blank" rel="noopener">A Minimal Span-Based Neural Constituency Parser</a>中，自顶向下贪心的选择每一个span的最佳split，也要用到Dynamic Oracle来防止错误扩大。之前的博客有过专门介绍，可以去翻看一下：<a href="https://godweiyang.com/2018/06/28/ACL17-ConParsing/#top-down解码模型">Dynamic Oracle</a></p><p>下面就将从定义、证明等方面来详细阐述Dynamic Oracle。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><hr><p><strong>定义1：</strong> 定义$c{ \vdash _\tau }c’$为状态$c$经过动作$\tau $之后转移到状态${c’}$，写成函数的形式就是$c’ = \tau ({c})$。另外定义$ \vdash $为所有动作$\tau $的并集，也就是状态$c$经过任意动作之后转移到状态${c’}$。定义${ \vdash ^*}$为$ \vdash $的自反和传递闭包。</p><p><strong>定义2（派生树/可到达树）：</strong> 定义$D({c})$为从状态$c$出发，最终可以产生的句法树的集合，即<br>\[D({c}) = \left\{ {t|c{ \vdash ^*}\left\langle {z,\sigma ,t} \right\rangle } \right\}\]<br>也可以称作“派生树”或者“可到达树”。</p><p><strong>定义3（$F_1$值）：</strong> 定义预测树$t$关于标准树$t_G$的$F_1$值为<br>\[{F_1}(t) = \frac{ {rp}}{ {r + p}}\]<br>其中$r = \frac{ {\left| {t \cap {t_G}} \right|}}{ {\left| { {t_G}} \right|}},p = \frac{ {\left| {t \cap {t_G}} \right|}}{ {\left| t \right|}}$。</p><p><strong>定义4：</strong> 将$F_1$扩展为状态$c$的函数，定义${F_1}({c})$为从状态$c$出发可以产生的$F_1$值最高的句法树的$F_1$值，即<br>\[{F_1}(c) = {\max _{t \in D(c)}}{F_1}(t)\]</p><p><strong>定义5（oracle）：</strong> 定义状态$c$的oracle为使状态$c$转移过后最优$F_1$值不变的动作集合，即<br>\[oracle(c) = \left\{ {\tau |{F_1}(\tau (c)) = {F_1}(c)} \right\}\]<br>至于这个集合该怎么求解，下面将会讲到。</p><p><strong>定义6（span包含）：</strong> span$(i,j)$被span$(p,q)$包含，当且仅当$p \le i &lt; j \le q$，记为<br>\[(i,j) \preceq (p,q)\]</p><p><strong>定义7（严格包含）：</strong> span$(i,j)$被span$(p,q)$严格包含，当且仅当$(i,j) \preceq (p,q)$，并且$(i,j) \ne (p,q)$，记为<br>\[(i,j) \prec (p,q)\]<br>同样可以将偏序关系从span扩展到类别，即$_i{X_j}{ \prec _p}{Y_q}$，当且仅当$(i,j) \prec (p,q)$。</p><p><strong>定义8（可到达类别）：</strong> 对于任意状态$c = \left\langle {z,\sigma |i|j,t} \right\rangle $，定义它的可到达类别集合为<br>\[reach(c) = left(c) \cup right(c)\]<br>其中左右可到达类别集合又分别定义为<br>\[\begin{array}{l}left(c) = \left\{ {_p{X_q} \in {t_G}|(i,j) \prec (p,q),p \in \sigma |i} \right\}\\right(c) = \left\{ {_p{X_q} \in {t_G}|p \ge j} \right\}\end{array}\]<br>光看定义可能有点生涩，通俗理解就是，$left(c)$为标准树中包含span$(i,j)$的类别集合，并且类别的左端点与栈中的span没有交叉，也就是说类别的左端点就是栈中除了$j$以外的其余split中的某一个。而$right(c)$为标准树中还处于队列中没有进栈的类别集合。<br><img src="3.png" alt><br>如上图所示，还以之前的句法树为例，现在的状态为$\left\langle {10,[0,1,2,4],\left\{ {_0N{P_1}} \right\}} \right\rangle $，此时的栈顶span$(i,j)=(2,4)$，也就是红色梯形部分，那么$left(c)$就是深蓝色类别，$right(c)$就是天蓝色类别。而灰色类别因为与红色类别交叉了，所以属于不可到达类别，而标准树中还有一个类别$_0N{P_1}$由于已经被识别出来了，所以也属于不可到达类别。</p><p>上面定义是基于动作序号为偶数的情况，而对于动作序号为奇数的情况，也就是预测label的动作，只需要将偏序$\prec$修改为$\preceq$即可，因为转移过后span依然是本身，所以不是严格包含关系。</p><p>特殊情况（初始值）：<br>\[reach(\left\langle {0,[0],\emptyset } \right\rangle ) = {t_G}\]<br>很显然，初始时$t_G$中所有类别都属于$right(c)$。</p><p>最后需要注意的一点是，根据以上定义有<br>\[reach(c) \cap t = \emptyset ,reach(c) \subseteq {t_G} - t\]<br>这一点也是很显然的，$left(c)$都是严格包含span$(i,j)$的，所以与$t$不存在交集，而$right(c)$在队列里，更不可能存在交集，观察上面的例子会更加好理解。</p><p><strong>定义9（next类别）：</strong> 对于任意状态$c = \left\langle {z,\sigma |i|j,t} \right\rangle $，上面已经定义了它的可到达类别集合，最后再定义它的下一个可到达类别为严格包含span$(i,j)$的可到达类别集合（即$left(c)$）中偏序关系最小的类别<br>\[next(c) = {\min _ \prec }left(c)\]</p><h1 id="结构化和label-Oracles"><a href="#结构化和label-Oracles" class="headerlink" title="结构化和label Oracles"></a>结构化和label Oracles</h1><hr><p>对于任意动作序号为偶数的状态$c = \left\langle {z,\sigma |i|j,t} \right\rangle $，记$next(c){ = _p}{X_q}$，那么定义它的结构化Dynamic Oracle为<br><img src="4.png" alt><br>也就是使当前状态向着标准树中最接近它的状态$next(c)$转移，如果$p = i,q &gt; j$，那么应该在移进栈里一些单词；如果$p &lt; i,q = j$，那么不能再移进了，而应该在栈里combine两个span；如果$p &lt; i,q &gt; j$，那么移进或者归约都可以，反正总能达到前两种状态。</p><p>特殊情况（初始值）：<br>\[dyna(\left\langle {0,[0],\emptyset } \right\rangle ) = \{ sh\} \]<br>即使当前预测的span是错的，也可以经过Dynamic Oracle指导，几步之后预测到正确的$next(c)$。而如果没有Dynamic Oracle，可能就一直错下去了。<br><img src="5.png" alt><br>上图是几种任意状态的Dynamic Oracle示例，除了第一种之外，其余三个都是预测错误的，如果没有Dynamic Oracle，甚至都不知道下一步转移的动作是什么。</p><p><strong>引理1：</strong> 对于任意状态$c$，任意动作$\tau  \in dyna(c)$，有<br>\[reach(\tau (c)) = reach(c)\]<br>而对于任意动作$\tau  \notin dyna(c)$，有<br>\[reach(\tau (c)) \not\subset reach(c)\]</p><p>最后是label Dynamic Oracle，这个就很简单了，如果span$(i,j)$出现在了标准树中，那么预测类别就行了，否则的话预测为nolabel：<br><img src="6.png" alt></p><h1 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h1><hr><p>主要证明两点内容：</p><ul><li>首先定义一个特殊的树$t^*{(c)}$，下面会证明它是从状态$c$开始可以得到的得分最高的树。</li><li>然后证明从状态$c$开始按照Dynamic Oracle策略，确实可以得到最优树$t^*{(c)}$。</li></ul><p><strong>定义10（$t^*{(c)}$）：</strong> 对于任意状态$c = \left\langle {z,\sigma,t} \right\rangle $，定义最优树$t^*{(c)}$为$c$中的子树$t$并上当前状态可到达的类别集合，也就是<br>\[{t^*}(c) = t \cup reach(c)\]<br>下面我们会证明，$t^*{(c)}$的确是当前状态可以得到的得分最高的树。<br><img src="7.png" alt><br>上图形象的说明了几种树之间的关系。当前子树$t$与标准树$t_G$不一定完全重合，可能有预测错误的，所以是交叉的。那么接下来的预测如果全部预测为标准树中的$reach(c)$，那么得分一定是最高的。而剩余的白色部分就是与$t$的span产生交叉的类别，属于不可到达的。</p><p><strong>引理2：</strong> 对于任意状态$c$，最优树$t^*{(c)}$一定是$c$的派生树，也就是<br>\[{t^*}(c) \in D(c)\]</p><p><strong>定理1：</strong> 对于任意状态$c$，有<br>\[{F_1}({t^*}(c)) = {F_1}(c)\]</p><p>也就是说最优树$t^*{(c)}$的得分一定是当前状态可以得到的最高分数。</p><p>证明也很简单，根据召回率和准确率公式，最优树$t^*{(c)}$是在$t$的基础上加入了所有的标准树中的可到达类别$reach(c)$，所以召回率分子不会降下来，召回率不可能更高了；同时并没有加入任何不在标准树中的类别，所以准确率的分母也不可能减小，准确率也不会更高了。因此$t^*{(c)}$就是当前状态可以得到的最优树。</p><p><strong>推论1：</strong> 对于任意状态$c = \left\langle {z,\sigma,t} \right\rangle $，对任意$t’ \in D(c),t’ \ne {t^*}(c)$，都有<br>\[{F_1}(t’) &lt; {F_1}(c)\]<br>上面已经证明了$t^*{(c)}$是最优树，所以自然其余的树得分都比它低了。</p><p>最后需要证明的一点就是，按照Dynamic Oracle策略进行转移，一定能到达这个最优树吗？</p><p><strong>引理3：</strong> 对于任意状态$c = \left\langle {z,\sigma,t} \right\rangle $，对任意动作$\tau  \in dyna(c)$，都有<br>\[{t^*}(\tau (c)) = {t^*}(c)\]<br>反之如果$\tau  \notin dyna(c)$，那么有<br>\[{t^*}(\tau (c)) \ne {t^*}(c)\]<br>原文并没有给出证明，粗略理解的话，按照Dynamic Oracle策略，下面应该向着$next(c)$这个类别靠近，而在这个过程中，包含在$next(c)$内的$right(c)$都会被sh动作识别，而其余不在标准树中的类别都会被识别为nolabel，$next(c)$又是第一个$left(c)$，所以所有的$reach(c)$都可以被识别，所以这是符合$t^*{(c)}$定义的。</p><p>反之如果不按照Dynamic Oracle策略来转移，下一步产生的span一定会与$next(c)$产生交叉，因此$next(c)$再也无法被包括进最终的句法树中，所以第二点也成立。</p><p>最终综合引理3、定理1和推论1，得到了本文中最关键的结论：</p><p><strong>定理2：</strong> $dyna()$函数符合定义5中的oracle定义，即对于任意状态$c$，有<br>\[dyna(c) = oracle(c)\]</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>至此关于Dynamic Oracle已经全部介绍完了，在黄亮老师的个人主页上面，还有这篇论文的会议视频和ppt，还有github源码，大家可以去深入学习：<a href="http://web.engr.oregonstate.edu/~huanlian/" target="_blank" rel="noopener">Liang Huang</a>。</p><p>当然，在具体实现中，由于在训练集上过早的拟合，单纯使用Dynamic Oracle并没有得到任何效果提升，所以要加入exploration机制，也就是人为的干预动作分类，使模型故意预测错误的动作，这样就能学习到更多的情况了，事实证明这样的确得到了略微提升。PTB上的结果如下：<br><img src="8.png" alt></p><p>最后提一个小疑问，关于引理1，原文说之后定理的证明会用到它，但我没看出来哪里用到了。而且我对它的正确性也有所怀疑，按照Dynamic Oracle转移之后，$reach(c)$不可能一直不变啊，按理说会先不变，再变少，交替变化，最后生成句法树后变为空集。并且原文中引理1符号也出现了一个小错误，我在这里修改正确了。</p><p>关于这一点疑问，我已经发邮件请教了原作者James Cross，他也已经回复我了，更深入的解答不久应该就会告诉我了，到时候我再更新一下。如果大家有想法的话，也可以提出来。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Straight to the Tree： Constituency Parsing with Neural Syntactic Distance</title>
      <link href="/2018/07/19/conparsing-syntactic-distance/"/>
      <url>/2018/07/19/conparsing-syntactic-distance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/P18-1108" target="_blank" rel="noopener">Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>今天要讲的这篇论文发表在ACL18上面，一句话概括，本文就是<strong>将句法树序列化，通过预测序列进行句法分析。</strong></p><p>主要思想是通过预测一个实值向量来构造出成分句法树，该实值向量表示的就是成分句法树的所有split，并且按照中序遍历给出，具体细节之后会讲到。这个方法之前没有见过，很有新意，效果也很不错，虽然比不上之前讲的基于span的方法，但是该模型最大的优点就是可以并行，时间复杂度低。</p><p>近些年来，成分句法分析模型大多是通过学习出词和短语的表示，然后用基于转移的或者基于chart的方法进行句法分析，亦或者是上一篇笔记中提到的top-down方法。但是这一类方法都有一些不可避免的缺点，比如基于转移的方法，通过预测转移序列来生成句法分析树，但是一棵句法分析树可能对应着多棵不同的转移序列，所以训练的时候可能产生错误，可以通过动态Oracle技术解决。基于chart的模型缺点就是速度太慢。</p><p>本文提出了一种新的概念叫做“syntactic distance”，以下称作句法距离，这个概念首次提出是2017年一篇语言模型的论文中的，本文将其用在了句法分析中。主要思想是这样的：对于一棵二叉树，它的中序遍历的split序列和二叉树是唯一对应的，所以只需要预测这个split序列就行了，而每个split就是用句法距离来表示。下图就是一棵句法树对应的句法距离：<br><img src="1.png" alt><br>这棵树有两个split，第一个split的高度更高，所以对应的句法距离数值更大。</p><p>最后通过top-down顺序进行解码，解码时间复杂度为$O(n\log n)$。最后模型在PTB上取得了91.8的F1值，CTB上取得了86.5的F1值。</p><h1 id="Syntactic-Distances"><a href="#Syntactic-Distances" class="headerlink" title="Syntactic Distances"></a>Syntactic Distances</h1><hr><p>一棵句法树的句法距离如下定义：<br>对于句法分析树$T$，它的叶子结点也就是句子为$({w_0}, \ldots ,{w_n})$，记叶子结点$w_i,w_j$的最近公共祖先LCA为$\tilde d_j^i$，那么句法树$T$的句法距离定义为任意向量$d = ({d_1}, \ldots ,{d_n})$，并且满足<br>\[sign({d_i} - {d_j}) = sign(\tilde d_i^{i - 1} - \tilde d_j^{j - 1})\]<br>这个定义可能看起来比较难理解，通俗一点讲就是，$({d_1}, \ldots ,{d_n})$中任意一对元素的大小关系和$(\tilde d_1^0, \ldots ,\tilde d_n^{n - 1})$中下标相同的一对元素的大小关系是完全一样的，也就是说，句法距离大小反映的是一个句子两两相邻元素的LCA的高度大小。</p><p>还用上面那张图举个例子，$\tilde d_1^0 = 2,\tilde d_2^1 = 1$，那么它的句法距离$d=(d_1,d_2)$就是满足$d_1&gt;d_2$的任意向量。</p><p>这样就可以将一棵句法树唯一对应到一个句法距离的序列，只要预测这个序列就可以得到句法树了，这比预测span集合更加直接。</p><p>那么训练的时候如何将句法树转化为句法距离呢？这里只考虑二叉树，下面的算法1给出了伪代码，将句法树转化为三元组$(d,c,t)$。其中$d$是两两相邻的叶子结点的LCA的高度向量，可以证明，这和中序遍历得到的结点顺序完全相同。$c$是与之顺序相同的结点的label向量。$t$是叶子结点从左向右的tag标签向量。<br><img src="2.png" alt><br>从算法中可以看出，采用自顶向下递归的形式，叶子结点高度为0，不存在句法距离和label。而内结点的高度等于左右儿子高度较大的一个加1，句法距离为左儿子句法距离拼接上自身句法距离再拼接上右儿子句法距离，label也是如此。</p><p>那么如果得到了一棵句法树的三元组$(d,c,t)$，如何还原出这棵句法树呢？算法2给出了构造方法，其实类似于之前那篇论文的top-down方法。<br><img src="3.png" alt><br>原理很简单，只要在每一步寻找$d$中最大的元素，也就是寻找高度最大的内结点，该内结点对应的下标就是句法树的split，然后对左右子树递归解析就行了。时间复杂度只要$O(n\log n)$，而之前的top-down模型时间复杂度为$O(n^2)$。<br><img src="4.png" alt><br>上图是构造句法树的一个例子，和之前一样，通过$\emptyset$的label隐式的将句法树二叉化了，一元还是处理成新的label。图中的矩形高度就代表了句法距离的大小，可以看出，除了$d_0,d_5$这两个句子开始结束标记的句法距离以外，$d_1$最大，所以句法树的split就是$w_0$和$w_1$，然后对右子树递归分析。</p><p>在子树递归过程中，可以并行计算，理论上时间复杂度可以降到$O(\log n)$，但是句子长度过短的话，是否与cpu通讯时间都要大于这个数量级了呢？这个并行的意义还有待商榷。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><hr><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>下面的问题就是给出一个句子，如何学习出它的三元组$(d,c,t)$呢？</p><p>首先将每个单词的词向量和tag向量拼接作为输入，然后送入一个Bi-LSTM，得到隐含层输出为<br>\[h_0^w, \ldots ,h_n^w = {\rm{BiLST}}{ {\rm{M}}_w}([e_0^w,e_0^t], \ldots ,[e_n^w,e_n^t])\]</p><p>对于每个单词，可能存在一元结点，也可能不存在，不存在的话就标记为$\emptyset$，用一个前馈神经网络和softmax预测每个单词的一元结点：<br>\[p(c_i^w|w) = {\rm{softmax(FF}}_c^w(h_i^w))\]</p><p>为了得到每个split的表示，对两两相邻单词进行卷积：<br>\[g_1^s, \ldots ,g_n^s = {\rm{CONV(}}h_0^w, \ldots ,h_n^w)\]<br>注意输出比输入少一个，因为split数量比单词少一个。</p><p>然后再将输出通过一层Bi-LSTM，得到最终的split表示：<br>\[h_1^s, \ldots ,h_n^s = {\rm{BiLST}}{ {\rm{M}}_s}(g_1^s, \ldots ,g_n^s)\]<br>当然这里也可以选择采用self-attention，详见我的上一篇博客。</p><p>最后将输出通过一个两层前馈神经网络，得到每个split的句法距离值：<br>\[{ {\hat d}_i} = {\rm{F}}{ {\rm{F}}_d}(h_i^s)\]</p><p>每个内结点的label同样用一个前馈神经网络和softmax预测：<br>\[p(c_i^s|w) = {\rm{softmax(FF}}_c^s(h_i^s))\]</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>对于训练样例$\left\{ {\left\langle { {d_k},{c_k},{t_k},{w_k}} \right\rangle } \right\}_{k = 1}^K$，它的损失函数就是$d$和$c$的损失函数之和。</p><p>对于$c$，因为用的是softmax预测的，所以直接用交叉熵即可得到损失${L_{ {\rm{label}}}}$。</p><p>对于$d$，可以用均方误差：<br>\[L_{dist}^{mse} = \sum\limits_i { { {({d_i} - { {\hat d}_i})}^2}} \]<br>然而我们并不在意句法距离的绝对值大小，我们只要它的相对大小是正确的即可，所以均方误差在这里不是很合适，可以换成如下损失函数：<br>\[L_{dist}^{rank} = \sum\limits_{i,j &gt; i} {\max (0,1 - sign({d_i} - {d_j})({ {\hat d}_i} - { {\hat d}_j}))} \]</p><p>最后总的损失函数为：<br>\[L = {L_{ {\rm{label}}}} + L_{dist}^{rank}\]</p><p>下面这张图形象的说明了模型的结构，由下往上，第一层圆圈是单词之间的LSTM，然后每个单词上面的五边形是前馈神经网络用来预测一元label，两个相邻单词之间的三角形是卷积，卷积得到的结果再通过一个LSTM得到split表示，最后每个split上面有两个五边形，一个是前馈神经网络用来预测label，另一个是前馈神经网络用来预测句法距离。<br><img src="5.png" alt></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>在PTB数据集上的实验结果如下：<br><img src="6.png" alt><br>可以看出，结果还是很有竞争力的，虽然有很多比本文高的模型，但本文解释了，那是因为他们用了Char-LSTM，用了外部数据，用了半监督方法或者重排序方法。。。目前单模型最高的方法依然是上一篇博客讲的span-based模型。</p><p>最后值得一提的是模型的运行速度，之前理论分析时间复杂度非常低，而实际上运行速度的确快了许多，结果如下：<br><img src="7.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文最大的创新点就是应用句法距离进行句法分析，并且时间复杂度很低。至于文章题目为什么叫“Straight to the Tree”，文章最后说因为只通过一个最普通的LSTM和卷积就预测出了句法树，所以是很直接的。。。</p><p>本文的模型还比较粗糙，我觉得仍然有许多改进之处：</p><ul><li>可以将LSTM替换为self-attention，因为之前博客讲到了，伯克利的self-attention编码器比LSTM编码器准确率高了1个多的百分点。</li><li>可以尝试最近新出的词向量模型ELMo，也许会有特别大的提升。</li><li>加入词级别的Char-LSTM，可能会有一定提升。</li><li>我觉得split的表示可以更加复杂化一点，而不仅仅是一层卷积+一层LSTM这么简单。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Constituency Parsing with a Self-Attentive Encoder</title>
      <link href="/2018/07/04/acl18-attconparsing/"/>
      <url>/2018/07/04/acl18-attconparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/pdf/1805.01052.pdf" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a><br><strong>代码地址：</strong><a href="https://github.com/nikitakit/self-attentive-parser" target="_blank" rel="noopener">github</a></p><p>今天要介绍的这篇论文是成分句法分析领域目前的state-of-the-art，结果最高的几篇paper可以参见ruder在github整理的列表：<a href="https://github.com/sebastianruder/NLP-progress/blob/master/constituency_parsing.md" target="_blank" rel="noopener">github</a>。<br>下面就是成分句法分析目前排名：</p><table><thead><tr><th>Model</th><th align="center">F1 score</th><th>Paper / Source</th></tr></thead><tbody><tr><td>Self-attentive encoder + ELMo (Kitaev and Klein, 2018)</td><td align="center">95.13</td><td><a href="https://arxiv.org/abs/1805.01052" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a></td></tr><tr><td>Model combination (Fried et al., 2017)</td><td align="center">94.66</td><td><a href="https://arxiv.org/abs/1707.03058" target="_blank" rel="noopener">Improving Neural Parsing by Disentangling Model Combination and Reranking Effects</a></td></tr><tr><td>In-order (Liu and Zhang, 2017)</td><td align="center">94.2</td><td><a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a></td></tr><tr><td>Semi-supervised LSTM-LM (Choe and Charniak, 2016)</td><td align="center">93.8</td><td><a href="http://www.aclweb.org/anthology/D16-1257" target="_blank" rel="noopener">Parsing as Language Modeling</a></td></tr><tr><td>Stack-only RNNG (Kuncoro et al., 2017)</td><td align="center">93.6</td><td><a href="https://arxiv.org/abs/1611.05774" target="_blank" rel="noopener">What Do Recurrent Neural Network Grammars Learn About Syntax?</a></td></tr><tr><td>RNN Grammar (Dyer et al., 2016)</td><td align="center">93.3</td><td><a href="https://www.aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a></td></tr><tr><td>Transformer (Vaswani et al., 2017)</td><td align="center">92.7</td><td><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a></td></tr><tr><td>Semi-supervised LSTM (Vinyals et al., 2015)</td><td align="center">92.1</td><td><a href="https://papers.nips.cc/paper/5635-grammar-as-a-foreign-language.pdf" target="_blank" rel="noopener">Grammar as a Foreign Language</a></td></tr><tr><td>Self-trained parser (McClosky et al., 2006)</td><td align="center">92.1</td><td><a href="https://pdfs.semanticscholar.org/6f0f/64f0dab74295e5eb139c160ed79ff262558a.pdf" target="_blank" rel="noopener">Effective Self-Training for Parsing</a></td></tr></tbody></table><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>本篇论文将之前<a href="http://godweiyang.com/2018/06/28/ACL17-ConParsing/">A Minimal Span-Based Neural Constituency Parser</a>这篇论文中模型的编码器部分由LSTM替换为了Self-Attentive，来捕捉句子单词内容(content)与位置(position)之间的联系。实验结果可以达到93.55%的F1值，如果再加上预训练的词向量ELMo，那么F1值可以提升到95.13%。这是目前效果最好的一个模型了。</p><p>Attention的主要想法借鉴了谷歌的神作：<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>，这篇论文网上也有很多讲解了，我挑选了一篇讲解比较好的，大家可以先看看：<a href="https://yq.aliyun.com/articles/342508?utm_content=m_39938" target="_blank" rel="noopener">Attention Is All You Need</a>。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>这部分详见我之前写的一篇笔记：<a href="http://godweiyang.com/2018/06/28/ACL17-ConParsing/">A Minimal Span-Based Neural Constituency Parser</a>，解码器部分和之前模型基本一致。本文主要探讨的是编码器的构造，也就是如何求出每个span的向量表示，从而得到span的得分$s(i,j,l)$，然后应用解码器进行解码，生成成分句法分析树。</p><h2 id="词向量表示"><a href="#词向量表示" class="headerlink" title="词向量表示"></a>词向量表示</h2><p>第$t$个单词的词向量由三个部分组成：</p><ul><li>word embdding：$w_t$，这部分可以用随机初始化的向量，也可以用CharLSTM，也可以用预训练的词向量。</li><li>tag embdding：$m_t$</li><li>位置向量：$p_t$</li></ul><p>最终词向量为三部分的加和：<br>\[z_t = w_t + m_t + p_t\]</p><h2 id="Self-Attentive"><a href="#Self-Attentive" class="headerlink" title="Self-Attentive"></a>Self-Attentive</h2><p>模型结构如下图所示：<br><img src="1.png" alt><br>这一部分是不同位置单词互相联系的唯一方式，采用谷歌<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>中的Self-Attentive模型。</p><p>模型一共由8个SingleHead组成，每个SingleHead结构如下图：<br><img src="2.png" alt><br>计算方式如下：<br>\[{\rm{SingleHead}}(X) = \left[ { {\rm{Softmax}}\left( {\frac{ {Q{K^{\rm{T}}}}}{ {\sqrt { {d_k}} }}} \right)V} \right]{W_o}\]<br>其中$Q = X{W_Q};K = X{W_K};V = X{W_V}$，而$W_O$用来将输出映射到与输入相同的维度。</p><p>详细分析一下计算过程，首先输入矩阵$X = [{z_1},{z_2}, \ldots ,{z_T}]$是由一个句子中所有词向量组成的矩阵，拼接在一起是为了并行，加快计算速度，$X \in {\mathbb{R}^{T \times {d_{ {model}}}}}$。</p><p>然后将$X$映射为三个矩阵，query矩阵$Q$，key矩阵$K$，value矩阵$V$，其中$Q,K \in {\mathbb{R}^{ {d_{ {model}}} \times {d_k}}}$。</p><p>我们想要计算单词$i$和单词$j$之间的Attention大小，可以用两者query向量和key向量元素乘得到：<br>\[p(i \to j) \propto \exp \left( {\frac{ { {q_i} \cdot {k_j}}}{ {\sqrt { {d_k}} }}} \right)\]<br>所有单词的value向量乘以单词$i$对它的Attention值，加权求和之后得到的结果就是单词$i$最后的向量表示：<br>\[{ {\bar v}_i} = \sum\nolimits_j {p(i \to j){v_j}} \]<br>最后乘以$W_O$映射到与输入$X$相同的维度。</p><p>整个过程如果写成矩阵形式就是最开始的那个矩阵式子。注意到式子中$Q{K^{\rm{T}}} \in {\mathbb{R}^{ {\rm{T \times T}}}}$，矩阵中的每个元素恰好就是Attention值$p(i \to j)$。$\sqrt { {d_k}}$是归一化因子。</p><p>最后将8个SingleHead的结果求和得到MultiHead结果，注意这8个SingleHead参数不共享：<br>\[{\rm{MultiHead(}}X) = \sum\limits_{i = 1}^8 { {\rm{SingleHea}}{ {\rm{d}}^{(i)}}(X)} \]</p><p>注意到Attention模型有一个很严重的问题，就是无论单词的顺序是怎么样的，都不影响最终的结果。所以在输入中要添加位置向量$p_t$，否则之后会有实验表明，不加的话效果大大下降。</p><p>图一中还有一个前馈神经网络的部分，使用的是一个双层前馈神经网络：<br>\[{\rm{FeedForward}}(x) = {W_2}{\rm{relu}}({W_1}x + {b_1}) + {b_2}\]</p><h2 id="Span得分"><a href="#Span得分" class="headerlink" title="Span得分"></a>Span得分</h2><p>最终的span得分计算方式如下：<br>\[s(i,j, \cdot ) = {M_2}{\rm{relu}}({\rm{LayerNorm}}({M_1}v + {c_1})) + {c_2}\]<br>其中$v$就是短语的向量表示，由之前的每个单词的向量输出得到：<br>\[v = [{ {\vec y}_j} - { {\vec y}_i},{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over y} }_{j + 1}} - { {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over y} }_{i + 1}}]\]<br>在之前的LSTM模型中前向后向表示很容易得到，在这里只能通过将输出向量一分为二，一半作为前向表示，一半作为后向表示，实际实现中，偶数维度作为前向表示，奇数维度作为后向表示。</p><h1 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h1><hr><h2 id="Content-vs-Position-Attention"><a href="#Content-vs-Position-Attention" class="headerlink" title="Content vs Position Attention"></a>Content vs Position Attention</h2><p>之前的模型中，我们采用元素加将三个输入向量求和作为输入，期待模型自己训练出它们之间的权重，将它们很好地分开，但是实际上效果并不好。</p><p>下面论文做了许多实验来探讨content和position的重要性。</p><p>首先修改模型输入，令$Q=PW_Q,K=PW_K$，也就是丢弃了content信息，但是最后结果只下降了0.27个百分点，说明了content信息对模型影响不是很大。</p><p>然后为了验证是不是元素加导致content和position信息混合在一起模型无法分开，实验将输入向量显示分开，输入改为<br>\[z_t=[w_t+m_t;p_t]\]<br>但是实验结果只下降了0.07个百分点，说明不是这个因素导致的。事实上元素加和拼接操作在高维度上面是相似的，特别是之后立即乘上了一个矩阵，这就会混合里面的信息。</p><p>所以最好的解决办法就是将content和position向量分开计算attention，最后求和。这样attention矩阵就可以表示为：<br>\[QK^{\rm{T}} = {Q_c}K_c^{\rm{T}} + {Q_p}K_p^{\rm{T}}\]<br>这时的权重矩阵$W$就可以写为<br>\[W = \left[ {\begin{array}{*{20}{c}}{ {W_c}}&amp;0\\0&amp;{ {W_p}}\end{array}} \right]\]</p><p>通过将content和position信息分开，模型的效果从92.67%提升到了93.15%，模型示意图如下：<br><img src="3.png" alt></p><p>最后的实验在测试阶段的8层模型中，每一层手动选择采不采用content或者position attention，实验结果如下：<br><img src="4.png" alt><br>可以发现，不用position信息的话结果大大下降，接近传统的CKY算法，这也说明了普通的CKY算法是无法捕捉到全局的信息的。还有就是content信息主要作用在最后几层，这也说明了前面几层有点类似于扩张卷积网络。</p><h2 id="窗口Attention"><a href="#窗口Attention" class="headerlink" title="窗口Attention"></a>窗口Attention</h2><p>这一部分也不是什么新鲜玩意了，谷歌的论文中也有提到，主要思想就是限制attention的范围，每个单词只与周围窗口大小内的单词进行计算。在本文中还提出一个relaxed变体，就是除了窗口大小范围外，再加入首尾各两个单词进行attention操作。</p><p>如果只在测试阶段进行窗口attention的话，实验结果如下：<br><img src="5.png" alt><br>可以看出，首尾的4个单词对模型效果有很大的影响，如果加上的话，即使窗口很小，效果下降也不会很多。</p><p>然后如果训练和测试阶段都采用窗口attention，结果如下：<br><img src="6.png" alt><br>这时结果下降反而不是很明显了，其实模型的8层就类似于卷积操作，假设窗口大小为10，那么经过8层计算之后，窗口其实可以覆盖到长度为80的句子，这已经足够了，所以性能没有下降太多不足为奇。</p><h1 id="模型的一些改进"><a href="#模型的一些改进" class="headerlink" title="模型的一些改进"></a>模型的一些改进</h1><hr><h2 id="Subword-Features"><a href="#Subword-Features" class="headerlink" title="Subword Features"></a>Subword Features</h2><p>可以尝试加入CharLSTM来代替随机初始化的tag embdding，并且可以直接删除随机初始化的word embdding，只保留tag embdding和位置向量，效果反而能有提升。</p><p>受到其他工作的启发，还可以将每个单词的前后各8个字符向量拼接起来作为输入，但是实验结果不如CharLSTM。</p><p>上面的实验结果如下图所示：<br><img src="7.png" alt><br>可以看出，采用CharLSTM输出作为tag embdding，并且不采用word embdding的效果最好。</p><h2 id="外部词向量"><a href="#外部词向量" class="headerlink" title="外部词向量"></a>外部词向量</h2><hr><p>如果采用另一项关于词向量的工作成果ELMo，将其预训练的结果作为word embdding，实验结果可以更高。因为该词向量已经很好的学习到了全局的信息，所以模型可以减少到4层，效果比8层更好，结果如下：<br><img src="8.png" alt><br>F1值大大提高，达到了惊人的95.21%。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>在PTB数据集上，无论是单模型还是多模型或者加入外部词向量，本文的模型结果都是近来最好的，单模型93.55%，多模型95.13%，对比结果如下：<br><img src="9.png" alt><br>本文开头已经提到了最高的几个排名，大家可以去看看其他的方法学习学习。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>之前的工作大多数围绕解码器的算法优化，但是本文对编码器进行了改进，使其能更好的捕捉全局信息。</p><p>同时提出了几点重要的改进：</p><ul><li>subword的信息（CharLSTM）和预训练的词向量非常重要。</li><li>将content和position信息分开可以提升实验结果。</li></ul><p>同时在阅读<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>的同时，我也发现了谷歌的attention模型其实还是有很多问题的，例如模型本身无法捕捉位置信息，需要加入position embdding来表示位置信息，但这只是临时应付措施，今后工作可以探讨更好的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What&#39;s Going On in Neural Constituency Parsers? An Analysis</title>
      <link href="/2018/07/03/naacl18-conparsing/"/>
      <url>/2018/07/03/naacl18-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/pdf/1804.07853.pdf" target="_blank" rel="noopener">What’s Going On in Neural Constituency Parsers? An Analysis</a><br><strong>代码地址：</strong><a href="https://github.com/dgaddy/parser-analysis" target="_blank" rel="noopener">github</a></p><p><img src="1.jpg" alt></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>最近几年，成分句法分析的方法发生了巨大的变化。传统的有基于PCFG的CKY算法，最近几年随着神经网络的兴起又产生了基于转移的方法、CRF句法分析、重排序方法等等。</p><p>本文是伯克利大学在NAACL18提出的一种基于神经网络的句法分析方法，和传统的方法不同的是，完全不使用语法规则和词汇特征，只需要用神经网络学习出短语的表示即可。通过实验可以发现，神经网络的确也很好的隐式学习出了传统的方法显式用到的语法规则和其他一些特征。在PTB数据集上，该方法达到了92.08%的F1值，这也直接超过了传统的大多数方法。而在下一篇伯克利的ACL18论文中，他们提出的基于Multi-Head Attention的成分句法分析方法更是达到了95.13%的F1值。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>在过去几年，成分句法分析方法发生了巨大的变化。最大的变化就是语法规则和人工的词汇特征变得越来越不那么重要，取而代之的用循环神经网络学习短语的表示，但是还没有什么人对这种神经网络表示的有效性做研究分析。本文提出了一种用RNN学习表示用来句法分析的模型，并对模型的各个方面进行了分析。</p><h1 id="句法分析模型"><a href="#句法分析模型" class="headerlink" title="句法分析模型"></a>句法分析模型</h1><hr><h2 id="模型总览"><a href="#模型总览" class="headerlink" title="模型总览"></a>模型总览</h2><p>和传统的CKY算法一样，该模型还是采用动态规划的算法求解每个短语的最大得分对应的类别以及分割点。只不过这里的短语得分不再是产生式概率之积，而是用RNN训练出来的短语得分。</p><p>用$s(i,j,l)$表示短语$x_{ij}$类别为$l$的得分，句法树$T$的得分表示为所有产生式的得分总和：<br>\[s(T) = \sum\limits_{(i,j,l) \in T} {s(i,j,l)} \]</p><p><strong>值得一提的是，该句法分析模型不需要句法树是二叉树，所以可以直接分析出$n$叉树结构。</strong></p><p>模型的任务依然是寻找得分最高的句法分析树：<br>\[\hat T = \mathop {\arg \max }\limits_T s(T)\]</p><p>短语得分$s(i,j,l)$的计算可以通过三个部分实现：单词表示、短语表示、短语类别得分。</p><h2 id="单词表示"><a href="#单词表示" class="headerlink" title="单词表示"></a>单词表示</h2><p>首先采用Char-BiLSTM训练出每个单词的字符级别的表示，这种表示方法已经很常见了，优点是可以捕捉到单词的前缀后缀等信息，还可以解决未登录词的表示问题。</p><p>最后将字符级别的词表示和预训练的词向量拼接起来作为最终的单词表示。也可以用外部序列标注器预测出单词的词性，并拼接上去作为输入，但是在这里只要Char-BiLSTM训练的足够好，就不需要词性标注了。</p><h2 id="短语表示"><a href="#短语表示" class="headerlink" title="短语表示"></a>短语表示</h2><p>对句子单词序列跑一遍双向LSTM，得到每个单词的前向后向上下文表示${ {\bf{f}}_i}$和${ {\bf{b}}_i}$，然后对于短语$x_{ij}$，用两者的上下文表示的差值拼接起来作为该短语的向量表示：<br>\[{ {\bf{r}}_{ij}} = [{ {\bf{f}}_j} - { {\bf{f}}_i},{ {\bf{b}}_i} - { {\bf{b}}_j}]\]<br>图1是一个具体的例子：<br><img src="2.jpg" alt></p><h2 id="短语类别得分"><a href="#短语类别得分" class="headerlink" title="短语类别得分"></a>短语类别得分</h2><p>最后将短语表示输入到一个单层前馈神经网络中，输出得分向量，其中得分向量每个维度就对应了每个类别的概率。具体计算公式如下：<br>\[s(i,j,l) = {[{ {\bf{W}}_2}ReLU({ {\bf{W}}_1}{ {\bf{r}}_{ij}} + { {\bf{z}}_1}) + { {\bf{z}}_2}]_l}\]</p><h2 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h2><p>虽然现在是$n$叉树，但是依然可以用CKY算法来进行句法分析。这时候就需要定义一个虚拟短语类别$\emptyset$，表示实际上不能构成短语的临时短语。例如对于产生式$A \to BCD$，分析的时候可以将其分析为$A \to \emptyset D,\emptyset  \to BC$。定义虚拟短语类别的得分为0，即$s(i,j,\emptyset ) = 0$。</p><p>定义${s_{best}}(i,j)$为短语$x_{ij}$得分最高的句法分析树的得分。首先对长度为1的短语即单词进行初始化：<br>\[{s_{best}}(i,i + 1) = \mathop {\max }\limits_l s(i,i + 1,l)\]<br>然后对于短语$x_{ij}$，运用动态规划算法计算得分最高的句法分析树：<br>\[{s_{best}}(i,j) = \mathop {\max }\limits_l s(i,j,l) + \mathop {\max }\limits_k [{s_{best}}(i,k) + {s_{best}}(k,j)]\]<br>注意到这里对类别的预测和分割点的预测是分开的，短语的最高分数就是最优子树的每个结点的类别得分之和。</p><p>自底向上进行计算，最终整个句子的最高得分就是${s_{best}}(0,n)$。然后自顶向下回溯得到整个句子的句法分析树，注意如果回溯遇到了虚拟短语类别$\emptyset$，就直接忽略它，继续往下回溯。</p><p>整个算法的时间复杂度为$O({n^3} + L{n^2})$，因为没有用到语法规则，所以$n^3$的常数系数$\left| G \right|$就没有了，复杂度大大降低！</p><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>损失函数依然使用的是max-margin，即<br>\[\mathcal L = \max \left( {0,\mathop {\max }\limits_T [s(T) + \Delta (T,{T^*})] - s({T^*})} \right)\]<br>这里提到了一点加快计算的方法，${\Delta (T,{T^*})}$可以融入到动态规划算法中一起计算，即将短语类别得分$s(i,j,l)$替换为$s(i,j,l) + 1[l \ne l_{ij}^*]$，其中$l_{ij}^*$是标准树中短语$x_{ij}$的类别。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经过10轮训练之后，模型在验证集上的F1值达到了92.22%，在测试集上的F1值为92.08%。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Minimal Span-Based Neural Constituency Parser</title>
      <link href="/2018/06/28/acl17-conparsing/"/>
      <url>/2018/06/28/acl17-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文地址：<a href="https://www.aclweb.org/anthology/P/P17/P17-1076.pdf" target="_blank" rel="noopener">ACL17</a><br>代码地址：<a href="https://github.com/mitchellstern/minimal-span-parser" target="_blank" rel="noopener">github</a></p><p>今天要分享的是伯克利2017年发表在ACL的一篇成分句法分析论文，论文和代码地址都已经放在上面了，代码里还给出了处理过的PTB数据集，使用起来非常方便。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>本文提出了一种不同于传统方法的成分句法分析方法。</p><p>传统的句法分析器需要预处理出语法规则集合，然后利用语法规则来进行各种句法分析，这类方法的弊端有很多，我列举了主要的三点：</p><ul><li>语法规则集合构造的好坏直接影响到分析效果的好坏。</li><li>不仅如此，利用语法规则的方法时间复杂度高，因为每次都要遍历一遍语法规则集合来决定每个短语采用哪一条语法规则。</li><li>还有一种弊端就是利用语法规则的方法无法产生新的产生式，也就是说如果测试集中的语法规则没有在训练集中出现过，那么是无法预测出来的。</li></ul><p>而本文提出的模型不需要预先构造出语法规则集合，只需要预测出每个短语的label和split就行了，这样就能构造出一棵完整的句法树。</p><p>该模型分为编码与解码两部分，其中编码部分就是利用双向LSTM将每个词和短语表示成向量，解码部分提出了两种模型，一种是chart模型，类似于CKY算法，另一种是top-down模型，就是自顶向下的贪心算法，具体模型之后介绍。</p><h1 id="编码模型"><a href="#编码模型" class="headerlink" title="编码模型"></a>编码模型</h1><hr><p>一棵句法分析树可以看做是$(label, span)$的集合，也就是句法树中的每一个结点的类别是label，该结点对应的短语在句子中的下标范围就是span。所以模型的任务就是要预测这个集合，给每一个label和span一个得分，找出使得一个句子得分最高的$(label, span)$集合即可。</p><p>那么我们的编码模型任务就是要得出每一个短语的表示，并将其转换为短语的label得分和span得分。这里用到的就是最简单的双向LSTM，对于句子的第$i$个位置，得到它的双向表示$f_i$和$b_i$，那么$span(i,j)$就可以表示为$[f_j-f_i,b_i-b_j]$。</p><p>然后将短语表示输入到两个单独的单层前馈神经网络中，就能分别得到label得分和span得分了。假设用$s_{ij}$表示$span(i,j)$的短语表示，那么label得分和span得分可以分别表示为：<br>\[\begin{array}{*{20}{l}}{ {s_{labels}}(i,j) = {V_l}g({W_l}{s_{ij}} + {b_l})}\\\ { {s_{span}}(i,j) = {v_s}^{\rm{T}}g({W_s}{s_{ij}} + {b_s})}\end{array}\]<br>注意到这里计算出来的label得分是一个向量，维数为label的类别数，而span得分计算出来就是一个标量了。而对于某一个特定的类别，它的得分就可以直接从label得分向量中取出对应的那一维就行了：</p><p>\[{s_{label}}(i,j,l) = {[{s_{labels}}(i,j)]_l}\]</p><p>还有个重要的问题就是一元和$n$元的产生式怎么处理，对于一元产生式，可以将所有的类别合并为一个新的类别，然后加入类别集合中共同预测就行了，在实现代码中，将一元的产生式链上面的类别合并成了一个元组作为这棵子树的label。对于$n$元的产生式，可以添加一个临时类别$\emptyset $，相当于进行了二叉化，所有的新增节点全部预测为$\emptyset $。</p><h1 id="chart解码模型"><a href="#chart解码模型" class="headerlink" title="chart解码模型"></a>chart解码模型</h1><hr><p>chart模型本质上就是一个动态规划算法，类似于CKY算法。</p><p>首先一棵句法树的总得分可以表示为组成它的$(label, span)$集合的label得分与span得分之和：<br>\[{s_{tree}}(T) = \sum\limits_{(l,(i,j)) \in T} {[{s_{label}}(i,j,l) + {s_{span}}(i,j)]} \]<br>我们目的就是寻找使得该式最大的集合$T$，利用动态规划可以将时间复杂度降到$O(n^3)$。</p><p>对于叶子结点的情况，因为没有split，所以我们只需要预测最大得分的label就行了：<br>\[{s_{best}}(i,i + 1) = \mathop {\max }\limits_l [{s_{label}}(i,i + 1,l)]\]<br>而对于一般的$span(i,j)$，我们不仅要预测label，还得预测split。对于split$k$，我们可以将split得分表示为：<br>\[{s_{split}}(i,k,j) = {s_{span}}(i,k) + {s_{span}}(k,j)\]<br>那么最大得分可以表示为：<br>\[{s_{best}}(i,j) = \mathop {\max }\limits_l [{s_{label}}(i,j,l)] + \mathop {\max }\limits_k [{s_{split}}(i,k,j) + {s_{best}}(i,k) + {s_{best}}(k,j)]\]<br>这样就可以对label和split单独预测，在实际代码实现中，去掉了${s_{split}}(i,k,j)$这一部分，也就是只预测label得分之和最高的split。这样做的一个好处就是防止了二叉化过程中，从左边开始合并和从右边开始合并得到的分数不一样，从而导致偏差，另外加上这部分效果提升也不大，所以为了简便就删掉了。</p><p>训练的话采用的还是Max-Margin：<br>\[max\left( {0,\Delta (\hat T,{T^*}) - {s_{tree}}({T^*}) + {s_{tree}}(\hat T)} \right)\]<br>至于句法树差异${\Delta (\hat T,{T^*})}$，可以方便的将${s_{label}}(i,j,l)$替换为${s_{label}}(i,j,l) + {\bf{1}}(l \ne l_{ij}^*)$，其中$l_{ij}^*$就是$span(i,j)$在标准树中的label。</p><h1 id="top-down解码模型"><a href="#top-down解码模型" class="headerlink" title="top-down解码模型"></a>top-down解码模型</h1><hr><p>top-down模型其实就是自顶向下贪心的选择每一个短语的最大label和split。</p><p>其中叶子结点处依然还是直接找得分最高的那一维：<br>\[\hat l = \mathop {arg\max }\limits_l [{s_{label}}(i,i + 1,l)]\]<br>对于一般的$span(i,j)$，直接贪心的寻找得分最高的label和split就行了：<br>\[\begin{array}{l}\hat l = \mathop {\arg \max }\limits_l [{s_{label}}(i,j,l)]\\\hat k = \mathop {\arg \max }\limits_k [{s_{split}}(i,k,j)]\end{array}\]<br>虽然这种贪心的方法看上去并不十分科学，但是实际效果却比动态规划算法还要好一点，并且它的时间复杂度只有$O(n^2)$。</p><p>下面是top-down模型进行解析的一个例子：<br><img src="1.png" alt><br>其中$\emptyset $在构造句法树的时候就直接忽略，最后可以还原成$n$元的产生式。并且一元产生式$S \to VP$被直接替换为了新的类别$S-VP$。</p><p>训练过程类似，对标准树中的每一个$span(i,j)$，分别计算label和split的loss就行了：<br>\[\begin{array}{l}\max \left( {0,1 - {s_{label}}(i,j,{l^*}) + {s_{label}}(i,j,\hat l)} \right)\\\max \left( {0,1 - {s_{split}}(i,{k^*},j) + {s_{split}}(i,\hat k,j)} \right)\end{array}\]<br>最后累加求出总的loss即可。</p><p><strong>动态Oracle</strong><br>top-down模型在每一个$span(i,j)$处都计算出得分最高的label和split，然后与标准树对应的$span(i,j)$作比较，计算出loss。但是这样存在一个很严重的问题，就是如果这个预测出来的$span(i,j)$没有出现在标准树中，那么他在标准树中的label和split是什么呢？这时候就要用到这里提到的动态Oracle技术了。</p><p>对于label而言，如果$span(i,j)$出现在标准树中，那么label就是标准树中的label，否则的话就是$\emptyset $。</p><p>对于split而言，定义$b(i,j)$为$span(i,j)$的split集合，因为可能是$n$元的，所以split可能不止一个。如果$span(i,j)$在标准树中，那么$b(i,j)$显然就是标准树中$span(i,j)$的split集合。如果$span(i,j)$不在标准树中，那么就寻找一个标准树中包含$span(i,j)$的最小span，该span的split集合中位于$i,j$之间的split就构成了$b(i,j)$。</p><p>形式化定义为，寻找：<br>\[({i^*},{j^*}) = \min \left\{ {(i’,j’) \in T:i’ \le i &lt; j \le j’} \right\}\]<br>其中这里的最小是定义在区间长度上的偏序关系。所以$b(i,j)$就可以定义为：<br>\[b(i,j) = \left\{ {k \in b({i^*},{j^*}):i &lt; k &lt; j} \right\}\]</p><p>这样对于任意的$span(i,j)$，都能在标准树中找到对应的split集合，然后计算出loss。这样也能解决因为$n$叉树不同的二叉化导致的不同的split产生的问题。在实际的代码中，直接采用了$b(i,j)$集合中最左边的split作为标准树中的split，当然也可以选择得分最高的一个split，不过提升不大没有必要。</p><p>采用动态Oracle有两个好处：</p><ul><li>一个就是上面说到的，训练的时候不需要每次都预测的和标准树一样了，就算不一样也能给出评判标准。</li><li>另一个就是在预测不准的时候，可以给出在该span里的标准树中的split，这样可以将贪心预测从错误中逐渐“拉回正轨”。</li></ul><h1 id="其他的得分计算方法"><a href="#其他的得分计算方法" class="headerlink" title="其他的得分计算方法"></a>其他的得分计算方法</h1><hr><p><strong>Top-Middle-Bottom label得分</strong><br>其实就是将每个span的label拆分为三元组$(top,middle,bottom)$，主要用来应对一元产生式的：</p><ul><li>如果不是一元产生式，那么父结点label就可以写为$(X,\emptyset,\emptyset)$。</li><li>如果产生式为$X \to Y$，那么label可以合并写为$(X,\emptyset,Y)$。</li><li>如果产生式为$X \to {Z_1} \to  \cdots  \to {Z_k} \to Y$，那么label可以合并写为$(X,{Z_1} -  \cdots  - {Z_k},Y)$。</li></ul><p>label的得分也由三部分求和得到：<br>\[{s_{label}}(i,j,({l_t},{l_m},{l_b})) = {s_{top}}(i,j,{l_t}) + {s_{middle}}(i,j,{l_m}) + {s_{bottom}}(i,j,{l_b})\]<br>求最大得分的时候也可以三部分分开求。</p><p><strong>左右span得分</strong><br>其实就是在计算split得分时，将左右span的得分区别为left和right两部分：<br>\[{s_{split}}(i,k,j) = {s_{left}}(i,k) + {s_{right}}(k,j)\]</p><p><strong>span连接得分</strong><br>之前计算split得分都是将左右span得分直接相加，当然也可以将他们拼接起来，输入到单层前馈神经网络里，输出作为得分：<br>\[{s_{split}}(i,k,j) = {v^{\rm{T}}}g({W_s}[{s_{ik}};{s_{kj}}] + {b_s})\]</p><p><strong>深度双仿射span得分</strong><br>首先令${h_{ik}} = {f_{left}}({s_{ik}}),{h_{kj}} = {f_{right}}({s_{kj}})$，然后split得分可以计算为：<br>\[{s_{split}}(i,k,j) = h_{ik}^{\rm{T}}{W_s}{h_{kj}} + v_{left}^{\rm{T}}{h_{ik}} + v_{right}^{\rm{T}}{h_{kj}}\]</p><p><strong>结构化label损失</strong><br>对于两个label集合，定义它们之间的结构化Hamming损失为：<br>\[\left| { {l_1}\backslash {l_2}} \right| + \left| { {l_2}\backslash {l_1}} \right|\]<br>这个loss可以被用在之前的训练过程中。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>具体代码细节以及超参数设置请参看代码。</p><p>首先实验对不同的得分计算方式以及loss计算方式进行了对比，发现效果最好的chart模型用的是原始label，0-1标签损失，split得分用的是拼接得分，而top-down模型效果最好的是原始label，结构化label损失，split得分用的是左右span得分。</p><p>当然提升都不是很大，实验为了简便，用了最简单原始的设置：原始label，0-1标签损失，split得分用的是直接求和。</p><p>实验对比结果如下图所示：<br><img src="2.png" alt></p><p>在PTB数据集上，实验结果都要好于之前的所有parser，结果如下：<br><img src="3.png" alt></p><p>不仅结果更好，处理速度也有很大提升，chart模型一秒钟能处理20.3句话，top-down模型一秒钟能处理75.5句话。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>近些年来，效果最好的成分句法分析器基本都是基于转移系统的，还有诸如基于CRF之类的句法分析器。本文提出的基于span表示与得分，从而进行chart解析或者top-down解析的模型是当时结果最好的模型。而且该模型非常的简单，不再需要复杂的语法规则。模型仍然有很多改进之处，体现在span表示的计算方式，各种得分的计算方式。在下一篇博客中，我将为大家介绍一篇伯克利最新的成分句法分析论文，使用的是自注意力机制的编码器，F1值达到了惊人的95.15%。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ3006. 计算多项式的系数II</title>
      <link href="/2018/06/05/eoj3006/"/>
      <url>/2018/06/05/eoj3006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>题目链接：<a href="https://acm.ecnu.edu.cn/problem/3006/" target="_blank" rel="noopener">EOJ3006</a></strong></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><hr><p>给定一个多项式${(ax + by)^k}$，计算多项式展开后${x^n}{y^m}$项的系数，结果对1000000007取模。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr><p>由二项式定理可以得知，${x^n}{y^m}$项的系数就是<br>\[{a^n}{b^m}C_k^n\]<br>然后再对1000000007取模，其中${a^n}{b^m}$取模很方便，用快速幂就行了，剩下的问题就是如何求解<br>\[C_k^n\bmod p\]<br>这里由于$n,k$都不是很大，所以直接采用组合数计算公式求出答案，再进行取模就行了。</p><p>拓展一下，如果$n,k$都是小于$10^9$的，那么就不能直接计算了。</p><p>这时候要用到一个大组合数取模的定理，叫做lucas定理：</p><blockquote><p><strong>定理：</strong><br>对于组合数取模<br>\[C_n^m\bmod p\]<br>其中$p$是质数。<br>如果令$n=sp+q,m=tp+r. (q,r&lt;p)$<br>那么有<br>\[C_{sp + q}^{tp + r} \equiv C_s^tC_q^r\bmod p\]<br><strong>证明:</strong><br>\[\begin{array}{l}{(1 + x)^n} \equiv {(1 + x)^{sp + q}} \equiv {(1 + x)^{sp}}{(1 + x)^q}\\ \equiv {({(1 + x)^p})^s}{(1 + x)^q} \equiv {(1 + {x^p})^s}{(1 + x)^q}\\ \equiv \sum\limits_{i = 0}^s {C_s^i{x^{ip}}} \sum\limits_{j = 0}^q {C_q^j{x^j}} \bmod p\end{array}\]<br>其中$(1 + x)^n$中$x^{tp+r}$项的系数为$C_{sp + q}^{tp + r}$，而在同余号右边$x^{tp+r}$项的系数只能为$C_s^tC_q^r$。<br>因为假设<br>\[tp + r = ip + j\]<br>所以<br>\[(t - i)p = j - r\]<br>而<br>\[ - p &lt;  - r \le j - r \le q - r &lt; p - r \le p\]<br>所以只能是<br>\[t - i = 0,j - r = 0\]<br>所以<br>\[C_{sp + q}^{tp + r} \equiv C_s^tC_q^r\bmod p\]</p></blockquote><p>在代码实现中，应用lucas定理之后，将$C_n^m$替换为$C_s^t$继续调用lucas定理即可。递归终止条件是$t=0$。</p><p>最后计算$C_q^r\bmod p$时直接应用组合数定义即可：<br>\[C_q^r \equiv \frac{ {q!}}{ {r!(q - r)!}} \equiv q!{(r!(q - r)!)^{p - 2}} \equiv q!{(r!(q - r)!\bmod p)^{p - 2}}\bmod p\]<br>这里还用到了逆元：<br>\[{a^{ - 1}} \equiv {a^{p - 2}}\bmod p\]<br>证明详见我的另一篇博客：<a href="http://godweiyang.com/2018/05/14/concrete-math-12/">具体数学-第12课</a>中的费马小定理和欧拉定理。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">1000000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> LL MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>LL f<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>LL <span class="token function">QuickPow</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL n<span class="token punctuation">,</span> LL p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>        n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>LL <span class="token function">C</span><span class="token punctuation">(</span>LL n<span class="token punctuation">,</span> LL m<span class="token punctuation">,</span> LL p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL res <span class="token operator">=</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">QuickPow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">*</span> f<span class="token punctuation">[</span>n<span class="token operator">-</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> T<span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld%lld%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">QuickPow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">QuickPow</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> m<span class="token punctuation">,</span> MOD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">C</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> MOD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"case #%d:\n%lld\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> eoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ2854. 统计特定字串模式的个数</title>
      <link href="/2018/06/05/eoj2854/"/>
      <url>/2018/06/05/eoj2854/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>题目链接：<a href="https://acm.ecnu.edu.cn/problem/2854/" target="_blank" rel="noopener">EOJ2854</a></strong></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><hr><p>在0和1组成的长度为$n(1 \le n \le 31)$的字符串中，统计包含$m(1 \le m \le n)$个连续1子串的字符串的个数。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr><p>这题要用到的算法思想是动态规划。</p><p>首先令$f(n, m)$表示长度为$n(1 \le n \le 31)$的字符串中，包含$m(1 \le m \le n)$个连续1子串的字符串的个数。考虑最后一位，也就是第$n$位的取值，可以分为两种情况：</p><ul><li>如果第$n$位为0，那么只能在前面的$n-1$位里取长度为$m$的连续1子串，那么答案就是<br>\[f(n-1,m)\]</li><li>如果第$n$位为1，那么考虑两种情况。<br>一种是最后$m$位全为1，那么前面$n-m$位就可以任意取值，答案为<br>\[2^{n-m}\]<br>另一种情况是最后$m$位不全为1，也就是存在某一位为0，枚举最后一位0出现的位置，可能出现在第$n-1$位、第$n-2$位，一直到第$n-m+1$位，不管最后一个0出现在哪里，都要在之前的字符串中重新出现长度为$m$的连续1子串，所以答案是<br>\[\sum\limits_{n - m \le i \le n - 2} {f(i,m)} \]</li></ul><p>所以最终的答案就是<br>\[f(n,m) = {2^{n - m}} + \sum\limits_{n - m \le i \le n - 1} {f(i,m)} \]<br>进一步化简这个式子，用$n-1$替换$n$可以得到<br>\[f(n - 1,m) = {2^{n - m - 1}} + \sum\limits_{n - m - 1 \le i \le n - 2} {f(i,m)} \]<br>两式相减可以得到<br>\[f(n,m) = {2^{n - m - 1}} + 2f(n - 1,m) - f(n - m - 1,m)\]<br>边界条件为：</p><ul><li>当$n &lt; m$时，$f(n,m)=0$。</li><li>当$n = m$时，$f(n,m)=1$。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> m <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> eoj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第五章作业解答</title>
      <link href="/2018/06/01/concrete-math-hw5/"/>
      <url>/2018/06/01/concrete-math-hw5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><hr><p><strong>题目：</strong><br>通过上指标翻转计算出$\left( {\begin{array}{*{20}{c}}{ - 1}\\k\end{array}} \right)$。<br><strong>解答：</strong><br>如果$k \ge 0$，那么<br>\[<br>\left( {\begin{array}{*{20}{c}}{ - 1}\\k\end{array}} \right) = {( - 1)^k}\left( {\begin{array}{*{20}{c}}{k - ( - 1) - 1}\\k\end{array}} \right) = {( - 1)^k}\left( {\begin{array}{*{20}{c}}k\\k\end{array}} \right) = {( - 1)^k}<br>\]<br>如果$k&lt;0$，那么<br>\[<br>\left( {\begin{array}{*{20}{c}}{ - 1}\\k\end{array}} \right) = 0<br>\]</p><h1 id="46"><a href="#46" class="headerlink" title="46."></a>46.</h1><hr><p><strong>题目：</strong><br>求出下列和式的闭形式解，其中$n$是正整数。<br>\[<br>\sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}{4n - 2k - 1}\\{2n - k}\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {(2k - 1)(4n - 2k - 1)}}}<br>\]<br><strong>解答：</strong><br>由公式$(5.69)$可得<br>\[<br>{\mathcal B_{ - 1}}(z) = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { { {( - z)}^k}}}{ {1 - 2k}}}  = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {2k - 1}}{z^k}}<br>\]<br>\[<br>{\mathcal{B}_{ - 1}}( - z) = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { {z^k}}}{ {1 - 2k}}}  = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { - 1}}{ {2k - 1}}{z^k}}<br>\]<br>两式相乘得到${\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z)$，其中$z^{2n}$项的系数恰好就是<br>\[<br>\begin{array}{l}\sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {2k - 1}} \cdot \left( {\begin{array}{*{20}{c}}{2(2n - k) - 1}\\{2n - k}\end{array}} \right)\frac{ { - 1}}{ {2(2n - k) - 1}}} \\ =  - \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}{4n - 2k - 1}\\{2n - k}\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {(2k - 1)(4n - 2k - 1)}}} \end{array}<br>\]<br>所以题目所求的和式的闭形式解就是${\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z)$的$z^{2n}$项的系数的相反数。<br>由公式$(5.69)$还可以得到<br>\[<br>{\mathcal{B}_{ - 1}}(z) = \frac{ {1 + \sqrt {1 + 4z} }}{2}<br>\]<br>\[<br>{\mathcal{B}_{ - 1}}( - z) = \frac{ {1 + \sqrt {1 - 4z} }}{2}<br>\]<br>所以<br>\[<br>(2{\mathcal{B}_{ - 1}}(z) - 1)(2{\mathcal{B}_{ - 1}}( - z) - 1) = \sqrt {1 - 16{z^2}}<br>\]<br>展开化简可以得到<br>\[<br>{\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z) = \frac{1}{4}\sqrt {1 - 16{z^2}}  + \frac{1}{2}{\mathcal{B}_{ - 1}}(z) + \frac{1}{2}{\mathcal{B}_{ - 1}}( - z) - 1<br>\]<br>而<br>\[<br>\begin{array}{l}{(1 - 16{z^2})^{1/2}} = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{1/2}\\k\end{array}} \right){ {( - 16)}^k}{z^{2k}}} \\ = \sum\limits_k {\frac{1}{ {1 - 2k}}\left( {\begin{array}{*{20}{c}}{ - 1/2}\\k\end{array}} \right){ {( - 16)}^k}{z^{2k}}} \\ = \sum\limits_k {\frac{1}{ {1 - 2k}}\frac{ { { {( - 1)}^k}}}{ { {4^k}}}\left( {\begin{array}{*{20}{c}}{2k}\\k\end{array}} \right){ {( - 16)}^k}{z^{2k}}} \\ = \sum\limits_k {\frac{1}{ {1 - 2k}}\left( {\begin{array}{*{20}{c}}{2k}\\k\end{array}} \right){4^k}{z^{2k}}} \end{array}<br>\]<br>所以题目答案即${\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z)$的$z^{2n}$项的系数的相反数为<br>\[<br>\left( {\begin{array}{*{20}{c}}{2n}\\n\end{array}} \right)\frac{ { {4^{n - 1}}}}{ {2n - 1}} + \left( {\begin{array}{*{20}{c}}{4n - 1}\\{2n}\end{array}} \right)\frac{1}{ {4n - 1}}<br>\]</p><h1 id="64"><a href="#64" class="headerlink" title="64."></a>64.</h1><hr><p><strong>题目：</strong><br>计算<br>\[<br>\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)/\left\lceil {\frac{ {k + 1}}{2}} \right\rceil }<br>\]<br><strong>解答：</strong><br>\[<br>\begin{array}{l}\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)/\left\lceil {\frac{ {k + 1}}{2}} \right\rceil } \\ = \sum\limits_{k = 0}^n {\left( {\left( {\begin{array}{*{20}{c}}n\\{2k}\end{array}} \right) + \left( {\begin{array}{*{20}{c}}n\\{2k + 1}\end{array}} \right)} \right)\frac{1}{ {k + 1}}} \\ = \sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}{n + 1}\\{2k + 1}\end{array}} \right)\frac{1}{ {k + 1}}} \\ = \frac{2}{ {n + 2}}\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}{n + 2}\\{2k + 2}\end{array}} \right)} \\ = \frac{ { {2^{n + 2}} - 2}}{ {n + 2}}\end{array}<br>\]</p><h1 id="65"><a href="#65" class="headerlink" title="65."></a>65.</h1><hr><p><strong>题目：</strong><br>证明<br>\[<br>\sum\limits_k {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{ - k}}(k + 1)!}  = n<br>\]<br><strong>解答：</strong><br>等号左边可以写为<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{ - k}}(k + 1)!}<br>\]<br>替换$k$为$n-1-k$，得到<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{1 + k - n}}(n - k)!}<br>\]<br>即证<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{1 + k - n}}(n - k)!}  = n<br>\]<br>等式两边同时乘以$n^{n-1}$，即证<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^k}(n - k)!}  = {n^n}<br>\]<br>等式左边等于<br>\[<br>\begin{array}{l}\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^k}(n - k)!} \\ = (n - 1)!\sum\limits_{0 \le k \le n - 1} {\frac{ { {n^k}(n - k)}}{ {k!}}} \\ = (n - 1)!\sum\limits_{0 \le k \le n - 1} {\left( {\frac{ { {n^{k + 1}}}}{ {k!}} - \frac{ { {n^k}}}{ {(k - 1)!}}} \right)} \\ = (n - 1)!\frac{ { {n^n}}}{ {(n - 1)!}}\\ = {n^n}\end{array}<br>\]<br>得证。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第14课（牛顿级数和生成函数）</title>
      <link href="/2018/05/28/concrete-math-14/"/>
      <url>/2018/05/28/concrete-math-14/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="牛顿级数"><a href="#牛顿级数" class="headerlink" title="牛顿级数"></a>牛顿级数</h1><hr><p>多项式函数的一般表示形式为：<br>\[f(x) = {a_d}{x^d} + {a_{d - 1}}{x^{d - 1}} +  \cdots  + {a_1}{x^1} + {a_0}{x^0}\]<br>也可以将其表示为下降阶乘幂的形式：<br>\[f(x) = {b_d}{x^\underline{d}} + {b_{d - 1}}{x^{\underline{d - 1}}} +  \cdots  + {b_1}{x^\underline{1}} + {b_0}{x^\underline{0}}\]<br>这种表示的好处是，求差分更加方便：<br>\[\Delta (f(x)) = {b_d}d{x^{\underline{d - 1}}} + {b_{d - 1}}(d - 1){x^{\underline {d - 2} }} +  \cdots  + {b_1}{x^\underline{0}}\]<br>因为有<br>\[\left( {\begin{array}{*{20}{c}}x\\k\end{array}} \right) = \frac{ { {x^\underline{k}}}}{ {k!}}\]<br>所以多项式又可以表示为组合数的形式，也被叫做牛顿级数：<br>\[f(x) = {c_d}\left( {\begin{array}{*{20}{c}}x\\d\end{array}} \right) + {c_{d - 1}}\left( {\begin{array}{*{20}{c}}x\\{d - 1}\end{array}} \right) +  \cdots  + {c_1}\left( {\begin{array}{*{20}{c}}x\\1\end{array}} \right) + {c_0}\left( {\begin{array}{*{20}{c}}x\\0\end{array}} \right)\]<br>这种形式的差分也特别简单，因为有<br>\[\Delta \left( {\left( {\begin{array}{*{20}{c}}x\\k\end{array}} \right)} \right) = \left( {\begin{array}{*{20}{c}}x\\{k - 1}\end{array}} \right)\]<br>所以$n$阶差分可以写为：<br>\[{\Delta ^n}(f(x)) = {c_d}\left( {\begin{array}{*{20}{c}}x\\{d - n}\end{array}} \right) + {c_{d - 1}}\left( {\begin{array}{*{20}{c}}x\\{d - 1 - n}\end{array}} \right) +  \cdots  + {c_1}\left( {\begin{array}{*{20}{c}}x\\{1 - n}\end{array}} \right) + {c_0}\left( {\begin{array}{*{20}{c}}x\\{ - n}\end{array}} \right)\]<br>所以有：<br>\[{\Delta ^n}(f(0)) = \left\{ {\begin{array}{*{20}{c}}{ {c_n},n \le d}\\{0,n &gt; d}\end{array}} \right.\]<br>所以牛顿级数又可以写为：<br>\[f(x) = {\Delta ^d}(f(0))\left( {\begin{array}{*{20}{c}}x\\d\end{array}} \right) + {\Delta ^{d - 1}}(f(0))\left( {\begin{array}{*{20}{c}}x\\{d - 1}\end{array}} \right) +  \cdots  + \Delta (f(0))\left( {\begin{array}{*{20}{c}}x\\1\end{array}} \right) + f(0){c_0}\left( {\begin{array}{*{20}{c}}x\\0\end{array}} \right)\]<br>这个形式是不是很像泰勒展开？</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><hr><p>对于无限序列$\left\langle { {a_0},{a_1},{a_2}, \ldots } \right\rangle $，定义它的生成函数为：<br>\[A(z) = {a_0} + {a_1}z + {a_2}{z^2} +  \cdots  = \sum\limits_{k \ge 0} { {a_k}{z^k}} \]<br>定义一个函数用来表示$z^n$的系数：<br>\[[{z^n}]A(z) = {a_n}\]<br>两个生成函数相乘的结果为：<br>\[A(z)B(z) = \sum\limits_{k \ge 0} {\sum\limits_{i = 0}^k { {a_i}{b_{k - i}}} {z^k}} \]<br>考虑下面的二项展开：<br>\[{(1 + z)^r} = \sum\limits_{k \ge 0} {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right){z^k}} \]<br>可以发现这就是序列$\left\langle {\left( {\begin{array}{*{20}{c}}r\\0\end{array}} \right),\left( {\begin{array}{*{20}{c}}r\\1\end{array}} \right),\left( {\begin{array}{*{20}{c}}r\\2\end{array}} \right), \ldots } \right\rangle $的生成函数。<br>替换变量可以得到：<br>\[{(1 + z)^s} = \sum\limits_{k \ge 0} {\left( {\begin{array}{*{20}{c}}s\\k\end{array}} \right){z^k}} \]<br>两个式子相乘可以得到：<br>\[{(1 + z)^r}{(1 + z)^s} = {(1 + z)^{r + s}}\]<br>等式两边$z^n$的系数相等，于是：<br>\[\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}s\\{n - k}\end{array}} \right)}  = \left( {\begin{array}{*{20}{c}}{r + s}\\n\end{array}} \right)\]<br>这和上节课讲到的范德蒙德卷积公式类似！这里是用生成函数证出来的。</p><p>同理根据<br>\[{(1 + z)^r}{(1 - z)^r} = {(1 - {z^2})^r}\]<br>可以得到<br>\[\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}r\\{n - k}\end{array}} \right)} {( - 1)^k} = {( - 1)^{n/2}}\left( {\begin{array}{*{20}{c}}r\\{n/2}\end{array}} \right)[n是偶数]\]<br>下面是一个重要的生成函数：<br>\[\frac{1}{ {1 - z}} = 1 + z + {z^2} + {z^3} +  \cdots  = \sum\limits_{k \ge 0} { {z^k}} \]<br>它其实就是序列$\left\langle { {1},{1},{1}, \ldots } \right\rangle $的生成函数。</p><h1 id="生成函数应用"><a href="#生成函数应用" class="headerlink" title="生成函数应用"></a>生成函数应用</h1><hr><p>那么生成函数有什么应用呢？一个很重要的应用就是用来求解递归式。</p><p>例如大家很熟悉的斐波那契数列：<br>\[\begin{array}{l}{g_0} = 0;{g_1} = 1\\{g_n} = {g_{n - 1}} + {g_{n - 2}},n \ge 2\end{array}\]</p><p>首先为了统一表示，将递归式改写为如下形式：<br>\[{g_n} = {g_{n - 1}} + {g_{n - 2}} + [n = 1]\]<br>然后两边同时乘以$z^n$，得到：<br>\[{g_n}{z^n} = {g_{n - 1}}{z^n} + {g_{n - 2}}{z^n} + [n = 1]{z^n}\]<br>两边对指标$n$同时求和，可以得到：<br>\[G(z) = zG(z) + {z^2}G(z) + z\]<br>所以<br>\[G(z) = \frac{z}{ {1 - z - {z^2}}}\]<br>最后只要将$\frac{z}{ {1 - z - {z^2}}}$表示成多项式的形式就行了，$[{z^n}]\frac{z}{ {1 - z - {z^2}}}$就是斐波那契数列的通项公式了。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第13课（组合数各种性质）</title>
      <link href="/2018/05/27/concrete-math-13/"/>
      <url>/2018/05/27/concrete-math-13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>首先庆祝我自己顺利毕业了，忙完了毕业论文答辩一直在浪，所以上周的具体数学没有更新，现在补更一下，大家见谅。</p></blockquote><p>首先这节课讲的基本都是组合数的相关性质，而且特别多，所以我就不在这里详细证明了，如果你们对某一个性质感兴趣，可以自己证明去。</p><h1 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h1><hr><p>首先将组合数推广到负数域，也就是底数为负数的情况：<br>\[\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right) = {( - 1)^k}\left( {\begin{array}{*{20}{c}}{k - r - 1}\\k\end{array}} \right)\]<br>证明可以从下降阶乘幂的定义直接得到。</p><h1 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h1><hr><p>由于<br>\[\left( {\begin{array}{*{20}{c}}{m + n}\\m\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{m + n}\\n\end{array}} \right)\]<br>所以由性质1可得<br>\[{( - 1)^m}\left( {\begin{array}{*{20}{c}}{ - n - 1}\\m\end{array}} \right) = {( - 1)^n}\left( {\begin{array}{*{20}{c}}{ - m - 1}\\n\end{array}} \right)\]</p><h1 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h1><hr><p>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right){ {( - 1)}^k}}  = {( - 1)^m}\left( {\begin{array}{*{20}{c}}{r - 1}\\m\end{array}} \right)\]<br>这就说明了杨辉三角同一行的前面若干项交错和是可以求得的，但是它们的直接和是无法求出的。</p><h1 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h1><hr><p>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r}\\k\end{array}} \right){x^k}{y^{m - k}} = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{ - r}\\k\end{array}} \right){ {( - x)}^k}{ {(x + y)}^{m - k}}} } \]<br>证明可以通过令<br>\[{S_m} = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r}\\k\end{array}} \right){x^k}{y^{m - k}}}  = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r - 1}\\k\end{array}} \right){x^k}{y^{m - k}}}  + \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r - 1}\\{k - 1}\end{array}} \right){x^k}{y^{m - k}}} \]<br>将左边表示成递归式的形式，同理如果右边可以表示成相同的递归式，那么左右就相等了。</p><p>性质4看起来特别复杂，那么它有什么用呢？如果令$x$和$y$等于不同的值，那么就可以得到许多不同的恒等式。</p><h1 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h1><hr><p>令$x =  - 1,y = 1$可以得到<br>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r}\\k\end{array}} \right){ {( - 1)}^k}}  = \left( {\begin{array}{*{20}{c}}{ - r}\\m\end{array}} \right)\]<br>这其实就是性质3的特例。</p><h1 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h1><hr><p>令$x = y = 1,r = m + 1$可以得到<br>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{2m + 1}\\k\end{array}} \right)}  = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + k}\\k\end{array}} \right){2^{m - k}}} \]<br>左边就是杨辉三角一行中左边一半的和，所以可以得到<br>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + k}\\k\end{array}} \right){2^{ - k}}} {\rm{ = }}{2^m}\]</p><h1 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h1><hr><p>\[\left( {\begin{array}{*{20}{c}}r\\m\end{array}} \right)\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right) = \left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}{r - k}\\{m - k}\end{array}} \right)\]<br>这个公式可以形象理解为，从$r$个物品中取$m$个，再从这$m$个中取$k$个的方法数等于从$r$个物品中取$k$个，再从剩下的$r-k$个中取$m-k$个的方法数。证明的话直接用定义可证。</p><h1 id="性质8"><a href="#性质8" class="headerlink" title="性质8"></a>性质8</h1><hr><p>之前介绍了二项式系数，那么可以推广到任意$m$个未知数，它的展开式为<br>\[{({x_1} + {x_2} +  \cdots  + {x_m})^n} = \sum\limits_{\scriptstyle0 \le {a_1},{a_2}, \cdots ,{a_m} \le n\atop\scriptstyle{a_1} + {a_2} +  \cdots  + {a_m} = n} {\left( {\begin{array}{*{20}{c}}{ {a_1} + {a_2} +  \cdots  + {a_m}}\\{ {a_1},{a_2}, \cdots ,{a_m}}\end{array}} \right)} {x_1}^{ {a_1}}{x_2}^{ {a_2}} \cdots {x_m}^{ {a_m}}\]<br>其中<br>\[\left( {\begin{array}{*{20}{c}}{ {a_1} + {a_2} +  \cdots  + {a_m}}\\{ {a_1},{a_2}, \cdots ,{a_m}}\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{ {a_1} + {a_2} +  \cdots  + {a_m}}\\{ {a_2} +  \cdots  + {a_m}}\end{array}} \right) \cdots \left( {\begin{array}{*{20}{c}}{ {a_{m - 1}} + {a_m}}\\{ {a_m}}\end{array}} \right)\]</p><h1 id="性质9"><a href="#性质9" class="headerlink" title="性质9"></a>性质9</h1><hr><p>范德蒙德卷积式：<br>\[\sum\limits_k {\left( {\begin{array}{*{20}{c}}r\\{m + k}\end{array}} \right)} \left( {\begin{array}{*{20}{c}}s\\{n - k}\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{r + s}\\{m + n}\end{array}} \right)\]<br>很多公式都可以通过替换其中的一些变量推导得到：<br>\[\begin{array}{l}\sum\limits_k {\left( {\begin{array}{*{20}{c}}l\\{m + k}\end{array}} \right)} \left( {\begin{array}{*{20}{c}}s\\{n + k}\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{l + s}\\{l - m + n}\end{array}} \right)\\\sum\limits_k {\left( {\begin{array}{*{20}{c}}l\\{m + k}\end{array}} \right)} \left( {\begin{array}{*{20}{c}}{s + k}\\n\end{array}} \right){( - 1)^k} = {( - 1)^{l + m}}\left( {\begin{array}{*{20}{c}}{s - m}\\{n - l}\end{array}} \right)\\\sum\limits_{k \le l} {\left( {\begin{array}{*{20}{c}}{l - k}\\m\end{array}} \right)} \left( {\begin{array}{*{20}{c}}s\\{k - n}\end{array}} \right){( - 1)^k} = {( - 1)^{l + m}}\left( {\begin{array}{*{20}{c}}{s - m - 1}\\{l - m - n}\end{array}} \right)\\\sum\limits_{0 \le k \le l} {\left( {\begin{array}{*{20}{c}}{l - k}\\m\end{array}} \right)} \left( {\begin{array}{*{20}{c}}{q + k}\\n\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{l + q + 1}\\{m + n + 1}\end{array}} \right)\end{array}\]</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>最后详细求解一道组合题，其他的题目就不介绍了，可以去看具体数学英文版第173页。</p><p>求下面式子的闭形式解：<br>\[\sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)} ,n \ge m \ge 0\]</p><p>根据性质7，可以得到<br>\[\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{n - k}\\{m - k}\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\m\end{array}} \right)\]<br>所以<br>\[\sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)}  = \sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}{n - k}\\{m - k}\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\m\end{array}} \right)} \]<br>而<br>\[\begin{array}{l}\sum\limits_{k \ge 0} {\left( {\begin{array}{*{20}{c}}{n - k}\\{m - k}\end{array}} \right)}  = \sum\limits_{m - k \ge 0} {\left( {\begin{array}{*{20}{c}}{n - (m - k)}\\{m - (m - k)}\end{array}} \right)} \\ = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{n - m + k}\\k\end{array}} \right)} \\ = \left( {\begin{array}{*{20}{c}}{(n - m) + m + 1}\\m\end{array}} \right)\\ = \left( {\begin{array}{*{20}{c}}{n + 1}\\m\end{array}} \right)\end{array}\]<br>所以<br>\[\sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)}  = \left( {\begin{array}{*{20}{c}}{n + 1}\\m\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\m\end{array}} \right) = \frac{ {n + 1}}{ {n + 1 - m}}\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第12课（数论进阶与组合数入门）</title>
      <link href="/2018/05/14/concrete-math-12/"/>
      <url>/2018/05/14/concrete-math-12/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>这节课内容太多了，再加上感冒身体不舒服，下面的定理就不一一证明了，大家可以自行练习。以后有空我会补上的！</p></blockquote><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>首先接着上节课同余继续讲，在<a href="http://godweiyang.com/2018/04/23/concrete-math-9/">第三章例题2</a>中，我们遗留了一个问题：对于如下序列<br>\[0\bmod m,n\bmod m,2n\bmod m, \ldots ,(m - 1)n\bmod m\]<br>它的值就是<br>\[0,d,2d, \ldots ,(m/d - 1)d\]<br>的某个排列，并且重复了$d$次。其中$d = gcd(m, n)$</p><p>首先我们有如下同余式：<br>\[jn \equiv kn(\bmod m) \Leftrightarrow j(n/d) \equiv k(n/d)(\bmod m/d)\]<br>这就可以看出该序列的确是重复出现了$d$次，那么剩下的问题就是证明这$m/d$个数恰好就是<br>\[\{ 0,d,2d, \ldots ,m - d\} \]<br>的某个排列。<br>令$m = m’d,n = n’d$，所以有<br>\[kn\bmod m = d(kn’\bmod m’)\]<br>所以我们只考虑$m \bot n$的情形，在此情形下，我们可以得到<br>\[jn \equiv kn(\bmod m) \Leftrightarrow j \equiv k(\bmod m)\]<br>由此可以看出，这$m-1$个数一定就是<br>\[\{ 0,1,2, \ldots ,m - 1\} \]<br>至此得证。</p><p>下面介绍几个著名的数论定理。</p><h1 id="费马最后定理"><a href="#费马最后定理" class="headerlink" title="费马最后定理"></a>费马最后定理</h1><hr><p>对于所有的正整数$a,b,c,n&gt;2$，有<br>\[{a^n} + {b^n} \ne {c^n}\]</p><h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><hr><p>如果$n \bot p$，那么有<br>\[{n^{p - 1}} \equiv 1(\bmod p)\]</p><p>证明也很好证。</p><p>之前证过了，序列<br>\[n\bmod p,2n\bmod p, \ldots ,(p - 1)n\bmod p\]<br>结果就是<br>\[1,2, \ldots ,p-1\]<br>的某个排列，所以有<br>\[n \cdot (2n) \cdot  \ldots  \cdot ((p - 1)n) \equiv (p - 1)!\]<br>所以<br>\[(p - 1)!{n^{p - 1}} \equiv (p - 1)!(\bmod p)\]<br>所以<br>\[{n^{p - 1}} \equiv 1(\bmod p)\]</p><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><hr><p>定义$\varphi (m)$为小于$m$且与其互素的正整数个数。</p><p>所以我们有欧拉定理<br>\[{n^{\varphi (m)}} \equiv 1(\bmod m)\]<br>其中$n \bot m$，可以发现，当$m$是素数时，欧拉定理就是费马小定理，所以欧拉定理是费马小定理的推广形式。</p><p>欧拉定理有很多有趣的性质，这里就不一一介绍了，详情见<a href="https://blog.csdn.net/howe_young/article/details/50282775" target="_blank" rel="noopener">博客地址</a>。</p><h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><hr><p>定义莫比乌斯函数$\mu (m)$为<br>\[\sum\limits_{d|m} {\mu (d)}  = [m = 1]\]</p><p>这个定义看起来很奇怪是不是？其实这是一个递归定义，可以递归地计算得到所有的值。</p><p>这个函数有什么用呢？主要用来进行莫比乌斯反演：<br>\[g(m) = \sum\limits_{d|m} {f(d)}  \Leftrightarrow f(m) = \sum\limits_{d|m} {\mu (d)g(\frac{m}{d})} \]</p><p>详细的性质及应用也不介绍了，给大家推荐一个牛逼的博客<a href="https://blog.csdn.net/acdreamers/article/details/8542292" target="_blank" rel="noopener">博客地址</a>，我当时学ACM的时候这部分都是看着他的学的。</p><h1 id="组合数入门"><a href="#组合数入门" class="headerlink" title="组合数入门"></a>组合数入门</h1><hr><p>定义组合数$\left( {\begin{array}{c}n\\k\end{array}} \right)$为从$n$个物品中取出$k$个物品的方法数，具体计算为<br>\[\left( {\begin{array}{c}n\\k\end{array}} \right) = \frac{ {n(n - 1) \ldots (n - k + 1)}}{ {k(k - 1) \ldots 1}}\]</p><p>推广到实数领域，定义<br>\[\left( {\begin{array}{c}r\\k\end{array}} \right) = \left\{ {\begin{array}{c}{\frac{ {r(r - 1) \ldots (r - k + 1)}}{ {k(k - 1) \ldots 1}} = \frac{ { {r^{\underline{k}}}}}{ {k!}},k \ge 0}\\{0,k &lt; 0}\end{array}} \right.\]</p><p>下面介绍一些组合数性质。</p><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>\[\left( {\begin{array}{c}n\\k\end{array}} \right) = \left( {\begin{array}{c}n\\{n - k}\end{array}} \right),n,k \in \mathbb{Z},n \ge 0\]<br>这里为什么要限定$n \ge 0$呢？举个例子，如果$n = -1$，那么有<br>\[\left( {\begin{array}{c}{ - 1}\\k\end{array}} \right) \ne \left( {\begin{array}{c}{ - 1}\\{ - 1 - k}\end{array}} \right)\]<br>因为左边等于${( - 1)^k}$，而右边等于${( - 1)^{-1-k}}$。</p><h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>\[\left( {\begin{array}{c}r\\k\end{array}} \right) = \frac{r}{k}\left( {\begin{array}{c}{r - 1}\\{k - 1}\end{array}} \right)\]</p><h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>\[(r - k)\left( {\begin{array}{c}r\\k\end{array}} \right) = r\left( {\begin{array}{c}{r - 1}\\k\end{array}} \right)\]</p><h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>\[\left( {\begin{array}{c}r\\k\end{array}} \right) = \left( {\begin{array}{c}{r - 1}\\k\end{array}} \right) + \left( {\begin{array}{c}{r - 1}\\{k - 1}\end{array}} \right)\]<br>这条性质可以通过性质3和性质4两边分别相加得到。</p><h2 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h2><p>\[\sum\limits_{k \le n} {\left( {\begin{array}{c}{r + k}\\k\end{array}} \right)}  = \left( {\begin{array}{c}{r + n + 1}\\n\end{array}} \right)\]</p><h2 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h2><p>\[\sum\limits_{0 \le k \le n} {\left( {\begin{array}{c}k\\m\end{array}} \right)}  = \left( {\begin{array}{c}{n + 1}\\{m + 1}\end{array}} \right)\]</p><h2 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h2><p>微分形式：<br>\[\Delta \left( {\left( {\begin{array}{c}x\\m\end{array}} \right)} \right) = \left( {\begin{array}{c}{x + 1}\\m\end{array}} \right) - \left( {\begin{array}{c}x\\m\end{array}} \right) = \left( {\begin{array}{c}x\\{m - 1}\end{array}} \right)\]<br>\[\sum {\left( {\begin{array}{c}x\\m\end{array}} \right)\delta x = } \left( {\begin{array}{c}x\\{m + 1}\end{array}} \right) + C\]</p><h1 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h1><hr><p>\[{(x + y)^r} = \sum\limits_k {\left( {\begin{array}{c}r\\k\end{array}} \right)} {x^k}{y^{r - k}},r \in \mathbb{Z}\]</p><p>二项式系数也有很多有趣的性质。</p><p>\[{2^n} = \left( {\begin{array}{c}n\\0\end{array}} \right) + \left( {\begin{array}{c}n\\1\end{array}} \right) +  \cdots  + \left( {\begin{array}{c}n\\n\end{array}} \right)\]</p><p>\[{0^n} = \left( {\begin{array}{c}n\\0\end{array}} \right) - \left( {\begin{array}{c}n\\1\end{array}} \right) +  \cdots  + {( - 1)^n}\left( {\begin{array}{c}n\\n\end{array}} \right)\]<br>即奇数项系数和等于偶数项系数和。</p><p>推广到实数域：<br>\[{(1 + z)^r} = \sum\limits_k {\left( {\begin{array}{c}r\\k\end{array}} \right){z^k}} ,\left| z \right| &lt; 1,r \in \mathbb{R}\]<br>可以通过泰勒展开证明。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第11课（Stern-Brocot树和同余关系）</title>
      <link href="/2018/05/07/concrete-math-11/"/>
      <url>/2018/05/07/concrete-math-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="Stern-Brocot树"><a href="#Stern-Brocot树" class="headerlink" title="Stern-Brocot树"></a>Stern-Brocot树</h1><hr><p>我们接着上节课讲到的Stern-Brocot树继续往下讲。</p><h2 id="LR序列表示"><a href="#LR序列表示" class="headerlink" title="LR序列表示"></a>LR序列表示</h2><p>对于任意分数$\frac{a}{b}$，我们从$\frac{1}{1}$开始走到它所在的结点。如果向左走就记为L，向右走记为R，最终可以得到一个L和R的序列。例如$\frac{5}{7}$的表示就是LRRL。</p><p>这种表示产生了两个问题：</p><ol><li>给定满足正整数$m$和$n$互素的分数$\frac{m}{n}$，它所对应的LR序列是什么？</li><li>给定LR序列，它所表示的分数是什么？</li></ol><p>第二个问题看起来更好解决一点，我们先解决第二个问题。<br>我们定义<br>\[f(S) = 与S对应的分数\]<br>例如<br>\[f(LRRL) = \frac{5}{7}\]<br>如果用代码实现的话，对于每个L或者R，如果是L，那么就把右边界设为中间值，如果是R，那么就把左边界设为中间值。</p><p>但是如何用数学式子来表达这一过程呢？</p><p>我们建立一个2阶方阵：<br>\[M(S) = \left( {\begin{array}{*{20}{c}}n&amp;{n’}\\m&amp;{m’}\end{array}} \right)\]<br>表示$f(S)$的两个祖先分数$\frac{m}{n}$和$\frac{m’}{n’}$</p><p>那么初始状态就可以表示为<br>\[M(I) = \left( {\begin{array}{*{20}{c}}1&amp;0\\0&amp;1\end{array}} \right)\]</p><p>如果遇到了向左符号L，那么</p><p>\[M(SL) = \left( {\begin{array}{}n&amp;{n + n’}\\m&amp;{m + m’}\end{array}} \right) = M(S)\left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right)\]</p><p>如果遇到了向右符号R，那么<br>\[M(SL) = \left( {\begin{array}{}{n + n’}&amp;{n’}\\{m + m’}&amp;{m’}\end{array}} \right) = M(S)\left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\]<br>所以我们将L和R定义成2阶方阵就行了：<br>\[L = \left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right),R = \left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\]<br>所以<br>\[\begin{array}{l}M(LRRL) = LRRL\\ = \left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right)\left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right)\\ = \left( {\begin{array}{}3&amp;4\\2&amp;3\end{array}} \right)\end{array}\]<br>所以LRRL表示的分数为<br>\[\frac{ {2 + 3}}{ {3 + 4}} = \frac{5}{7}\]<br>那么第一个问题如何解决呢？<br>同样可以用类似二叉搜索的方法来求出LR序列，也可以用矩阵的方法来求解，根据上面的L和R的方阵，可以发现：<br>\[f(RS) = f(S) + 1\]<br>对于L也有类似的性质，所以我们得到了如下的求解算法：</p><ul><li>如果$m &gt; n$，输出R，令$m = m - n$。</li><li>如果$m &lt; n$，输出L，令$n = n - m$。</li></ul><h2 id="无理数近似表示"><a href="#无理数近似表示" class="headerlink" title="无理数近似表示"></a>无理数近似表示</h2><p>虽然说无理数不在Stern-Brocot树中，但是我们可以找到无限逼近它的分数。</p><p>方法仍然使用二叉搜索，不同的是，搜索过程不会终止，除非得到了我们想要的精度或者我们人为终止。</p><p>值得一提的是，无理数$e$的LR表示很有规律性：<br>\[e = R{L^0}RL{R^2}LR{L^4}RL{R^6}LR{L^8}RL{R^{10}}LR{L^{12}} \cdots \]</p><p>最后值得一提的是，欧几里得算法和有理数的Stern-Brocot树表示有密切的关系。给定$\alpha  = \frac{m}{n}$，根据之前的算法，它的LR表达式首先是$\left\lfloor {m/n} \right\rfloor $个R，然后是$\left\lfloor {n/(m\bmod n)} \right\rfloor $个L，依次下去，这些系数恰好就是求最大公因数的时候用到的系数。</p><h1 id="同余关系"><a href="#同余关系" class="headerlink" title="同余关系"></a>同余关系</h1><hr><p>同余定义为：<br>\[a \equiv b(\bmod m) \Leftrightarrow a\bmod m = b\bmod m\]<br>读作“a关于模m与b同余”，我们只讨论都是整数的情况。</p><p>同样可以写作：<br>\[a \equiv b(\bmod m) \Leftrightarrow a - b是m的倍数\]</p><p>同余是等价关系，满足自反律、对称律、传递律，即：<br>\[\begin{array}{l}a \equiv a\\a \equiv b \Rightarrow b \equiv a\\a \equiv b \equiv c \Rightarrow a \equiv c\end{array}\]<br>如果我们对同余两边的元素加减乘，同余仍然满足：<br>\[\begin{array}{l}a \equiv b,c \equiv d \Rightarrow a + c \equiv b + d(\bmod m)\\a \equiv b,c \equiv d \Rightarrow a - c \equiv b - d(\bmod m)\\a \equiv b,c \equiv d \Rightarrow ac \equiv bd(\bmod m)\end{array}\]<br>因此可以得到<br>\[a \equiv b \Rightarrow {a^n} \equiv {b^n}(\bmod m)\]</p><p>然而对于除法同余并不总是成立，一些特殊条件下可能成立。<br>如果<br>\[ad \equiv bd(\bmod m)\]<br>当$d,m$互素的时候，我们可以得到<br>\[a \equiv b(\bmod m)\]<br>同样<br>\[ad \equiv bd(\bmod md) \Leftrightarrow a \equiv b(\bmod m)\]<br>更一般的情况下，我们有<br>\[ad \equiv bd(\bmod m) \Leftrightarrow a \equiv b(\bmod \frac{m}{ {\gcd (d,m)}})\]<br>还有许多性质我就直接列举了，不做证明了，证明很简单：<br>\[\begin{array}{l}a \equiv b(\bmod md) \Rightarrow a \equiv b(\bmod m)\\a \equiv b(\bmod m),a \equiv b(\bmod n) \Leftrightarrow a \equiv b(\bmod lcm(m,n))\\a \equiv b(\bmod mn),m \bot n \Leftrightarrow a \equiv b(\bmod m),a \equiv b(\bmod n)\\a \equiv b(\bmod m) \Leftrightarrow \forall p,a \equiv b(\bmod {p^{ {m_p}}})\end{array}\]<br>其中$m = \prod\nolimits_p { {p^{ {m_p}}}} $是$m$的素因子分解。<br>第三条性质是中国剩余定理的特例，今后我们再做证明。</p><h1 id="独立剩余"><a href="#独立剩余" class="headerlink" title="独立剩余"></a>独立剩余</h1><hr><p>同余的应用之一就是剩余系，将整数$x$表示为一组互素的模的剩余（余数）序列：<br>\[(x\bmod {m_1}, \ldots ,x\bmod {m_r})\]<br>其中模$m$两两互素。</p><p>通过这个剩余序列可以确定出$x$的通解，其实可以看出来，这就是中国剩余定理的另一种表示形式。</p><p>这种表示形式有很多好处，比如可以直接在每个维度上面进行加减乘法。例如对于$m_1 = 3, m_2 = 5$的剩余系，有如下表示：<br>\[13 = (1,3),7 = (1,2)\]<br>那么$13 \cdot 7\,\bmod \,15$就可以这样计算：<br>\[(1 \cdot 1\bmod 3,3 \cdot 2\bmod 5) = (1,1)\]<br>所以<br>\[13 \cdot 7\bmod 15 = 1 \cdot 1\bmod 15 = 1\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第10课（素数和阶乘的有趣性质）</title>
      <link href="/2018/04/28/concrete-math-10/"/>
      <url>/2018/04/28/concrete-math-10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="欧几里得数"><a href="#欧几里得数" class="headerlink" title="欧几里得数"></a>欧几里得数</h1><hr><p>首先我们来证明一下，素数有无穷多个。</p><p>假设素数只有$k$个，分别为$2,3, \ldots ,{P_k}$，那么我们构造下面的数字：<br>\[M = 2 \cdot 3 \cdot  \ldots  \cdot {P_k} + 1\]<br>显然$M$无法被$2,3, \ldots ,{P_k}$中的任意一个整除，那么要么$M$可以被其他的素数整除，要么$M$自己就是一个素数。所以素数有无穷多个。</p><p>下面我们来定义欧几里得数，是用递归形式来定义的：<br>\[{e_n} = {e_0}{e_1}{e_2} \ldots {e_{n - 1}} + 1\]</p><p>那么欧几里得数是否是素数呢？当然不是的，${e_5} = 1807 = 13 \cdot 139$。</p><p>但是欧几里得数还是有很多奇妙的性质。</p><p><strong>性质1</strong><br>\[\gcd ({e_m},{e_n}) = 1,m \ne n\]<br><strong>证明：</strong><br>假设$n &gt; m$，那么有<br>\[\gcd ({e_m},{e_n}) = \gcd ({e_m},{e_0}{e_1} \ldots {e_m}{e_{m + 1}} \ldots {e_{n - 1}} + 1) = \gcd (1,{e_m}) = 1\]<br><strong>性质2</strong><br>如果令$q_j$等于$e_j$的最小素因子，那么${q_1},{q_2}, \ldots $就是一个不重复的素数序列，这也证明了素数有无穷多个。<br><strong>性质3</strong><br>\[{e_n} = {e_0}{e_1}{e_2} \ldots {e_{n - 1}} + 1 = ({e_{n - 1}} - 1){e_{n - 1}} + 1 = e_{n - 1}^2 - {e_{n - 1}} + 1\]<br>在后面的章节可以证明：<br>\[{e_n} = \left\lfloor { {E^{ {2^n}}} + \frac{1}{2}} \right\rfloor \]<br>其中$E \approx 1.264$</p><p>下面我们稍稍探究一下下面这个数的性质：<br>\[{2^p} - 1\]<br>这个数如果是素数，那么就被叫做<strong>梅森素数</strong>，那么它在什么情况下是素数呢？</p><p>首先$p$不能是合数，因为有<br>\[{2^{km}} - 1 = ({2^m} - 1)({2^{m(k - 1)}} + {2^{m(k - 2)}} +  \cdots  + 1)\]<br>但是如果$p$是素数，这个数也不一定是素数，2017年年末美国一个电气工程师发现了人类历史上最大的梅森素数——${2^{77232917}} - 1$。</p><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><p>阶乘定义如下：<br>\[n! = 1 \cdot 2 \cdot  \ldots  \cdot n = \prod\limits_{k = 1}^n k \]<br>所以有<br>\[n{!^2} = (1 \cdot 2 \cdot  \ldots  \cdot n)(n \cdot  \ldots  \cdot 2 \cdot 1) = \prod\limits_{k = 1}^n {k(n + 1 - k)} \]<br>由基本不等式可以得到<br>\[n \le k(n + 1 - k) \le \frac{ { { {(n + 1)}^2}}}{4}\]<br>所以<br>\[\prod\limits_{k = 1}^n n  \le n{!^2} \le \prod\limits_{k = 1}^n {\frac{ { { {(n + 1)}^2}}}{4}} \]<br>所以<br>\[{n^{n/2}} \le n! \le \frac{ { { {(n + 1)}^n}}}{ { {2^n}}}\]<br>这里得到了阶乘的一个粗略范围，在后面章节中，我们会得到阶乘的一个更精确的表达式：<br>\[n! \sim \sqrt {2\pi n} {\left( {\frac{n}{e}} \right)^n}\]<br>这就是斯特林数，搞ACM还是很有用的。</p><p>下面我们来探讨$n!$中含有多少个素因子$p$，个数记为${\varepsilon _p}(n!)$。</p><p>从特殊情况讨论起，当$p = 2$的时候，我们首先看$n!$含有多少个2，然后看有多少个4，再看有多少个8，依次下去，所以答案为：<br>\[{\varepsilon _2}(n!) = \sum\limits_{k \ge 1} {\left\lfloor {\frac{n}{ { {2^k}}}} \right\rfloor } \]<br>可以看出，这个答案不就是$n$的二进制表示不停右移1位，然后相加吗？所以又可以写成：<br>\[{\varepsilon _2}(n!) = n - {\nu _2}(n)\]<br>其中${\nu _2}(n)$表示$n$的二进制表示中1的个数。</p><p>推广到一般情况：<br>\[{\varepsilon _p}(n!) = \sum\limits_{k \ge 1} {\left\lfloor {\frac{n}{ { {p^k}}}} \right\rfloor } \]<br>放缩一下有：<br>\[{\varepsilon _p}(n!) = \sum\limits_{k \ge 1} {\left\lfloor {\frac{n}{ { {p^k}}}} \right\rfloor }  &lt; \sum\limits_{k \ge 1} {\frac{n}{ { {p^k}}} = \frac{n}{ {p - 1}}} \]</p><p>如果我们令$p = 2$和$p = 3$可以发现：<br>\[{\varepsilon _2}(n!) \approx 2{\varepsilon _3}(n!)\]<br>但是这个式子在什么情况下相等呢？这仍然是一个未解之谜。</p><p>所以$p$对$n!$的贡献度满足如下式子：<br>\[{p^{ {\varepsilon _p}(n!)}} &lt; {p^{\frac{n}{ {p - 1}}}}\]<br>又因为$p \le 2^{p - 1}$，所以<br>\[{p^{ {\varepsilon _p}(n!)}} &lt; {p^{\frac{n}{ {p - 1}}}} \le {2^n}\]<br>假设素数只有$k$个，分别为$2,3, \ldots ,{P_k}$，那么有<br>\[n! &lt; {({2^n})^k}\]<br>如果我们令$n = {2^{2k}}$，那么<br>\[n! &lt; {({2^n})^k} = {2^{k{2^{2k}}}} = {2^{2k{2^{2k}}/2}} = {n^{n/2}}\]<br>这与我们之前推过的不等式矛盾！所以一定有无穷个素数。</p><p>设小于等于$n$的素数个数为$\pi (n)$，所以<br>\[n! &lt; {2^{n\pi (n)}}\]<br>根据斯特林数公式，我们可以得到<br>\[\pi (n) &gt; \lg (n/e)\]</p><h1 id="互素"><a href="#互素" class="headerlink" title="互素"></a>互素</h1><hr><p><strong>定义</strong><br>$m$和$n$互素定义为$gcd(m, n) = 1$，记作$m \bot n$。</p><p>互素也有很多性质。</p><p><strong>性质1</strong><br>\[m/\gcd (m,n) \bot n/\gcd (m,n)\]<br><strong>性质2</strong><br>\[m \bot n \Leftrightarrow \min ({m_p},{n_p}) = 0\]<br>其中${m_p},{n_p}$就是两个数的素数指数表示法，详细定义见上一节课。<br>或者可以表示为<br>\[m \bot n \Leftrightarrow {m_p}{n_p} = 0\]<br><strong>性质3</strong><br>\[k \bot m,k \bot n \Leftrightarrow k \bot mn\]</p><h1 id="Stern-Brocot树"><a href="#Stern-Brocot树" class="headerlink" title="Stern-Brocot树"></a>Stern-Brocot树</h1><hr><p><img src="1.png" alt><br>如上图所示，Stern-Brocot树就是0到1之间的分数生成的一棵二叉树。</p><p>初始时只有$\frac{0}{1},\frac{1}{0}$两个数，第一轮将两者分母相加，分子也相加作为新的分数的分母分子。第二轮再对相邻的两个分数做相同的操作，生成新的分数序列。不断生成下去，得到了上图的二叉树。</p><p>Stern-Brocot树有下面四个性质：</p><ol><li>0到1之间的所有有理数都出现在了这棵树中。</li><li>每个分数仅出现了1次。</li><li>每个分数都是不可约分的，即分子分母互素。</li><li>生成的序列是单调递增的。</li></ol><p>下面我们来一个一个证明。</p><p><strong>引理</strong><br>对于相邻的两个分数$\frac{m}{n},\frac{ {m’}}{ {n’}}$，满足：<br>\[m’n - mn’ = 1\]<br><strong>证明</strong><br>用数学归纳法证明。</p><p>性质4就是证明：<br>\[\frac{m}{n} &lt; \frac{ {m + m’}}{ {n + n’}} &lt; \frac{ {m’}}{ {n’}}\]<br>结论是很显然的，这样性质2同时就成立了。</p><p>性质1的话，对于任意有理数$\frac{a}{b}$，假设$\frac{m}{n} &lt; \frac{a}{b} &lt; \frac{ {m’}}{ {n’}}$。<br>我们采用如下策略生成$\frac{a}{b}$。</p><ul><li>如果$\frac{ {m + m’}}{ {n + n’}} = \frac{a}{b}$，那么成功。</li><li>如果$\frac{ {m + m’}}{ {n + n’}} &lt; \frac{a}{b}$，那么令$m = m + m’,n = n + n’$。</li><li>如果$\frac{ {m + m’}}{ {n + n’}} &gt; \frac{a}{b}$，那么令$m’ = m + m’,n’ = n + n’$。</li></ul><p>那么有<br>\[an - bm \ge 1,bm’ - an’ \ge 1\]<br>所以<br>\[(m’ + n’)(an - bm) + (m + n)(bm’ - an’) \ge m’ + n’ + m + n\]<br>而左边式子就等于$a + b$，所以<br>\[a + b \ge m’ + n’ + m + n\]<br>因为$m,n,m’,n’$都在不断增加，所以最多$a + b$轮就能生成$\frac{a}{b}$。</p><p>性质3的话，同样用数学归纳法。通过引理可以得到<br>\[(m + m’)n - m(n + n’) = 1\]<br>由扩展欧几里得定理可以得到$m + m’$与$n + n’$互素。</p><p><strong>Farey序列</strong><br>我们引申出Farey序列的概念，定义如下：<br>\[{F_n} = \{ a/b|\gcd (a,b) = 1,0 \le a,b \le n,0 \le a/b \le 1\} \]<br>关于它的更多性质，留到下一节课继续。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-best Iterative Viterbi Parsing</title>
      <link href="/2018/04/24/ivp-eacl17/"/>
      <url>/2018/04/24/ivp-eacl17/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>本文链接：<a href="https://www.aclweb.org/anthology/E/E17/E17-2049.pdf" target="_blank" rel="noopener">EACL17</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>CKY算法或维特比inside算法是成分句法分析的主要方法之一，但是当产生式数量特别大之后，时间复杂度也线性增大。可行的一种方法是剪枝，但是剪枝会造成准确率的下降。所以本文就提出了一种迭代的维特比句法分析算法，通过剪枝去除掉没用的边。实验表明，时间上加快了一个数量级，但是本文并没有说准确率怎么样。。。</p><p>本文用到的inside和outside算法之前已经介绍过了，详见<a href="http://godweiyang.com/2018/04/19/inside-outside/">PCFG中inside和outside算法详解</a>。</p><h1 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h1><hr><h2 id="分层聚类"><a href="#分层聚类" class="headerlink" title="分层聚类"></a>分层聚类</h2><p>首先提出分层聚类的概念。</p><p><img src="1.jpg" alt><br>如上图所示，原来的类别标记有很多，将他们聚类成几个小类，再将这几个小类聚成更小的类，依次下去，最后类别标记会少很多很多。<br><img src="2.jpg" alt><br>以上图为例，${X_1}{\rm{ = \{ }}A,B{\rm{\} ,}}{X_2}{\rm{ = \{ }}C,D{\rm{\} }}$，聚类之后的分析表为b图，原始的分析表为a图，聚类之后的表（下面叫<strong>粗表</strong>）b唯一对应了聚类之前的表（下面叫<strong>原始表</strong>）a，而反过来原始表a能对应多种不同的粗表b。</p><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>我们将类别分为$m + 1$层，分别表示为${N_0} \ldots {N_m}$，那么第$m$层的类别集合$N_m$就是原始的类别集合，而$0$到$m - 1$层的类别就称之为<strong>收缩符号</strong>。</p><p>对于$0 \le i \le j \le m$，我们定义${\pi _{i \to j}}:{N_i} \mapsto \Im ({N_j})$，其中$\Im ({N_j})$就是$N_j$的一个子集。该式将$N_i$中的一个类别$X_i$映射为了$N_j$中所有聚类为$X_i$的类别集合。</p><p>举个例子吧，在第一张图中，${\pi _{1 \to 2}}(ADJ\_) = \{ JJ,JJR,JJS\} $。如果$i = j$，那么${\pi _{i \to j}}(A) = \{ A\} $。</p><p>那么对于${X_i} \in {N_i},{X_j} \in {N_j},{X_k} \in {N_k}$，我们定义产生式${X_i} \to {X_j}{X_k}$的概率为：<br>\[\log q({X_i} \to {X_j}{X_k}) = \mathop {\max }\limits_{\scriptstyle A \in {\pi _{i \to m}}({X_i})\atop{\scriptstyle B \in {\pi _{j \to m}}({X_j})\atop\scriptstyle C \in {\pi _{k \to m}}({X_k})}} \log q(A \to BC)\]<br>也就是说，粗表中的每一棵句法树都给出了它在原始表中的句法树的分数的上界，通俗说就是，如果把粗表中的收缩符号全部替换成原始表中的符号，那么新的句法树的分数一定会小于等于粗表中的句法树。</p><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><blockquote><p>如果粗表中的最优句法树${\hat d}$不包含任意收缩符号，那么它等价于原始表中的最优句法树。</p></blockquote><p><strong>证明：</strong><br>令$Y$等于原始表中的句法树集合，$Y’ \subset Y$等于没有出现在粗表中，但是出现在原始表中的句法树集合，${Y’’}$等于粗表中的句法树集合。</p><p>那么对于每一个句法树$d \in Y’$，都存在唯一的句法树$d’ \in Y’’$与之对应。所以可以推出：<br>\[\forall d \in Y,\exists d’ \in Y’’,s(d) \le s(d’) &lt; s(\hat d)\]<br>这就意味着$\hat d$也是原始表中的最优句法树。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="3.jpg" alt></p><ul><li><p>$lb$初始化为句法树的最优得分或者负无穷，其中<code>det()</code>用来求解句法树的最优得分，但是没有必要真的求出最优句法树，只需要在每个结点处保留得分最高的边即可。尽管这样得出来的句法树基本不是最高的，但是能够缩小$lb$范围即可。</p></li><li><p><code>init-chart()</code>首先初始化分析表，全部初始化为收缩符号。</p></li><li><p>然后开始迭代过程，首先执行维特比inside算法，也就是CKY算法<code>Viterbi-inside()</code>，得到最优句法树$\hat d$。</p></li><li><p>如果最优句法树不含有任意收缩符号，那么迭代结束，直接返回该句法树。</p></li><li><p>否则的话，更新$lb$为最优句法树的分数<code>best()</code>。</p></li><li><p><code>expand-chart()</code>将所有收缩符号替换为下一层的收缩符号。</p></li><li><p><code>Viterbi-outside()</code>计算outside值。</p></li><li><p><code>prune-chart()</code>进行剪枝，过滤掉无用的边。</p></li></ul><h2 id="剪枝过程"><a href="#剪枝过程" class="headerlink" title="剪枝过程"></a>剪枝过程</h2><p>算法的重要部分就是<code>prune-chart()</code>剪枝过程，这里要详细讲一下。</p><p>对于一条边$e = (A,i,j)$，定义$\alpha \beta (e) = \alpha (e) + \beta (e)$为含有边$e$的句法树的最大分数。那么如果<br>$\alpha \beta (e) &lt; lb$，这条边$e$就没有搜索的必要了，可以从分析表中去掉。</p><p>但是每次迭代都从原始表中计算$\alpha \beta (e)$值太麻烦了，可以在每次迭代的时候计算粗表中的值：<br>\[\alpha \beta (e) \le \hat \alpha (e) + \hat \beta (e) = \hat {\alpha \beta} (e)\]</p><p>所以当$\hat {\alpha \beta} (e) &lt; lb$时，从分析表中删除这条边。虽然搜索空间减少了，但是不影响算法的迭代轮数。</p><p>虽然在<code>expand-chart()</code>这一步要扩展收缩符号为下一层所有符号，但是实际运行起来时间比普通的CKY算法大大减少。</p><h2 id="K-best扩展"><a href="#K-best扩展" class="headerlink" title="K-best扩展"></a>K-best扩展</h2><p><img src="4.jpg" alt></p><p>基本框架和1-best是一样的，主要思路就是首先求出最优句法树，如果包含收缩符号，那么就下面步骤和1-best一样。否则的话求出后面k-1棵最优的句法树，如果都不包含收缩符号，直接返回k-best棵句法树。否则从中选出最好的一棵含有收缩符号的句法树，下面的步骤和1-best一样。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>数据集用的是PTB中长度小于35的句子。<br><img src="5.jpg" alt></p><p>上面这张表显示出，IVP算法的边的数量远远小于CKY算法，虽然迭代次数大大增加，但是总时间仍然远远小于CKY算法，而且边数减少了之后inside和outside算法的时间可以忽略不计了。最后一行是平均数据。<br><img src="6.jpg" alt><br>上图说明了，当k较小时，IVP算法时间快于普通的k-best算法，但是k大了之后就变慢了，原因如下图所示：<br><img src="7.jpg" alt><br>当k太大了之后，lb不能很好的得到最优得分的下界，所以无法有效地剪枝。而且k越小，算法收敛的也越快。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><hr><p>提出了K-best IVP算法，基本框架还是inside-outside算法。</p><p>但是全文自始自终没有提及算法的准确率，感觉应该不是很高，不知道有没有又高又快的优化方法？</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> EACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第9课（取整进阶与数论入门）</title>
      <link href="/2018/04/23/concrete-math-9/"/>
      <url>/2018/04/23/concrete-math-9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天讲完了取整的最后一部分知识，并给第四章数论开了个头。</p><p>首先还是以一道例题开始我们今天的课程。</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>求和：<br>\[\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor } \]</p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>首先令$m = \left\lfloor {\sqrt k } \right\rfloor $<br>那么有<br>\[\begin{array}{l}\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor }  = \sum\limits_{k,m \ge 0} {m\left[ {k &lt; n} \right]\left[ {m = \left\lfloor {\sqrt k } \right\rfloor } \right]} \\ = \sum\limits_{k,m \ge 0} {m\left[ {k &lt; n} \right]\left[ {m \le \sqrt k  &lt; m + 1} \right]} \\ = \sum\limits_{k,m \ge 0} {m\left[ {k &lt; n} \right]\left[ { {m^2} \le k &lt; { {(m + 1)}^2}} \right]} \\ = \sum\limits_{k,m \ge 0} {m\left[ { {m^2} \le k &lt; { {(m + 1)}^2} \le n} \right]} \\ + \sum\limits_{k,m \ge 0} {m\left[ { {m^2} \le k &lt; n &lt; { {(m + 1)}^2}} \right]} \end{array}\]<br>我们先算左半部分，先假设$n = {a^2}$，那么有<br>\[\begin{array}{l}\sum\limits_{k,m \ge 0} {m\left[ { {m^2} \le k &lt; { {(m + 1)}^2} \le {a^2}} \right]} \\ = \sum\limits_{m \ge 0} {m(2m + 1)\left[ {m &lt; a} \right]} \\ = \frac{1}{6}(4a + 1)a(a - 1)\end{array}\]<br>而对于一般的$n$，令$a = \left\lfloor {\sqrt n } \right\rfloor $，我们只需要计算${a^2} \le k &lt; n$的部分，而这部分$\sqrt k  = a$，所以结果为$(n - {a^2})a$。</p><p>所以总的结果为：<br>\[\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor }  = na - \frac{1}{3}{a^3} - \frac{1}{2}{a^2} - \frac{1}{6}a,a = \left\lfloor {\sqrt n } \right\rfloor \]</p><p>这里解释一下为什么没有算右半部分？因为右半部分就是${a^2} \le k &lt; n$的这部分，已经计算过了。</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>因为$\left\lfloor x \right\rfloor  = \sum\nolimits_j {\left[ {1 \le j \le x} \right]} $，所以可以将原式替换掉，还是令$n = {a^2}$，然后如下计算：<br>\[\begin{array}{l}\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor }  = \sum\limits_{j,k} {\left[ {1 \le j \le \sqrt k } \right]\left[ {0 \le k &lt; {a^2}} \right]} \\ = \sum\limits_{1 \le j &lt; a} {\sum\limits_k {\left[ { {j^2} \le k &lt; {a^2}} \right]} } \\ = \sum\limits_{1 \le j &lt; a} {({a^2} - {j^2})}  = {a^3} - \frac{1}{3}a(a + \frac{1}{2})(a + 1)\end{array}\]<br>其中第二行交换了变量计算顺序。</p><h1 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h1><hr><p>这里直接介绍一个定理，就不证明了，过程比较复杂：<br>\[\mathop {\lim }\limits_{n \to \infty } \frac{1}{n}\sum\limits_{0 \le k &lt; n} {f(\{ k\alpha \} )}  = \int_0^1 {f(x)dx} \]<br>其中$\alpha $是一个无理数。</p><p>这个公式说明了，无理数$\alpha $的整数倍的小数部分均匀分布在$(0,1)$之间。</p><p>这就给了我们一个启示，我们可以用它来生成随机数啊！其他用处还有很多，自己想咯。</p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><hr><p>求如下和式：<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor } \]<br>其中整数$m &gt; 0$，$n$也是整数。</p><p>通过枚举$m = 1,2,3, \ldots $，可以发现和式满足如下形式：<br>\[a\left\lfloor {\frac{x}{a}} \right\rfloor  + bn + c\]<br>那么怎么计算出来呢？</p><p>首先做一个变形：<br>\[\left\lfloor {\frac{ {x + kn}}{m}} \right\rfloor  = \left\lfloor {\frac{ {x + kn\bmod m}}{m}} \right\rfloor  + \frac{ {kn}}{m} - \frac{ {kn\bmod m}}{m}\]<br>这就将原来的和式分为了三个部分求和。</p><p><strong>第一个部分为：</strong><br>\[\left\lfloor {\frac{x}{m}} \right\rfloor  + \left\lfloor {\frac{ {x + n\bmod m}}{m}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {x + (m - 1)n\bmod m}}{m}} \right\rfloor \]<br>具体怎么算留到下一章节，这里通过枚举可以发现它的值是有周期的，周期重复次数是$d = \gcd (m,n)$。所以算出来结果为：<br>\[\begin{array}{l}d\left( {\left\lfloor {\frac{x}{m}} \right\rfloor  + \left\lfloor {\frac{ {x + d}}{m}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {x + m - d}}{m}} \right\rfloor } \right)\\ = d\left( {\left\lfloor {\frac{ {x/d}}{ {m/d}}} \right\rfloor  + \left\lfloor {\frac{ {x/d + 1}}{ {m/d}}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {x/d + m/d - 1}}{ {m/d}}} \right\rfloor } \right)\\ = d\left\lfloor {\frac{x}{d}} \right\rfloor \end{array}\]<br><strong>第二个部分为：</strong><br>\[\sum\limits_{0 \le k &lt; m} {\frac{ {kn}}{m}}  = \frac{ {(m - 1)n}}{2}\]<br><strong>第三个部分为：</strong><br>\[d\left( {\frac{0}{m} + \frac{d}{m} +  \cdots  + \frac{ {m - d}}{m}} \right) = \frac{ {m - d}}{2}\]</p><p>所以总的结果为：<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor }  = d\left\lfloor {\frac{x}{d}} \right\rfloor  + \frac{ {(m - 1)n}}{2} + \frac{ {d - m}}{2}\]</p><p>这里我们对结果稍稍变形，可以得到另一个结果：<br>\[\begin{array}{l}\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor }  = d\left\lfloor {\frac{x}{d}} \right\rfloor  + \frac{ {(m - 1)(n - 1)}}{2} + \frac{ {m - 1}}{2} + \frac{ {d - m}}{2}\\ = d\left\lfloor {\frac{x}{d}} \right\rfloor  + \frac{ {(m - 1)(n - 1)}}{2} + \frac{ {d - 1}}{2}\end{array}\]<br>可以发现，$m$和$n$是对称的！所以可以得到如下结论：<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor }  = \sum\limits_{0 \le k &lt; n} {\left\lfloor {\frac{ {mk + x}}{n}} \right\rfloor } \]<br>这有什么用呢？当$m$特别大、$n$很小的时候可以大大减少项的个数！</p><p>如果我们令$n=1$，就会发现，得到的式子和之前证过的一个式子一模一样！<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {k + x}}{m}} \right\rfloor }  = \left\lfloor x \right\rfloor \]</p><p>到这里为止，第三章取整就讲完了，下面开始讲第四章数论部分。</p><h1 id="数论相关性质"><a href="#数论相关性质" class="headerlink" title="数论相关性质"></a>数论相关性质</h1><hr><h2 id="整除定义"><a href="#整除定义" class="headerlink" title="整除定义"></a>整除定义</h2><p>\[m|n \Leftrightarrow m &gt; 0,n = mk,k \in \mathbb{Z}\]<br>注意这里整除的定义中要求$m&gt;0$。</p><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p>定义我就不说了，大家应该都知道的。</p><h2 id="欧几里得定理"><a href="#欧几里得定理" class="headerlink" title="欧几里得定理"></a>欧几里得定理</h2><p>又叫辗转相除法，就是用来求最大公约数的。<br>\[\begin{array}{l}\gcd (0,n) = n\\\gcd (m,n) = \gcd (n\bmod m,m)\end{array}\]</p><h2 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h2><p>在用欧几里得定理求到最大公约数之后，反过来可以将最大公约数表示为两个数的线性和：<br>\[\gcd (m,n) = m’m + n’n\]</p><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>如果$k|m,k|n$，那么$k|gcd(m,n)$。</p><h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>\[\sum\limits_{m|n} { {a_m}}  = \sum\limits_{m|n} { {a_{n/m}}} \]<br>这个就是用了交换律，按照因子顺序倒过来算。</p><h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>\[\sum\limits_{m|n} { {a_m}}  = \sum\limits_k {\sum\limits_{m &gt; 0} { {a_m}[n = mk]} } \]<br>这个虽然变成了二重求和，但是对于每个$k$，其实只有一个$m$有效。</p><h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>\[\sum\limits_{m|n} {\sum\limits_{k|m} { {a_{k,m}}} }  = \sum\limits_{k|n} {\sum\limits_{l|(n/k)} { {a_{k,kl}}} } \]<br>这个一眼就不一定能看出来了。</p><p>左边等于：<br>\[\begin{array}{l}\sum\limits_{m|n} {\sum\limits_{k|m} { {a_{k,m}}} }  = \sum\limits_{j,l} {\sum\limits_{k,m &gt; 0} { {a_{k,m}}[n = jm][m = kl]} } \\ = \sum\limits_j {\sum\limits_{k,l &gt; 0} { {a_{k,kl}}[n = jkl]} } \end{array}\]<br>右边等于：<br>\[\begin{array}{l}\sum\limits_{k|n} {\sum\limits_{l|(n/k)} { {a_{k,kl}}} }  = \sum\limits_{j,m} {\sum\limits_{k,l &gt; 0} { {a_{k,kl}}[n = jk][n/k = ml]} } \\ = \sum\limits_m {\sum\limits_{k,l &gt; 0} { {a_{k,kl}}[n = mlk]} } \end{array}\]<br>可以看出左右两边相等。</p><h2 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h2><p>一个整数可以唯一表示为若干个素数乘积：<br>\[n = \prod\limits_p { {p^{ {n_p}}}} ,{n_p} \ge 0\]<br>所以用指数形式来表示一个整数$n$，例如$18 = {2^1} \times {3^2}$，那么$18$可以表示为：<br>\[ &lt; 1,2,0,0, \ldots  &gt; \]<br>最大公约数和最小公倍数也能很方便的用指数形式计算：<br>其中最大公约数的每个素数的指数等于两个数对应指数最小值，最小公倍数的每个素数的指数等于两个数对应指数最大值。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第三章作业解答</title>
      <link href="/2018/04/20/concrete-math-hw3/"/>
      <url>/2018/04/20/concrete-math-hw3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h1><hr><p><strong>题目</strong><br>求$\left\lfloor {nx} \right\rfloor  = n\left\lfloor x \right\rfloor $的充要条件。<br><strong>解答</strong><br>因为</p><p>\[<br>x = \left\lfloor x \right\rfloor  + \{ x\}<br>\]<br>所以</p><p>\[<br>\left\lfloor {nx} \right\rfloor  = \left\lfloor {n(\left\lfloor x \right\rfloor  + \{ x\} )} \right\rfloor  = n\left\lfloor x \right\rfloor  + \left\lfloor {n\{ x\} } \right\rfloor<br>\]<br>要使得$\left\lfloor {nx} \right\rfloor  = n\left\lfloor x \right\rfloor$，就必须有</p><p>\[<br>\left\lfloor {n\{ x\} } \right\rfloor  = 0<br>\]<br>所以</p><p>\[<br>n\{ x\}  &lt; 1<br>\]<br>即</p><p>\[<br>\{ x\}  &lt; \frac{1}{n}<br>\]</p><h1 id="题7"><a href="#题7" class="headerlink" title="题7"></a>题7</h1><hr><p><strong>题目</strong><br>求下列递推式<br>\[\begin{array}{l}{X_n} = n,0 \le n &lt; m\\{X_n} = {X_{n - m}} + 1,n \ge m\end{array}\]<br><strong>解答</strong><br>因为</p><p>\[<br>n - \left\lfloor {\frac{n}{m}} \right\rfloor m = n\bmod m &lt; m<br>\]<br>所以</p><p>\[<br>\begin{array}{l}{X_n} = {X_{n - m}} + 1 = {X_{n - 2m}} + 2 =  \cdots \\ = {X_{n - \left\lfloor {\frac{n}{m}} \right\rfloor m}} + \left\lfloor {\frac{n}{m}} \right\rfloor  = n - \left\lfloor {\frac{n}{m}} \right\rfloor m + \left\lfloor {\frac{n}{m}} \right\rfloor \\ = n\,\bmod \,m + \left\lfloor {\frac{n}{m}} \right\rfloor \end{array}<br>\]</p><h1 id="题8"><a href="#题8" class="headerlink" title="题8"></a>题8</h1><hr><p><strong>题目</strong><br>$n$个物品放到$m$个盒子中，求证至少有一个盒子物品数大于等于$\left\lceil {\frac{n}{m}} \right\rceil$，至少有一个盒子物品数小于等于$\left\lfloor {\frac{n}{m}} \right\rfloor$。<br><strong>解答</strong><br>假设所有的盒子物品数都小于$\left\lceil {\frac{n}{m}} \right\rceil$，那么总物品数$S$满足</p><p>\[<br>S \le m(\left\lceil {\frac{n}{m}} \right\rceil  - 1)<br>\]<br>令$n = qm + r,0 \le r &lt; m$，那么有</p><p>\[<br>S \le m(\left\lceil {q + \frac{r}{m}} \right\rceil  - 1) = qm - m + m\left\lceil {\frac{r}{m}} \right\rceil<br>\]<br>如果$r=0$，那么有</p><p>\[<br>S \le qm - m &lt; n<br>\]<br>如果$r&gt;0$，那么有</p><p>\[<br>S \le qm &lt; n<br>\]<br>这与$S=n$矛盾！所以至少有一个盒子物品数大于等于$\left\lceil {\frac{n}{m}} \right\rceil$。</p><p>假设所有的盒子物品数都大于$\left\lfloor {\frac{n}{m}} \right\rfloor$，那么总物品数$S$满足</p><p>\[<br>S \ge m(\left\lfloor {\frac{n}{m}} \right\rfloor  + 1)<br>\]<br>令$n = qm + r,0 \le r &lt; m$，那么有</p><p>\[<br>S \ge m(\left\lfloor {q + \frac{r}{m}} \right\rfloor  + 1) = qm + m + m\left\lfloor {\frac{r}{m}} \right\rfloor  = qm + m &gt; qm + r = n<br>\]<br>这与$S=n$矛盾！所以至少有一个盒子物品数小于等于$\left\lfloor {\frac{n}{m}} \right\rfloor$。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inside-outside Algorithm in PCFG</title>
      <link href="/2018/04/19/inside-outside/"/>
      <url>/2018/04/19/inside-outside/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>inside-outside算法是用来预测一棵句法分析树的概率的算法，算法建立在文法是乔姆斯基范式（CFG）的基础之上，CFG的定义见<a href="https://en.wikipedia.org/wiki/Chomsky_normal_form" target="_blank" rel="noopener">维基百科</a>。一棵句法分析树的potential定义为它包含的产生式的potential乘积，在PCFG中表示概率，在CRF-CFG中表示特征集合的分数。</p><p>inside-outside算法需要定义两个变量：</p><ul><li>$\alpha (A,i,j)$定义为内部的potential之和，即以$A$为根结点，短语为${x_{i;j}}$的所有可能的子树的potential之和。</li><li>$\beta (A,i,j)$定义为外部的potential之和，即以$A$为根结点，短语为${x_{1;i - 1}}A{x_{j + 1;n}}$的所有可能的子结构的potential之和。</li></ul><p><strong>给定文法CFG，输入字符串${x_{1;n}}$，计算inside和outside值。</strong></p><h1 id="inside"><a href="#inside" class="headerlink" title="inside"></a>inside</h1><hr><p>初始化：<br>如果$A \to {x_i} \in R$，那么$\alpha (A,i,i) = \varphi (A \to {x_i},i,i,i)$。否则就等于0。<br>其中$\varphi (A \to {x_i},i,i,i)$为potential值。</p><p>类似于CKY算法，自底向上计算inside值：<br>\[\alpha (A,i,j) = \sum\limits_{A \to BC \in R} {\sum\limits_{k = i}^{j - 1} {\varphi (A \to BC,i,k,j) \cdot \alpha (B,i,k) \cdot \alpha (C,k + 1,j)} } \]</p><h1 id="outside"><a href="#outside" class="headerlink" title="outside"></a>outside</h1><hr><p>初始化：<br>$\beta (S,1,n) = 1$，其余都等于0。</p><p>outside值要分为两部分计算：<br><img src="1.jpg" alt><br>第一部分是${B \to AC}$，如上图所示。<br><img src="2.jpg" alt><br>第二部分是${B \to CA}$，如上图所示。</p><p>和inside相反，通过自顶向下计算outside值：<br>\[\begin{array}{l}\beta (A,i,j) = \sum\limits_{B \to AC \in R} {\sum\limits_{k = j + 1}^n {\varphi (B \to AC,i,j,k) \cdot \beta (B,i,k) \cdot \alpha (C,j + 1,k)} } \\ + \sum\limits_{B \to CA \in R} {\sum\limits_{k = 1}^{i - 1} {\varphi (B \to CA,k,i - 1,j) \cdot \beta (B,k,j) \cdot \alpha (C,k,i - 1)} } \end{array}\]</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><hr><p>所有可能的句法树potential之和为：<br>\[{Z_s} = \alpha (S,1,n)\]<br>包含产生式$(A \to BC,i,k,j)$的所有可能句法树potential之和是：<br>\[\mu (A \to BC,i,k,j) = \varphi (A \to BC,i,k,j) \cdot \beta (A,i,j) \cdot \alpha (B,i,k) \cdot \alpha (C,k + 1,j)\]<br>存在非终结符$A$，且短语是${x_{i;j}}$的所有可能句法树potential之和是：<br>\[\mu (A,i,j) = \alpha (A,i,j) \cdot \beta (A,i,j)\]</p><h1 id="PCFG参数估计"><a href="#PCFG参数估计" class="headerlink" title="PCFG参数估计"></a>PCFG参数估计</h1><hr><p>参数估计的目的就是为了估计出PCFG的概率$P$，使得所有句子的概率之和最大，采用的是EM迭代法。<br>首先定义：<br>\[\varphi (A \to BC,i,k,j) = P(A \to BC)\]<br>这里$P(A \to BC)$是随机初始化的，满足归一化条件就行。<br>对于语料库的每一条句子，可以计算出：<br>\[\begin{array}{l}count(A \to BC) = \frac { {\sum\limits_{i,k,j} {\mu (A \to BC,i,k,j)} }}{ { {Z_s}}}\\P(A \to BC) = \frac{ {count(A \to BC)}}{ {\sum\limits_r {count(r)} }}\end{array}\]<br>然后算出期望，更新概率，迭代就行了。</p><h1 id="CRF-CFG参数估计"><a href="#CRF-CFG参数估计" class="headerlink" title="CRF-CFG参数估计"></a>CRF-CFG参数估计</h1><hr><p>首先定义:<br>\[\varphi (A \to BC,i,k,j) = \exp \sum\limits_t { {\theta _t}{f_t}(A \to BC,i,k,j)} \]<br>其中$f_t$为特征函数。<br>那么我们的目的就是训练特征参数$\theta$。<br>然后定义似然函数为<br>\[L(D;\theta ) = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s) - {Z_s}} } } \right)}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \]<br>求偏导为<br>\[\frac{ {\partial L(D;\theta )}}{ {\partial {\theta _i}}} = \sum\limits_{(t,s) \in D} {(\sum\limits_{r \in t} { {f_i}(r,s)}  - {E_\theta }[{f_i}|s])}  + \frac{ { {\theta _i}}}{ { {\sigma ^2}}}\]</p><p>这里可能有人看不懂，似然函数和偏导是怎么来的呢？下面我详细写一下过程。<br>似然函数：<br>\[\begin{array}{l}L(D;\theta ) = \sum\limits_{(t,s) \in D} {\log \frac{ {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } }}{ {\sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } }}}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \\ = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} }  - \log \sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } } \right)}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \\ = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} }  - {Z_s}} \right)}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \end{array}\]<br>所以偏导为：<br>\[\frac{ {\partial L(D;\theta )}}{ {\partial {\theta _i}}} = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} { {f_i}(r,s)}  - \frac{ {\partial \left( {\log \sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } } \right)}}{ {\partial {\theta _i}}}} \right)}  + \frac{ { {\theta _i}}}{ { {\sigma ^2}}}\]<br>而<br>\[\begin{array}{l}\frac{ {\partial \left( {\log \sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } } \right)}}{ {\partial {\theta _i}}}\\ = \frac{ {\sum\limits_{t \in T(s)} {\left( {\left( {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } \right) \cdot \sum\limits_{r \in t} { {f_i}(r,s)} } \right)} }}{ {\sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } }}\\ = {E_\theta }[{f_i}|s]\end{array}\]<br>所以偏导就是这么来的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第8课（取整进阶）</title>
      <link href="/2018/04/16/concrete-math-8/"/>
      <url>/2018/04/16/concrete-math-8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天主要讲了取整与递归式的结合，还有取模的相关知识。</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>给出下列递归式：<br>\[\begin{array}{l}{K_0}{\rm{ = }}1\\{K_{n + 1}} = 1 + \min (2{K_{\left\lfloor {n/2} \right\rfloor }},3{K_{\left\lfloor {n/3} \right\rfloor }}),n \ge 0\end{array}\]<br>现在不要求你求解，要你证明：<br>\[{K_n} \ge n\]<br>首先想到的就是数学归纳法，假设对于任意$k \le n$，都有${K_k} \ge k$，那么：<br>\[\begin{array}{l}{K_{n + 1}} = 1 + \min (2{K_{\left\lfloor {n/2} \right\rfloor }},3{K_{\left\lfloor {n/3} \right\rfloor }})\\ \ge 1 + \min (2\left\lfloor {\frac{n}{2}} \right\rfloor ,3\left\lfloor {\frac{n}{3}} \right\rfloor )\end{array}\]<br>如果$n = 2k$，那么${K_{n + 1}} \ge 1 + n$。<br>如果$n = 2k + 1$，那么${K_{n + 1}} \ge n$，这时不成立。</p><p>所以数学归纳法无法证明，今后我们会用其他方法来证明这个式子。</p><h1 id="约瑟夫环新解"><a href="#约瑟夫环新解" class="headerlink" title="约瑟夫环新解"></a>约瑟夫环新解</h1><hr><p>还记得约瑟夫环问题吗？详见<a href="http://godweiyang.com/2018/02/27/concrete-math-1/">第一节课</a>。</p><p>这里我们继续推广到一般情况，如果有$n$个人，每隔$q$个人踢掉一个人，最后剩下的是几号？</p><p>初始编号为$1 \ldots n$，现在考虑一种新的编号方式。</p><p>第一个人不会被踢掉，编号加$1$，变成$n + 1$，然后第二个人编号变为$n + 2$，直到第$q$个人，他被踢掉了。</p><p>然后第$q + 1$个人编号继续加$1$，变成了$n + q$，依次下去。</p><p>考虑当前踢到的人编号为$kq$，那么此时已经踢掉了$k$个人，所以接下去的人新的编号为$n + k(q - 1) + 1 \ldots$。</p><p>所以编号为$kq+d$的人编号变成了$n + k(q - 1) + d$，其中$1 \le d &lt; q$。</p><p>直到最后，可以发现活下来的人编号为$qn$，问题是怎么根据这个编号推出他原来的编号？</p><p>以$n = 10$，$q = 3$为例，下图就是每个人新的编号：<br><img src="1.jpg" alt></p><p>令<br>\[N = n + k(q - 1) + d\]<br>所以他上一次的编号是<br>\[kq + d = kq + N - n - k(q - 1) = k + N - n\]<br>因为<br>\[k = \frac{ {N - n - d}}{ {q - 1}} = \left\lfloor {\frac{ {N - n - 1}}{ {q - 1}}} \right\rfloor \]<br>所以上一次编号可以写为<br>\[\left\lfloor {\frac{ {N - n - 1}}{ {q - 1}}} \right\rfloor  + N - n\]</p><p>因此最后存活的人编号可以用如下的算法计算：</p><pre><code>N = qnwhile N &gt; n:    N = k + N - nans = N</code></pre><p>其中$k = \left\lfloor {\frac{ {N - n - 1}}{ {q - 1}}} \right\rfloor $</p><p>如果我们用$D = qn + 1 - N$替代$N$，将会进一步简化算法：<br>\[\begin{array}{l}D = qn + 1 - N\\ = qn + 1 - \left( {\left\lfloor {\frac{ {(qn + 1 - D) - n - 1}}{ {q - 1}}} \right\rfloor  + qn + 1 - D - n} \right)\\ = n + D - \left\lfloor {\frac{ {(q - 1)n - D}}{ {q - 1}}} \right\rfloor \\ = D - \left\lfloor {\frac{ { - D}}{ {q - 1}}} \right\rfloor \\ = D + \left\lceil {\frac{D}{ {q - 1}}} \right\rceil \\ = \left\lceil {\frac{q}{ {q - 1}}D} \right\rceil \end{array}\]</p><p>算法伪代码如下：</p><pre><code>D = 1while D &lt;= (q-1)n:    D = kans = qn + 1 - D</code></pre><p>其中$k = \left\lceil {\frac{q}{ {q - 1}}D} \right\rceil $</p><h1 id="模的性质"><a href="#模的性质" class="headerlink" title="模的性质"></a>模的性质</h1><hr><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>模定义如下：<br>\[x\bmod y = x - y\left\lfloor {\frac{x}{y}} \right\rfloor \]<br>特别的<br>\[x\bmod 0 = x\]</p><p>与此类似，定义一个与模类似的运算：<br>\[x{\rm{ mumble }}y = y\left\lceil {\frac{x}{y}} \right\rceil  - x\]<br>形象理解如下图所示：<br><img src="2.jpg" alt><br>圆的周长是$y$，一共走过的路长（红色+绿色部分）是$x$，所以$x\bmod y$就是绿色部分，$x{\rm{ mumble }}y$就是一圈长度减去绿色部分。</p><p>模有一些性质：<br>\[c(x\bmod y) = (cx)\bmod (cy)\]</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>考虑如下问题，怎么平均分配$n$个东西给$m$个人？</p><p>很容易想到，首先分给每个人$\left\lfloor {\frac{n}{m}} \right\rfloor $个东西，剩下$n\bmod m$件东西分给前$n\bmod m$个人，一人多一件就行。</p><p>概括起来就是，前$n\bmod m$个人，每人$\left\lceil {\frac{n}{m}} \right\rceil $件，剩下的人，每人$\left\lfloor {\frac{n}{m}} \right\rfloor $件。</p><p>那有没有办法统一表示呢？有的，每个人分到的件数为<br>\[\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil ,1 \le k \le m\]</p><p>为什么呢？假设<br>\[n = qm + r,0 \le r &lt; m\]<br>那么<br>\[\begin{array}{l}\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil  = \left\lceil {\frac{ {qm + r - k + 1}}{m}} \right\rceil \\ = q + \left\lceil {\frac{ {r - k + 1}}{m}} \right\rceil \end{array}\]<br>当$1 \le k \le r$时，<br>\[\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil  = 1\]<br>当$r &lt; k \le m$时，<br>\[\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil  = 0\]</p><p>得证，因此可以得到如下等式：<br>\[n = \left\lceil {\frac{n}{m}} \right\rceil  + \left\lceil {\frac{ {n - 1}}{m}} \right\rceil  +  \cdots  + \left\lceil {\frac{ {n - m + 1}}{m}} \right\rceil \]</p><p>由$n = \left\lfloor {\frac{n}{2}} \right\rfloor  + \left\lceil {\frac{n}{2}} \right\rceil $<br>可以进一步将其转换为下取整形式：<br>\[n = \left\lfloor {\frac{n}{m}} \right\rfloor  + \left\lfloor {\frac{ {n + 1}}{m}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {n + m - 1}}{m}} \right\rfloor \]</p><p>令$n = \left\lfloor {mx} \right\rfloor $<br>我们得到了一个令人惊奇的等式：<br>\[\left\lfloor {mx} \right\rfloor  = \left\lfloor x \right\rfloor  + \left\lfloor {x + \frac{1}{m}} \right\rfloor  +  \cdots  + \left\lfloor {x + \frac{ {m - 1}}{m}} \right\rfloor \]</p><h1 id="HDU3089"><a href="#HDU3089" class="headerlink" title="HDU3089"></a>HDU3089</h1><hr><p>最后用今天介绍的约瑟夫环算法来解决一道经典的ACM题！题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3089" target="_blank" rel="noopener">杭电3089</a>。</p><p>C++代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL <span class="token function">J</span><span class="token punctuation">(</span>LL n<span class="token punctuation">,</span> LL q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL D <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>D <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        D <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">*</span>D<span class="token operator">+</span>q<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>q<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>D<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL n<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> <span class="token function">J</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比网上各种快速算法还要快哦，理论时间复杂度是$\log n$的。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细Hexo+Github博客搭建小白教程</title>
      <link href="/2018/04/13/hexo-blog/"/>
      <url>/2018/04/13/hexo-blog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p><strong>关注我公众号：算法码上来，获取实时更新</strong>。有任何问题请加 QQ 技术交流群【群号：864832264】。如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</p></blockquote><h1 id="我的博客源代码地址"><a href="#我的博客源代码地址" class="headerlink" title="我的博客源代码地址"></a>我的博客源代码地址</h1><p>大家可以直接素质二连，star&amp;fork我的博客源代码：<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-matery-modified</a>，然后改改配置就可以写文章啦。</p><p>为了减小源码的体积，我将插件目录<code>node_modules</code>进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。</p><ul><li>首先运行<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>将所有文件下载到本地。</li><li>解压<code>node_modules.zip</code>，然后删除<code>node_modules.zip</code>和<code>.git</code>文件夹。</li><li>还缺一个字体（为图片添加水印需要用到），去<code>C:\Windows\Fonts</code>下找到<code>STSong Regular</code>，复制到<code>hexo-matery-modified</code>文件夹下。</li></ul><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：</p><ul><li>根目录配置文件<code>_config.yml</code>和主题目录配置文件<code>_config.yml</code>中修改个人信息。</li><li>根目录配置文件中修改<code>deploy</code>一栏的<code>repository</code>。</li><li>根目录配置文件中修改<code>baidu_url_submit</code>一栏的<code>token</code>。</li><li>主题配置文件中修改<code>gitalk</code>一栏，修改方法见正文。</li></ul><p><strong>当然前提是个性化设置章节之前的环境还是需要配置好！</strong></p><p>平时常用命令：</p><pre class="line-numbers language-txt"><code class="language-txt">hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>17年9月的时候开始搭建了第一个自己的独立博客，到现在也稍微像模像样了。很多小伙伴应该也想过搭建一个自己的博客，网上也有一堆详细教程。我在此稍稍总结一下具体的搭建步骤，另外网上很少有修改博客源码的个性化教程，我就稍稍分享一下我的一些修改经验，更多的个性化操作需要你自己以后去摸索。</p><p>具体效果可以参观我的博客：<a href="https://godweiyang.com">godweiyang.com</a>，欢迎大家支持。</p><p>我不是一个前端程序员，有些东西不是很了解，写的有问题或有改进的地方请大家指出。</p><p>首先要了解一下我们搭建博客要用到的框架。Hexo是高效的静态站点生成框架，它基于Node.js。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到你的github上，然后别人就可以看到你的网页啦。是不是很简单？你无需关心网页源代码的具体细节，你只需要用心写好你的博客内容就行。</p><p><strong>目录结构</strong></p><ul><li>安装Node.js</li><li>添加国内镜像源</li><li>安装Git</li><li>注册Github账号</li><li>安装Hexo</li><li>连接Github与本地</li><li>写文章、发布文章</li><li>绑定域名</li><li>备份博客源文件</li><li>博客源代码下载</li><li>个性化设置（matery主题）</li><li>常见问题及解答（FAQ）</li><li>个性化设置（beantech主题，已停更）</li></ul><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>首先下载稳定版<a href="https://nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi" target="_blank" rel="noopener">Node.js</a>，我这里给的是64位的。</p><p>安装选项全部默认，一路点击<code>Next</code>。</p><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><h1 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h1><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">[下载地址]</a>。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h1 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h1><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>，新建一个项目，如下所示：<br><img src="1.jpg" alt><br>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，README初始化也要勾上。<strong>名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code>。</strong><br><img src="2.jpg" alt><br>然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，会变成下面这样：<br><img src="3.jpg" alt><br>点击那个链接，就会出现自己的网页啦，效果如下：<br><img src="4.jpg" alt></p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：<br><img src="5.jpg" alt></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h1 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h1><p>首先右键打开git bash，然后输入下面命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"godweiyang"</span><span class="token function">git</span> config --global user.email <span class="token string">"792321264@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用户名和邮箱根据你注册github的信息自行修改。</p><p>然后生成密钥SSH key：</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"792321264@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开<a href="http://github.com" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。<br><img src="6.jpg" alt></p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre class="line-numbers language-bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/godweiyang/godweiyang.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>repository修改为你自己的github项目地址。</p><h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p><p>以我的百度云为例，如下图所示，添加两条解析记录：<br><img src="7.jpg" alt></p><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：<br><img src="8.jpg" alt></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p><h1 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h1><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p><p>当然我新建了一个仓库存放了源文件，具体效果可以看我的博客源文件仓库：<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-matery-modified</a>。大家也可以先用下文hexo安装方法安装完hexo，然后直接<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>克隆我的所有源文件，然后这是我修改完的基本没bug的定制化的博客，就可以直接拿来用啦。</p><p><strong>我这个源文件和原来的主题没有什么区别，只是我把插件都安装完了，有些小bug也修复了，所以拿来就能直接用，方便大家。</strong></p><h1 id="博客源代码下载"><a href="#博客源代码下载" class="headerlink" title="博客源代码下载"></a>博客源代码下载</h1><p>如果大家不想这么麻烦的装一堆东西，然后还要自己修改bug，那么只需要做好上面的准备工作，然后下载我的源代码，改改个人配置就行了。</p><p>源码地址：<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-matery-modified</a>。大家可以直接下载下来使用，修改个人配置信息即可，当然环境要先搭好。</p><p><strong>如果大家下载好了源代码，就可以直接使用了，基本可以跳过文章后面的部分了！喜欢的记得star并fork哦！</strong></p><h1 id="个性化设置（matery主题）"><a href="#个性化设置（matery主题）" class="headerlink" title="个性化设置（matery主题）"></a>个性化设置（matery主题）</h1><p>下面的个性化设置主要针对的是<code>matery</code>主题，如果你想用我现在博客这个主题，可以直接看这个章节。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>这两天花时间将我的博客换了一个主题，现在这个主题看着更加的炫（zhuang）酷（bi），并且响应式更友好，点起来就很舒服，功能也多很多。</p><p>主题的原地址在这里：<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>，它的文档写得也非常的详细，还有中英文两个版本，作者回复也很及时。效果图如下，可以看出非常合我的口味：<br><img src="21.jpg" alt></p><p>但是我自己使用起来还是遇到了好几个问题，经过两天的不懈摸鱼，终于基本解决了，这里分享一下。</p><p>首先先按照文档教程安装一遍主题，然后是可以正常打开的，如果你是一般使用的话，基本没啥问题了。但是我是重度强迫症，一点小毛病就看着难受，下面列举一下我遇到的问题以及解决方法。</p><h2 id="文章头设置"><a href="#文章头设置" class="headerlink" title="文章头设置"></a>文章头设置</h2><p>首先为了新建文章方便，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre class="line-numbers language-json"><code class="language-json">---title<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span>date<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> date <span class="token punctuation">}</span><span class="token punctuation">}</span>top<span class="token operator">:</span> <span class="token boolean">false</span>cover<span class="token operator">:</span> <span class="token boolean">false</span>password<span class="token operator">:</span>toc<span class="token operator">:</span> <span class="token boolean">true</span>mathjax<span class="token operator">:</span> <span class="token boolean">true</span>summary<span class="token operator">:</span>tags<span class="token operator">:</span>categories<span class="token operator">:</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样新建文章后不用你自己补充了，修改信息就行。</p><h2 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h2><p>原来的主题没有404页面，加一个也不是什么难事。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><pre class="line-numbers language-json"><code class="language-json">---title<span class="token operator">:</span> <span class="token number">404</span>date<span class="token operator">:</span> <span class="token number">2019</span>-<span class="token number">07</span>-<span class="token number">19</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">10</span>type<span class="token operator">:</span> <span class="token string">"404"</span>layout<span class="token operator">:</span> <span class="token string">"404"</span>description<span class="token operator">:</span> <span class="token string">"你来到了没有知识的荒原 :("</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件，内容如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token comment" spellcheck="true">/* don't remove. */</span>    <span class="token selector"><span class="token class">.about-cover</span> </span><span class="token punctuation">{</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">75</span>vh<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg-cover pd-header about-cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col s10 offset-s1 m8 offset-m2 l8 offset-l2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>brand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title center-align<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        404                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description center-align<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        &lt;%= page.description %>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 每天切换 banner 图.  Switch banner image every day.</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="“关于”页面增加简历（可选）"><a href="#“关于”页面增加简历（可选）" class="headerlink" title="“关于”页面增加简历（可选）"></a>“关于”页面增加简历（可选）</h2><p>修改<code>/themes/matery/layout/about.ejs</code>，找到<code>&lt;div class=&quot;card&quot;&gt;</code>标签，然后找到它对应的<code>&lt;/div&gt;</code>标签，接在后面新增一个card，语句如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>card-content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>card-content article-card-content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title center-align<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-in-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-address-book<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">__('myCV')</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>articleContent<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">page.content</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就会多出一张card，然后可以在<code>/source/about/index.md</code>下面写上你的简历了，当然这里的位置随你自己设置，你也可以把简历作为第一个card。</p><h2 id="解决mathjax与代码高亮的冲突"><a href="#解决mathjax与代码高亮的冲突" class="headerlink" title="解决mathjax与代码高亮的冲突"></a>解决mathjax与代码高亮的冲突</h2><p>如果你按照教程安装了代码高亮插件<code>hexo-prism-plugin</code>，单独使用是没有问题的，但如果你又使用了mathjax，并且按照网上教程，安装<code>kramed</code>插件并修改了js文件里的正则表达式（为了解决markdown和mathjax的语法冲突），好了，那你的代码就无法高亮了。解决方法很简单，别用<code>kramed</code>插件了，还用原来自带的<code>marked</code>插件，直接改它的正则表达式就行了，改法如下：</p><p>打开<code>D:\study\program\blog\node_modules\marked\lib\marked.js</code><br><code>escape:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">escape<span class="token operator">:</span> /^\\(<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>(<span class="token punctuation">)</span>#$+\-.!_><span class="token punctuation">]</span><span class="token punctuation">)</span>/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>em:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>\*(?!\*<span class="token punctuation">)</span>/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时在文章里写数学公式基本没有问题了，但是要注意：<br><strong>数学公式中如果出现了连续两个{，中间一定要加空格！</strong></p><h2 id="增加建站时间"><a href="#增加建站时间" class="headerlink" title="增加建站时间"></a>增加建站时间</h2><p>修改<code>/themes/matery/layout/_partial/footer.ejs</code>文件，在最后加上</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script language<span class="token operator">=</span>javascript<span class="token operator">></span>    <span class="token keyword">function</span> <span class="token function">siteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"siteTime()"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> seconds <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> minutes <span class="token operator">=</span> seconds <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> hours <span class="token operator">=</span> minutes <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> days <span class="token operator">=</span> hours <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> years <span class="token operator">=</span> days <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> today <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayMonth <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayDate <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayHour <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayMinute <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todaySecond <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)        year - 作为date对象的年份，为4位年份值        month - 0-11之间的整数，做为date对象的月份        day - 1-31之间的整数，做为date对象的天数        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数        minutes - 0-59之间的整数，做为date对象的分钟数        seconds - 0-59之间的整数，做为date对象的秒数        microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span>        <span class="token keyword">var</span> t1 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">09</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//北京时间2018-2-13 00:00:00</span>        <span class="token keyword">var</span> t2 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span>todayYear<span class="token punctuation">,</span> todayMonth<span class="token punctuation">,</span> todayDate<span class="token punctuation">,</span> todayHour<span class="token punctuation">,</span> todayMinute<span class="token punctuation">,</span> todaySecond<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diff <span class="token operator">=</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">;</span>        <span class="token keyword">var</span> diffYears <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>diff <span class="token operator">/</span> years<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffDays <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">/</span> days<span class="token punctuation">)</span> <span class="token operator">-</span> diffYears <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffHours <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days<span class="token punctuation">)</span> <span class="token operator">/</span> hours<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffMinutes <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days <span class="token operator">-</span> diffHours <span class="token operator">*</span> hours<span class="token punctuation">)</span> <span class="token operator">/</span> minutes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffSeconds <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days <span class="token operator">-</span> diffHours <span class="token operator">*</span> hours <span class="token operator">-</span> diffMinutes <span class="token operator">*</span> minutes<span class="token punctuation">)</span> <span class="token operator">/</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"sitetime"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"本站已运行 "</span> <span class="token operator">+</span>diffYears<span class="token operator">+</span><span class="token string">" 年 "</span><span class="token operator">+</span>diffDays <span class="token operator">+</span> <span class="token string">" 天 "</span> <span class="token operator">+</span> diffHours <span class="token operator">+</span> <span class="token string">" 小时 "</span> <span class="token operator">+</span> diffMinutes <span class="token operator">+</span> <span class="token string">" 分钟 "</span> <span class="token operator">+</span> diffSeconds <span class="token operator">+</span> <span class="token string">" 秒"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/</span>    <span class="token function">siteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在合适的地方（比如copyright声明后面）加上下面的代码就行了：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sitetime<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改不蒜子初始化计数"><a href="#修改不蒜子初始化计数" class="headerlink" title="修改不蒜子初始化计数"></a>修改不蒜子初始化计数</h2><p>因为不蒜子至今未开放注册，所以没办法在官网修改初始化，只能自己动手了。和上一条一样，在<code>/themes/matery/layout/_partial/footer.ejs</code>文件最后加上：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> int <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>fixCount<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 50ms周期检测函数</span>        <span class="token keyword">var</span> pvcountOffset <span class="token operator">=</span> <span class="token number">80000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化首次数据</span>        <span class="token keyword">var</span> uvcountOffset <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">fixCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"busuanzi_container_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">!=</span> <span class="token string">"none"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> pvcountOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_container_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"display"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">"none"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_uv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_uv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> uvcountOffset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加上初始数据 </span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 停止检测</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后把上面几行有段代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalTraffic)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_pv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-heart-o<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>        本站总访问量 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_pv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalNumberOfvisitors)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_uv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        人次,<span class="token entity" title="&nbsp;">&amp;nbsp;</span>访客数 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_uv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 人.    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改为：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalTraffic)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_pv<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">='</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-heart-o<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>        本站总访问量 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_pv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalNumberOfvisitors)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_uv<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">='</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>        人次,<span class="token entity" title="&nbsp;">&amp;nbsp;</span>访客数 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_uv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 人.    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是增加了两个<code>style=&#39;display:none&#39;</code>而已。</p><h2 id="添加动漫人物"><a href="#添加动漫人物" class="headerlink" title="添加动漫人物"></a>添加动漫人物</h2><p>其实三步就行了，不用像网上有些教程那么复杂。</p><p><strong>第一步：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-helper-live2d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>第二步：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> live2d-widget-model-shizuku<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>第三步：</strong><br>在根目录配置文件中添加如下代码：</p><pre class="line-numbers language-json"><code class="language-json">live2d<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  scriptFrom<span class="token operator">:</span> local  pluginRootPath<span class="token operator">:</span> live2dw/  pluginJsPath<span class="token operator">:</span> lib/  pluginModelPath<span class="token operator">:</span> assets/  tagMode<span class="token operator">:</span> <span class="token boolean">false</span>  log<span class="token operator">:</span> <span class="token boolean">false</span>  model<span class="token operator">:</span>    use<span class="token operator">:</span> live2d-widget-model-shizuku  display<span class="token operator">:</span>    position<span class="token operator">:</span> right    width<span class="token operator">:</span> <span class="token number">150</span>    height<span class="token operator">:</span> <span class="token number">300</span>  mobile<span class="token operator">:</span>    show<span class="token operator">:</span> <span class="token boolean">true</span>  react<span class="token operator">:</span>    opacity<span class="token operator">:</span> <span class="token number">0.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>hexo g</code>再<code>hexo s</code>就能预览出效果了，但是有个注意的地方，我发现<strong>这个动漫人物最好不要和不蒜子同时使用</strong>，不然不蒜子会显示不出来。</p><h2 id="图片添加水印"><a href="#图片添加水印" class="headerlink" title="图片添加水印"></a>图片添加水印</h2><p>为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。</p><p>首先在博客根目录下新建一个<code>watermark.py</code>，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> glob<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageDraw<span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageFont<span class="token keyword">def</span> <span class="token function">watermark</span><span class="token punctuation">(</span>post_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> post_name <span class="token operator">==</span> <span class="token string">'all'</span><span class="token punctuation">:</span>        post_name <span class="token operator">=</span> <span class="token string">'*'</span>    dir_name <span class="token operator">=</span> <span class="token string">'source/_posts/'</span> <span class="token operator">+</span> post_name <span class="token operator">+</span> <span class="token string">'/*'</span>    <span class="token keyword">for</span> files <span class="token keyword">in</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>dir_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        im <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>files<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>im<span class="token punctuation">.</span>getbands<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>            im <span class="token operator">=</span> im<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">'RGB'</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>        font <span class="token operator">=</span> ImageFont<span class="token punctuation">.</span>truetype<span class="token punctuation">(</span><span class="token string">'STSONG.TTF'</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        draw <span class="token operator">=</span> ImageDraw<span class="token punctuation">.</span>Draw<span class="token punctuation">(</span>im<span class="token punctuation">)</span>        draw<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">(</span>im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                  u<span class="token string">'@yourname'</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> font<span class="token operator">=</span>font<span class="token punctuation">)</span>        im<span class="token punctuation">.</span>save<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        watermark<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[usage] &lt;input>'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行<code>python3 watermark.py postname</code>添加水印，如果第一次运行要给所有文章添加水印，可以运行<code>python3 watermark.py all</code>。</p><h2 id="添加网易云音乐BGM"><a href="#添加网易云音乐BGM" class="headerlink" title="添加网易云音乐BGM"></a>添加网易云音乐BGM</h2><p>写文章的时候，想插入一段BGM怎么办？</p><p>首先打开网易云网页版，找到想听的歌曲，然后点击生成外链：<br><img src="15.jpg" alt><br>复制如下代码：<br><img src="16.jpg" alt></p><p>粘贴到文章里就行了，为了美观，设置一下居中，具体代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里粘贴刚刚复制的代码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="添加评论插件"><a href="#添加评论插件" class="headerlink" title="添加评论插件"></a>添加评论插件</h2><p>主题已经自带了gitalk插件了，所以你只需要去github官网配置好就行了。</p><p>首先打开<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">github</a>申请一个应用，要填四个东西：</p><pre class="line-numbers language-txt"><code class="language-txt">Application name //应用名称，随便填Homepage URL //填自己的博客地址Application description //应用描述，随便填Authorization callback URL //填自己的博客地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后点击注册，会出现两个字符串<code>Client ID</code>和<code>Client Secret</code>，这个要复制出来。</p><p>然后去主题的配置文件<code>_config.yml</code>下修改<code>gitalk</code>那里：</p><pre class="line-numbers language-txt"><code class="language-txt">gitalk:  enable: true  owner: 你的github用户名  repo: 你的github用户名.github.io  oauth:    clientId: 粘贴刚刚注册完显示的字符串    clientSecret: 粘贴刚刚注册完显示的字符串  admin: 你的github用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以后写文章的时候，只要在文章页面登陆过github，就会自动创建评论框，<strong>记得每次写完文章后打开博客文章页面一下</strong>。</p><h2 id="添加百度统计和谷歌统计代码"><a href="#添加百度统计和谷歌统计代码" class="headerlink" title="添加百度统计和谷歌统计代码"></a>添加百度统计和谷歌统计代码</h2><p>首先打开<a href="https://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">百度站长平台</a>，然后点击添加网站，输入网址并选择领域。</p><p>接下来要验证网站所有权，有三种方式，推荐采用HTML标签验证，最简单，将代码复制出来。</p><p>打开<code>themes/matery/layout/_partial/head.ejs</code>，修改下面两行：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>baidu-site-verification<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>google-site-verification<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>content</code>内容改成你自己刚刚复制出来的就行了。</p><h2 id="修复代码块行号不显示bug"><a href="#修复代码块行号不显示bug" class="headerlink" title="修复代码块行号不显示bug"></a>修复代码块行号不显示bug</h2><p>修改<code>themes/matery/source/css/matery.css</code>第95行左右的<code>pre</code>和<code>code</code>两段改为如下代码：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">pre </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* padding: 1.5rem !important; */</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">3.3</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1</span>rem <span class="token number">0</span> <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#272822</span><span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0.35</span>rem<span class="token punctuation">;</span>    <span class="token property">tab-size</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">code </span><span class="token punctuation">{</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">5</span>px<span class="token punctuation">;</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> Inconsolata, Monaco, Consolas, <span class="token string">'Courier New'</span>, Courier, monospace<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* font-size: 0.91rem; */</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#e96900</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#f8f8f8</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">2</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在根目录的<code>_config.yml</code>中设置<code>prism_plugin.line_number</code>为<code>true</code>。</p><h2 id="优化文章url路径"><a href="#优化文章url路径" class="headerlink" title="优化文章url路径"></a>优化文章url路径</h2><p>有教程认为，将博客目录结构改为如下，就能减少层级，有利于搜索引擎的SEO。其实不然，网站内容的层级是按照从首页开始点击几次能到达你的文章来算的，所以你改不改都是两层就到达了，不在首页的也可以通过<code>index-archives-post</code>到达，跟文章url长度没有任何关系，所以如下操作作废，你想改也行，不改也行。但是建议已经建站一段时间的同学千万别改，不然会产生很多死链，并且评论issue全部会清空，很麻烦。</p><p><del>seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：<code>sitename/year/mounth/day/title</code>四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成<code>sitename/title</code>的形式，并且title最好是用英文，在根目录的<code>_config.yml</code>文件下修改permalink如下：</del></p><pre class="line-numbers language-text"><code class="language-text"># permalink: :year/:month/:day/:title/permalink: :title/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="添加雪花特效"><a href="#添加雪花特效" class="headerlink" title="添加雪花特效"></a>添加雪花特效</h2><p>首先在<code>themes/matery/source/libs/others</code>下新建文件<code>snow.js</code>，并插入如下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*样式一*/</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span><span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>snow <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> $flake <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'&lt;div id="snowbox" />'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token string">'absolute'</span><span class="token punctuation">,</span><span class="token string">'z-index'</span><span class="token punctuation">:</span><span class="token string">'9999'</span><span class="token punctuation">,</span> <span class="token string">'top'</span><span class="token punctuation">:</span> <span class="token string">'-50px'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'&amp;#10052;'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    documentHeight  <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    documentWidth   <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    defaults <span class="token operator">=</span> <span class="token punctuation">{</span>        minSize     <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>        maxSize     <span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>        newOn       <span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>        flakeColor  <span class="token punctuation">:</span> <span class="token string">"#AFDAEF"</span> <span class="token comment" spellcheck="true">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    options <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> defaults<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> interval<span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> startPositionLeft <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> documentWidth <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">,</span>    startOpacity <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    sizeFlake <span class="token operator">=</span> options<span class="token punctuation">.</span>minSize <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> options<span class="token punctuation">.</span>maxSize<span class="token punctuation">,</span>    endPositionTop <span class="token operator">=</span> documentHeight <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">,</span>    endPositionLeft <span class="token operator">=</span> startPositionLeft <span class="token operator">-</span> <span class="token number">500</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">,</span>    durationFall <span class="token operator">=</span> documentHeight <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5000</span><span class="token punctuation">;</span>    $flake<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        left<span class="token punctuation">:</span> startPositionLeft<span class="token punctuation">,</span>        opacity<span class="token punctuation">:</span> startOpacity<span class="token punctuation">,</span>        <span class="token string">'font-size'</span><span class="token punctuation">:</span> sizeFlake<span class="token punctuation">,</span>        color<span class="token punctuation">:</span> options<span class="token punctuation">.</span>flakeColor    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        top<span class="token punctuation">:</span> endPositionTop<span class="token punctuation">,</span>        left<span class="token punctuation">:</span> endPositionLeft<span class="token punctuation">,</span>        opacity<span class="token punctuation">:</span> <span class="token number">0.2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>durationFall<span class="token punctuation">,</span><span class="token string">'linear'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>newOn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">snow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>         minSize<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 定义雪花最小尺寸 */</span>        maxSize<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 定义雪花最大尺寸 */</span>        newOn<span class="token punctuation">:</span> <span class="token number">300</span>  <span class="token comment" spellcheck="true">/* 定义密集程度，数字越小越密集 */</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*样式二*/</span><span class="token comment" spellcheck="true">/* 控制下雪 */</span><span class="token keyword">function</span> <span class="token function">snowFall</span><span class="token punctuation">(</span>snow<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 可配置属性 */</span>    snow <span class="token operator">=</span> snow <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maxFlake <span class="token operator">=</span> snow<span class="token punctuation">.</span>maxFlake <span class="token operator">||</span> <span class="token number">200</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 最多片数 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>flakeSize <span class="token operator">=</span> snow<span class="token punctuation">.</span>flakeSize <span class="token operator">||</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 雪花形状 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed <span class="token operator">=</span> snow<span class="token punctuation">.</span>fallSpeed <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 坠落速度 */</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 兼容写法 */</span>requestAnimationFrame <span class="token operator">=</span> window<span class="token punctuation">.</span>requestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>mozRequestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>webkitRequestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>msRequestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>oRequestAnimationFrame <span class="token operator">||</span>    <span class="token keyword">function</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>cancelAnimationFrame <span class="token operator">=</span> window<span class="token punctuation">.</span>cancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>mozCancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>webkitCancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>msCancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>oCancelAnimationFrame<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 开始下雪 */</span>snowFall<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 创建画布 */</span>    snowCanvas<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建雪花形状 */</span>    createFlakes<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 画雪 */</span>    drawSnow<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 创建画布 */</span><span class="token keyword">function</span> <span class="token function">snowCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 添加Dom结点 */</span>    <span class="token keyword">var</span> snowcanvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">"snowfall"</span><span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span>height <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"style"</span><span class="token punctuation">,</span> <span class="token string">"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>snowcanvas<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>canvas <span class="token operator">=</span> snowcanvas<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> snowcanvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 窗口大小改变的处理 */</span>    window<span class="token punctuation">.</span>onresize <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        snowcanvas<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* snowcanvas.height = window.innerHeight */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 雪运动对象 */</span><span class="token keyword">function</span> <span class="token function">flakeMove</span><span class="token punctuation">(</span>canvasWidth<span class="token punctuation">,</span> canvasHeight<span class="token punctuation">,</span> flakeSize<span class="token punctuation">,</span> fallSpeed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> canvasWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* x坐标 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> canvasHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* y坐标 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> flakeSize <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 形状 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maxSize <span class="token operator">=</span> flakeSize<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">/* 最大形状 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>speed <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">+</span> fallSpeed<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 坠落速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed <span class="token operator">=</span> fallSpeed<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">/* 坠落速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">/* Y方向速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">/* X方向速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stepSize <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">30</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/* 步长 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">=</span> <span class="token number">0</span>                                       <span class="token comment" spellcheck="true">/* 步数 */</span><span class="token punctuation">}</span>flakeMove<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>update <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span>        y <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 左右摆动(余弦) */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">0.98</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">+</span><span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">.</span><span class="token number">05</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stepSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>velY<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>velX<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 飞出边界的处理 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">>=</span> canvas<span class="token punctuation">.</span>width <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">>=</span> canvas<span class="token punctuation">.</span>height <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>canvas<span class="token punctuation">.</span>width<span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>height<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 飞出边界-放置最顶端继续坠落 */</span>flakeMove<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>reset <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxSize <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>speed <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染雪花-随机形状（此处可修改雪花颜色！！！）</span>flakeMove<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>render <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> snowFlake <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">createRadialGradient</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    snowFlake<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"rgba(255, 255, 255, 0.9)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 此处是雪花颜色，默认是白色 */</span>    snowFlake<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"rgba(255, 255, 255, 0.5)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 若要改为其他颜色，请自行查 */</span>    snowFlake<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"rgba(255, 255, 255, 0)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 找16进制的RGB 颜色代码。 */</span>    ctx<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> snowFlake<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 创建雪花-定义形状 */</span><span class="token keyword">function</span> <span class="token function">createFlakes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> maxFlake <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxFlake<span class="token punctuation">,</span>        flakes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flakes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        canvas <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>canvas<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxFlake<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flakes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">flakeMove</span><span class="token punctuation">(</span>canvas<span class="token punctuation">.</span>width<span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>height<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flakeSize<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 画雪 */</span><span class="token keyword">function</span> <span class="token function">drawSnow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> maxFlake <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxFlake<span class="token punctuation">,</span>        flakes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flakes<span class="token punctuation">;</span>    ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ctx<span class="token punctuation">,</span> canvas <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>canvas<span class="token punctuation">,</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清空雪花 */</span>    ctx<span class="token punctuation">.</span><span class="token function">clearRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>width<span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">&lt;</span> maxFlake<span class="token punctuation">;</span> e<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flakes<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flakes<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  一帧一帧的画 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loop <span class="token operator">=</span> <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        drawSnow<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 调用及控制方法 */</span><span class="token keyword">var</span> snow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">snowFall</span><span class="token punctuation">(</span><span class="token punctuation">{</span>maxFlake<span class="token punctuation">:</span><span class="token number">60</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>snow<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在主题配置文件里<code>libs.js</code>里添加一行<code>snow: /libs/others/snow.js</code>。</p><p>在<code>themes/matery/layout/layout.ejs</code>里添加如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 雪花特效 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.snow.enable)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>&lt;script type="text/javascript" src="<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">theme.libs.js.snow</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token script language-javascript">"<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后在主题配置文件最后添加：</p><pre class="line-numbers language-txt"><code class="language-txt"># 雪花特效snow:  enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>这个特效和动漫一样，有点花里胡哨，并且可能会造成卡顿，所以我并没有开启，还是给大家一个最干净的阅读体验吧。</p></blockquote><h2 id="动态标签栏"><a href="#动态标签栏" class="headerlink" title="动态标签栏"></a>动态标签栏</h2><p>在<code>theme/matery/layout/layout.ejs</code>下添加如下代码：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"> <span class="token keyword">var</span> OriginTitile <span class="token operator">=</span> document<span class="token punctuation">.</span>title<span class="token punctuation">,</span> st<span class="token punctuation">;</span> document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"visibilitychange"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>hidden <span class="token operator">?</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Σ(っ °Д °;)っ喔哟，崩溃啦！"</span><span class="token punctuation">,</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"φ(゜▽゜*)♪咦，又好了！"</span><span class="token punctuation">,</span> st <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> OriginTitile <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3e3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="常见问题及解答（FAQ）"><a href="#常见问题及解答（FAQ）" class="headerlink" title="常见问题及解答（FAQ）"></a>常见问题及解答（FAQ）</h1><p>这个章节主要更新许多同学在搭建博客的过程中咨询我的一些问题。</p><h2 id="为什么本地生成完ssh-key之后没有-ssh文件夹？"><a href="#为什么本地生成完ssh-key之后没有-ssh文件夹？" class="headerlink" title="为什么本地生成完ssh key之后没有.ssh文件夹？"></a>为什么本地生成完ssh key之后没有.ssh文件夹？</h2><p>这是我没有想到会遇到的问题，但是很多人还是遇到了，主要问题就是在输入完<code>ssh-keygen -t rsa -C &quot;792321264@qq.com&quot;</code>之后，很多同学没有按照提示继续输入，而是就这么结束了，然后报错了也没有发现。正确做法是按照提示，一路按回车就行了。</p><h2 id="为什么代码块显示有问题？"><a href="#为什么代码块显示有问题？" class="headerlink" title="为什么代码块显示有问题？"></a>为什么代码块显示有问题？</h2><p>代码要显示正确，要注意以下几个点：</p><ul><li>根目录<code>_config.yml</code>文件下的<code>highlight</code>中的<code>line_number</code>要设置为<code>false</code>，因为行号有bug，当然如果你按照上面教程修复了bug，就可以改成<code>true</code>。</li><li>不要按照网上教程安装<code>kramed</code>插件，已经装了的卸载掉。</li><li>修改<code>node_modules/marked/lib/marked.js</code>文件中的<code>escape</code>和<code>em</code>两行（在538行左右），改成下面：<pre class="line-numbers language-json"><code class="language-json">escape<span class="token operator">:</span> /^\\(<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>(<span class="token punctuation">)</span>#$+\-.!_><span class="token punctuation">]</span><span class="token punctuation">)</span>/<span class="token punctuation">,</span>em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>\*(?!\*<span class="token punctuation">)</span>/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="为什么博客本地预览没问题，push到github上就显示不正常？"><a href="#为什么博客本地预览没问题，push到github上就显示不正常？" class="headerlink" title="为什么博客本地预览没问题，push到github上就显示不正常？"></a>为什么博客本地预览没问题，push到github上就显示不正常？</h2><p>这个问题可能原因有很多，我暂时列举遇到的情况：</p><ul><li>github博客的仓库名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code>。这是大多数人会犯的错误，会导致显示不正常。</li></ul><h2 id="更换主题之后，配置文件是修改根目录下的还是主题目录下的？"><a href="#更换主题之后，配置文件是修改根目录下的还是主题目录下的？" class="headerlink" title="更换主题之后，配置文件是修改根目录下的还是主题目录下的？"></a>更换主题之后，配置文件是修改根目录下的还是主题目录下的？</h2><p>这个其实都要修改，一般也不会出现重复的属性。具体使用哪个，要看主题的源代码，如果是<code>config.xxx</code>那就是用的根目录配置文件，如果是<code>theme.xxx</code>那就用的是主题目录的配置文件。</p><h2 id="在哪建立github分支？"><a href="#在哪建立github分支？" class="headerlink" title="在哪建立github分支？"></a>在哪建立github分支？</h2><p>点击仓库的<code>settings-branches</code>，右边点击<code>add new branch</code>即可。</p><h1 id="个性化设置（beantech主题，已停更）"><a href="#个性化设置（beantech主题，已停更）" class="headerlink" title="个性化设置（beantech主题，已停更）"></a>个性化设置（beantech主题，已停更）</h1><p><strong>下面的个性化设置主要针对的是我之前使用的<code>beantech</code>主题，当然如果你想用我现在博客这个主题，可以不看这部分。这部分已经停止更新，今后我只会更新<code>matery</code>主题的各种配置。</strong></p><h2 id="更换主题-1"><a href="#更换主题-1" class="headerlink" title="更换主题"></a>更换主题</h2><p>网上大多数主题都是github排名第一的<code>Next</code>主题，但是我个人不是很喜欢，我更喜欢<code>beantech</code>主题，地址在<a href="https://github.com/YenYuHsuan/hexo-theme-beantech" target="_blank" rel="noopener">传送门</a>。</p><p>首先要注意的是，<strong>这个github项目不仅包含了主题文件，还包含了hexo的各种文件</strong>。</p><p>所以首先下载下来这个项目，然后推荐将下图所有文件全部替换你原本博客根目录下的文件：<br><img src="9.jpg" alt></p><p>当然一般的主题和这个主题有点不一样，只含有主题文件夹，所以把整个文件夹丢到<code>theme</code>下就行了。</p><p>然后运行<code>hexo clean</code>清空所有生成的网页缓存，<code>hexo g</code>、<code>hexo d</code>。这时候新的主题网页就生成好了，博客根目录的情况应该大致如下：<br><img src="10.jpg" alt></p><h2 id="博客目录构成介绍"><a href="#博客目录构成介绍" class="headerlink" title="博客目录构成介绍"></a>博客目录构成介绍</h2><p>从上图可以看出，博客的目录结构如下：</p><pre class="line-numbers language-md"><code class="language-md">- node_modules- public- scaffolds- source    - _posts    - about    - archive    - img    - tags- themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>node_modules</code>是node.js各种库的目录，<code>public</code>是生成的网页文件目录，<code>scaffolds</code>里面就三个文件，存储着新文章和新页面的初始设置，<code>source</code>是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，<code>themes</code>存放着主题文件，一般也用不到。</p><p>我们平时写文章只需要关注<code>source/_posts</code>这个文件夹就行了。</p><p>网站图片都保存在<code>D:\study\program\blog\source\img</code>目录下，可以修改成自己的图片。</p><h2 id="修复文档分类bug"><a href="#修复文档分类bug" class="headerlink" title="修复文档分类bug"></a>修复文档分类bug</h2><p>这个主题文档分类功能有个bug，一直没有得到解决，直到最近，我才发现是源文件的单词拼错了。。。</p><p>打开<code>D:\study\program\blog\scaffolds\post.md</code>，单词<code>catagories</code>改为<code>categories</code>。</p><h2 id="添加畅言评论插件"><a href="#添加畅言评论插件" class="headerlink" title="添加畅言评论插件"></a>添加畅言评论插件</h2><p>主题自带了多说评论插件，但是多说已经关闭了，所以我换成了畅言评论插件。</p><p>首先你得注册一个畅言账号，<a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">地址</a>。<br>然后打开如下页面，复制该段代码：<br><img src="11.jpg" alt><br>打开<code>D:\study\program\blog\themes\beantech\layout\post.ejs</code>，将代码粘贴到如下位置：<br><img src="12.jpg" alt><br>然后重新生成一下网页，可以看到效果图如下：<br><img src="13.jpg" alt><br>更多插件例如热评话题之类的，可以自行在畅言后台找到代码添加。</p><h2 id="添加图片放大功能"><a href="#添加图片放大功能" class="headerlink" title="添加图片放大功能"></a>添加图片放大功能</h2><p>首先下载<code>zooming.js</code>文件<a href="https://github.com/godweiyang/godweiyang.github.io/blob/master/js/zooming.js" target="_blank" rel="noopener">地址</a>，保存在<code>D:\study\program\blog\themes\beantech\source\js</code>目录下。</p><p>打开<code>D:\study\program\blog\themes\beantech\layout\post.ejs</code>，在最下方粘贴如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/zooming.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后文章里的图片就可以单击全屏啦。</p><h2 id="添加数学公式显示"><a href="#添加数学公式显示" class="headerlink" title="添加数学公式显示"></a>添加数学公式显示</h2><p>打开<code>D:\study\program\blog\themes\beantech\layout\post.ejs</code>，在最下方粘贴如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://cdn.mathjax.org/mathjax/latest/MathJax.js?config<span class="token punctuation">=</span>default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于markdown语法与mathjax语法存在冲突，所以还需要修改源文件。</p><p>打开<code>D:\study\program\blog\node_modules\marked\lib\marked.js</code><br><code>escape:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">escape<span class="token operator">:</span> /^$<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>(<span class="token punctuation">)</span>#$+\-.!_><span class="token punctuation">]</span><span class="token punctuation">)</span>/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>em:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>\*(?!\*<span class="token punctuation">)</span>/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时在文章里写数学公式基本没有问题了，但是要注意：<br><strong>数学公式中如果出现了连续两个{，中间一定要加空格！</strong></p><p>举个例子:<br>行内公式：$y = f(x)$<br>代码：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token equation string">$y = f(x)$</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>行间公式：<br>\[y = {f_{ {g_1}}}(x)\]<br>代码：</p><pre class="line-numbers language-latex"><code class="language-latex">\<span class="token equation string">\[y = {f_{ {g_1}}}(x)<span class="token equation-command regex">\\</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意上面花括号之间有空格！</strong></p><h2 id="添加留言板"><a href="#添加留言板" class="headerlink" title="添加留言板"></a>添加留言板</h2><p>在<code>D:\study\program\blog\themes\beantech\layout</code>中新建<code>bbs.ejs</code>，文件内容如下：</p><pre class="line-numbers language-html"><code class="language-html">---layout: page---<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector">header<span class="token class">.intro-header</span></span><span class="token punctuation">{</span>        <span class="token property">background-position</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>     <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- Chinese Version --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh post-container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">page.content</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>D:\study\program\blog\source</code>中新建<code>\bbs</code>文件夹，里面在新建<code>index.md</code>文件，内容如下：</p><pre class="line-numbers language-json"><code class="language-json">---layout<span class="token operator">:</span> <span class="token string">"bbs"</span>title<span class="token operator">:</span> <span class="token string">"BBS"</span>date<span class="token operator">:</span> <span class="token number">2017</span>-<span class="token number">09</span>-<span class="token number">19</span> <span class="token number">12</span><span class="token operator">:</span><span class="token number">48</span><span class="token operator">:</span><span class="token number">33</span>description<span class="token operator">:</span> <span class="token string">"欢迎交换友链，一起交流学习！"</span>header-img<span class="token operator">:</span> <span class="token string">"img/header_img/home-bg-2-dark.png"</span>comments<span class="token operator">:</span> <span class="token boolean">true</span>---此处替换为你的畅言评论代码~~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加置顶功能"><a href="#添加置顶功能" class="headerlink" title="添加置顶功能"></a>添加置顶功能</h2><p>运行如下两条命令安装置顶插件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> uninstall hexo-generator-index --save<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-index-pin-top --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后打开<code>D:\study\program\blog\themes\beantech\layout\index.ejs</code>，在如下位置添加代码：<br><img src="14.jpg" alt></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(post.top)</span> <span class="token attr-name">{%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-thumb-tack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7D26CD<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>置顶<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post-meta-divider<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>|<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%}%</span><span class="token punctuation">></span></span>&lt; code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>%}%</span><span class="token punctuation">></span></span>&lt;><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在你想置顶的文章md文件里，添加如下配置选项：</p><pre class="line-numbers language-json"><code class="language-json">top<span class="token operator">:</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="添加访客人数统计和字数统计"><a href="#添加访客人数统计和字数统计" class="headerlink" title="添加访客人数统计和字数统计"></a>添加访客人数统计和字数统计</h2><p>我们使用一个国外的流量统计网站：<a href="gostats.com">gostats.com</a>，首先注册一下。</p><p>然后自己添加网站地址，过程就不详细说了，然后点击<code>Get counter code</code>，选择一个自己喜欢的风格。<br>如下图所示，选择一个样式，选择<code>HTML</code>，生成代码：<br><img src="17.jpg" alt></p><p>复制这段代码到<code>D:\study\program\blog\themes\beantech\layout\_partial\footer.ejs</code>，具体位置如下：<br><img src="18.jpg" alt><br>默认的代码和我图中不一样，因为我不想点击图片跳转到它统计网站的链接，可以模仿我的自行修改。</p><p>字数统计首先安装插件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开<code>D:\study\program\blog\themes\beantech\layout\_partial\footer.ejs</code>，添加如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&lt;%= totalcount(site) %> words altogether<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体位置见上图。</p><h2 id="文章属性配置"><a href="#文章属性配置" class="headerlink" title="文章属性配置"></a>文章属性配置</h2><p>首先解释一下文章开头的属性配置，如下图所示：<br><img src="19.jpg" alt></p><pre class="line-numbers language-json"><code class="language-json">title<span class="token operator">:</span> 文章标题catalog<span class="token operator">:</span> 是否显示段落目录date<span class="token operator">:</span> 文章日期subtitle<span class="token operator">:</span> 子标题header-img<span class="token operator">:</span> 顶部背景图片top<span class="token operator">:</span> 是否置顶tags<span class="token operator">:</span> 标签categories<span class="token operator">:</span> 分类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次写文章修改每个值就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第7课（取整基础）</title>
      <link href="/2018/04/09/concrete-math-7/"/>
      <url>/2018/04/09/concrete-math-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>首先声明一下，最近这段时间忙毕设，没时间更新博客了，大家见谅。</p><p>今天这节课开始讲解取整相关知识，主要是数论相关的了。</p><h1 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h1><hr><p>向下取整函数$\left\lfloor x \right\rfloor $定义为小于等于$x$的最大整数。<br>向上取整函数$\left\lceil x \right\rceil $定义为大于等于$x$的最小整数。<br>$\{ x\} $定义为实数$x$的小数部分，即<br>\[\{ x\}  = x - \left\lfloor x \right\rfloor \]</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><hr><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>\[\left\lceil x \right\rceil  - \left\lfloor x \right\rfloor  = [x \in \mathbb{Z}]\]</p><h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>取整函数范围：<br>\[x - 1 &lt; \left\lfloor x \right\rfloor  \le x \le \left\lceil x \right\rceil  &lt; x + 1\]</p><h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>负数的取整：<br>\[\begin{array}{l}\left\lfloor { - x} \right\rfloor  =  - \left\lceil x \right\rceil \\\left\lceil { - x} \right\rceil  =  - \left\lfloor x \right\rfloor \end{array}\]</p><h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>取整函数中的整数可以提取出来：<br>\[\left\lfloor {x + n} \right\rfloor  = \left\lfloor x \right\rfloor  + n\]</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><hr><h2 id="应用1"><a href="#应用1" class="headerlink" title="应用1"></a>应用1</h2><p>证明：<br>\[\left\lfloor {\sqrt {\left\lfloor x \right\rfloor } } \right\rfloor  = \left\lfloor {\sqrt x } \right\rfloor \]</p><p>更一般的，我们还可以证明，对于任意连续、递增的函数$f(x)$，如果它满足<br>\[f(x) \in \mathbb{Z} \Rightarrow x \in \mathbb{Z}\]<br>那么有<br>\[\begin{array}{l}\left\lfloor {f(x)} \right\rfloor  = \left\lfloor {f(\left\lfloor x \right\rfloor )} \right\rfloor \\\left\lceil {f(x)} \right\rceil  = \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \end{array}\]</p><p>我们证明第2个式子，第1个同理可证。</p><p>如果$x = \left\lceil x \right\rceil $，显然成立。</p><p>否则$x &lt; \left\lceil x \right\rceil $，因为$f(x)$递增，所以有<br>\[f(x) &lt; f(\left\lceil x \right\rceil )\]<br>两边同时取整，有<br>\[\left\lceil {f(x)} \right\rceil  \le \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]<br>要证左右两边相等，那么只要证<br>\[\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]<br>不成立即可。假设上式成立，那么由中间值定理，一定存在$x \le y &lt; \left\lceil x \right\rceil $，使得<br>\[f(y) = \left\lceil {f(x)} \right\rceil \]<br><strong>敲黑板！！</strong>这里是怎么来的呢？<br>由下图可以看出，当下面式子成立时，满足中间值定理<br>\[f(x) &lt; \left\lceil {f(x)} \right\rceil  &lt; f(\left\lceil x \right\rceil )\]<br>但是在这里，我们假设是<br>\[\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]<br>那么由$\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil $能否推出$\left\lceil {f(x)} \right\rceil  &lt; f(\left\lceil x \right\rceil )$呢？当然是可以的。<br>\[\begin{array}{l}\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \\ \Rightarrow \left\lceil {f(x)} \right\rceil  \le \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil  - 1 &lt; f(\left\lceil x \right\rceil )\end{array}\]<br><img src="1.jpg" alt><br>所以<br>\[f(y) \in \mathbb{Z} \Rightarrow y \in \mathbb{Z}\]<br>又因为$x \le y &lt; \left\lceil x \right\rceil $，所以不存在整数$y$，矛盾！</p><p>所以证得<br>\[\left\lceil {f(x)} \right\rceil  = \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]</p><p>另一个特殊的例子是<br>\[\left\lfloor {\frac{ {x + m}}{n}} \right\rfloor  = \left\lfloor {\frac{ {\left\lfloor x \right\rfloor  + m}}{n}} \right\rfloor \]<br>其中$m$和$n$都是整数，并且$n$是正整数。</p><h2 id="应用2"><a href="#应用2" class="headerlink" title="应用2"></a>应用2</h2><p>接着介绍区间相关的性质。</p><p>求1到1000中使得下列式子成立的$n$一共有多少个？<br>\[\left\lfloor {\sqrt[3]{n}} \right\rfloor |n\]<br>求解方法如下：<br>\[\begin{array}{l}W{\rm{ = }}\sum\limits_{1 \le n \le 1000} {\left[ {\left\lfloor {\sqrt[3]{n}} \right\rfloor |n} \right]} \\ = \sum\limits_{k,n} {\left[ {k = \left\lfloor {\sqrt[3]{n}} \right\rfloor } \right]\left[ {k|n} \right]\left[ {1 \le n \le 1000} \right]} \\ = \sum\limits_{k,m,n} {\left[ { {k^3} \le n &lt; { {(k + 1)}^3}} \right]\left[ {n = km} \right]} \left[ {1 \le n \le 1000} \right]\\ = 1 + \sum\limits_{k,m} {\left[ { {k^3} \le km &lt; { {(k + 1)}^3}} \right]} \left[ {1 \le k &lt; 10} \right]\\ = 1 + \sum\limits_{k,m} {\left[ {m \in [{k^2},{ {(k + 1)}^3}/k)} \right]} \left[ {1 \le k &lt; 10} \right]\\ = 1 + \sum\limits_{1 \le k &lt; 10} {(\left\lceil { {k^2} + 3k + 3 + 1/k} \right\rceil  - \left\lceil { {k^2}} \right\rceil )} \\ = 1 + \sum\limits_{1 \le k &lt; 10} {(3k + 4)} \\ = 172\end{array}\]</p><p>继续推广，求1到$N$中使得上面式子成立的$n$有多少个？<br>令<br>\[K = \left\lfloor {\sqrt[3]{N}} \right\rfloor \]<br>也就是小于等于$\left\lfloor {\sqrt[3]{N}} \right\rfloor $的最大整数。<br>所以<br>\[\begin{array}{l}W = \sum\limits_{1 \le k &lt; K} {(3k + 4)}  + \sum\limits_m {\left[ { {K^3} \le Km \le N} \right]} \\ = \left\lfloor {N/K} \right\rfloor  + \frac{1}{2}{K^2} + \frac{5}{2}K - 3\end{array}\]<br>渐进地等于<br>\[W = \frac{3}{2}{N^{2/3}} + O({N^{1/3}})\]</p><h2 id="应用3"><a href="#应用3" class="headerlink" title="应用3"></a>应用3</h2><p>定义一个实数的谱为：<br>\[Spec(\alpha ) = \{ \left\lfloor \alpha  \right\rfloor ,\left\lfloor {2\alpha } \right\rfloor ,\left\lfloor {3\alpha } \right\rfloor , \ldots \} \]</p><p>很容易证明如果两个实数$\alpha  \ne \beta $，那么<br>\[Spec(\alpha ) \ne Spec(\beta )\]</p><p>假设$\alpha  &lt; \beta $，那么令<br>\[m(\beta  - \alpha ) \ge 1\]<br>所以<br>$m\beta  \ge m\alpha  + 1 \Rightarrow \left\lfloor {m\beta } \right\rfloor  &gt; \left\lfloor {m\alpha } \right\rfloor $<br>所以集合$Spec(\beta )$中小于$\left\lfloor {m\alpha } \right\rfloor $的元素个数小于$m$。而集合$Spec(\alpha )$中小于$\left\lfloor {m\alpha } \right\rfloor $的元素个数大于等于$m$。所以两个集合不相等。</p><p>谱有很多奇妙的性质，例如下面两个谱：<br>\[\begin{array}{l}Spec(\sqrt 2 ) = \{ \left\lfloor {\sqrt 2 } \right\rfloor ,\left\lfloor {2\sqrt 2 } \right\rfloor ,\left\lfloor {3\sqrt 2 } \right\rfloor , \ldots \} \\Spec(2{\rm{ + }}\sqrt 2 ) = \{ \left\lfloor {2{\rm{ + }}\sqrt 2 } \right\rfloor ,\left\lfloor {2(2{\rm{ + }}\sqrt 2 )} \right\rfloor ,\left\lfloor {3(2{\rm{ + }}\sqrt 2 )} \right\rfloor , \ldots \} \end{array}\]<br>可以发现，这两个谱正好划分了正整数集。<br>证明方法也很简单，只要证明对任意正整数$n$，两个集合中小于$n$的元素个数之和为$n$，过程如下：<br>\[\begin{array}{l}\left\lfloor {k\sqrt 2 } \right\rfloor  \le n\\ \Rightarrow k\sqrt 2  &lt; n + 1\\ \Rightarrow k &lt; \frac{ {n + 1}}{ {\sqrt 2 }}\end{array}\]<br>所以第一个集合中小于$n$的元素个数为<br>\[\left\lfloor {\frac{ {n + 1}}{ {\sqrt 2 }}} \right\rfloor \]<br>同理第二个集合中小于$n$的元素个数为<br>\[\left\lfloor {\frac{ {n + 1}}{ {2 + \sqrt 2 }}} \right\rfloor \]<br>所以总个数为<br>\[\begin{array}{l}\left\lfloor {\frac{ {n + 1}}{ {\sqrt 2 }}} \right\rfloor  + \left\lfloor {\frac{ {n + 1}}{ {2 + \sqrt 2 }}} \right\rfloor \\ = \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  + \left\lfloor {\frac{ {2 - \sqrt 2 }}{2}(n + 1)} \right\rfloor \\ = n + 1 + \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  + \left\lfloor { - \frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor \\ = n + 1 + \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  + \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  - 1\\ = n\end{array}\]<br>得证。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第6课（下降阶乘幂）</title>
      <link href="/2018/04/02/concrete-math-6/"/>
      <url>/2018/04/02/concrete-math-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>上节课讲到下降阶乘幂和差分运算，这节课继续讲它和差分的各种性质。</p><h1 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h1><hr><p>首先在后面章节会证明，${(x + y)^{\underline{m}}}$的二项展开形式和普通的${(x + y)^m}$是一样的，这里提一下，暂时用不到。</p><h1 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h1><hr><p>接下来给出下降阶乘幂为负数的定义：<br>\[{x^{ \underline{- m}}} = \frac{1}{ {(x + 1)(x + 2) \ldots (x + m)}}\]</p><h1 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h1><hr><p>和普通幂${x^{m + n}} = {x^m}{x^n}$不同，下降阶乘幂有如下性质：<br>\[{x^{\underline{m + n}}} = {x^{\underline{m}}}{(x - m)^{\underline{n}}}\]</p><h1 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h1><hr><p>上一节课说到，定义下降阶乘幂的好处就是为了求差分方便，下降阶乘幂的差分为：<br>\[\Delta ({x^{\underline{m}}}) = m{x^{\underline{ {m - 1}}}}\]<br>反之，类比不定积分，它的不定和为：<br>\[\sum\nolimits_a^b { {x^{\underline{m}}}\delta x}  = \left. {\frac{ { {x^{\underline{m + 1}}}}}{ {m + 1}}} \right|_a^b\]</p><p>但是这里$m \ne  - 1$，那要是$m =  - 1$怎么办呢？<br>直接运用差分定义可以求出<br>\[\begin{array}{l}{x^{ \underline{- 1}}} = \frac{1}{ {x + 1}} = \Delta f(x) = f(x + 1) - f(x)\\ \Rightarrow f(x) = {H_x}\end{array}\]</p><p>所以<br>\[\sum\nolimits_a^b { {x^{\underline{m}}}\delta x}  = \left\{ {\begin{array}{*{20}{c}}{\left. {\frac{ { {x^{\underline{m + 1}}}}}{ {m + 1}}} \right|_a^b,m \ne  - 1}\\{\left. { {H_x}} \right|_a^b,m =  - 1}\end{array}} \right.\]</p><h1 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h1><hr><p>在微积分里面，$e^x$的导数是它自身。那么什么函数的差分是自身呢？<br>通过定义可以很容易算出来：<br>\[\begin{array}{l}f(x + 1) - f(x) = f(x)\\ \Rightarrow f(x + 1) = 2f(x)\\ \Rightarrow f(x) = {2^x}\end{array}\]</p><p>进一步推广可以得到：<br>\[\Delta ({c^x}) = {c^{x + 1}} - {c^x} = (c - 1){c^x}\]<br>所以得到如下一种新的等比数列计算方式：<br>\[\sum\limits_{a \le k &lt; b} { {c^k}}  = \sum\nolimits_a^b { {c^x}\delta x}  = \left. {\frac{ { {c^x}}}{ {c - 1}}} \right|_a^b = \frac{ { {c^b} - {c^a}}}{ {c - 1}}\]</p><h1 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h1><hr><p>结合律和分配律在差分运算里也适用。<br>\[\begin{array}{l}\Delta (cf) = c\Delta (f)\\\Delta (f + g) = \Delta (f) + \Delta (g)\end{array}\]</p><h1 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h1><hr><p>类似分部积分，这里也可以分部来求差分。<br>\[\begin{array}{l}\Delta (u(x)v(x)) = u(x + 1)v(x + 1) - u(x)v(x)\\ = u(x + 1)v(x + 1) - u(x)v(x + 1) + u(x)v(x + 1) - u(x)v(x)\\ = [u(x + 1) - u(x)]v(x + 1) + u(x)[v(x + 1) - v(x)]\\ = u(x)\Delta (v(x)) + v(x + 1)\Delta (u(x))\end{array}\]<br>这里给出一个新的记号叫做移位运算：<br>\[Ef(x) = f(x + 1)\]<br>所以就得到了差分的分部运算法则：<br>\[\Delta (uv) = u\Delta (v) + Ev\Delta (u)\]<br>对两边求和，又可以得到不定求和的分部运算法则：<br>\[\sum {u\Delta (v)}  = uv - \sum {Ev\Delta (u)} \]</p><p>这个分部法则非常有用，下面举两个例子来说明一下怎么用。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>一道老题，计算：<br>\[\sum\limits_{k = 0}^n {k{2^k}} \]<br>首先计算<br>\[\sum {x{2^x}\delta x} \]<br>在这里可以令<br>\[u = x,v = {2^x}\]<br>所以<br>\[\sum {x{2^x}\delta x}  = x{2^x} - \sum { {2^{x + 1}}\delta x}  = x{2^x} - {2^{x + 1}} + C\]<br>那么求和式就可以转化为不定求和来算了：<br>\[\begin{array}{l}\sum\limits_{k = 0}^n {k{2^k}}  = \sum\nolimits_0^{n + 1} {x{2^x}\delta x} \\ = \left. {x{2^x} - {2^{x + 1}}} \right|_0^{n + 1}\\ = (n - 1){2^{n + 1}} + 2\end{array}\]</p><h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p>计算<br>\[\sum\limits_{0 \le k &lt; n} {k{H_k}} \]<br>首先计算<br>\[\sum {x{H_x}\delta x} \]<br>这里注意要令<br>\[u = {H_x},\Delta v = x\]<br>不能倒过来哦，因为$H_x$的不定和很难求出来的。所以<br>\[\begin{array}{l}\sum {x{H_x}\delta x}  = \frac{ { {x^{\underline{2}}}}}{2}{H_x} - \sum {\frac{ { { {(x + 1)}^{\underline{2}}}}}{2}} {x^{ \underline{- 1}}}\delta x\\ = \frac{ { {x^{\underline{2}}}}}{2}{H_x} - \frac{1}{2}\sum { {x^{\underline{1}}}\delta x} \\ = \frac{ { {x^{\underline{2}}}}}{2}{H_x} - \frac{ { {x^{\underline{2}}}}}{4} + C\end{array}\]</p><p>所以<br>\[\sum\limits_{0 \le k &lt; n} {k{H_k}}  = \sum\nolimits_0^n {x{H_x}\delta x}  = \frac{ { {n^{\underline{2}}}}}{2}({H_n} - \frac{1}{2})\]</p><h1 id="无限求和"><a href="#无限求和" class="headerlink" title="无限求和"></a>无限求和</h1><hr><p>回顾一下以前我们是怎么计算下面求和式的。<br>\[S = {\rm{1}} + \frac{1}{2} + \frac{1}{4} +  \cdots \]<br>首先两边同时乘2，得到：<br>\[2S = 2 + {\rm{1}} + \frac{1}{2} + \frac{1}{4} +  \cdots  = 2 + S\]<br>解出<br>\[S = 2\]</p><p>那么可不可以用同样的方法计算下面式子呢？<br>\[T = 1 + 2 + 4 + 8 +  \cdots \]<br>两边同时乘2，得到：<br>\[2T = 2 + 4 + 8 +  \cdots  = T - 1\]<br>解出<br>\[T = -1\]<br>显然不可能，因为这里的$T$是发散的，所以不能这么求。那么如何用一般的方法来求解呢？</p><p>首先我们只考虑正数求和，求解$\sum\limits_{k \in K} { {a_k}} $，其中$K$是一个无限集合。<br>那么，如果存在$A$，使得对任意$F \subset K$，都有<br>\[\sum\limits_{k \in F} { {a_k}}  \le A\]<br>那么我们说这个最小的$A$就是$\sum\limits_{k \in K} { {a_k}} $的结果。<br>如果不存在这么一个$A$，那么这个求和式就是发散的，即结果为正无穷。</p><p>一般使用中，对于$K = N$，我们可以令$F = \{ 0,1,2, \ldots ,n\} $<br>所以<br>\[\sum\limits_{k \ge 0} { {a_k}}  = \mathop {\lim }\limits_{n \to \infty } \sum\limits_{k = 0}^n { {a_k}} \]</p><p>举两个例子，比如<br>\[\sum\limits_{k \ge 0} { {x^k}}  = \mathop {\lim }\limits_{n \to \infty } \frac{ {1 - {x^{n + 1}}}}{ {1 - x}} = \left\{ {\begin{array}{*{20}{c}}{\frac{1}{ {1 - x}},0 \le x &lt; 1}\\{\infty ,x \ge 1}\end{array}} \right.\]<br>再如：<br>\[\sum\limits_{k \ge 0} {\frac{1}{ {(k + 1)(k + 2)}}}  = \sum\limits_{k \ge 0} { {k^{ \underline{- 2}}}}  = \mathop {\lim }\limits_{n \to \infty } \sum\limits_{k = 0}^n { {k^{ \underline{- 2}}}}  = \mathop {\lim }\limits_{n \to \infty } \left. {\frac{ { {k^{ \underline{- 1}}}}}{ { - 1}}} \right|_0^{n + 1} = 1\]</p><p>剩下的问题就是如何求有正有负的和式？</p><p>可以考虑的方案就是用不同的配对，将正负组合在一起，从而相消求和。</p><p>但是不同的组合方式会得到不同的答案。就比如：<br>\[\sum\limits_{k \ge 0} { { {( - 1)}^k}}  = 1 - 1 + 1 - 1 +  \cdots \]<br>有两种组合方式：<br>\[(1 - 1) + (1 - 1) +  \cdots  = 0\]<br>和<br>\[1 - (1 - 1) - (1 - 1) -  \cdots  = 1\]<br>得到了两种不同的结果。</p><p>事实上，我们可以将正数和负数分开求和，因为正数求和我们已经解决了，所以我们定义：<br>\[x = {x^ + } - {x^ - }\]<br>其中<br>\[{x^ + } = x \cdot [x &gt; 0],{x^ - } =  - x \cdot [x &lt; 0]\]</p><p>所以求和式可以分成两部分分别求和：<br>\[\sum\limits_{k \in K} { {a_k}}  = \sum\limits_{k \in K} { {a_k}^ + }  - \sum\limits_{k \in K} { {a_k}^ - } \]</p><p>最后推广到二重求和：<br>\[\sum\limits_{j \in J,k \in {K_j}} { {a_{j,k}}}  = \sum\limits_{j \in J} {\sum\limits_{k \in {K_j}} { {a_{j,k}}} }  = \sum\limits_{j \in J} { {A_j}}  = A\]</p><p>这里也没啥好细说的，就先了解了解吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第5课（8种方法求和）</title>
      <link href="/2018/03/26/concrete-math-5/"/>
      <url>/2018/03/26/concrete-math-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天继续讲求和的方法。<br>针对以下求和式，我们用8种方法来求解：<br>\[{S_n} = \sum\limits_{0 \le k \le n} { {k^2}} \]<br>大家应该都已经背上了它的答案：<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><h1 id="方法0"><a href="#方法0" class="headerlink" title="方法0"></a>方法0</h1><hr><p><strong>查表。</strong><br>这就不用说了，很多文献都有现成的解，拿来直接用就行了。<br>再给大家推荐一个整数序列查询网站OEIS：<a href="http://oeis.org/" target="_blank" rel="noopener">链接</a></p><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><hr><p><strong>猜答案，然后用数学归纳法证明。</strong><br>这个也不多说了，前提是你得猜得出来，这题的公式还是很难猜的。</p><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><hr><p><strong>扰动法。</strong><br>令<br>\[T = \sum\limits_{0 \le k \le n} { {k^3}} \]<br>所以<br>\[\begin{array}{l}T + {(n + 1)^3}\\ = \sum\limits_{1 \le k \le n + 1} { {k^3}} \\ = \sum\limits_{1 \le k \le n + 1} { { {(k - 1)}^3}}  + \sum\limits_{1 \le k \le n + 1} {(3{k^2} - 3k + 1)} \\ = \sum\limits_{0 \le k \le n} { {k^3}}  + \sum\limits_{1 \le k \le n + 1} {[3{ {(k - 1)}^2} + 3k - 2]} \\ = T + 3{S_n} + \frac{ {3(n + 2)(n + 1)}}{2} - 2(n + 1)\end{array}\]<br>解出<br>\[3{S_n} = {(n + 1)^3} - \frac{ {3(n + 2)(n + 1)}}{2} + 2(n + 1) = n(n + \frac{1}{2})(n + 1)\]<br>最终得到<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>可以看出，我们本来是要对$k^2$求和的，但是只要对$k^3$用扰动法求和即可，因为求和过程中$k^3$项会被抵消掉。</p><h1 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h1><hr><p><strong>成套方法。</strong><br>定义如下递归式：<br>\[\begin{array}{l}{R_0} = \alpha \\{R_n} = {R_{n - 1}} + \beta  + \gamma n + \delta {n^2}\end{array}\]<br>由<a href="http://godweiyang.com/2018/03/05/concrete-math-2/">第2课</a>可知，设解的形式为：<br>\[{R_n} = A(n)\alpha  + B(n)\beta  + C(n)\gamma  + D(n)\delta \]<br>分别令${R_n} = 1,n,{n^2}$可以解出<br>\[A(n) = 1,B(n) = n,C(n) = \frac{ {n(n + 1)}}{2}\]<br>再另${R_n} = {n^3}$，可以得到<br>\[3D(n) = {n^3} + 3C(n) - B(n) = n(n + \frac{1}{2})(n + 1)\]<br>即<br>\[D(n) = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>这时如果令<br>\[\alpha  = \beta  = \gamma  = 0,\delta  = 1\]<br>那么<br>\[{R_n} = \sum\limits_{0 \le k \le n} { {k^2}}  = D(n) = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><h1 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h1><hr><p><strong>积分法</strong><br>求和式可以近似成积分\[\int_0^n { {x^2}dx}  = {n^3}/3\]<br>但是还少算了一部分误差，设为$E_n$，则有<br>\[{E_n} = {S_n} - \frac{1}{3}{n^3} = {S_{n - 1}} + {n^2} - \frac{1}{3}{n^3} = {E_{n - 1}} + n - \frac{1}{3}\]<br>解得<br>\[{E_n} = \frac{ {3{n^2} + n}}{6}\]<br>所以<br>\[{S_n} = {E_n} + \frac{1}{3}{n^3} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>其实这种方法就是把最高次直接给算出来了，低次项可以直接求和的。</p><h1 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h1><hr><p><strong>扩展成二重指标求和</strong><br>\[\begin{array}{l}{S_n} = \sum\limits_{1 \le k \le n} { {k^2}}  = \sum\limits_{1 \le j \le k \le n} { {k^2}} \\ = \sum\limits_{1 \le j \le n} {\sum\limits_{j \le k \le n} k } \\ = \sum\limits_{1 \le j \le n} {(\frac{ {j + n}}{2})(n - j + 1)} \\ = \frac{1}{2}\sum\limits_{1 \le j \le n} {(n(n + 1) + j - {j^2})} \\ = \frac{1}{2}{n^2}(n + 1) + \frac{1}{4}n(n + 1) - \frac{1}{2}{S_n}\\ = \frac{1}{2}n(n + \frac{1}{2})(n + 1) - \frac{1}{2}{S_n}\end{array}\]<br>所以<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><h1 id="方法6"><a href="#方法6" class="headerlink" title="方法6"></a>方法6</h1><hr><p><strong>用有限微分求和</strong><br>微分的形式大家都知道，如下：<br>\[\Delta f(x) = f(x + 1) - f(x)\]<br>那如果我们定义<br>\[f(x) = {x^m}\]<br>则有<br>\[\Delta f(x) = {(x + 1)^m} - {x^m}\]<br>似乎并不能和导数形式统一起来，用起来也不方便，那么我们定义一个新的函数，叫做<strong>下降阶乘幂</strong>：<br>\[f(x) = {x^{\underline{m}}} = x(x - 1) \ldots (x - m + 1)\]<br>同理还可以定义<strong>上升阶乘幂</strong>。<br>这个函数有一个很好的性质，那就是<br>\[\Delta ({x^{\underline{m}}}) = m{x^{\underline{ {m - 1}}}}\]<br>令<br>\[g(x) = \Delta f(x)\]<br>那么和积分类似，有<br>\[\sum\nolimits_a^b {g(x)\delta x}  = f(b) - f(a)\]<br>所以<br>\[\sum\limits_{0 \le k &lt; n} { {k^{\underline{m}}}}  = \left. {\frac{ { {k^{ {\underline{m + 1}}}}}}{ {m + 1}}} \right|_0^n = \frac{ { {n^{ {\underline{m + 1}}}}}}{ {m + 1}}\]</p><p>因为有<br>\[{k^2} = {k^{\underline{2}}} + {k^{\underline{1}}}\]<br>所以<br>\[\sum\limits_{0 \le k &lt; n} { {k^2}}  = \frac{ { {n^{\underline{3}}}}}{3} + \frac{ { {n^{\underline{2}}}}}{2} = \frac{ {n(n - 1)(2n - 1)}}{6}\]<br>同样可以得到<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>下降阶乘幂还有很多好用的性质，下节课继续。</p><h1 id="方法7"><a href="#方法7" class="headerlink" title="方法7"></a>方法7</h1><hr><p><strong>生成函数。</strong><br>以后章节会讲。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第二章作业解答</title>
      <link href="/2018/03/19/concrete-math-hw2/"/>
      <url>/2018/03/19/concrete-math-hw2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这章作业提前先做掉了，不是很难，有些算着麻烦了一点，就是倒数第二题不大解释的清楚。</p><p><img src="1.jpg" alt><br><img src="2.jpg" alt><br><img src="3.jpg" alt><br><img src="4.jpg" alt><br><img src="5.jpg" alt><br><img src="6.jpg" alt><br><img src="7.jpg" alt><br><img src="8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第4课（多重求和方法）</title>
      <link href="/2018/03/19/concrete-math-4/"/>
      <url>/2018/03/19/concrete-math-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天讲了多重求和，也就是一个和式由多个下标来指定。</p><p>首先是最简单的形式：<br>\[\sum\limits_{1 \le j,k \le n} { {a_j}{b_k}}  = (\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {a_k}} )\]</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>下面给出一个对称矩阵：<br>\[A(i,j) = {a_i}{a_j}\]<br>求：<br>\[S = \sum\limits_{1 \le j \le k \le n} { {a_j}{a_k}} \]<br>这是这个矩阵的上三角加对角线求和，因为是对称的嘛，可以补全下三角，加上对角线就行了。<br>\[2S = \sum\limits_{1 \le j,k \le n} { {a_j}{a_k}}  + \sum\limits_{1 \le j = k \le n} { {a_j}{a_k}}  = {(\sum\limits_{1 \le k \le n} { {a_k}} )^2} + \sum\limits_{1 \le k \le n}^{} { {a_k}^2} \]<br>所以<br>\[S = \frac{1}{2}({(\sum\limits_{1 \le k \le n} { {a_k}} )^2} + \sum\limits_{1 \le k \le n}^{} { {a_k}^2} )\]</p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><hr><p>下面再看一个例子：<br>\[S = \sum\limits_{1 \le j &lt; k \le n} {({a_j} - {a_k})({b_j} - {b_k})} \]<br>同样模仿上例调换$j,k$位置，得到：<br>\[\begin{array}{l}2S = \sum\limits_{1 \le j,k \le n} {({a_j} - {a_k})({b_j} - {b_k})}  - \sum\limits_{1 \le j = k \le n} {({a_j} - {a_k})({b_j} - {b_k})} \\ = \sum\limits_{1 \le j,k \le n} {({a_j}{b_j} - {a_j}{b_k} - {a_k}{b_j} + {a_k}{b_k})} \\ = 2\sum\limits_{1 \le j,k \le n} { {a_j}{b_j}}  - 2\sum\limits_{1 \le j,k \le n} { {a_j}{b_k}} \\ = 2n\sum\limits_{1 \le j \le n} { {a_j}{b_j}}  - 2(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} )\end{array}\]<br>所以<br>\[S = n\sum\limits_{1 \le j \le n} { {a_j}{b_j}}  - (\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} )\]<br>至此解完，然后可以推出一个著名的不等式————切比雪夫不等式：<br>\[(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} ) = n\sum\limits_{1 \le j \le n} { {a_j}{b_j}}  - \sum\limits_{1 \le j &lt; k \le n} {({a_j} - {a_k})({b_j} - {b_k})} \]<br>如果<br>\[{a_1} \le {a_2} \le  \cdots  \le {a_n},{b_1} \le {b_2} \le  \cdots  \le {b_n}\]<br>那么<br>\[(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} ) \le n\sum\limits_{1 \le j \le n} { {a_j}{b_j}} \]<br>反之如果<br>\[{a_1} \le {a_2} \le  \cdots  \le {a_n},{b_1} \ge {b_2} \ge  \cdots  \ge {b_n}\]<br>那么<br>\[(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} ) \ge n\sum\limits_{1 \le j \le n} { {a_j}{b_j}} \]<br>更一般的结论，给定两个序列$a$和$b$，求下面式子最大值与最小值：<br>\[\sum\limits_{k = 1}^n { {a_k}{b_{p(k)}}} \]<br>其中$p(k)$是$\{ 1,2, \cdots ,n\} $的一个排列。<br>答案是$b$增序最大，降序最小，至于为什么，下面给出两种证明方法。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><img src="1.jpg" alt><br>如上图所示，$a$和$b$按照递增顺序排列，每个方格的面积代表$a_i$与$b_j$的乘积，记为$s_{ij}$。<br>那么上面的求和式其实就是每一行每一列都必须有且只有一块被取。<br>考虑第一行，如果不取$s_{11}$，取其他的$s_{1j}$，那么第一列也只能取其他的$s_{i1}$，这样的话$s_{ij}$也就取不了了。但是发现<br>\[s_{11}+s_{ij} \ge s_{i1}+s_{1j}\]<br>并且两种取法影响的行和列都是相同的，这说明了，取$s_{i1}$和$s_{1j}$不如取$s_{11}$和$s_{ij}$。所以$s_{11}$必取，然后第一行第一列就不能取了。剩下的方阵用相同的方法可以得出必取$s_{22}, \cdots ,s_{nn}$，也就是主对角线。<br>同理最小取法用副对角线可以推出。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>设数列$a$和$b$非单调递减，那么有如下证明：<br>\[\begin{array}{l}{S_k} = \sum\limits_{i = 1}^k { {b_i}} ,{ {S’}_k} = \sum\limits_{i = 1}^k { {b_{p(i)}}} \\ \Rightarrow {S_k} \le { {S’}_k}\\ \Rightarrow \\\sum\limits_{i = 1}^n { {a_i}{b_i}}  = {S_1}{a_1} - {S_1}{a_2} + {S_2}{a_2} - {S_2}{a_3} +  \cdots  + {S_n}{a_n}\\ = \sum\limits_{i = 1}^{n - 1} { {S_i}} ({a_i} - {a_{i + 1}}) + {S_n}{a_n}\\ \ge \sum\limits_{i = 1}^{n - 1} { { {S’}_i}} ({a_i} - {a_{i + 1}}) + {S_n}{a_n}\\ = \sum\limits_{i = 1}^n { {a_i}{b_{p(i)}}} \end{array}\]<br>反之亦证。</p><p>题外话，其实切比雪夫不等式原来是以微积分形式给出的：<br>如果函数$f(x)$和$g(x)$非单调递减，那么有：<br>\[(\int_a^b {f(x)dx} )(\int_a^b {g(x)dx} ) \le (b - a)(\int_a^b {f(x)g(x)dx} )\]</p><h1 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h1><hr><p>求<br>\[S = \sum\limits_{1 \le j &lt; k \le n} {\frac{1}{ {k - j}}} \]<br>我将用三种方法来求解这个式子。</p><h3 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h3><p>首先将$j$和$k$分开，首先计算对$j$求和：<br>\[\begin{array}{l}S = \sum\limits_{1 \le k \le n} {\sum\limits_{1 \le j &lt; k} {\frac{1}{ {k - j}}} } \\ = \sum\limits_{1 \le k \le n} {\sum\limits_{1 \le k - j &lt; k} {\frac{1}{j}} } \\ = \sum\limits_{1 \le k \le n} {\sum\limits_{0 &lt; j \le k - 1} {\frac{1}{j}} } \\ = \sum\limits_{1 \le k \le n} { {H_{k - 1}}} \\ = \sum\limits_{0 \le k &lt; n} { {H_k}} \end{array}\]</p><h3 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h3><p>先计算对$k$求和：<br>\[\begin{array}{l}S = \sum\limits_{1 \le j \le n} {\sum\limits_{j &lt; k \le n} {\frac{1}{ {k - j}}} } \\ = \sum\limits_{1 \le j \le n} {\sum\limits_{j &lt; k + j \le n} {\frac{1}{k}} } \\ = \sum\limits_{1 \le j \le n} {\sum\limits_{0 &lt; k \le n - j} {\frac{1}{k}} } \\ = \sum\limits_{1 \le j \le n} { {H_{n - j}}} \\ = \sum\limits_{0 \le j &lt; n} { {H_j}} \end{array}\]</p><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>按对角线求和：<br>\[\begin{array}{l}S = \sum\limits_{1 \le j &lt; k \le n} {\frac{1}{ {k - j}}} \\ = \sum\limits_{1 \le j &lt; k + j \le n} {\frac{1}{k}} \\ = \sum\limits_{1 \le k \le n} {\sum\limits_{1 \le j \le n - k} {\frac{1}{k}} } \\ = \sum\limits_{1 \le k \le n} {\frac{ {n - k}}{k}} \\ = n\sum\limits_{1 \le k \le n} {\frac{1}{k} - } \sum\limits_{1 \le k \le n} 1 \\ = n{H_n} - n\end{array}\]</p><p>由此得到了一个完全不同的表示形式！<br>所以我们得到了：<br>\[\sum\limits_{0 \le j &lt; n} { {H_j}}  = n{H_n} - n\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业论文相关细节记录</title>
      <link href="/2018/03/18/graduate-technique/"/>
      <url>/2018/03/18/graduate-technique/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h1><hr><p>这是玄学，姑且就设为我的QQ号，看起来效果不错。</p><h1 id="神经网络维数"><a href="#神经网络维数" class="headerlink" title="神经网络维数"></a>神经网络维数</h1><hr><p>不断测试发现，64维效果最好，但最后可能改成512维的。<br>而且64维的话CPU跑的比GPU还要快6倍，但是512维的话GPU就比CPU快6倍左右了。<br>所以维度低还是用CPU比较好。</p><h1 id="结点分数"><a href="#结点分数" class="headerlink" title="结点分数"></a>结点分数</h1><hr><p>\[\begin{array}{l}Score(A \to BC) = \lambda d \cdot (W \cdot e + b) + Spcfg(A)\\Spcfg(A) = \log (Spcfg(B) \cdot Spcfg(C) \cdot p(A \to BC))\end{array}\]<br>其中$d,W,b$是权值矩阵，$\lambda$是超参数，测试发现设为100左右效果最好。</p><h1 id="结点表示"><a href="#结点表示" class="headerlink" title="结点表示"></a>结点表示</h1><hr><p>\[e = LST{M^{left}}({e_{right}})\]<br>至于用左儿子还是右儿子作为LSTM，还是加一层动态规划记录两者最优值，小数据上暂时没有太大差别。</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><hr><p>\[L(\theta ) = Scor{e_{predict}}(ROOT) - Scor{e_{gold}}(ROOT) + k \cdot \Delta (predict,gold) + \frac{1}{2}{\left| \theta  \right|^2}\]<br>其中正则项加了可以使loss下降更稳定，但是效果貌似不如不加，可能是因为数据集太小吧。<br>$k$一般取0.1。</p><h1 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h1><hr><p>batch取50左右效果最好，不过我用的是dynet自带的自动batch，手动batch还不是很会写，所以效率提升不是很大。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr><p>原来是4层循环，用时特别久，改进了一下变成6层循环效率大大提高。<br>原算法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">0</span> to n    <span class="token keyword">for</span> j <span class="token keyword">from</span> <span class="token number">0</span> to n        <span class="token keyword">for</span> k <span class="token keyword">from</span> i to j            <span class="token keyword">for</span> A<span class="token operator">-</span><span class="token operator">></span>BC <span class="token keyword">in</span> grammar                balabala<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改进算法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">0</span> to n    <span class="token keyword">for</span> j <span class="token keyword">from</span> <span class="token number">0</span> to n        <span class="token keyword">for</span> k <span class="token keyword">from</span> i to j            <span class="token keyword">for</span> B <span class="token keyword">in</span> nodetype<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                <span class="token keyword">for</span> C <span class="token keyword">in</span> nodetype<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                    <span class="token keyword">for</span> A <span class="token keyword">in</span> panode<span class="token punctuation">[</span>BC<span class="token punctuation">]</span>                        balabala<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="未来改进"><a href="#未来改进" class="headerlink" title="未来改进"></a>未来改进</h1><hr><ul><li>如果测试集中的句法规则在训练集中没有出现的话，会直接产生None的结果，是否可以考虑产生新的规则，这样就可以对所有句子进行句法分析了？</li><li>效率虽然有了很大提升，但是大数据依然跑的很慢，可以考虑加上手动batch、减少规则数量、动态规划算法优化等等。</li></ul><p>最后附上我的主要代码（丑是丑了点，不喜勿喷，封装什么的以后再说）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict <span class="token keyword">as</span> dd<span class="token punctuation">,</span> defaultdict<span class="token keyword">from</span> itertools <span class="token keyword">import</span> count<span class="token keyword">import</span> re<span class="token keyword">import</span> time<span class="token keyword">import</span> math<span class="token keyword">import</span> _dynet <span class="token keyword">as</span> dydyparams <span class="token operator">=</span> dy<span class="token punctuation">.</span>DynetParams<span class="token punctuation">(</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>from_args<span class="token punctuation">(</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>set_requested_gpus<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>set_mem<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>set_random_seed<span class="token punctuation">(</span><span class="token number">792321264</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># read train file</span>DEBUG <span class="token operator">=</span> <span class="token boolean">True</span>train_string_file <span class="token operator">=</span> <span class="token string">"data/train.strings"</span>train_tree_file <span class="token operator">=</span> <span class="token string">"data/train.trees.pre.unk"</span>dev_string_file <span class="token operator">=</span> <span class="token string">"data/dev.strings"</span>dev_tree_file <span class="token operator">=</span> <span class="token string">"data/dev.trees"</span>dev_parse_file <span class="token operator">=</span> <span class="token string">"data/dev.parses"</span><span class="token keyword">if</span> DEBUG<span class="token punctuation">:</span>    train_string_file <span class="token operator">=</span> <span class="token string">"data/train_small.strings"</span>    train_tree_file <span class="token operator">=</span> <span class="token string">"data/train_small.trees.pre.unk"</span>    dev_string_file <span class="token operator">=</span> <span class="token string">"data/dev_small.strings"</span>    dev_tree_file <span class="token operator">=</span> <span class="token string">"data/dev_small.trees"</span>    dev_parse_file <span class="token operator">=</span> <span class="token string">"data/dev_small.parses"</span>train_string <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>train_tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">with</span> open<span class="token punctuation">(</span>train_string_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>        train_string<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span>        <span class="token keyword">for</span> word <span class="token keyword">in</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"&lt;unk>"</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span>train_tree_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>        train_tree<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span>w2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>    w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span>i2w <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> w2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>nwords <span class="token operator">=</span> len<span class="token punctuation">(</span>w2i<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># read grammar file</span>nonTerms <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>rules_set1 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>rules_set2 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>rules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>lexicons <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>origText <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>probs <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>node_pa <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">read_grammar</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>    grammar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    file <span class="token operator">=</span> open<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> rule <span class="token keyword">in</span> file<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># AAA -> # BBB @ prob</span>        tokens <span class="token operator">=</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">"\-\>|\@"</span><span class="token punctuation">,</span> rule<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        lhs <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        rhs <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span>r<span class="token string">'\''</span><span class="token punctuation">)</span>        rhs <span class="token operator">=</span> rhs<span class="token punctuation">.</span>strip<span class="token punctuation">(</span>r<span class="token string">'\"'</span><span class="token punctuation">)</span>        prob <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        probs<span class="token punctuation">[</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> float<span class="token punctuation">(</span>prob<span class="token punctuation">)</span>        nonTerms<span class="token punctuation">.</span>add<span class="token punctuation">(</span>lhs<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            rules_set1<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            rules_set2<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> rhs <span class="token keyword">in</span> node_pa<span class="token punctuation">:</span>                node_pa<span class="token punctuation">[</span>rhs<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>lhs<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                node_pa<span class="token punctuation">[</span>rhs<span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>                node_pa<span class="token punctuation">[</span>rhs<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>lhs<span class="token punctuation">)</span>        rules<span class="token punctuation">[</span>lhs<span class="token punctuation">]</span> <span class="token operator">=</span> rhs        <span class="token keyword">if</span> len<span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">and</span> rhs <span class="token operator">!=</span> <span class="token string">'&lt;unk>'</span><span class="token punctuation">:</span>            lexicons<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token keyword">if</span> DEBUG<span class="token punctuation">:</span>    grammar <span class="token operator">=</span> read_grammar<span class="token punctuation">(</span><span class="token string">'data/pcfg_small'</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    grammar <span class="token operator">=</span> read_grammar<span class="token punctuation">(</span><span class="token string">'data/pcfg'</span><span class="token punctuation">)</span><span class="token keyword">print</span> rules_set1<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rules_set2<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># LSTM and parameters initialization</span>EPOCH <span class="token operator">=</span> <span class="token number">40</span>EMBDDING_SIZE <span class="token operator">=</span> <span class="token number">512</span>lamda <span class="token operator">=</span> <span class="token number">100</span>k <span class="token operator">=</span> <span class="token number">0.1</span>model <span class="token operator">=</span> dy<span class="token punctuation">.</span>ParameterCollection<span class="token punctuation">(</span><span class="token punctuation">)</span>builder <span class="token operator">=</span> dy<span class="token punctuation">.</span>FastLSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">,</span> model<span class="token punctuation">)</span>trainer <span class="token operator">=</span> dy<span class="token punctuation">.</span>AdamTrainer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>WORDS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>nwords<span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>pd <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>pW <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>EMBDDING_SIZE<span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>pb <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>EMBDDING_SIZE<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># construct trees</span><span class="token keyword">class</span> <span class="token class-name">MTree</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lhs<span class="token punctuation">,</span> wrd<span class="token operator">=</span>None<span class="token punctuation">,</span> subs<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>label <span class="token operator">=</span> lhs        self<span class="token punctuation">.</span>word <span class="token operator">=</span> wrd        self<span class="token punctuation">.</span>subs <span class="token operator">=</span> subs        self<span class="token punctuation">.</span>str <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">is_lexicon</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>word <span class="token keyword">is</span> <span class="token operator">not</span> None    <span class="token keyword">def</span> <span class="token function">dostr</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"(%s %s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>label<span class="token punctuation">,</span> self<span class="token punctuation">.</span>word<span class="token punctuation">)</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_lexicon<span class="token punctuation">(</span><span class="token punctuation">)</span> \                <span class="token keyword">else</span> <span class="token string">"(%s %s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>label<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> self<span class="token punctuation">.</span>subs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token boolean">True</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>str <span class="token keyword">is</span> None<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>str <span class="token operator">=</span> self<span class="token punctuation">.</span>dostr<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>str<span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>    begin <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    end <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    A <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> next <span class="token operator">not</span> <span class="token keyword">in</span> backPointers<span class="token punctuation">:</span>        <span class="token keyword">if</span> next <span class="token keyword">in</span> terminals<span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#base condition</span>            word <span class="token operator">=</span> origText<span class="token punctuation">[</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            node <span class="token operator">=</span> MTree<span class="token punctuation">(</span>lhs<span class="token operator">=</span>A<span class="token punctuation">,</span> subs<span class="token operator">=</span>None<span class="token punctuation">,</span> wrd<span class="token operator">=</span>word<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>split<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=</span> backPointers<span class="token punctuation">[</span>next<span class="token punctuation">]</span>    next1 <span class="token operator">=</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span>    next2 <span class="token operator">=</span> <span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span>    t1<span class="token punctuation">,</span> s1 <span class="token operator">=</span> helper<span class="token punctuation">(</span>next1<span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    t2<span class="token punctuation">,</span> s2 <span class="token operator">=</span> helper<span class="token punctuation">(</span>next2<span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>MTree<span class="token punctuation">(</span>lhs<span class="token operator">=</span>A<span class="token punctuation">,</span> subs<span class="token operator">=</span><span class="token punctuation">[</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">]</span><span class="token punctuation">,</span> wrd<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>text<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> backPointers<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    t<span class="token punctuation">,</span> s <span class="token operator">=</span> helper<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'S'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">math_log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">100</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">score_calc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> p<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> d <span class="token operator">*</span> <span class="token punctuation">(</span>W <span class="token operator">*</span> p <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> lamda <span class="token operator">+</span> s_pcfg<span class="token keyword">def</span> <span class="token function">cal_loss</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> gold<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> result <span class="token operator">==</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> dy<span class="token punctuation">.</span>inputTensor<span class="token punctuation">(</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>gold<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> result<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    gold <span class="token operator">=</span> gold<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    cnt <span class="token operator">=</span> dy<span class="token punctuation">.</span>inputTensor<span class="token punctuation">(</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> cnt<span class="token keyword">def</span> <span class="token function">cal_gold</span><span class="token punctuation">(</span>gold<span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    words <span class="token operator">=</span> gold<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        A <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        word <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># print gold, word, w2i[word]</span>        LSTM <span class="token operator">=</span> builder<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>        TMP <span class="token operator">=</span> LSTM<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>WORDS_LOOKUP<span class="token punctuation">[</span>w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        e <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>        s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> e<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">,</span> TMP<span class="token punctuation">,</span> A<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        sz <span class="token operator">=</span> len<span class="token punctuation">(</span>gold<span class="token punctuation">)</span>        p <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> i                <span class="token keyword">break</span>        m <span class="token operator">=</span> <span class="token number">0</span>        cnt <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>                cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>                cnt <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                m <span class="token operator">=</span> i                <span class="token keyword">break</span>        x1<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s1_pcfg<span class="token punctuation">,</span> LSTM1<span class="token punctuation">,</span> B <span class="token operator">=</span> cal_gold<span class="token punctuation">(</span>gold<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">:</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        x2<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s2_pcfg<span class="token punctuation">,</span> LSTM2<span class="token punctuation">,</span> C <span class="token operator">=</span> cal_gold<span class="token punctuation">(</span>gold<span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">2</span> <span class="token punctuation">:</span> sz<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        A <span class="token operator">=</span> gold<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>p<span class="token punctuation">]</span>        TMP <span class="token operator">=</span> LSTM2<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>x1<span class="token punctuation">)</span>        e <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>        s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>C<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> s1_pcfg <span class="token operator">+</span> s2_pcfg        ss1 <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> e<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> ss1<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">,</span> TMP<span class="token punctuation">,</span> A<span class="token punctuation">)</span>total_time <span class="token operator">=</span> <span class="token number">0.0</span><span class="token comment" spellcheck="true"># print nonTerms.__len__()</span>ff <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"loss.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">"epoch %d"</span> <span class="token operator">%</span> epoch    sumloss <span class="token operator">=</span> <span class="token number">0</span>    num <span class="token operator">=</span> len<span class="token punctuation">(</span>train_string<span class="token punctuation">)</span>    batch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> line <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_string<span class="token punctuation">)</span><span class="token punctuation">:</span>        sstart <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        gold <span class="token operator">=</span> train_tree<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        sent <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>        origText <span class="token operator">=</span> list<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>        d <span class="token operator">=</span> pd<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>        W <span class="token operator">=</span> pW<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>        b <span class="token operator">=</span> pb<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>        terminals <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        embdding <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        score <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>        score_pcfg <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>        backPointers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        LSTM <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        node_rules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            begin <span class="token operator">=</span> i            end <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>            word <span class="token operator">=</span> sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">for</span> A <span class="token keyword">in</span> nonTerms<span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span> <span class="token keyword">in</span> rules_set1<span class="token punctuation">:</span>                    LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> builder<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>                    LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>WORDS_LOOKUP<span class="token punctuation">[</span>w2i<span class="token punctuation">[</span>sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                    score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    terminals<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> word                    node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">for</span> span <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> begin <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> span <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                end <span class="token operator">=</span> begin <span class="token operator">+</span> span                node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> split <span class="token keyword">in</span> range<span class="token punctuation">(</span>begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> B <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        <span class="token keyword">for</span> C <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                            X <span class="token operator">=</span> B<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>C                            <span class="token keyword">if</span> X <span class="token keyword">in</span> node_pa<span class="token punctuation">:</span>                                <span class="token keyword">for</span> A <span class="token keyword">in</span> node_pa<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">:</span>                                    node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>                                    TMP <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                    p <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span>                                    s <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> p<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span>                                    <span class="token comment" spellcheck="true"># print (d * (W * p + b) * 100).value(), s_pcfg</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> score <span class="token operator">or</span> s<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                        LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> TMP                                        score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s                                        score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s_pcfg                                        embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> p                                        backPointers<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>split<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>        t<span class="token punctuation">,</span> s <span class="token operator">=</span> backtrack<span class="token punctuation">(</span>sent<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>        result <span class="token operator">=</span> None        <span class="token keyword">if</span> t <span class="token operator">!=</span> None<span class="token punctuation">:</span>            result <span class="token operator">=</span> t<span class="token punctuation">.</span>dostr<span class="token punctuation">(</span><span class="token punctuation">)</span>        golds_e<span class="token punctuation">,</span> golds<span class="token punctuation">,</span> golds_pcfg<span class="token punctuation">,</span> lstm<span class="token punctuation">,</span> S <span class="token operator">=</span> cal_gold<span class="token punctuation">(</span>gold<span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        cnt <span class="token operator">=</span> cal_loss<span class="token punctuation">(</span>result<span class="token punctuation">,</span> gold<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># loss = dy.abs(s - golds) + cnt * k</span>        loss <span class="token operator">=</span> dy<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>s <span class="token operator">-</span> golds<span class="token punctuation">)</span> <span class="token operator">+</span> cnt <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> <span class="token punctuation">(</span>dy<span class="token punctuation">.</span>l2_norm<span class="token punctuation">(</span>W<span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span>l2_norm<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span>l2_norm<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>        sumloss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>        batch<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>batch<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">50</span><span class="token punctuation">:</span>            loss <span class="token operator">=</span> dy<span class="token punctuation">.</span>esum<span class="token punctuation">(</span>batch<span class="token punctuation">)</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            trainer<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>            dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>            batch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        eend <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># print "time of sent ", idx, ": ", eend - sstart</span>        <span class="token keyword">if</span> idx <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> idx <span class="token operator">%</span> <span class="token number">500</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> <span class="token string">"time of 500 sent: "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>eend <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>idx <span class="token operator">/</span> <span class="token number">500</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># print idx, " -------------"</span>            <span class="token comment" spellcheck="true"># print "result: " + result</span>            <span class="token comment" spellcheck="true"># print "gold:   " + gold</span>            <span class="token comment" spellcheck="true"># print "loss: ", loss.value()</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    total_time <span class="token operator">+=</span> end <span class="token operator">-</span> start    <span class="token keyword">print</span> <span class="token string">"epoch time: "</span><span class="token punctuation">,</span> end <span class="token operator">-</span> start    <span class="token keyword">print</span> <span class="token string">"epoch loss: "</span><span class="token punctuation">,</span> sumloss <span class="token operator">/</span> num    ff<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'%f\n'</span><span class="token operator">%</span><span class="token punctuation">(</span>sumloss <span class="token operator">/</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">"total time: "</span><span class="token punctuation">,</span> total_timefh <span class="token operator">=</span> open<span class="token punctuation">(</span>dev_string_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>outfile <span class="token operator">=</span> open<span class="token punctuation">(</span>dev_parse_file<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>    sent <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    origText <span class="token operator">=</span> list<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> word <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>sent<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> word <span class="token operator">not</span> <span class="token keyword">in</span> lexicons<span class="token punctuation">:</span>            sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'&lt;unk>'</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    d <span class="token operator">=</span> pd<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>    W <span class="token operator">=</span> pW<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> pb<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>    terminals <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    embdding <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    score <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>    score_pcfg <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>    backPointers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    LSTM <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    node_rules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        begin <span class="token operator">=</span> i        end <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        word <span class="token operator">=</span> sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> A <span class="token keyword">in</span> nonTerms<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span> <span class="token keyword">in</span> rules_set1<span class="token punctuation">:</span>                LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> builder<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>                LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>WORDS_LOOKUP<span class="token punctuation">[</span>w2i<span class="token punctuation">[</span>sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                terminals<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> word                node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>    <span class="token keyword">for</span> span <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> begin <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> span <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            end <span class="token operator">=</span> begin <span class="token operator">+</span> span            node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> split <span class="token keyword">in</span> range<span class="token punctuation">(</span>begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> B <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> C <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        X <span class="token operator">=</span> B<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>C                        <span class="token keyword">if</span> X <span class="token keyword">in</span> node_pa<span class="token punctuation">:</span>                            <span class="token keyword">for</span> A <span class="token keyword">in</span> node_pa<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">:</span>                                node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>                                TMP <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                p <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                                s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span>                                s <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> p<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> score <span class="token operator">or</span> s<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                    LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> TMP                                    score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s                                    score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s_pcfg                                    embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> p                                    backPointers<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>split<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>    t<span class="token punctuation">,</span> s <span class="token operator">=</span> backtrack<span class="token punctuation">(</span>sent<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    <span class="token keyword">if</span> t <span class="token operator">==</span> None<span class="token punctuation">:</span>        outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"None\n"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> t<span class="token punctuation">.</span>dostr<span class="token punctuation">(</span><span class="token punctuation">)</span>        outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>result<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第3课（递归式转化为求和求解）</title>
      <link href="/2018/03/12/concrete-math-3/"/>
      <url>/2018/03/12/concrete-math-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天讲了一种将递归式转化为求和的方法。 </p><p>考虑如下递归式：<br>\[{a_n}{T_n} = {b_n}{T_{n - 1}} + {c_n}\]<br>两边同时乘以$s_n$得到：<br>\[{s_n}{a_n}{T_n} = {s_n}{b_n}{T_{n - 1}} + {s_n}{c_n}\]<br>要想转化成可以求和的递归式，那么必须有：<br>\[{s_n}{b_n} = {s_{n - 1}}{a_{n - 1}}\]<br>也就是：<br>\[{s_n} = \frac { { {a_{n - 1}}{a_{n - 2}} \cdots {a_1}}}{ { {b_n}{b_{n - 1}} \cdots {b_2}}}\]<br>这时令<br>\[{S_n} = {s_n}{a_n}{T_n}\]<br>得到：<br>\[{S_n} = {S_{n - 1}} + {s_n}{c_n}\]<br>这时就可以转化为求和了，解出：<br>\[{S_n} = {s_0}{a_0}{T_0} + \sum\limits_{k = 1}^n { {s_k}{c_k}} \]<br>所以<br>\[{T_n} = \frac{1}{ { {s_n}{a_n}}}({s_0}{a_0}{T_0} + \sum\limits_{k = 1}^n { {s_k}{c_k}} )\]</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>设$n$个数快速排序的操作次数为$C_n$，那么有<br>\[\begin{array}{l}{C_0} = 0\\{C_n} = n + 1 + \frac{2}{n}\sum\limits_{k = 0}^{n - 1} { {C_k}} ,n &gt; 0\end{array}\]<br>用$n-1$取代$n$可以得到<br>\[{C_{n - 1}} = n + \frac{2}{ {n - 1}}\sum\limits_{k = 0}^{n - 2} { {C_k}} ,n &gt; 1\]<br>两式相减可以得到<br>\[\begin{array}{l}{C_0} = 0\\n{C_n} = (n + 1){C_{n - 1}} + 2n,n &gt; 0\end{array}\]<br>由上面方法可以得到<br>\[{a_n} = n,{b_n} = n + 1,{c_n} = 2n\]<br>所以<br>\[{s_n} = \frac{2}{ {n(n + 1)}}\]<br>进而可以求出<br>\[{C_n} = 2(n + 1)\sum\limits_{k = 1}^n {\frac{1}{ {k + 1}}} \]<br>这里介绍一个概念叫做调和级数：<br>\[{H_n} = 1 + \frac{1}{2} +  \cdots  + \frac{1}{n} = \sum\limits_{k = 1}^n {\frac{1}{k}} \]<br>所以<br>\[{C_n} = 2(n + 1){H_n} - 2n\]</p><h1 id="求和三大定律"><a href="#求和三大定律" class="headerlink" title="求和三大定律"></a>求和三大定律</h1><hr><p>结合律、分配率、交换律。这里就不展开说了，相信你们都知道的。<br>来两题简单的例题说明一下。</p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><hr><p>求<br>\[S = \sum\limits_{0 \le k \le n} {(a + bk)} \]<br>普通的方法每个人应该都会，等差数列嘛。这里用求和定律来做一做。<br>用$n-k$取代$k$，得到<br>\[S = \sum\limits_{0 \le n - k \le n} {(a + b(n - k))} \]<br>即<br>\[S = \sum\limits_{0 \le k \le n} {(a + b(n - k))} \]<br>两式相加得到<br>\[2S = \sum\limits_{0 \le k \le n} {(2a + bn)}  = (2a + bn)\sum\limits_{0 \le k \le n} 1  = (2a + bn)(n + 1)\]<br>所以<br>\[S = (2a + bn)(n + 1)/2\]</p><h1 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h1><hr><p>求<br>\[S = \sum\limits_{0 \le k \le n} {k{x^k}} \]<br>这里用到另一种求和的方法。<br>两边同时加上第$n+1$项，得到<br>\[\begin{array}{l}S + (n + 1){x^{n + 1}}\\ = \sum\limits_{0 \le k \le n + 1} {k{x^k}} \\ = \sum\limits_{1 \le k \le n + 1} {k{x^k}} \\ = \sum\limits_{0 \le k \le n} {(k + 1){x^{k + 1}}} \\ = x\sum\limits_{0 \le k \le n} {(k{x^k} + {x^k})} \\ = xS + x\sum\limits_{0 \le k \le n} { {x^k}} \\ = xS + x\frac{ {1 - {x^{n + 1}}}}{ {1 - x}}\end{array}\]<br>所以<br>\[S = \frac{ {x - (n + 1){x^{n + 1}} + n{x^{n + 2}}}}{ { { {(1 - x)}^2}}}\]<br>这里介绍另一种方法来求解。<br>令<br>\[f(x) = \sum\limits_{0 \le k \le n} { {x^k}}  = \frac{ {1 - {x^{n + 1}}}}{ {1 - x}}\]<br>求导得到<br>\[f’(x) = \sum\limits_{0 \le k \le n} {k{x^{k - 1}}}  = \frac{1}{x}S\]<br>所以<br>\[\frac{1}{x}S = \frac{ {\partial f}}{ {\partial x}}(\frac{ {1 - {x^{n + 1}}}}{ {1 - x}}) = \frac{ {1 - (n + 1){x^n} + n{x^{n + 1}}}}{ { { {(1 - x)}^2}}}\]<br>同样可以得到<br>\[S = \frac{ {x - (n + 1){x^{n + 1}} + n{x^{n + 2}}}}{ { { {(1 - x)}^2}}}\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16.04下Nvidia+Cuda8.0+Dynet安装教程</title>
      <link href="/2018/03/09/nvidia-cuda-dynet/"/>
      <url>/2018/03/09/nvidia-cuda-dynet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>之前也在笔记本上装过几次cuda，均以失败告终，网上的教程都没有完全能拿来用的，多多少少都会出现一些问题。<br>这次终于完完全全安装成功了，可喜可贺。。。说起来都是泪。</p><p>注意显卡驱动安装最新版就行了，但是cuda最好还是别安装最新版了，装个8.0版本吧，不然都是泪。</p><p>最终版本为ubuntu16.04 + cuda8.0 + gcc5.4。</p><h1 id="NVIDIA驱动安装"><a href="#NVIDIA驱动安装" class="headerlink" title="NVIDIA驱动安装"></a>NVIDIA驱动安装</h1><hr><p>进入<a href="http://www.nvidia.com/Download/index.aspx?lang=en-us" target="_blank" rel="noopener">NVIDIA官网</a>，选择适合自己显卡的驱动，下载后是一个.run文件。</p><p>清除之前安装过的NVIDIA：<code>sudo apt-get remove --purge nvidia*</code></p><p>禁止nouveau等驱动：<code>sudo gedit /etc/modprob.d/blacklist.conf</code></p><p>加入下列语句并保存：</p><pre><code>blacklist vga16fbblacklist nouveaublacklist rivafbblacklist nvidiafbblacklist rivatv</code></pre><p>执行<code>sudo update-initramfs -u</code>并重启<code>reboot</code>。</p><p>按<code>ctrl+alt+f1</code>，登录命令行界面。</p><p>执行<code>sudo service lightdm stop</code></p><p>进入NVIDIA.run目录，运行<code>sudo sh ./NVIDIA.run –no-x-check –no-nouveau-check –no-opengl-files</code></p><p>安装过程中会报错，直接无视。会问你要不要自动更新X配置文件，选择是就行了。</p><p>重启。输入<code>sudo nvidia-smi</code>或者<code>nvidia-settings</code>，如果显示显卡信息，那么恭喜你安装成功了。</p><h1 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h1><hr><p>进入<a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">cuda官网</a>，根据自己版本下载cuda.run文件。</p><p>执行<code>sudo sh cuda.run</code>，注意中间问你要不要安装驱动程序，选择no</p><p>执行<code>sudo gedit /etc/profile</code><br>添加下列语句并保存：</p><pre><code>export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH</code></pre><p>重启，打开<code>/NVIDIA_CUDA-8.0_Samples/1_Utilities/deviceQuery</code></p><p>执行<code>sudo make</code>和<code>./deviceQuery</code>，如果出现显卡信息，那么cuda安装成功了。</p><h1 id="Dynet安装"><a href="#Dynet安装" class="headerlink" title="Dynet安装"></a>Dynet安装</h1><hr><p>首先安装Anaconda，过程就不说了，直接运行shell脚本就行了。</p><p>然后重要的地方来了，创建虚拟环境，在虚拟环境里安装dynet！！！</p><p>执行</p><pre><code>conda create --name python2 python=2 cython numpysource activate python2</code></pre><p>然后CPU版本的话很简单，直接执行<code>pip install dynet</code>就行了。</p><p>GPU版本执行<code>BACKEND=cuda pip install git+https://github.com/clab/dynet#egg=dynet -i https://pypi.tuna.tsinghua.edu.cn/simple</code>。</p><p>然后就成功啦，但是运行dynet程序的时候还是会报错，找不到libcudart库，这时执行下面三条语句就行了：</p><pre><code>sudo cp /usr/local/cuda-8.0/lib64/libcudart.so.8.0 /usr/local/lib/libcudart.so.8.0 &amp;&amp; sudo ldconfigsudo cp /usr/local/cuda-8.0/lib64/libcublas.so.8.0 /usr/local/lib/libcublas.so.8.0 &amp;&amp; sudo ldconfigsudo cp /usr/local/cuda-8.0/lib64/libcurand.so.8.0 /usr/local/lib/libcurand.so.8.0 &amp;&amp; sudo ldconfig</code></pre><p>然后终于可以运行了，感动哭了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynet </tag>
            
            <tag> cuda </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第一章作业解答</title>
      <link href="/2018/03/05/concrete-math-hw1/"/>
      <url>/2018/03/05/concrete-math-hw1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这是我的第一章作业答案，只有四题，标准答案太精简了。</p><p>总体做下来，只有最后一题的第二小问一开始算错了，正如题目所说，的确有点难想。我看了标准答案的式子，想了一会儿才想出来的。。。</p><p><img src="1.jpg" alt><br><img src="2.jpg" alt><br><img src="3.jpg" alt><br><img src="4.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第2课（成套方法求解递归式）</title>
      <link href="/2018/03/05/concrete-math-2/"/>
      <url>/2018/03/05/concrete-math-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天主要讲了关于递推式和求和的一些方法，主要是成套方法。</p><h1 id="约瑟夫环推广"><a href="#约瑟夫环推广" class="headerlink" title="约瑟夫环推广"></a>约瑟夫环推广</h1><p>上一节课说到，约瑟夫环问题的解是<br>\[f(n) = 2l + 1\]<br>其中$n = {2^m} + l$<br>将$n$写成二进制可以发现，$f(n)$就是$n$的二进制循环左移1位。<br>现在做一下推广，求解如下递推式：<br>\[\begin{array}{l}f(1) = \alpha \\f(2n) = 2f(n) + \beta \\f(2n + 1) = 2f(n) + \gamma \end{array}\]<br>可以设<br>\[f(n) = A(n)\alpha  + B(n)\beta  + C(n)\gamma \]<br>同样，令$n = {2^m} + l$<br>可以解出<br>\[\begin{array}{l}A(n) = {2^m}\\B(n) = {2^m} - 1 - l\\C(n) = l\end{array}\]<br>再从二进制角度理解一下，将递推式继续推广：<br>\[\begin{array}{l}f(j) = {\alpha _j},1 \le j &lt; d\\f(dn + j) = cf(n) + {\beta _j},0 \le j \le d,n \ge 1\end{array}\]<br>可以得到解为<br>\[f({({b_m}{b_{m - 1}} \ldots {b_1}{b_0})_d}) = {({\alpha _{ {b_m}}}{\beta _{ {b_{m - 1}}}}{\beta _{ {b_{m - 2}}}} \ldots {\beta _{ {b_1}}}{\beta _{ {b_0}}})_c}\]</p><h1 id="递推式求和"><a href="#递推式求和" class="headerlink" title="递推式求和"></a>递推式求和</h1><p>求解如下递推式：<br>\[\begin{array}{l}{R_0} = \alpha \\{R_n} = {R_{n - 1}} + \beta n + \gamma \end{array}\]<br>用成套方法求解，设<br>\[{R_n} = A(n)\alpha  + B(n)\beta  + C(n)\gamma \]<br>首先令${R_n} = 1$，可以得到$\alpha  = 1,\beta  = 0,\gamma  = 0$，所以$A(n) = 1$。<br>再令${R_n} = n$，可以得到$\alpha  = 0,\beta  = 0,\gamma  = 1$，所以$C(n) = n$。<br>最后令${R_n} = {n^2}$，可以得到$\alpha  = 0,\beta  = 2,\gamma  =  - 1$，所以$2B(n) - C(n) = {n^2}$，所以$B(n) = ({n^2} + n)/2$</p><p>再来一个更复杂的递推式：<br>\[\begin{array}{l}{R_0} = \alpha \\{R_n} = 2{R_{n - 1}} + \beta n + \gamma \end{array}\]<br>同样的方法，设<br>\[{R_n} = A(n)\alpha  + B(n)\beta  + C(n)\gamma \]<br>首先令${R_n} = 1$，可以得到$\alpha  = 1,\beta  = 0,\gamma  = -1$，所以$A(n) - C(n) = 1$。<br>再令${R_n} = n$，可以得到$\alpha  = 0,\beta  = -1,\gamma  = 2$，所以$2C(n) - B(n) = n$。<br>这时候能不能令${R_n} = {n^2}$呢？答案是不能，因为如果${R_n} = {n^2}$，那么<br>\[{n^2} = 2{(n - 1)^2} + \beta n + \gamma \]显然不可能成立。<br>观察系数，可以令${R_n} = 2^n$，可以得到$\alpha  = 1,\beta  = 0,\gamma  = 0$，所以$A(n) = 2^n$。<br>所以<br>\[A(n) = {2^n},B(n) = {2^{n + 1}} - n + 2,C(n) = {2^n} + 1\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第1课（递归求解实际问题）</title>
      <link href="/2018/02/27/concrete-math-1/"/>
      <url>/2018/02/27/concrete-math-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这学期提前选修了研究生的课程：具体数学、人工智能前沿、NLP讨论班，就随便记记具体数学每一节课所学的东西吧。</p><p>第一节课讲的都是一些很简单的东西，这里就一带而过了。</p><h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><hr><p>这是个老生常谈的问题了，n个盘子，3个柱子的汉诺塔问题，最少移动次数记为$T(n)$。<br>那么\[T(n)=2T(n-1)+1\]<br>边界条件为$T(0)=0$。<br>解出\[T(n)=2^n-1\]<br>验证可以采用数学归纳法，这里就不多说了。</p><h1 id="直线分割平面问题"><a href="#直线分割平面问题" class="headerlink" title="直线分割平面问题"></a>直线分割平面问题</h1><hr><p>这也是个高中问题了，n条直线最多分割平面为几部分，记为$L(n)$。<br>那么\[L(n)=L(n-1)+n\]<br>边界条件为$L(0)=1$。<br>解出\[L(n)=n(n+1)/2+1\]</p><p>这题有个扩展，n个V型最多分割平面为几部分？<br>解决思路如下：<br><img src="1.jpg" alt><br>如上图所示，将V型补全（红色虚线部分），那么就转化为了$2n$条直线划分平面数，那么n个V型划分数只要减去$2n$就行了，所以答案为：<br>\[Z(n)=L(2n)-2n=2n^2-n+1\]</p><h1 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h1><hr><p>这个问题暴力求解的话模拟就行了，复杂度是$O(n^2)$的，这里探索一种直接求解的方法。<br>分两种情况讨论：<br>当有$2n$个人时，踢掉$n$个人之后，情况如下图所示<br><img src="2.jpg" alt><br>观察对应关系可以得出<br>\[J(2n)=2J(n)-1\]<br>同理，当有$2n+1$个人时，踢掉$n+1$个人之后，情况如下图所示<br><img src="3.jpg" alt><br>观察对应关系可以得出<br>\[J(2n+1)=2J(n)+1\]<br>边界条件为<br>\[J(1)=1\]<br>这个递推式很难求解，但是枚举出前面几项可以发现，如果令$n=2^m+l$，其中$2^m$是小于等于$n$的最大2的幂，那么<br>\[J(n)=2l+1\]<br>正确性可以通过数学归纳法求证。</p><p>第一节课就讲了这么多，约瑟夫环还有很多问题值得探讨，下节课继续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业论文代码实现思路</title>
      <link href="/2018/02/26/biyelunwen/"/>
      <url>/2018/02/26/biyelunwen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>一个寒假就写了个基本的代码，难受啊，整理一下思路吧，好久不看代码头都大了。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><hr><p>首先使用的是PTB数据集，原始的数据是长这样的：<br>(S (NP-SBJ (NNP Ms.) (NNP Haag) ) (VP (VBZ plays) (NP (NNP Elianti) )) (. .) )</p><p>因为不一定是二叉树，所以要先预处理成二叉树，这里全部借用了github上别人的代码来进行预处理，二叉化之后变成了这样：<br>(S (S*^. (NP-SBJ (NNP Ms.) (NNP Haag)) (VP (VBZ plays) (NP_NNP Elianti))) (. .))</p><p>然后将整个数据集中出现次数过小的单词替换为unk：<br>(S (S*^. (NP-SBJ (NNP Ms.) (NNP Haag)) (VP (VBZ plays) (NP_NNP &lt; unk&gt;))) (. .))</p><p>最后还需要将每个训练数据对应的句子单独提取出来，方便训练时用，比如上面的例子提取出来就是：<br>Ms. Haag plays Elianti . </p><h1 id="文法规则提取"><a href="#文法规则提取" class="headerlink" title="文法规则提取"></a>文法规则提取</h1><hr><p>接着还是利用现成代码将数据集中出现的所有文法生成规则提取出来，保存到文件pcfg中。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><hr><p>这部分大部分代码是自己写的，也有一部分是从CKY算法代码修改得到的。</p><p>首先将数据集中出现的所有单词和词向量数组下标一一映射，词性类别也做一个映射吧。</p><p>然后初始化神经网络的各个参数，要训练的权值矩阵一共有两个，$W$和$d$，接下来就是训练了。</p><p>训练过程是这样的，采用了动态规划的思想，用三个维度$i$，$j$，$A$来表示这个句子从第$i$个位置到第$j$个位置且类别为$A$的信息。<br>用$e(i,j,A)$作为每个结点的向量表示，然后对他的儿子的所有情况进行遍历：<br>\[e(i,j,A) = \tanh (W \cdot [e(i,k,B),e(k,j,C)]) + type[A]\]<br>然后计算这个节点的分数：<br>\[s(i,j,A) = d \cdot e(i,j,A)\]<br>找出能使得分数最大的那个分割点和对应的类别，保存下来。</p><p>这样动态规划做好之后一棵树实际上就已经建好了，再回溯生成这棵树就好了。</p><p>但是这棵树很不准确的，刚开始就是随意生成的，所以要和标准树进行对比，计算出损失函数进行反向传播。</p><p>所以接下来用当前的权值矩阵计算出标准树的分数，然后对刚刚生成的结果和这个标准括号序列进行对比，我就直接粗暴统计出两个字符串有多少位置不同，记为$cnt$。</p><p>总的损失函数就是：<br>\[\left| {result - gold + cnt} \right|\]<br>然后进行反向传播就行了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><hr><p>在测试集上面直接照搬训练过程代码就行了，按照动态规划生成一棵树就行了。</p><p>然后用现成的代码和标准结果进行对比，得出F1值。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><hr><p>总的来说，大体就是这样的了，但是还有很多问题没有解决。</p><ul><li>动态规划结合一个节点的两个子节点的时候，现在还只是直接连接的，准备将其改成LSTM的结点函数。</li><li>改成LSTM的话就有左右结点的顺序问题，准备再加一个维度，0和1分别表示左右儿子的顺序。</li><li>我在$e(i,j,A) = \tanh (W \cdot [e(i,k,B),e(k,j,C)]) + type[A]$加了一个$type[A]$，其实原来没有这个的，但是不加会出现一个很大的问题，就是会出现A1-&gt;B,C和A2-&gt;B,C这两种情况，但是不加的话两种情况算出的分数是一样的，先入为主，后算的那种就永远不会考虑了。所以我强行加上了父节点类型向量，来区别这两种情况。但是具体怎么加还没有个说法，我只是随便试试。</li><li>关于损失函数，论文里写的就是$result - gold + cnt$，但是这样并不能保证非负，我就强行加上了一个绝对值。貌似也可以收敛了，到底应该怎么搞不清楚。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一七年终总结</title>
      <link href="/2018/01/22/2017-conclusion/"/>
      <url>/2018/01/22/2017-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>时间过得很快，终于等到放寒假了，虽然这几个月没有课，天天和放假也没啥区别呢。细数一下，还有5个月就要毕业了吧，大一刚入学的场景却依然清楚地记得，转眼间就成了老学长了呢。闲来无事，随便写写，有感而发，无病呻吟而已。</p><h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><hr><p>回顾我的2017，没做什么事，令我能记得就3件大事吧：</p><ul><li>失恋ing</li><li>ACM退役</li><li>顺利保研</li></ul><p><strong>第一件事</strong>就不想过多回忆了，<strong>2014.12.13 ~ 2017.03.01</strong>，曲终人散。<br><img src="749826.jpg" alt><br>最后引用《我的少女时代》里的一句话吧。</p><blockquote><p>每人都有一颗林真心，遇见是最美好的小幸运，谢谢你出现在我的青春里。</p></blockquote><p><img src="1.jpg" alt><br><strong>第二件事</strong>其实也是黯淡退出吧，大三下开始课程繁忙，也就没怎么训练了，再加上暑假考驾照，于是乎就退役了。回顾三年来，从大一入学时电脑都没怎么碰过的小白，到现在算法也略有所知，也是付出过很大的努力吧，毕竟当年每天刷题，为了一个bug而熬夜到凌晨。最后也算是混了个水水的金牌，奖项不算耀眼。但最重要的是从这段经历中，学到了拼搏、坚持的一种精神，这对以后的研究生涯想必也有很大帮助。<br><img src="2.jpg" alt><br><strong>第三件事</strong>也是意料之中吧，没有什么波折。纠结了很多，虽然<strong>专业第一</strong>，但是最后还是选择保了本校。要问原因，也许是校园情怀，也许是导师人很好，也许是为了方便更早研究，也许就是懒吧。现在尘埃落定，靠人靠天不如靠自己，继续努力吧。<br><img src="3.jpg" alt></p><p>过去的一年，学业未有很大长进，看着同学们整页的4.0绩点，心里倒也没有什么不平衡了。下学期保了研之后选了一门研究生的文本挖掘课，也马马虎虎读了几十篇论文，也算是对自然语言处理和深度学习入了个门，最后的presentation做的还算满意。</p><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><hr><p>今年最重要的大事莫过于毕业论文了，因为以后要做的方向是句法分析，所以导师给我的毕业论文安排的就是《基于循环神经网络的成分句法分析》。虽然说是基于ACL2013的一篇论文改编的，但是目前为止，我还没有发现有人做和这个完全一样的。也许最后写的好的话可以直接发paper了。</p><p>但是目前基本的框架还没完全搭建起来吧，代码还不是很熟练，现在只写了一个最基础的动态规划+RNN。最近有如下计划：</p><ul><li>准备试一下动态规划+LSTM。</li><li>然后动态规划扩增一个维度，用来保存左右结点的head结点。</li><li>如果这个写好了，就可以和我github找到的PCFG+CYK代码融合了，准备加上每个结点的POS。</li><li>最后加入预训练词向量应该就基本完成了。</li></ul><p>希望能顺利毕业吧，前一段时间一直对一些实现细节有些困惑，代码还写错了，还以为理论错了。也不知道最后出来的结果会怎么样，希望能不错。</p><p>生活方面，最近半年越来越懒了，极少出门，睡得晚，起的也晚。最近买了把尤克里里，也算是陶冶陶冶情操吧，不至于一直盯着电脑。现在也小有长进，能弹一点点了。</p><p>现在能聊天的人越来越少了，QQ微信放那一天也不一定会有人来找，就算有人也多半是咨询问题的，等一个可以交心的人吧。有时我也想过，我是不是太像中央空调了，对所有人都这么有耐心，到头来却还是一个人，付出那么多最后还是一无所有。<br><img src="4.jpg" alt><br>最后还是祝自己2018年顺利吧，希望毕业顺利，研究生涯小有收获，最后等一个有缘人吧。</p><blockquote><p>我遇见谁，会有怎样的对白。<br>我等的人，她在多远的未来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top-down Tree Long Short-Term Memory Networks</title>
      <link href="/2018/01/15/paperdaily-4/"/>
      <url>/2018/01/15/paperdaily-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>昨天又鸽了一天，由于水平有限，最主要还是懒，一篇paper看了两天才看了个大概。最近很颓废啊，白天啥都不想干一天就这么过去了，明天开始还是写写毕设代码吧，再好好研究研究。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这次介绍的仍然是树状LSTM，但是这次是在依存句法树上做的LSTM。主要功能就是给定一个句子的依存句法树，预测这个句子的生成概率。实验主要是在Microsoft Sentence Completion Challenge上面进行的，取得了不错的效果。不仅如此，这个模型还可以对依存句法分析产生的依存句法树进行重排序，从而提升依存句法分析的效果。（PS. 又让我联想到了我的毕业论文，用SU-RNN对PCFG产生的成分句法树进行重排序。。。。。。都是泪，代码还没开始动。）</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>首先介绍几个概念。</p><h3 id="依存路径"><a href="#依存路径" class="headerlink" title="依存路径"></a>依存路径</h3><p><img src="1.png" alt><br>如上图所示，虚线箭头就是依存树中的箭头，其中$w_0$就是$w_1$到$w_n$的head结点。那么$w_1$就是$w_0$左边的第一个结点，边$(w_0,w_1)$类型叫做$LEFT$边，而继续向左，例如边$(w_{k-1},w_k)$类型叫做$NX-LEFT$边。同理，向右的边也有两种类型$RIGHT$和$NX-RIGHT$。</p><p>那么依存路径$\mathcal D(w)$定义为从$ROOT$结点到$w$结点的路径，注意不是原来依存树的路径哦。具体计算方式如下：<br><img src="2.png" alt><br>以上图为例，原来$w_0$到$w_n$的路径为${w_0} \to {w_n}$，而现在变成了${w_0} \to {w_1} \to {w_2} \to  \ldots  \to {w_n}$。</p><p>那么给定依存树$T$，句子$S$的概率可以表示为<br><img src="3.png" alt><br>由于每个句子都有$ROOT$，所以就不需要计算它的概率了。$w$按照树$T$的宽度优先搜索顺序访问。</p><h3 id="树状LSTMs"><a href="#树状LSTMs" class="headerlink" title="树状LSTMs"></a>树状LSTMs</h3><p>那么问题就是如何计算$P(w|\mathcal D(w))$了。我们定义4种LSTM：GEN-L,GEN-R,GEN-NX-L,GEN-NX-R，分别用来表示上文中提到的四种类型的边：LEFT,RIGHT,NX-LEFT,NX-RIGHT。</p><p>每个结点的表示如下计算：</p><p><img src="4.png" alt><br>概率表示为：<br><img src="5.png" alt></p><p>注意这里为了简化计算，省略了全部的偏移向量。</p><p>这里用了深层LSTM的内部结点函数，具体直接看公式吧，有点晕。。。<br><img src="6.png" alt><br><img src="7.png" alt><br>直接附上原文解释：<br><img src="8.png" alt><br><img src="9.png" alt></p><h3 id="左依赖树状LSTMs"><a href="#左依赖树状LSTMs" class="headerlink" title="左依赖树状LSTMs"></a>左依赖树状LSTMs</h3><p>上面的方法忽略了同一个结点向左向右依赖之间的联系，举个例子，The car factory sold cars，如果只根据向右的依赖，由sold是无法推出cars的，而加上左依赖The car factory之后就能推出了，所以就提出了这种改进。结构如下：<br><img src="10.png" alt></p><p>也就是计算向右依赖的第一个结点之前，先计算完向左依赖的所有结点（上图绿色箭头部分），然后将最后一个隐含层输出作为向右依赖的第一个结点的输入。<br>首先是左边依赖的表示计算，注意和之前的向左计算方向是反的：<br><img src="11.png" alt><br>然后是向右依赖的计算：<br><img src="12.png" alt></p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>定义两种损失函数，分别对应小规模数据和大规模数据。<br><img src="14.png" alt><br><img src="15.png" alt></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>我就只关注了这个模型的附属品————句法分析上的性能。<br><img src="13.png" alt><br>看起来左依赖树状LSTMs相比树状LSTM基本没有提升，可能在其他任务上不一样吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这个模型看了我两天，感觉以前没见过，还挺新奇的（事实是我孤陋寡闻了）。而且我也不知道搞这么复杂究竟能有多大的性能提升，感觉上训练时间会很长？性价比不是很高？</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Head-Lexicalized Bidirectional Tree LSTMs</title>
      <link href="/2018/01/13/paperdaily-3/"/>
      <url>/2018/01/13/paperdaily-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>首先给大家说明一下，前两天因为新入手了一个ukulele（就是下图这玩意），所以痴迷于学习弹奏，没有更新博客。照这个节奏下去，PaperDaily恐怕是要变成PaperWeekly了。（囧。。。）寒假一定要学会《小幸运》，嗯。<br><img src="ukulele.jpg" alt></p><p>好了，今天开始恢复吧（说不准过两天我又鸽了，嘻嘻嘻）。</p><p>今天要讲的这篇是TACL2017的，是关于树状LSTM的。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>前两年已经有人提出了树状LSTM的概念，之前一直不知道是个啥高大上的结构。其实就是递归神经网络中的结点单元替换成LSTM的结点单元。那有人要问了，LSTM不是有$x$输入吗，还有一个$h_{t-1}$输入，那这树状的哪来这两个输入？其实很简单，只要把这两个输入替换成左右儿子的输出表示就行了。瞬间感觉也没啥意思，就是换了结点函数，使得树状LSTM具有了遗忘功能，从而能够处理很长的句子罢了。</p><p>今天介绍的这篇paper就是在这基础上做了两点改进。</p><ul><li>除了左右儿子作为输入之外，还增加了$x$输入。$x$是啥呢？就是左右儿子中的头结点，头结点的话传统方法是根据规则来判断谁是头结点的，这里省去了这些复杂的步骤，直接将头结点的判断丢进神经网络中训练。</li><li>增加了反向的树状LSTM，也就是top-down的LSTM。那有人就很好奇了，一个结点分解成两个结点，怎么可能？其实从头结点到任意一个其他结点的路径都可以看成一个独立的LSTM，如果向左参数就是$U_L$，否则就是$U_R$。</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p><img src="1.png" alt><br>图1是序列LSTM和树状LSTM的结构区别，这个树状LSTM是之前传统的树状LSTM，不带head结点的。</p><p>之前的基本的树状LSTM的结点单元的具体公式如下：<br><img src="5.png" alt><br>具体我就不解释了（懒。。。），自行类比序列LSTM。</p><p>加入head结点之后，公式区别如下（加粗所示）：<br><img src="2.png" alt><br><img src="3.png" alt><br><img src="4.png" alt></p><p>那么top-down是怎么做的呢？<br><img src="6.png" alt><br>这里可以看出来，向左向右是用的两套不同的参数。注意到，top-down方向的LSTM前提是一定要用head机制作为支撑！不然头结点的$x$算不出来的话是没有办法计算的哦。</p><p>具体训练过程等等就不再阐述了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这个模型主要是用在了文本分类和情感分类上，我在想能不能用在我的毕设上面。</p><p>我觉得head机制可以加进去，但是反向LSTM貌似是不可行的，因为这里的短语结构树全部是给定的，所以向下计算知道什么时候停止。但是我是做句法分析任务的，没有给定句法树，向下计算无法知道什么时候停止扩展，情况有无数种！向上计算倒是无所谓，最多卡特兰数级别，加上动态规划，可以缩小到$n\log n$级别。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> TACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parsing with Compositional Vector Grammars</title>
      <link href="/2018/01/10/paperdaily-2/"/>
      <url>/2018/01/10/paperdaily-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天也没看新的paper，就讲讲我的毕设的paper吧，估计等我文本挖掘这门课上完，也不会再看太多序列标注相关的了，重点要转移到parsing了。毕竟序列标注效果也已经很好了，迁移学习方面也暂时不想弄，以后研究重点还是可能在parsing吧。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇paper名字叫做基于成分向量文法的句法分析，那么这是个什么东西呢？大家都知道（也许不知道？我就默认知道了( ╯□╰ )）概率上下文无关文法（PCFG）吧，这是基于传统方法的短语结构句法分析，也叫成分句法分析，还有一种叫做依存句法分析，现在大多数是做这个的。但是传统的成分句法分析无法解决歧义的问题，因为PCFG是基于上下文无关的独立性假设的，但是自然语言是一种上下文有关文法，必然会产生歧义。</p><p>那么如何消除这种歧义呢，Socher提出了SU-RNN的模型，引入了短语的语义表示，具体是什么样子的呢？</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>这个模型概括起来是这样的：首先用PCFG产生k-best句法树，比如产生概率最大的20棵句法树。然后对这k-best棵句法树每棵树都跑一遍SU-RNN，计算出每棵树的得分，然后综合PCFG得分和SU-RNN得分，对他们进行重排序，然后得到排名最高的句法树。</p><p>那么怎么通过SU-RNN计算一棵树的得分呢？</p><p>首先上一张图，看看SU-RNN是个什么结构：<br><img src="1.png" alt><br>可以看出，每个节点不仅含有它的类别表示，还有一个向量表示它的语义信息。而SU-RNN与之前提出过的RNN不一样的是，这里的每个节点的$W$权值矩阵全部是不同的，依赖于它的子节点的类别。<br>每个节点的语义表示向量计算方法如下：<br>\[{p^{(1)}} = f\left( { {W^{(B,C)}}\left[ {\begin{array}{*{20}{c}}b\\c\end{array}} \right]} \right)\]而这个节点的得分表示为<br>\[s({p^{(1)}}) = {({v^{(B,C)}})^T}{p^{(1)}} + \log P({P_1} \to B{\rm{ }}C)\]最后一整棵树的得分就是<br>\[s(CVG(\theta ,x,\hat y)) = \sum\limits_{d \in N(\hat y)} {s({p^d})} \]这样就可以枚举所有的句法树，然后计算得到得分最高的那棵树就是最终的句法树了。</p><p>但是这样枚举的话复杂度太高了，要知道一个长度为$n$的句子，可能的句法树有$Catalan(n)$种。而且是无法用动态规划算法来计算最优句法树的，因为SU-RNN破坏了上下文无关的独立性假设（因为反向传播？其实我也不是太懂。。。）。所以就要用到之前所说的先用PCFG得到k-best棵句法树，然后用SU-RNN重排序了。</p><p>那么用SU-RNN计算完得到最优树之后，怎么计算它与gold-tree之间的差异，从而得到loss呢？</p><p>本文计算两棵树差异的公式如下：<br>\[\Delta ({y_i},\hat y) = \sum\limits_{d \in N(\hat y)} {\kappa 1\{ d \notin N({y_i})\} } \]最终的损失函数定义为：<br>\[J(\theta ) = \frac{1}{m}\sum\limits_{i = 1}^m { {r_i}(\theta )}  + \frac{\lambda }{2}{\left| \theta  \right|^2}\]其中<br>\[{r_i}(\theta ) = \mathop {\max }\limits_{\hat y \in Y({x_i})} (s(CVG({x_i},\hat y)) + \Delta ({y_i},\hat y)) - s(CVG({x_i},{y_i}))\]也就是要尽量最大化标准树的得分，减小预测树的得分。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p><img src="2.png" alt><br>可以看出，SU-RNN结果比以往的结果都要好，但是没有最后两行的好。。。最后两个具体是啥我也没去细看。</p><h1 id="我的毕设任务"><a href="#我的毕设任务" class="headerlink" title="我的毕设任务"></a>我的毕设任务</h1><hr><p>其实我的任务不用PCFG，看起来减少了工作量？嘿嘿，其实貌似麻烦的一笔啊。。。我的模型主要的思想就是直接用SU-RNN训练出句法分析树！那枚举复杂度太高了怎么办？用动态规划啊！不是不能用吗？没事，假装它能用，要是效果好强行解释一波就行了。。。而且原模型的RNN是递归神经网络哦，这次我改成了循环神经网络，用LSTM来计算得分。看起来貌似挺麻烦的，纠结了好几天。LSTM每个节点总得有一个$x$输入，一个$h$隐层输入吧，所以可能还要给每两个节点指定一个作为head。。。</p><p>感觉心态炸了哦，一堆非主流写法？也不知道最后能不能写出来，也不知道写出来结果怎么样。。。说不定要延毕了？哈哈，自嘲一波吧，暑假好好研究研究了，python基础还是不行，写起来太累了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Empower Sequence Labeling with Task-Aware Neural Language Model</title>
      <link href="/2018/01/09/paperdaily-1/"/>
      <url>/2018/01/09/paperdaily-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>自从这学期没课以来，一直过着非正常人的生活，作息时间比正常人推迟了3个小时：<strong>3点睡觉、12点起床、15点吃午饭、21点吃晚饭。</strong>因此决定不再如此颓废，每日泛读一篇顶会paper，了解其大概思想即可，然后大概将思想发出来，美其名曰：PaperDaily，就从今天开始吧。</p><p>今天要讲的这篇是昨天偶然看到的，AAAI18的paper，正好与我文本挖掘课大作业主题一样，所以就看了一下。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇paper提出的模型叫做LM-LSTM-CRF，看起来和前面讲过的加入语言模型的两篇没有大区别，事实是区别的确不是很大。之前讲过的transfer模型基本都是共享一部分模型（底层模型），上层模型都是每个任务有各自独立的模型。然而这篇paper的模型所有部分全部共享，这就会带来许多表示上面的问题。于是这篇paper和以往最大的区别就是在character level LSTM之上加入了一个highway layer，用来将LSTM产生的字符表示映射到不同的表示空间，这样语言模型（这里的语言模型是基于字符层面的）和序列标注模型就可以共享character level LSTM。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>不多说，直接上图：<br><img src="1.png" alt></p><h3 id="character-level-LSTM"><a href="#character-level-LSTM" class="headerlink" title="character level LSTM"></a>character level LSTM</h3><p>这里和传统的差不多，只是改每个token单独训练一个LSTM为所有字符联合训练上下文表示（为了语言模型共用嘛），但是只在两个tokens之间输出token表示。</p><h3 id="highway-layer"><a href="#highway-layer" class="headerlink" title="highway layer"></a>highway layer</h3><p>其实就是对输出做了线性变换+门操作，具体表示如下：<br>\[\begin{array}{l}m = H(n) = t \odot g({W_H}n + {b_H}) + (1 - t) \odot n\\t = \sigma ({W_T}n + {b_T})\end{array}\]最终一共产生四个highway输出，分别是前后向序列标注表示和前后向语言模型表示。而序列标注的LSTM输入共有三个，分别是词向量、前后向序列标注表示。</p><h3 id="word-level-LSTM"><a href="#word-level-LSTM" class="headerlink" title="word level LSTM"></a>word level LSTM</h3><p>和传统的没什么不同。。。</p><h3 id="CRF-layer"><a href="#CRF-layer" class="headerlink" title="CRF layer"></a>CRF layer</h3><p>没什么不一样。。。</p><h3 id="joint-training"><a href="#joint-training" class="headerlink" title="joint training"></a>joint training</h3><p>总的损失函数就是语言模型损失函数加上序列标注损失函数，系数这里设置为1:1。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>直接上图，这里和之前我看过的几篇paper都进行了比较，还是非常bang的！<br><img src="2.png" alt><br>注意到，他们的结果和<code>Peter 2017.</code>比较还是差了一点，因为<code>Peter 2017.</code>虽然也使用了语言模型作为辅助训练，但是他们语言模型是在大量无标注数据下进行训练的，而且花费时间特别长！而本文根本不需要任何辅助数据，少量标注数据？足够了！就在他们上面联合训练一个语言模型就行了，花费时间大大缩短。</p><p>其实我个人认为，这零点几的提升意义并不是很大，时间大大缩短倒是挺不错的，毕竟<code>Peter 2017.</code>那篇32个GPU都要训练半个月。。。<br>更远一步思考，也许可以将语言模型和序列标注独立开来训练，先用语言模型来训练character level LSTM，再用它产生每个token的表示，直接输入到序列标注的LSTM中，当然highway layer还是必要的，毕竟表示空间是不同的。这样可以利用大量的无标注数据了，但是训练时间也会大大加长，而且感觉和<code>Peter 2017.</code>的模型区别貌似不大了？只是联合训练了一个character level LSTM而已。</p><p>以上都是我的拙见，毕竟这篇也就粗略读了一下没仔细看，各位有什么想法也欢迎和我讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> 迁移学习 </tag>
            
            <tag> AAAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词性标注+语言模型简易实现</title>
      <link href="/2018/01/01/pos-lm/"/>
      <url>/2018/01/01/pos-lm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>文本挖掘课的project，实现的是词性标注，增加了语言模型表示。<br>语言模型在小数据下会过拟合，但是大数据训练要三个星期。。。所以还是放弃了，不添加语言模型好了。<br>词性标注的话如果添加CRF效果反而会下降，也是很奇怪哦。。。如果直接用最裸的BiLSTM+charRNN的话，F1也能有97%左右，知足了，就这样吧。<br>数据和完整程序下载地址：<a href="https://github.com/godweiyang/text-mining" target="_blank" rel="noopener">传送门</a></p><p>下面是两组实验结果，由于速度太慢了，一组要1小时训练时间，所以就没有加语言模型，而且只训练了10轮。</p><p>第一组：</p><pre><code>DEBUG = FalseHASLM = FalseLM_EPOCH = 5TAG_EPOCH = 10MAX_LIK_ITERS = 3--------Language Model Training----------------Sequence Tagger Training--------epoch 0 finishedtotal loss:  0.29375948742total F1:  0.949073958671 0.395180722892epoch 1 finishedtotal loss:  0.132068497052total F1:  0.954682553531 0.427710843373epoch 2 finishedtotal loss:  0.110233872966total F1:  0.960266221303 0.483734939759epoch 3 finishedtotal loss:  0.0115048246573total F1:  0.944312884812 0.367469879518epoch 4 finishedtotal loss:  0.00533642838205total F1:  0.947378916669 0.375903614458epoch 5 finishedtotal loss:  0.00460870711354total F1:  0.945584166314 0.34156626506epoch 6 finishedtotal loss:  0.00420810207526total F1:  0.931001819677 0.269277108434epoch 7 finishedtotal loss:  0.00402948848795total F1:  0.943490290899 0.321084337349epoch 8 finishedtotal loss:  0.00390113119154total F1:  0.952813021911 0.431325301205epoch 9 finishedtotal loss:  0.00367663722034total F1:  0.938579654511 0.31265060241if SCONJyou PRONcould AUXsee VERBthat SCONJi PRONam AUXthe DETone NOUNwho PRONunderstands VERByou PRON. PUNC</code></pre><p>第二组：</p><pre><code>DEBUG = FalseHASLM = FalseLM_EPOCH = 5TAG_EPOCH = 10MAX_LIK_ITERS = 10--------Language Model Training----------------Sequence Tagger Training--------epoch 0 finishedtotal loss:  0.304520357251total F1:  0.948201510582 0.387951807229epoch 1 finishedtotal loss:  0.133941903738total F1:  0.957175262358 0.457228915663epoch 2 finishedtotal loss:  0.111774144948total F1:  0.959019866889 0.455421686747epoch 3 finishedtotal loss:  0.100073265445total F1:  0.960814617245 0.475301204819epoch 4 finishedtotal loss:  0.0922900494867total F1:  0.962310242541 0.487951807229epoch 5 finishedtotal loss:  0.0862275558798total F1:  0.963681232395 0.485542168675epoch 6 finishedtotal loss:  0.0811706444901total F1:  0.963706159484 0.492168674699epoch 7 finishedtotal loss:  0.0776693911075total F1:  0.962808784306 0.484939759036epoch 8 finishedtotal loss:  0.0741868944795total F1:  0.9630331281 0.495180722892epoch 9 finishedtotal loss:  0.0714286559878total F1:  0.963407034424 0.486144578313if SCONJyou PRONcould AUXsee VERBthat SCONJi PRONam VERBthe DETone NOUNwho PRONunderstands VERByou PRON. PUNC</code></pre><p>可以看出来，加了CRF（第一组）效果反而差了一点点，对最后例句的词性标注唯一的区别在于”am”是助动词AUX还是动词VERB，我发现训练集里两种都有，区别也不大。</p><p>完整代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token punctuation">,</span> defaultdict<span class="token keyword">from</span> itertools <span class="token keyword">import</span> count<span class="token keyword">import</span> random<span class="token keyword">import</span> dynet <span class="token keyword">as</span> dy<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npDEBUG <span class="token operator">=</span> <span class="token boolean">False</span>HASLM <span class="token operator">=</span> <span class="token boolean">False</span>LM_EPOCH <span class="token operator">=</span> <span class="token number">5</span>TAG_EPOCH <span class="token operator">=</span> <span class="token number">10</span><span class="token comment" spellcheck="true"># CRF parameters</span>MAX_LIK_ITERS <span class="token operator">=</span> <span class="token number">3</span>SMALL_NUMBER <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1e10</span>MARGIN <span class="token operator">=</span> <span class="token number">0</span>lm_train_file <span class="token operator">=</span> <span class="token string">"LM_TRAIN"</span>lm_test_file <span class="token operator">=</span> <span class="token string">"LM_DEV"</span>train_file <span class="token operator">=</span> <span class="token string">"TAG_TRAIN"</span>dev_file <span class="token operator">=</span> <span class="token string">"TAG_DEV"</span><span class="token keyword">if</span> DEBUG<span class="token punctuation">:</span>    lm_train_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span>    lm_test_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span>    train_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span>    dev_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span><span class="token comment" spellcheck="true"># Language Model</span><span class="token keyword">print</span> <span class="token string">"--------Language Model Training--------"</span><span class="token keyword">def</span> <span class="token function">read_lm</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> file<span class="token punctuation">(</span>fname<span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>            sent <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>            sent<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"&lt;s>"</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> sentlm_train <span class="token operator">=</span> list<span class="token punctuation">(</span>read_lm<span class="token punctuation">(</span>lm_train_file<span class="token punctuation">)</span><span class="token punctuation">)</span>lm_test <span class="token operator">=</span> list<span class="token punctuation">(</span>read_lm<span class="token punctuation">(</span>lm_test_file<span class="token punctuation">)</span><span class="token punctuation">)</span>lm_words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> sent <span class="token keyword">in</span> lm_train<span class="token punctuation">:</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> sent<span class="token punctuation">:</span>        lm_words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">)</span>lm_words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_UNK_"</span><span class="token punctuation">)</span>lm_w2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> lm_words<span class="token punctuation">:</span>    lm_w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span>lm_i2w <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> lm_w2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>lm_nwords <span class="token operator">=</span> len<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">)</span>lm_model <span class="token operator">=</span> dy<span class="token punctuation">.</span>Model<span class="token punctuation">(</span><span class="token punctuation">)</span>lm_trainer <span class="token operator">=</span> dy<span class="token punctuation">.</span>AdamTrainer<span class="token punctuation">(</span>lm_model<span class="token punctuation">)</span>lm_WORDS_LOOKUP <span class="token operator">=</span> lm_model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>lm_nwords<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lm_RNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> lm_model<span class="token punctuation">)</span>lm_pW <span class="token operator">=</span> lm_model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>lm_nwords<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lm_pb <span class="token operator">=</span> lm_model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span>lm_nwords<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">calc_lm_loss</span><span class="token punctuation">(</span>sent<span class="token punctuation">)</span><span class="token punctuation">:</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    W <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>lm_pW<span class="token punctuation">)</span>    b <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>lm_pb<span class="token punctuation">)</span>    f_init <span class="token operator">=</span> lm_RNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    wids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> sent<span class="token punctuation">:</span>        <span class="token keyword">if</span> w <span class="token keyword">in</span> lm_words<span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span><span class="token string">"_UNK_"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> f_init<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wids<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> wid <span class="token keyword">in</span> wids<span class="token punctuation">:</span>        score <span class="token operator">=</span> W <span class="token operator">*</span> s<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b        loss <span class="token operator">=</span> dy<span class="token punctuation">.</span>pickneglogsoftmax<span class="token punctuation">(</span>score<span class="token punctuation">,</span> wid<span class="token punctuation">)</span>        losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wid<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dy<span class="token punctuation">.</span>esum<span class="token punctuation">(</span>losses<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">calc_lm_embdding</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_init <span class="token operator">=</span> lm_RNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    wids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span>        <span class="token keyword">if</span> w <span class="token keyword">in</span> lm_words<span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span><span class="token string">"_UNK_"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span><span class="token string">"&lt;s>"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> f_init<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wids<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> wid <span class="token keyword">in</span> wids<span class="token punctuation">:</span>        outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wid<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> outputs<span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>    <span class="token keyword">for</span> ITER <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>LM_EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>        lm_num_tagged <span class="token operator">=</span> lm_cum_loss <span class="token operator">=</span> <span class="token number">0</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>lm_train<span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> s <span class="token keyword">in</span> lm_train<span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span> calc_lm_loss<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            lm_cum_loss <span class="token operator">+=</span> loss_exp<span class="token punctuation">.</span>scalar_value<span class="token punctuation">(</span><span class="token punctuation">)</span>            lm_num_tagged <span class="token operator">+=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            loss_exp<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            lm_trainer<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> DEBUG <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span> <span class="token string">"train loss "</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> lm_cum_loss <span class="token operator">/</span> lm_num_tagged        dev_loss <span class="token operator">=</span> dev_words <span class="token operator">=</span> <span class="token number">0</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> sent <span class="token keyword">in</span> lm_test<span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span> calc_lm_loss<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>            dev_loss <span class="token operator">+=</span> loss_exp<span class="token punctuation">.</span>scalar_value<span class="token punctuation">(</span><span class="token punctuation">)</span>            dev_words <span class="token operator">+=</span> len<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># if DEBUG == False:</span>            <span class="token comment" spellcheck="true">#     i += 1</span>            <span class="token comment" spellcheck="true">#     if i % 100 == 0:</span>            <span class="token comment" spellcheck="true">#         print "dev loss ", i, ": ", dev_loss / dev_words</span>        <span class="token keyword">print</span> <span class="token string">"epoch %r finished"</span> <span class="token operator">%</span> ITER        <span class="token keyword">print</span> <span class="token string">"total train loss: "</span><span class="token punctuation">,</span> lm_cum_loss <span class="token operator">/</span> lm_num_tagged        <span class="token keyword">print</span> <span class="token string">"total dev loss: "</span><span class="token punctuation">,</span> dev_loss <span class="token operator">/</span> dev_words<span class="token comment" spellcheck="true"># Tagger</span><span class="token keyword">print</span> <span class="token string">"--------Sequence Tagger Training--------"</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> file<span class="token punctuation">(</span>fname<span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>            line <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>            sent <span class="token operator">=</span> <span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>x<span class="token punctuation">.</span>rsplit<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> line<span class="token punctuation">]</span>            <span class="token keyword">yield</span> senttrain <span class="token operator">=</span> list<span class="token punctuation">(</span>read<span class="token punctuation">(</span>train_file<span class="token punctuation">)</span><span class="token punctuation">)</span>dev <span class="token operator">=</span> list<span class="token punctuation">(</span>read<span class="token punctuation">(</span>dev_file<span class="token punctuation">)</span><span class="token punctuation">)</span>words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>chars <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>wc <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> sent <span class="token keyword">in</span> train<span class="token punctuation">:</span>    <span class="token keyword">for</span> w<span class="token punctuation">,</span> p <span class="token keyword">in</span> sent<span class="token punctuation">:</span>        words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">)</span>        tags<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        chars<span class="token punctuation">.</span>update<span class="token punctuation">(</span>w<span class="token punctuation">)</span>        wc<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_UNK_"</span><span class="token punctuation">)</span>words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_S_"</span><span class="token punctuation">)</span>tags<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_S_"</span><span class="token punctuation">)</span>chars<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"&lt;*>"</span><span class="token punctuation">)</span>w2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>    w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span>i2w <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> w2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>t2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> tag <span class="token keyword">in</span> tags<span class="token punctuation">:</span>    t2i<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>i2t <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> t2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>c2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> char <span class="token keyword">in</span> chars<span class="token punctuation">:</span>    c2i<span class="token punctuation">[</span>char<span class="token punctuation">]</span>i2c <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> c2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>UNK <span class="token operator">=</span> w2i<span class="token punctuation">[</span><span class="token string">"_UNK_"</span><span class="token punctuation">]</span>S_W <span class="token operator">=</span> w2i<span class="token punctuation">[</span><span class="token string">"_S_"</span><span class="token punctuation">]</span>S_T <span class="token operator">=</span> t2i<span class="token punctuation">[</span><span class="token string">"_S_"</span><span class="token punctuation">]</span>nwords <span class="token operator">=</span> len<span class="token punctuation">(</span>w2i<span class="token punctuation">)</span>ntags  <span class="token operator">=</span> len<span class="token punctuation">(</span>t2i<span class="token punctuation">)</span>nchars  <span class="token operator">=</span> len<span class="token punctuation">(</span>c2i<span class="token punctuation">)</span>model <span class="token operator">=</span> dy<span class="token punctuation">.</span>Model<span class="token punctuation">(</span><span class="token punctuation">)</span>trainer <span class="token operator">=</span> dy<span class="token punctuation">.</span>AdamTrainer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>WORDS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>nwords<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span>CHARS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>nchars<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>TRANS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>ntags<span class="token punctuation">,</span> ntags<span class="token punctuation">)</span><span class="token punctuation">)</span>pH <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pO <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>ntags<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>bwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>    fwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>    bwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>cFwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>cBwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">word_rep</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> cf_init<span class="token punctuation">,</span> cb_init<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> wc<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">:</span>        w_index <span class="token operator">=</span> w2i<span class="token punctuation">[</span>w<span class="token punctuation">]</span>        <span class="token keyword">return</span> WORDS_LOOKUP<span class="token punctuation">[</span>w_index<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        pad_char <span class="token operator">=</span> c2i<span class="token punctuation">[</span><span class="token string">"&lt;*>"</span><span class="token punctuation">]</span>        char_ids <span class="token operator">=</span> <span class="token punctuation">[</span>pad_char<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>c2i<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> w<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pad_char<span class="token punctuation">]</span>        char_embs <span class="token operator">=</span> <span class="token punctuation">[</span>CHARS_LOOKUP<span class="token punctuation">[</span>cid<span class="token punctuation">]</span> <span class="token keyword">for</span> cid <span class="token keyword">in</span> char_ids<span class="token punctuation">]</span>        fw_exps <span class="token operator">=</span> cf_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>char_embs<span class="token punctuation">)</span>        bw_exps <span class="token operator">=</span> cb_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>char_embs<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dy<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span> fw_exps<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bw_exps<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">build_tagging_graph</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>    lm_wembs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>        lm_wembs <span class="token operator">=</span> calc_lm_embdding<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    H <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>pH<span class="token punctuation">)</span>    O <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>pO<span class="token punctuation">)</span>    f_init <span class="token operator">=</span> fwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    b_init <span class="token operator">=</span> bwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    cf_init <span class="token operator">=</span> cFwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    cb_init <span class="token operator">=</span> cBwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    wembs <span class="token operator">=</span> <span class="token punctuation">[</span>word_rep<span class="token punctuation">(</span>w<span class="token punctuation">,</span> cf_init<span class="token punctuation">,</span> cb_init<span class="token punctuation">)</span> <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">]</span>    <span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>        wembs1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> lmw<span class="token punctuation">,</span> w <span class="token keyword">in</span> zip<span class="token punctuation">(</span>lm_wembs<span class="token punctuation">,</span> wembs<span class="token punctuation">)</span><span class="token punctuation">:</span>            wv <span class="token operator">=</span> w<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>            wv<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>lmw<span class="token punctuation">)</span>            wembs1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>wv<span class="token punctuation">)</span>        wembs <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>inputTensor<span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token keyword">for</span> w <span class="token keyword">in</span> wembs1<span class="token punctuation">]</span>    wembs <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>noise<span class="token punctuation">(</span>we<span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> we <span class="token keyword">in</span> wembs<span class="token punctuation">]</span>    fw_exps <span class="token operator">=</span> f_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>wembs<span class="token punctuation">)</span>    bw_exps <span class="token operator">=</span> b_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>wembs<span class="token punctuation">)</span><span class="token punctuation">)</span>    bi_exps <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>f<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> f<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>fw_exps<span class="token punctuation">,</span> reversed<span class="token punctuation">(</span>bw_exps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    exps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> bi_exps<span class="token punctuation">:</span>        r_t <span class="token operator">=</span> O <span class="token operator">*</span> <span class="token punctuation">(</span>dy<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>H <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>        exps<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r_t<span class="token punctuation">)</span>    <span class="token keyword">return</span> exps<span class="token keyword">def</span> <span class="token function">viterbi_decoding</span><span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> gold_tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Initialize</span>    init_prob <span class="token operator">=</span> <span class="token punctuation">[</span>SMALL_NUMBER<span class="token punctuation">]</span> <span class="token operator">*</span> ntags    init_prob<span class="token punctuation">[</span>S_T<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    for_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>inputVector<span class="token punctuation">(</span>init_prob<span class="token punctuation">)</span>    best_ids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    trans_exprs <span class="token operator">=</span> <span class="token punctuation">[</span>TRANS_LOOKUP<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token keyword">for</span> tid <span class="token keyword">in</span> range<span class="token punctuation">(</span>ntags<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># Perform the forward pass through the sentence</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span><span class="token punctuation">:</span>        my_best_ids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        my_best_exprs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> next_tag <span class="token keyword">in</span> range<span class="token punctuation">(</span>ntags<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># Calculate vector for single next tag</span>            next_single_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> trans_exprs<span class="token punctuation">[</span>next_tag<span class="token punctuation">]</span>            next_single <span class="token operator">=</span> next_single_expr<span class="token punctuation">.</span>npvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># Find and save the best score</span>            my_best_id <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>next_single<span class="token punctuation">)</span>            my_best_ids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>my_best_id<span class="token punctuation">)</span>            my_best_exprs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>next_single_expr<span class="token punctuation">,</span> my_best_id<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Concatenate the scores for all vectors together</span>        for_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>my_best_exprs<span class="token punctuation">)</span> <span class="token operator">+</span> vec        <span class="token comment" spellcheck="true"># Give a bonus to all but the correct tag if using margin</span>        <span class="token keyword">if</span> MARGIN <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>gold_tags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            adjust <span class="token operator">=</span> <span class="token punctuation">[</span>MARGIN<span class="token punctuation">]</span> <span class="token operator">*</span> ntags            adjust<span class="token punctuation">[</span>t2i<span class="token punctuation">[</span>gold_tags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            for_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> dy<span class="token punctuation">.</span>inputVector<span class="token punctuation">(</span>adjust<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Save the best ids</span>        best_ids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>my_best_ids<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Perform the final step to the sentence terminal symbol</span>    next_single_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> trans_exprs<span class="token punctuation">[</span>S_T<span class="token punctuation">]</span>    next_single <span class="token operator">=</span> next_single_expr<span class="token punctuation">.</span>npvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>    my_best_id <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>next_single<span class="token punctuation">)</span>    best_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>next_single_expr<span class="token punctuation">,</span> my_best_id<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Perform the reverse pass</span>    best_path <span class="token operator">=</span> <span class="token punctuation">[</span>i2t<span class="token punctuation">[</span>my_best_id<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> my_best_ids <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>best_ids<span class="token punctuation">)</span><span class="token punctuation">:</span>        my_best_id <span class="token operator">=</span> my_best_ids<span class="token punctuation">[</span>my_best_id<span class="token punctuation">]</span>        best_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i2t<span class="token punctuation">[</span>my_best_id<span class="token punctuation">]</span><span class="token punctuation">)</span>    best_path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Remove final &lt;s></span>    best_path<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Return the best path and best score as an expression</span>    <span class="token keyword">return</span> best_path<span class="token punctuation">,</span> best_expr<span class="token keyword">def</span> <span class="token function">forced_decoding</span><span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Initialize</span>    for_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>scalarInput<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    for_tag <span class="token operator">=</span> S_T    <span class="token comment" spellcheck="true"># Perform the forward pass through the sentence</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span><span class="token punctuation">:</span>         my_tag <span class="token operator">=</span> t2i<span class="token punctuation">[</span>tags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        for_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>TRANS_LOOKUP<span class="token punctuation">[</span>my_tag<span class="token punctuation">]</span><span class="token punctuation">,</span> for_tag<span class="token punctuation">)</span> <span class="token operator">+</span> vec<span class="token punctuation">[</span>my_tag<span class="token punctuation">]</span>        for_tag <span class="token operator">=</span> my_tag    for_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>TRANS_LOOKUP<span class="token punctuation">[</span>S_T<span class="token punctuation">]</span><span class="token punctuation">,</span> for_tag<span class="token punctuation">)</span>    <span class="token keyword">return</span> for_expr<span class="token keyword">def</span> <span class="token function">viterbi_sent_loss</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>    vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    viterbi_tags<span class="token punctuation">,</span> viterbi_score <span class="token operator">=</span> viterbi_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> tags<span class="token punctuation">)</span>    <span class="token keyword">if</span> viterbi_tags <span class="token operator">!=</span> tags<span class="token punctuation">:</span>        reference_score <span class="token operator">=</span> forced_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> tags<span class="token punctuation">)</span>        <span class="token keyword">return</span> viterbi_score <span class="token operator">-</span> reference_score    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dy<span class="token punctuation">.</span>scalarInput<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">sent_loss</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>    vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    errs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> v<span class="token punctuation">,</span>t <span class="token keyword">in</span> zip<span class="token punctuation">(</span>vecs<span class="token punctuation">,</span>tags<span class="token punctuation">)</span><span class="token punctuation">:</span>        tid <span class="token operator">=</span> t2i<span class="token punctuation">[</span>t<span class="token punctuation">]</span>        err <span class="token operator">=</span> dy<span class="token punctuation">.</span>pickneglogsoftmax<span class="token punctuation">(</span>v<span class="token punctuation">,</span> tid<span class="token punctuation">)</span>        errs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> dy<span class="token punctuation">.</span>esum<span class="token punctuation">(</span>errs<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">tag_sent</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>    vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    vecs <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> vecs<span class="token punctuation">]</span>    probs <span class="token operator">=</span> <span class="token punctuation">[</span>v<span class="token punctuation">.</span>npvalue<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> vecs<span class="token punctuation">]</span>    tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> prb <span class="token keyword">in</span> probs<span class="token punctuation">:</span>        tag <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>prb<span class="token punctuation">)</span>        tags<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i2t<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> tags<span class="token keyword">for</span> ITER <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>TAG_EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>    num_tagged <span class="token operator">=</span> cum_loss <span class="token operator">=</span> <span class="token number">0</span>    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>train<span class="token punctuation">)</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> s <span class="token keyword">in</span> train<span class="token punctuation">:</span>        words <span class="token operator">=</span> <span class="token punctuation">[</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> s<span class="token punctuation">]</span>        golds <span class="token operator">=</span> <span class="token punctuation">[</span>t <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> s<span class="token punctuation">]</span>        <span class="token keyword">if</span> ITER <span class="token operator">&lt;</span> MAX_LIK_ITERS<span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span>  sent_loss<span class="token punctuation">(</span>words<span class="token punctuation">,</span> golds<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span>  viterbi_sent_loss<span class="token punctuation">(</span>words<span class="token punctuation">,</span> golds<span class="token punctuation">)</span>        cum_loss <span class="token operator">+=</span> loss_exp<span class="token punctuation">.</span>scalar_value<span class="token punctuation">(</span><span class="token punctuation">)</span>        num_tagged <span class="token operator">+=</span> len<span class="token punctuation">(</span>golds<span class="token punctuation">)</span>        loss_exp<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        trainer<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> DEBUG <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">1000</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">print</span> <span class="token string">"train loss "</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> cum_loss <span class="token operator">/</span> num_tagged    good_sent <span class="token operator">=</span> bad_sent <span class="token operator">=</span> good <span class="token operator">=</span> bad <span class="token operator">=</span> <span class="token number">0.0</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> sent <span class="token keyword">in</span> dev<span class="token punctuation">:</span>        words <span class="token operator">=</span> <span class="token punctuation">[</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> sent<span class="token punctuation">]</span>        golds <span class="token operator">=</span> <span class="token punctuation">[</span>t <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> sent<span class="token punctuation">]</span>        <span class="token keyword">if</span> ITER <span class="token operator">&lt;</span> MAX_LIK_ITERS<span class="token punctuation">:</span>            tags <span class="token operator">=</span> tag_sent<span class="token punctuation">(</span>words<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>            tags<span class="token punctuation">,</span> loss_exp <span class="token operator">=</span> viterbi_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span>        <span class="token keyword">if</span> tags <span class="token operator">==</span> golds<span class="token punctuation">:</span> good_sent <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> bad_sent <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> go<span class="token punctuation">,</span> gu <span class="token keyword">in</span> zip<span class="token punctuation">(</span>golds<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> go <span class="token operator">==</span> gu<span class="token punctuation">:</span> good <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> bad <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># if DEBUG == False:</span>        <span class="token comment" spellcheck="true">#     i += 1</span>        <span class="token comment" spellcheck="true">#     if i % 1000 == 0:</span>        <span class="token comment" spellcheck="true">#         print "F1 ", i, ": ", good / (good + bad)</span>    <span class="token keyword">print</span> <span class="token string">"epoch %r finished"</span> <span class="token operator">%</span> ITER    <span class="token keyword">print</span> <span class="token string">"total loss: "</span><span class="token punctuation">,</span> cum_loss <span class="token operator">/</span> num_tagged    <span class="token keyword">print</span> <span class="token string">"total F1: "</span><span class="token punctuation">,</span> good <span class="token operator">/</span> <span class="token punctuation">(</span>good <span class="token operator">+</span> bad<span class="token punctuation">)</span><span class="token punctuation">,</span> good_sent <span class="token operator">/</span> <span class="token punctuation">(</span>good_sent <span class="token operator">+</span> bad_sent<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">tagging</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">:</span>    words <span class="token operator">=</span> sentence<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> TAG_EPOCH <span class="token operator">&lt;=</span> MAX_LIK_ITERS<span class="token punctuation">:</span>        tags <span class="token operator">=</span> tag_sent<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>        tags<span class="token punctuation">,</span> loss_exp <span class="token operator">=</span> viterbi_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span>    <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> zip<span class="token punctuation">(</span>words<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> w<span class="token punctuation">,</span> t<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sentence <span class="token operator">=</span> <span class="token string">"if you could see that i am the one who understands you ."</span>    tagging<span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> dynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Tagging with Little Labeled Data</title>
      <link href="/2017/12/30/text-minning-ppt/"/>
      <url>/2017/12/30/text-minning-ppt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>历经几个星期的磨难，文本挖掘课的presentation课件初稿基本完成了，1月中下旬开讲，这次讲的是基于少量标注数据的序列标注，下面是我的综述。</p><h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><hr><ul><li>Sequence Tagging</li><li>Semi-supervised Learning</li><li>Transfer Learning</li><li>Conclusions</li><li>References</li></ul><h1 id="Sequence-Tagging"><a href="#Sequence-Tagging" class="headerlink" title="Sequence Tagging"></a>Sequence Tagging</h1><hr><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><strong>Definition</strong><br>Sequence tagging is a type of pattern recognition task that involves the algorithmic assignment of a categorical label to each member of a sequence of observed values.<br><strong>Significance</strong><br>Sequence tagging is one of the first stages in most natural language processing applications, such as part-of-speech tagging, chunking and named entity recognition.<br><strong>Approaches</strong></p><ul><li><del>Traditional models</del><ul><li><del>Hidden Markov Models</del></li><li><del>Conditional Random Fields</del></li></ul></li><li>Neural network models<ul><li>RNN, LSTM, GRU</li></ul></li></ul><h3 id="Neural-Network-Model"><a href="#Neural-Network-Model" class="headerlink" title="Neural Network Model"></a>Neural Network Model</h3><p><img src="1.png" alt></p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><img src="3.png" alt></p><h3 id="Sequence-Tagging-with-Little-Labeled-Data"><a href="#Sequence-Tagging-with-Little-Labeled-Data" class="headerlink" title="Sequence Tagging with Little Labeled Data"></a>Sequence Tagging with Little Labeled Data</h3><p><strong>Backgrounds</strong><br>Although recent neural networks obtain state-of-the-art performance on several sequence tagging tasks, they can’t be used for tasks with little labeled data.<br><strong>Approaches</strong></p><ul><li><del>Self-taught learning</del></li><li><del>Active learning</del></li><li><del>Transductive learning</del></li><li>Semi-supervised learning</li><li>Transfer learning</li></ul><h1 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h1><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><strong>Language Models Added</strong></p><ul><li>Semi-supervised Multitask Learning for Sequence Labeling. Marek Rei. ACL17.</li><li>Semi-supervised Sequence Tagging with Bidirectional Language Models. Matthew et al. ACL17.</li></ul><p><strong>Graph-based</strong></p><ul><li>Efficient Graph-Based Semi-Supervised Learning of Structured Tagging Models. Subramanya et al. EMNLP10.</li><li>Scientific Information Extraction with Semi-supervised Neural Tagging. Luan et al. EMNLP17.</li><li>Graph-based Semi-supervised Acoustic Modeling in DNN-based Speech Recognition. Liu et al. IEEE SLT14.</li></ul><h3 id="Language-Models-Added"><a href="#Language-Models-Added" class="headerlink" title="Language Models Added"></a>Language Models Added</h3><p><img src="2.png" alt></p><h3 id="Language-Modeling-Objective"><a href="#Language-Modeling-Objective" class="headerlink" title="Language Modeling Objective"></a>Language Modeling Objective</h3><p>\[\begin{array}{l}\overrightarrow { {m_t}}  = \tanh (\overrightarrow { {W_m}} \overrightarrow { {h_t}} )\\\overleftarrow { {m_t}}  = \tanh (\overleftarrow { {W_m}} \overleftarrow { {h_t}} )\\P({w_{t + 1}}|\overrightarrow { {m_t}} ) = {\rm{softmax}}(\overrightarrow { {W_q}} \overrightarrow { {m_t}} )\\P({w_{t - 1}}|\overleftarrow { {m_t}} ) = {\rm{softmax}}(\overleftarrow { {W_q}} \overleftarrow { {m_t}} )\\\overrightarrow E  =  - \sum\limits_{t = 1}^{T - 1} {\log (P({w_{t + 1}}|\overrightarrow { {m_t}} ))} \\\overleftarrow E  =  - \sum\limits_{t = 2}^T {\log (P({w_{t - 1}}|\overleftarrow { {m_t}} ))} \\E = E + \gamma (\overrightarrow E  + \overleftarrow E )\end{array}\]</p><h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p><img src="4.png" alt><br><img src="5.png" alt></p><h3 id="Language-Models-Added-1"><a href="#Language-Models-Added-1" class="headerlink" title="Language Models Added"></a>Language Models Added</h3><p><img src="6.png" alt></p><h3 id="Bidirectional-Language-Model"><a href="#Bidirectional-Language-Model" class="headerlink" title="Bidirectional Language Model"></a>Bidirectional Language Model</h3><p>\[\begin{array}{l}h_k^{LM} = [\overrightarrow {h_k^{LM}} ;\overleftarrow {h_k^{LM}} ]\\{h_{k,1}} = [\overrightarrow { {h_{k,1}}} ;\overleftarrow { {h_{k,1}}} ;h_k^{LM}]\end{array}\]<br><strong>Alternative</strong></p><ul><li>Replace $[\overrightarrow { {h_{k,1}}} ;\overleftarrow { {h_{k,1}}} ;h_k^{LM}]$ with $f([\overrightarrow { {h_{k,1}}} ;\overleftarrow { {h_{k,1}}} ;h_k^{LM}])$.</li><li>Concatenate the LM embeddings at different locations in the baseline sequence tagger.</li><li>Decrease the number of parameters in the second RNN layer.</li></ul><h3 id="Results-2"><a href="#Results-2" class="headerlink" title="Results"></a>Results</h3><p><img src="7.png" alt><br><img src="8.png" alt></p><h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>The language model transfer across domains.</li><li>The model is robust even when trained on a large number of labeled data.</li><li>Training the sequence tagging model and language model together increases performance.</li></ul><h3 id="Graph-based"><a href="#Graph-based" class="headerlink" title="Graph-based"></a>Graph-based</h3><ul><li>Steps<ul><li>Construct a graph of tokens based on their semantic similarity.</li><li>Use the CRF marginal as a regularization term to do label propagation on the graph.</li><li>The smoothed posterior is then used to either interpolate with the CRF marginal or as an additional feature to the neural network.</li></ul></li><li>Graph Construction<ul><li>${w_{uv}} = {d_e}(u,v)$ if $v \in K(u)$ or $u \in K(v)$.</li></ul></li><li>Label Propagation<br><img src="9.png" alt></li><li>Uncertain Label Marginalizing<br>\[\mathcal{Y}({x_t}) = \left\{ {\begin{array}{*{20}{c}}{\{ {y_t}\} }&amp;{ {\rm{if \ }}p({y_t}|x;\theta ) &gt; \eta }\\{ {\rm{All \ label \ types}}}&amp;{ {\rm{otherwise}}}\end{array}} \right.\]</li><li>Score<br>\[\phi (y;x,\theta ) = \sum\limits_{t = 0}^n { {T_{ {y_t},{y_{t + 1}}}}}  + \sum\limits_{t = 1}^n { {P_{t,{y_t}}}} \]</li><li>Probability<br>\[{p_\theta }(\mathcal{Y}({x^k})|{x^k}) = \frac{ {\sum\nolimits_{ {y^k} \in \mathcal{Y}({x^k})} {\exp (\phi ({y^k};{x^k},\theta ))} }}{ {\sum\nolimits_{y’ \in Y} {\exp (\phi (y’;x,\theta ))} }}\]<br><img src="10.png" alt></li></ul><h3 id="Results-3"><a href="#Results-3" class="headerlink" title="Results"></a>Results</h3><p><img src="11.png" alt></p><h3 id="Conclusions-1"><a href="#Conclusions-1" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>In-domain data performs better than cross-domain data.</li><li>The combination of in-domain data and ULM algorithms performs well.</li><li>We can add language models into the model in the future to capture the context information.</li></ul><h1 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h1><hr><h3 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h3><p><strong>Cross-domain Transfer</strong></p><ul><li>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks. Yang et al. ICLR17.</li><li>Improving Named Entity Recognition for Chinese Social Media with Word Segmentation Representation Learning. Peng et al. ACL16.</li><li>Multi-task Domain Adaptation for Sequence Tagging. Peng et al. Workshop17.</li></ul><p><strong>Cross-lingual Transfer</strong></p><ul><li>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks. Yang et al. ICLR17.</li><li>Cross-Lingual Transfer Learning for POS Tagging without Cross-Lingual Resources. Kim et al. EMNLP17.</li></ul><h3 id="Cross-domain-Transfer"><a href="#Cross-domain-Transfer" class="headerlink" title="Cross-domain Transfer"></a>Cross-domain Transfer</h3><ul><li>Label mapping exist<br><img src="13.png" alt></li><li>Disparate label sets<br><img src="12.png" alt></li></ul><p><img src="20.png" alt><br><img src="15.png" alt></p><h3 id="Domain-Projections"><a href="#Domain-Projections" class="headerlink" title="Domain Projections"></a>Domain Projections</h3><ul><li>Domain Masks<br>\[\begin{array}{l}{m_1} = [\overrightarrow 1 ,\overrightarrow 1 ,\overrightarrow 0 ],{m_2} = [\overrightarrow 1 ,\overrightarrow 0 ,\overrightarrow 1 ]\\\hat h = {m_d} \odot h\end{array}\]</li><li>Linear Projection<br>\[\hat h = {T_d}h\]</li></ul><h3 id="Results-4"><a href="#Results-4" class="headerlink" title="Results"></a>Results</h3><p><img src="16.png" alt></p><h3 id="Conclusions-2"><a href="#Conclusions-2" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>Multi-task learning can help domain adaptation.</li><li>The number of shared parameters has great impact on the performance.</li><li>We may use other domain adaptation methods besides parameter sharing and representation learning.</li></ul><h3 id="Cross-lingual-Transfer"><a href="#Cross-lingual-Transfer" class="headerlink" title="Cross-lingual Transfer"></a>Cross-lingual Transfer</h3><p><img src="17.png" alt><br><img src="18.png" alt></p><ul><li>Sequence Tagging Loss<br>\[{\mathcal{L}_p} =  - \sum\limits_{i = 1}^S {\sum\limits_{j = 1}^N { {p_{i,j}}\log ({ {\hat p}_{i,j}})} }\]</li><li>Language Classifier Loss<br>\[{\mathcal{L}_a} =  - \sum\limits_{i = 1}^S { {l_i}\log ({ {\hat l}_i})}\]</li><li>Bidirectional Language Model Loss<br>\[{\mathcal{L}_l} =  - \sum\limits_{i = 1}^S {\sum\limits_{j = 1}^N {\log (P({w_{j + 1}}|{f_j})) + \log (P({w_{j - 1}}|{b_j}))} }\]</li><li>Total Loss<br>\[\mathcal{L} = {w_s}({\mathcal{L}_p} + \lambda {\mathcal{L}_a} + \lambda {\mathcal{L}_l})\]</li></ul><h3 id="Results-5"><a href="#Results-5" class="headerlink" title="Results"></a>Results</h3><p><img src="19.png" alt></p><h3 id="Conclusions-3"><a href="#Conclusions-3" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>The language classifier can train the common LSTM to be language-agnostic.</li><li>Either too many or too little labeled data decrease the performance.</li><li>Multiple source languages can be used to increase the performance.</li></ul><h1 id="Conclusions-4"><a href="#Conclusions-4" class="headerlink" title="Conclusions"></a>Conclusions</h1><hr><h3 id="Semi-supervised-Learning-vs-Transfer-Learning"><a href="#Semi-supervised-Learning-vs-Transfer-Learning" class="headerlink" title="Semi-supervised Learning vs Transfer Learning"></a>Semi-supervised Learning vs Transfer Learning</h3><ul><li>It seems that semi-supervised learning is better than transfer learning on some tasks.</li><li>Semi-supervised learning is not always useful for the lack of unlabeled data in the same domain.</li><li>Andrew Ng had said that transfer learning is an important research direction in the next five years.</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><ul><li>Semi-supervised learning and transfer learning can be combined to increase performance.</li><li>Other methods like active learning can be added.</li></ul><h1 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h1><hr><p>Xuezhe Ma and Eduard Hovy. (2016).<br><strong>End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF.</strong><br><em>In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 1064–1074, Berlin, Germany, August 7-12, 2016.</em></p><p>Marek Rei. (2017).<br><strong>Semi-supervised Multitask Learning for Sequence Labeling.</strong><br><em>In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 2121–2130, Vancouver, Canada, July 30 - August 4, 2017.</em></p><p>Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. (2017).<br><strong>Semi-supervised Sequence Tagging with Bidirectional Language Models.</strong><br><em>In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1756–1765, Vancouver, Canada, July 30 - August 4, 2017.</em></p><p>Yi Luan, Mari Ostendorf, Hannaneh Hajishirzi. (2017).<br><strong>Scientific Information Extraction with Semi-supervised Neural Tagging.</strong><br><em>In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2631–2641, Copenhagen, Denmark, September 7–11, 2017.</em></p><p>Zhilin Yang, Ruslan Salakhutdinov, William W. Cohen. (2017).<br><strong>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks.</strong><br><em>In ICLR 2017.</em></p><p>Joo-Kyung Kim, Young-Bum Kim, Ruhi Sarikaya, Eric Fosler-Lussier. (2017).<br><strong>Cross-Lingual Transfer Learning for POS Tagging without Cross-Lingual Resources.</strong><br><em>In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2822–2828, Copenhagen, Denmark, September 7–11, 2017.</em></p><p>Nanyun Peng, Mark Dredze. (2017).<br><strong>Multi-task Domain Adaptation for Sequence Tagging.</strong><br><em>In Proceedings of the 2nd Workshop on Representation Learning for NLP, pages 91–100, Vancouver, Canada, August 3, 2017.</em></p><p>Amarnag Subramanya, Slav Petrov, Fernando Pereira. (2010).<br><strong>Efficient Graph-Based Semi-Supervised Learning of Structured Tagging Models.</strong><br><em>In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 167–176, MIT, Massachusetts, USA, 9-11 October 2010.</em></p><p>Yuzong Liu, Katrin Kirchhoff. (2014).<br><strong>Graph-based Semi-supervised Acoustic Modeling in DNN-based Speech Recognition.</strong><br><em>In IEEE SLT 2014.</em></p><p>Nanyun Peng, Mark Dredze. (2016).<br><strong>Improving Named Entity Recognition for Chinese Social Media with Word Segmentation Representation Learning.</strong><br><em>In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 149–155, Berlin, Germany, August 7-12, 2016.</em></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华东师范大学LaTeX幻灯片模板</title>
      <link href="/2017/12/29/ecnu-ppt/"/>
      <url>/2017/12/29/ecnu-ppt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>分享一套自用ppt模板，使用 <code>XeLaTeX</code> 编译<br>链接地址：<a href="https://github.com/godweiyang/ECNU_BeamerTemplate" target="_blank" rel="noopener">传送门</a></p><h1 id="界面示例"><a href="#界面示例" class="headerlink" title="界面示例"></a>界面示例</h1><p><img src="1.png" alt><br>觉得还可以的下载了用哦，欢迎修改的更美观！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
            <tag> ppt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scientific Information Extraction with Semi-supervised Neural Tagging</title>
      <link href="/2017/12/19/emnlp17-2/"/>
      <url>/2017/12/19/emnlp17-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/D/D17/D17-1279.pdf" target="_blank" rel="noopener">D17-1279</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>这篇论文研究的是科技论文的信息抽取问题，比如给你一篇paper，你要找出其中的Task（任务）、Process（过程方法）、Material（资料数据）三种实体。<br>这个问题可以归类为序列标注问题，但是科技论文的标注数据还是很少的，于是本文提出了一种基于图的半监督序列标注算法。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>背景就是近几年来论文发表数量越来越多，要对这些论文进行信息抽取，概括这篇论文的摘要。<br>由于标注过的论文很少，大量论文那都是无标注的，所以需要一个半监督的方法来进行序列标注。本文有三大贡献：一是结果比以往的更好啦，二是提出一种半监督序列标注方法，使用基于图的标签传播和可信度数据选择，三是探索了不同的利用无标注数据的方法，比如无监督的表示初始化和半监督的模型训练。</p><p>以往的工作大多是基于迁移学习的，本文提出的模型比他们结果都要好（ps.迁移学习和半监督方法都说自己最好。。。）</p><h1 id="2-模型"><a href="#2-模型" class="headerlink" title="2 模型"></a>2 模型</h1><hr><p>基本的模型就不用说了，就是传统的CNN+LSTM+CRF序列标注模型。<br>本文的重点就在于无标注数据的使用上，采用了基于图的标签传播算法，来对无标注数据进行标注，并添加到序列标注模型中进行训练。</p><h1 id="3-半监督学习"><a href="#3-半监督学习" class="headerlink" title="3 半监督学习"></a>3 半监督学习</h1><hr><p>具体是怎么标注的呢？<br>概括起来就是首先计算出每个无标注数据的后验概率，然后改进基本序列标注模型中的CRF，使它能够考虑到标签的不确定性。</p><h3 id="基于图的后验估计"><a href="#基于图的后验估计" class="headerlink" title="基于图的后验估计"></a>基于图的后验估计</h3><p>估计后验概率方法如下：<br>首先基于词的语义相似度构造出一个图，然后使用CRF边际函数作为正则化因子在图上进行标签传播，最后应用到神经网络中。</p><h4 id="图的构造"><a href="#图的构造" class="headerlink" title="图的构造"></a>图的构造</h4><p>图中的结点代表单词，边代表词之间的语义相似性。整个图的结点数量等于标注数据和未标注数据总单词数。<br>单词的表示是用前后共5个单词的词向量、和他最近的动词的词向量、一组离散特征例如词性和大写连接而成，然后用PCA降维到100维。<br>定义两个结点之间的边权重等于欧几里得距离，如果两个点中至少一个点在另一个点的K近邻里。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> EMNLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cross-Lingual Transfer Learning for POS Tagging without Cross-Lingual Resources</title>
      <link href="/2017/12/19/emnlp17-1/"/>
      <url>/2017/12/19/emnlp17-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/D/D17/D17-1302.pdf" target="_blank" rel="noopener">D17-1302</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>本文介绍了一个跨语言的序列标注迁移模型，和以往不同的是，不需要大量的跨语言语料。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>之前正好才看过一篇Yang et al. (2017)的论文Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks，还写了博客笔记<a href="http://godweiyang.com/2017/11/13/ICLR17-1/">[传送门]</a>。然而本文上来就说，他的模型不好！因为他的模型共享了字符层，其他层都是独立的，这样就导致了两种字符没有交集的语言迁移会很困难。<br>于是本文提出了基于一个公有LSTM和一个私有LSTM的模型。不过，我还是没明白这个字符层和前文批判的那个有啥区别。。。</p><h1 id="2-模型"><a href="#2-模型" class="headerlink" title="2 模型"></a>2 模型</h1><hr><p>模型结构如下图所示：<br><img src="1.png" alt></p><h3 id="跨语言训练"><a href="#跨语言训练" class="headerlink" title="跨语言训练"></a>跨语言训练</h3><p>整体训练过程是这样的：首先输入一个句子，对于每个单词中的每个字符，输入到双向LSTM中，取前向后向LSTM的最后一个隐含层输出，连接到一起来作为词的表示。然后输入到公有和私有LSTM中训练，最后的损失函数有三个。<br>图中蓝色部分是公有部分，红色部分是私有部分。紫色部分是不同语言预测出的结果，三个红色方框是三个损失函数。<br>其中softmax层的损失函数定义为：<br><img src="2.png" alt><br>$S$是句子个数，$N$是当前句子单词数，${p_{i,j}}$第$i$个句子的第$j$个标签，${\hat p_{i,j}}$是预测标签。</p><h3 id="语言对抗训练"><a href="#语言对抗训练" class="headerlink" title="语言对抗训练"></a>语言对抗训练</h3><p>为了让公有的LSTM部分变得语言无关，所以要对他进行语言对抗训练。<br>首先对公有LSTM的输出进行CNN/MaxPool编码（其实就是每一个维度取最大值），三个卷积层，得到三个向量，再连接到一起得到最终的向量表示，经过一个梯度反转层，最后输入到语言鉴别器。<br>这个语言鉴别器就是一个单隐含层的全连接的神经网络，激活函数用的是Leaky ReLU，具体就是当x&gt;=0时，f(x)=x；当x&lt;0时，f(x)=ax，这里a取0.2。<br>最后得到的损失函数定义为：<br><img src="3.png" alt><br>其中${l_{i}}$是第i个句子的语言，${\hat l_{i}}$是预测出的语言（原文说的是softmax输出的标签？？？这里不是很理解）。<br>由于经过了梯度反转层，所以这个语言鉴别器并不能鉴别出是哪一种语言，反而对两种语言的界限混淆了，使得它变得越来越语言无关了。</p><h3 id="双向语言模型"><a href="#双向语言模型" class="headerlink" title="双向语言模型"></a>双向语言模型</h3><p>这个就不用多说了，很多地方都用到了，之前的两篇半监督序列标注的论文也都提到了加入语言模型来提升效果，而且注意的是，就算是没有标注的数据也可以加入进语言模型的训练。<br>语言模型的损失函数定义为：<br><img src="4.png" alt><br>其中f和b分别代表前向和后向LSTM输出。<br>最终，三个损失函数合并起来定义一个总的损失函数：<br><img src="5.png" alt><br>其中$\lambda $随着训练进行缓慢的从0上升到1，这是为了增加额外损失函数的训练稳定性。<br>而$w_{s}$是为了给源语言和目标语言不同的权重的，当训练目标语言是，权重为1，否则权重为目标语言训练集大小/源语言训练集大小。</p><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h1><p>实验针对目标语言训练句子数为1280、320和32分别做了对比。<br>其中1280个句子的结果如下：<br><img src="6.png" alt><br>可以看出加入迁移学习后结果提升还是比较大的，表格中c表示公有LSTM，l表示语言模型，p表示私有LSTM，a表示语言对抗训练。本文的模型(c,p,l+a)结果是最好的。<br>320个句子的结果如下：<br><img src="7.png" alt><br>依然有提升，但是提升很不明显了，而且有几种语言直接采用私有LSTM+语言模型效果反而最好。原因就是目标语言的训练数据太少了，不足以训练出完美的公有和私有模型。<br>32个句子的训练数据就没有放出具体结果，结果依然有略微提升的，但是已经可以忽略不计了。<br>反过来思考，如果用上全部的目标语言训练数据，那么出来的结果会怎么样？事实是反而下降了，还不如直接用私有LSTM。<br>最后还做了一个实验，就是用多种不同的源语言+目标语言来训练模型，发现效果比用单种源语言效果好。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Tagging with Little Labeled Data</title>
      <link href="/2017/11/29/textminning/"/>
      <url>/2017/11/29/textminning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>文本挖掘课presentation还有一个多月了，依然很迷茫，不知道选什么课题。<br>最近看了一些序列标注相关的paper，暂且就准备挑一个相关的点做了，打算做一个“基于少量标注数据的序列标注”。</p><h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><hr><p>基于少量标注数据的序列标注，主要有两种方法：迁移学习和半监督学习。<br>代表性的paper分别有：<br><a href="https://arxiv.org/pdf/1703.06345.pdf" target="_blank" rel="noopener">Yang Z, Salakhutdinov R, Cohen W W. Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks. ICLR, 2017.</a><br><a href="https://arxiv.org/pdf/1705.00108.pdf" target="_blank" rel="noopener">Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. Semi-supervised sequence tagging with bidirectional language models. ACL, 2017.</a><br>具体该讲些什么，该怎么讲，等我慢慢补充吧。<br>其中传统的半监督序列标注模型有基于HMM之类的，这里就不说了。<br>下面说说几个基于双向LSTM的。</p><h3 id="Marek-Rei-Semi-supervised-Multitask-Learning-for-Sequence-Labeling-ACL-2017"><a href="#Marek-Rei-Semi-supervised-Multitask-Learning-for-Sequence-Labeling-ACL-2017" class="headerlink" title="Marek Rei. Semi-supervised Multitask Learning for Sequence Labeling. ACL, 2017."></a>Marek Rei. <em>Semi-supervised Multitask Learning for Sequence Labeling. ACL, 2017.</em></h3><p><img src="1.png" alt><br>这篇论文介绍了一个附加了语言模型的LSTM序列标注模型。<br>就是在传统的序列标注模型隐含层输出上额外附加了一层语言模型输出，总的损失函数也加上了语言模型的损失函数，共同训练。<br><img src="2.png" alt><br><img src="3.png" alt><br><img src="4.png" alt><br><img src="5.png" alt><br>其中E就是原始序列标注模型的损失。<br>当然了，这个模型不需要额外的未标注数据，只要用到少量的标注数据就行了。</p><h3 id="Matthew-E-Peters-Waleed-Ammar-Chandra-Bhagavatula-Russell-Power-Semi-supervised-sequence-tagging-with-bidirectional-language-models-ACL-2017"><a href="#Matthew-E-Peters-Waleed-Ammar-Chandra-Bhagavatula-Russell-Power-Semi-supervised-sequence-tagging-with-bidirectional-language-models-ACL-2017" class="headerlink" title="Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. Semi-supervised sequence tagging with bidirectional language models. ACL, 2017."></a>Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. <em>Semi-supervised sequence tagging with bidirectional language models. ACL, 2017.</em></h3><p>这篇论文就是半监督序列标注模型中我看到的效果最好的一个了。<br>和上面一篇相同的是，都加入了语言模型，来对单词上下文信息进行编码。但是不同的是，上文将语言模型和序列标注模型融合在了一起，所以只需要少量的标注数据就行了，无法利用大量的无标注数据。这篇的模型将其分开，预先对大量的无标注数据训练语言模型，然后将训练好的词表示加入到序列标注模型中，和原始的词向量结合，然后进行训练。<br>模型结构如下所示：<br><img src="6.png" alt></p><h3 id="Yi-Luan-Mari-Ostendorf-Hannaneh-Hajishirzi-Scientific-Information-Extraction-with-Semi-supervised-Neural-Tagging-EMNLP-2017"><a href="#Yi-Luan-Mari-Ostendorf-Hannaneh-Hajishirzi-Scientific-Information-Extraction-with-Semi-supervised-Neural-Tagging-EMNLP-2017" class="headerlink" title="Yi Luan, Mari Ostendorf, Hannaneh Hajishirzi. Scientific Information Extraction with Semi-supervised Neural Tagging. EMNLP, 2017."></a>Yi Luan, Mari Ostendorf, Hannaneh Hajishirzi. <em>Scientific Information Extraction with Semi-supervised Neural Tagging. EMNLP, 2017.</em></h3><p>这篇论文任务是科技文章的关键词提取，然后分类为task、process、material三类，可以将其看成一个序列标注任务。<br>这篇论文介绍了一种基于图的半监督方法</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理实践期末大作业</title>
      <link href="/2017/11/16/sw-compiler/"/>
      <url>/2017/11/16/sw-compiler/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这学期编译原理实践期末大作业是编写一个简化swift语法编译器，代码等到学期结束再上传百度云，现在先上传一个测试运行程序，bug很多。<br><a href="https://pan.baidu.com/s/1jHDbtcy" target="_blank" rel="noopener">程序地址</a>，密码是cnfj，在大四上文件夹下。<br>主界面：<br><img src="1.png" alt><br>支持常用编辑以及编译运行和单步调试查看数据栈。<br>目前暂时只做了跳过注释、mod、odd、自增、自减、常量定义、repeat这几个扩展点，其他再说吧，做的很烂，及格就行。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks</title>
      <link href="/2017/11/13/iclr17-1/"/>
      <url>/2017/11/13/iclr17-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://arxiv.org/pdf/1703.06345.pdf" target="_blank" rel="noopener">链接</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>探索一种神经序列标注的迁移学习方法，适用于源任务有大量标注标签，但是目标任务标注标签很少的情况，主要有三个方面：跨领域、跨应用、跨语言。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>序列标注任务的一个难点就是怎样将知识从一个任务迁移到另一个任务上面去，通常被叫做“迁移学习”。<br>这里对三种任务（跨领域、跨应用、跨语言）分别提出了参数共享的神经网络结构，实验结果也很好。即使标注标签很多，结果也比以前的结果更好。</p><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a>2 相关工作</h1><hr><p>NLP迁移学习通常有两种方法，一种是基于资源的迁移，另一种是基于模型的迁移。<br>基于资源的迁移需要大量的跨语言语料，而且通常只用在跨语言任务了，在跨领域和跨应用方面还没什么应用。<br>基于模型的迁移就不需要大量的额外资源了，只要探索源任务和目标任务之间的相似性和相关性，通过修改模型结构、训练算法、特征表示。<br>这里的模型就是基于模型的迁移。和以往不同的是，这个模型利用了深度递归神经网之间的一般性，可以在跨领域、跨应用、跨语言之间转换。</p><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h1><hr><p><img src="1.png" alt><br>上图分别是基本模型、跨领域模型、跨应用模型、跨语言模型。</p><h3 id="3-1-基本模型"><a href="#3-1-基本模型" class="headerlink" title="3.1 基本模型"></a>3.1 基本模型</h3><p>首先字符层输入每个字符表示，输出单词的字符层表示，然后和词向量结合作为每个词的表示，然后经过一个CNN或者RNN，隐含层输出再经过一个CRF得到每个词的标签。</p><h3 id="3-2-迁移学习结构"><a href="#3-2-迁移学习结构" class="headerlink" title="3.2 迁移学习结构"></a>3.2 迁移学习结构</h3><p>跨领域、跨应用、跨语言每种一个迁移结构，和基本模型不同的是，共享的参数不同。</p><h4 id="3-2-1-跨领域迁移"><a href="#3-2-1-跨领域迁移" class="headerlink" title="3.2.1 跨领域迁移"></a>3.2.1 跨领域迁移</h4><p>跨领域迁移有两种情况，一种是两个领域标签存在映射关系，一种是不存在映射关系。<br>第一种情况结构如图b所示，可以共享CRF层以及下面的所有层，最后加一个标签映射的步骤就行了<br>第二种情况结构如图c所示，CRF层独立训练。</p><h4 id="3-2-2-跨应用迁移"><a href="#3-2-2-跨应用迁移" class="headerlink" title="3.2.2 跨应用迁移"></a>3.2.2 跨应用迁移</h4><p>这里假设两种应用是同一种语言，所以和跨领域标签无映射关系类似，用的是图c的结构。</p><h4 id="3-2-3-跨语言迁移"><a href="#3-2-3-跨语言迁移" class="headerlink" title="3.2.3 跨语言迁移"></a>3.2.3 跨语言迁移</h4><p>这里重点放在两种字母表相同的语言上，比如英语和西班牙语。<br>由于字符相同，所以采用图d结构，共享字符层和词向量。</p><h3 id="3-3-训练"><a href="#3-3-训练" class="headerlink" title="3.3 训练"></a>3.3 训练</h3><p>假设从任务$s$迁移到任务$t$，训练集分为$X_s$和$X_t$，参数分为$W_s$和$W_t$。其中模型参数还分为任务特定参数和共享参数：<br>\[{W_s} = {W_{s,spec}} \cup {W_{shared}},{W_t} = {W_{t,spec}} \cup {W_{shared}}\]训练过程如下：<br>每一次迭代，都采用二项分布随机抽取一个任务$s$或$t$，然后训练该任务特定模型参数和共享参数。由于源任务和目标任务收敛速度不一定一样，所以对目标任务提前停止。</p><h3 id="3-4-模型实现"><a href="#3-4-模型实现" class="headerlink" title="3.4 模型实现"></a>3.4 模型实现</h3><p>RNN采用GRU，假设隐含层输出为$h$，输出标签为$y$，定义CRF的目标函数为<br>\[f(h,y) - \log \sum\limits_{y’ \in \gamma (h)} {\exp (f(h,y’) + \cos {\rm{t}}(y,y’))} \]</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h1><p><img src="2.png" alt><br><img src="3.png" alt><br>上图是实验结果，其中跨领域迁移：ade，跨应用迁移：fgh，跨语言迁移：ij，跨领域和应用：b，跨领域、应用和语言：c。<br><img src="4.png" alt><br>上表是各类任务在不同标签率下迁移学习和无迁移学习的性能对比。<br>可以看出三种迁移结构性能提升的顺序是A&gt;B&gt;C，因为结构C比如跨语言模型，源任务和目标任务相似性很小。<br><img src="5.png" alt><br>上图是和其他模型比较的结果。</p><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h1><hr><p>提出一种神经序列标注的迁移学习方法，主要有三个方面：跨领域、跨应用、跨语言。<br>以下三个因素对迁移学习性能有很大影响：目标任务标签数量、源任务和目标任务相关性、能够共享的参数数量。<br>在以后的工作中，可以在跨语言迁移学习中尝试结合基于模型的迁移和基于资源的迁移。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> ICLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Implicitly-Defined Neural Networks for Sequence Labeling</title>
      <link href="/2017/10/25/acl17-2027/"/>
      <url>/2017/10/25/acl17-2027/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/P/P17/P17-2027.pdf" target="_blank" rel="noopener">P17-2027</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>这篇论文介绍了一种新奇的、隐式定义神经网络，并且描述了计算它的方法。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>传统的双向RNN只能单独计算两个方向的隐含层，现在介绍一种新的机制，将两个方向的信息直接结合起来计算。</p><h1 id="2-INN"><a href="#2-INN" class="headerlink" title="2 INN"></a>2 INN</h1><hr><h3 id="2-1-传统的RNN"><a href="#2-1-传统的RNN" class="headerlink" title="2.1 传统的RNN"></a>2.1 传统的RNN</h3><p>经典的RNN给定一个输入序列$[{\xi _1},{\xi _2}, \ldots ,{\xi _n}]$和初始隐含层状态${h_s}$，然后迭代产生后续的隐含层状态：<br>\[\begin{array}{l}{h_1} = f({\xi _1},{h_s})\\{h_2} = f({\xi _2},{h_1})\\ \cdots \\{h_n} = f({\xi _n},{h_{n - 1}})\end{array}\]LSTM、GRU和其他的相关变体计算方法也都类似，都是像下图这样线性计算，每一时刻的状态只依赖于当前输入和前一时刻的状态。<br><img src="1.png" alt></p><h3 id="2-2-改进结构"><a href="#2-2-改进结构" class="headerlink" title="2.2 改进结构"></a>2.2 改进结构</h3><p>这篇论文中这样计算隐含层状态：<br>\[{h_t} = f({\xi _t},{h_{t - 1}},{h_{t + 1}})\]这样整个隐含层状态序列的等式就是隐式的，记为：<br>\[H = [{h_1},{h_2}, \ldots ,{h_n}]\]在这个神经网络中，定义如下变量：数据$X$、标签$Y$、参数$\theta$，定义如下函数：<br>输入层变换：<br>\[\xi  = g(\theta ,X)\]隐式隐含层：<br>\[H = F(\theta ,\xi ,H)\]损失函数：<br>\[L = \ell (\theta ,H,Y)\]定义${h_s}$和${h_e}$为边界状态，$n$为输入序列长度，$F$函数构造出了一系列非线性等式：<br>\[\begin{array}{l}{h_1} = f({h_s},{h_2},{\xi _1})\\ \cdots \\{h_i} = f({h_{i - 1}},{h_{i + 1}},{\xi _i})\\ \cdots \\{h_n} = f({h_{n - 1}},{h_e},{\xi _n})\end{array}\]INN结构如下图：<br><img src="2.png" alt></p><h3 id="2-3-计算前向传播"><a href="#2-3-计算前向传播" class="headerlink" title="2.3 计算前向传播"></a>2.3 计算前向传播</h3><p>为了计算等式$H = F(H)$，采用拟牛顿法。<br>令$G = H - F(H)$，转化为计算等式$G = 0$。<br>\[\begin{array}{l}{H_{n + 1}} = {H_n} - {({\nabla _H}G)^{ - 1}}G\\{H_{n + 1}} = {H_n} - {(I - {\nabla _H}F)^{ - 1}}({H_n} - F({H_n}))\end{array}\]注意到$(I - {\nabla _H}F)$是一个稀疏矩阵，所以采用Krylov子空间方法，具体是稳定双共轭梯度法(BICG-STAB)算法来计算。</p><h3 id="2-4-梯度"><a href="#2-4-梯度" class="headerlink" title="2.4 梯度"></a>2.4 梯度</h3><p>为了训练模型，采用随机梯度下降，定义损失函数：<br>\[{\nabla _\theta }L = {\nabla _\theta }\ell  + {\nabla _H}\ell {\nabla _\theta }H\]其中<br>\[{\nabla _\theta }H = {\nabla _\theta }F + {\nabla _H}F{\nabla _\theta }H + {\nabla _\xi }F{\nabla _\theta }\xi \]所以<br>\[{\nabla _\theta }H = {(I - {\nabla _H}F)^{ - 1}}({\nabla _\theta }F + {\nabla _\xi }F{\nabla _\theta }\xi )\]所以整个梯度就是<br>\[{\nabla _\theta }L = {\nabla _\theta }\ell  + {\nabla _H}\ell {(I - {\nabla _H}F)^{ - 1}}({\nabla _\theta }F + {\nabla _\xi }F{\nabla _\theta }\xi )\]</p><h3 id="2-5-转换函数"><a href="#2-5-转换函数" class="headerlink" title="2.5 转换函数"></a>2.5 转换函数</h3><p>回忆在GRU中，有如下转换函数：<br>\[\begin{array}{l}{h_t} = (1 - {z_t}){ {\hat h}_t} + {z_t}{ {\tilde h}_t}\\{ {\tilde h}_t} = \tanh (W{x_t} + U({r_t}{ {\hat h}_t}) + \tilde b)\\{z_t} = \sigma ({W_z}{x_t} + {U_z}{ {\hat h}_t} + {b_z})\\{r_t} = \sigma ({W_r}{x_t} + {U_r}{ {\hat h}_t} + {b_r})\end{array}\]其中在GRU中${ {\hat h}_t} = {h_{t - 1}}$，在INN中做一个替代：<br>\[\begin{array}{l}{ {\hat h}_t} = s{h_{t - 1}} + (1 - s){h_{t + 1}}\\s = \frac{ { {s_p}}}{ { {s_p} + {s_n}}}\\{s_p} = \sigma ({W_p}{x_t} + {U_p}{h_{t - 1}} + {b_p})\\{s_n} = \sigma ({W_n}{x_t} + {U_n}{h_{t + 1}} + {b_n})\end{array}\]</p><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h1><hr><h3 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h3><p>如下图所示，这个模型的效果甚至比标准的序列标注器还要好！<br><img src="3.png" alt></p><h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h1><hr><p>介绍了一种隐式定义神经网络，应用到了序列标注任务上，效果比双向LSTM、双向GRU等还要好。<br>还有一些工作可以改进，比如可以在双向LSTM上面改造INN，加速计算${(I - {\nabla _H}F)^{ - 1}}$等等。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semi-supervised sequence tagging with bidirectional language models</title>
      <link href="/2017/10/03/acl17-1161/"/>
      <url>/2017/10/03/acl17-1161/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/P/P17/P17-1161.pdf" target="_blank" rel="noopener">P17-1161</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>从未标注文本中学习到的预训练词向量已经成为NLP任务神经网络结构的重要组成部分。<br>但是大多数情况下，现在的循环神经网络还是从极少的标注数据中学习上下文相关的表示。<br>所以这篇论文研究一种通用的半监督学习方法，将从双向语言模型中预训练出来的词向量加到NLP系统中，把它应用到序列标注任务中。<br>我们在两个NLP任务上做实验：NER和chunking。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>这篇论文我们探讨一种半监督学习方法，不需要额外的标注数据。<br>我们使用一个神经语言模型，在大量未标注数据上训练，计算出每个位置上下文的编码，然后应用到半监督的标注模型中。<br>我们第一个主要贡献是证明了语言模型训练出的上下文相关表示在半监督标注模型中是很有用的。<br>第二个贡献是多使用一个后向的语言模型效果更好。<br>同时我们发现没必要针对某个领域数据来专门训练。</p><h1 id="2-语言模型增强的序列标注"><a href="#2-语言模型增强的序列标注" class="headerlink" title="2 语言模型增强的序列标注"></a>2 语言模型增强的序列标注</h1><hr><h3 id="2-1-概览"><a href="#2-1-概览" class="headerlink" title="2.1 概览"></a>2.1 概览</h3><p>这个模型的主要结构如图所示：<br><img src="1.jpg" alt><br>主要过程可以分为3步：</p><ul><li>首先在大量的未标注数据上训练词向量和一个神经语言模型</li><li>然后提取一个句子中每个单词的词向量表示与语言模型表示</li><li>最后将它们应用到监督序列标注模型中。</li></ul><p>具体的结构如下图所示：<br><img src="2.jpg" alt></p><h3 id="2-2-基本的序列标注模型"><a href="#2-2-基本的序列标注模型" class="headerlink" title="2.2 基本的序列标注模型"></a>2.2 基本的序列标注模型</h3><p>我们用到的基本的序列标注模型是一个分层的神经序列标注模型，如上图左半部分所示。<br>给定一个句子$({t_1},{t_2}, \ldots ,{t_N})$，首先对于每个单词${t_k}$产生一个表示${x_k}$，其中${x_k}$是由这个单词基于字符的表示${c_k}$和词向量表示${w_k}$连接而成：<br>\[\begin{array}{l}{c_k} = C({t_k};{\theta _c})\\{w_k} = E({t_k};{\theta _w})\\{x_k} = [{c_k};{w_k}]\end{array}\]字符表示${c_k}$捕获的是这个单词的形态信息，可以用CNN或者RNN来实现。<br>词向量表示${w_k}$是从预训练的词向量表中直接提取的。<br>为了学习到上下文相关的表示，我们采用多层双向RNN。<br>对于每个单词${x_k}$，第${i}$层隐含层${h_{k,i}}$是由前向隐含层状态${ {\vec h}_{k,i}}$和后向隐含层状态${ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,i}}$连接而成。<br>对于第一层隐含层，${h_{k,1}}$由${x_k}$经过如下运算获得：<br>\[\begin{array}{l}{ {\vec h}_{k,1}} = { {\vec R}_1}({x_k},{ {\vec h}_{k - 1,1}};{\theta _{ { {\vec R}_1}}})\\{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}} = { {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over R} }_1}({x_k},{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k + 1,1}};{\theta _{ { {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over R} }_1}}})\\{h_{k,1}} = [{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}}]\end{array}\]这个实验中我们使用2层隐含层，并且使用GRU或者LSTM作为双向RNN。<br>最后，最后一层隐含层的输出${h_{k,L}}$被输出到一个稠密层，用来预测每个标签的评分。<br>由于在我们的序列标注任务中，连续的标签之间是有依赖性的，所以联合起来预测一整个句子的标签比单独预测每个单词的标签更好。<br>因此，我们增加了额外的一层来计算相邻两个标签之间的条件随机场损失，然后用Viterbi算法来寻找概率最大的标签序列。</p><h3 id="2-3-双向语言模型"><a href="#2-3-双向语言模型" class="headerlink" title="2.3 双向语言模型"></a>2.3 双向语言模型</h3><p>一个语言模型是用来计算一个句子$({t_1},{t_2}, \ldots ,{t_N})$的概率：<br>\[p({t_1},{t_2}, \ldots ,{t_N}) = \prod\limits_{k - 1}^N {p({t_k}|{t_1},{t_2}, \ldots ,{t_{k - 1}})} \]之前的研究将每个单词的字符表示或者词向量表示送到多层LSTM中，用$({t_1},{t_2}, \ldots ,{t_k})$来求出隐含层${ {\vec h}^{LM}}_k$，这就是第$k$个单词的前向语言模型表示，同时也是语言模型LSTM层最顶端的输出。最后用softmax层来预测${t_{k + 1}}$的概率。<br>当然再加上一个后向语言模型表示效果就更好了：<br>\[p({t_1},{t_2}, \ldots ,{t_N}) = \prod\limits_{k - 1}^N {p({t_k}|{t_{k + 1}},{t_{k + 2}}, \ldots ,{t_N})} \]后向语言模型表示实现方式和前向相似，产生输出${ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }^{LM}}_k$<br>注意到在这个模型中，前向后向语言模型是独立的，不共享任何参数。</p><h3 id="2-4-结合语言模型和序列模型"><a href="#2-4-结合语言模型和序列模型" class="headerlink" title="2.4 结合语言模型和序列模型"></a>2.4 结合语言模型和序列模型</h3><p>我们结合的模型TagLM是将语言模型的词表示当作额外的输入传送到序列标注模型中。<br>在实验中，我们发现将语言模型表示和序列模型第一层隐含层输出结合效果最好。表示如下：<br>\[{h_{k,1}} = [{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}};{h_k}^{LM}]\]有许多方法可以结合语言模型表示和序列模型第一层隐含层输出，比如用一个非线性函数来结合：<br>\[{h_{k,1}} = f([{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}};{h_k}^{LM}])\]另一种可能的方法是用类似注意力模型的机制，给每个单词的语言模型表示加上权重，然后再加进序列模型中。<br>本次实验中直接结合效果已经很好了，所以没有尝试其他方法。</p><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h1><hr><p>我们在两个NLP任务上做实验：NER和chunking，使用F1评价指标和BIOES标注体系。<br>我们对数据做了预处理，对所有字母小写处理，将所有数字替换成0。</p><h4 id="CoNLL-2003-NER"><a href="#CoNLL-2003-NER" class="headerlink" title="CoNLL 2003 NER"></a>CoNLL 2003 NER</h4><p>CoNLL 2003 NER任务包含了路透社RCV1语料库，它是由4种不同的实体类型标注的：PER、LOC、ORG、MISC，包含了标准的训练集、验证集和测试集。<br>我们的序列模型的字符表示使用了80个隐含层和25维字符表示的双向GRU。上面的序列层使用了两个300个隐含层的双向GRU。为了正则化，每个GRU的输入都添加了25%的dropout。</p><h4 id="CoNLL-2000-chunking"><a href="#CoNLL-2000-chunking" class="headerlink" title="CoNLL 2000 chunking"></a>CoNLL 2000 chunking</h4><p>CoNLL 2000 chunking任务使用华尔街日报第15~18章训练，第20章测试。定义了11种句法分块类型，我们从训练集随机标记出1000个句子作为验证集。<br>序列模型字符表示使用了30维字符表示和带有30个宽度为3字符滤波器的CNN。上面的序列层使用了两个200个隐含层的双向GRU。每个GRU的输入都添加了50%的dropout。</p><h4 id="预训练语言模型"><a href="#预训练语言模型" class="headerlink" title="预训练语言模型"></a>预训练语言模型</h4><p>我们在1B Word Benchmark上面训练语言模型，包含了8亿个单词。<br>我们使用两个2048个单元，512维的LSTM，在4个GPU上进行参数的同步更新，在10轮训练后就停止训练。</p><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>所有的实验都采用Adam优化器在5.0处进行梯度截断。<br>提前结束训练来防止过拟合，采用以下方法来决定什么时候停止训练：开始时学习率设为0.001，观察验证集每一轮的性能，当验证集上的性能达到最高时，将学习率降低一个数量级，再训练5次，再降低一个数量级，再训练5次，最后停止训练。</p><h3 id="3-1-综合系统结果"><a href="#3-1-综合系统结果" class="headerlink" title="3.1 综合系统结果"></a>3.1 综合系统结果</h3><p>表1和表2比较的是TagLM和其他没有额外标注数据的模型结果。<br>表3和表4比较的是TagLM和其他包含额外标注数据的模型结果。<br><img src="3.jpg" alt><br><img src="4.jpg" alt></p><ul><li>增加外部标注数据<br>尽管我们没有使用外部标注数据，但是我们效果依然比其他模型要好。表3和表4还可以看出这个模型加了语言模型后的提升是最大的。</li></ul><h3 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2 分析"></a>3.2 分析</h3><p>为了解释我们的TagLM的特性，我们在CoNLL 2003 NER上做了许多额外的实验。</p><h4 id="怎样使用语言模型表示？"><a href="#怎样使用语言模型表示？" class="headerlink" title="怎样使用语言模型表示？"></a>怎样使用语言模型表示？</h4><p>在这个实验中，我们将语言模型产生的表示连接到序列模型的不同位置：</p><ul><li>连接到第一个RNN的输入层：<br>\[{x_k} = [{c_k};{w_k};{h_k}^{LM}]\]</li><li>连接到第一个RNN的输出层：<br>\[{h_{k,1}} = [{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}};{h_k}^{LM}]\]</li><li>连接到第二个RNN的输出层：<br>\[{h_{k,2}} = [{ {\vec h}_{k,2}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,2}};{h_k}^{LM}]\]</li></ul><p>表5显示出第二种位置是效果最好的，我们猜测原因可能是因为第二层RNN可以捕获第一层RNN产生的任务特定的上下文和语言模型产生的通用的上下文之间的互相联系。<br><img src="5.jpg" alt></p><h4 id="用哪一种语言模型重要吗？"><a href="#用哪一种语言模型重要吗？" class="headerlink" title="用哪一种语言模型重要吗？"></a>用哪一种语言模型重要吗？</h4><p>从表6可以看出，前向传播使用CNN-BIG-LSTM，后向传播使用LSTM-2048-512效果是最好的，但是我们没有测试后向也是CNN-BIG-LSTM的，那样效果估计会更好。<br><img src="6.jpg" alt></p><h4 id="任务特定RNN的重要性"><a href="#任务特定RNN的重要性" class="headerlink" title="任务特定RNN的重要性"></a>任务特定RNN的重要性</h4><p>我们把任务特定的RNN去掉了，只用语言模型和稠密层和CRF来预测输出标签，结果非常的差。说明还是需要任务特定RNN来对标注数据编码产生必要的信息的。</p><h4 id="数据集的大小"><a href="#数据集的大小" class="headerlink" title="数据集的大小"></a>数据集的大小</h4><p>通过在大数据和小数据上做实验，得出如下结论：<br>以往的模型在小数据上从无语言模型到有语言模型提升都是很大的，但是在大数据上提升就非常的少了。<br>而我们的TagLM不论是小数据还是大数据性能提升都非常的大。</p><h4 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h4><p>由于第二层RNN的输入加入了语言模型表示，所以维数增加了，但是对实验效果几乎没有影响的。<br>我们通过两个实验来验证：</p><ul><li>增加不包含语言模型的序列模型的第二层RNN维数。</li><li>减少TagLM的第二层RNN维数。</li></ul><p>性能提升都非常的少，而且还说明了TagLM增加的参数对性能是有略微削弱的。</p><h4 id="语言模型要跟随语料库领域而改变吗？"><a href="#语言模型要跟随语料库领域而改变吗？" class="headerlink" title="语言模型要跟随语料库领域而改变吗？"></a>语言模型要跟随语料库领域而改变吗？</h4><p>答案是不需要，之前都是在新闻语料上做的训练，我们直接把它应用到了科技语料库上，性能依然有很大提升。</p><h1 id="4-相关工作"><a href="#4-相关工作" class="headerlink" title="4 相关工作"></a>4 相关工作</h1><hr><h4 id="未标注数据"><a href="#未标注数据" class="headerlink" title="未标注数据"></a>未标注数据</h4><h4 id="神经语言模型"><a href="#神经语言模型" class="headerlink" title="神经语言模型"></a>神经语言模型</h4><h4 id="解释RNN状态"><a href="#解释RNN状态" class="headerlink" title="解释RNN状态"></a>解释RNN状态</h4><h4 id="其他序列标注模型"><a href="#其他序列标注模型" class="headerlink" title="其他序列标注模型"></a>其他序列标注模型</h4><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><hr><ul><li>提出了一种简单、通用的半监督方法，使用预训练的神经语言模型，来给序列标注模型增加上下文表示。</li><li>我们的方法在NER和chunking任务上比其他的方法都要好。</li><li>多使用一个后向的语言模型效果更好。</li><li>即使语言模型在不同领域的语料库上训练，或者序列模型在大数据量的标注数据上训练，效果依然有很大提升。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text安装与配置教程</title>
      <link href="/2017/10/02/sublime/"/>
      <url>/2017/10/02/sublime/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>Sublime Text是我一直使用的代码编辑器，我喜爱它的原因就是好看啊！当然打开速度毋庸置疑啦，毕竟不是IDE。这里我把我的安装与配置步骤教给大家，如有未尽之处，大家自己摸索咯，也欢迎与我交流。<br>先附上一张美图：<br><img src="sublime.png" alt></p><h1 id="安装Sublime-Text-3"><a href="#安装Sublime-Text-3" class="headerlink" title="安装Sublime Text 3"></a>安装Sublime Text 3</h1><hr><p>下载地址请点击<a href="https://download.sublimetext.com/Sublime%20Text%20Build%203143%20x64%20Setup.exe" target="_blank" rel="noopener">这里</a>。<br>安装过程就不多说了，一直点<code>next</code>就行了。</p><h1 id="配置C-运行环境"><a href="#配置C-运行环境" class="headerlink" title="配置C++运行环境"></a>配置C++运行环境</h1><hr><p>装完后可以直接写代码了，但是不能运行C++的哦，还需要配置运行环境。</p><ul><li><p>首先要安装C++的编译器MinGW，可以直接去官网下（<a href="http://www.mingw.org/" target="_blank" rel="noopener">传送门</a>）。不过我自己是直接下的CodeBlocks（<a href="https://downloads.sourceforge.net/project/codeblocks/Binaries/16.01/Windows/codeblocks-16.01mingw-setup.exe" target="_blank" rel="noopener">传送门</a>），然后用的自带的MinGW。</p></li><li><p>装完编译器之后在<code>我的电脑</code>右键，依次点击<code>属性 - 高级系统设置 - 环境变量</code>，在<code>系统变量</code>中找到<code>Path</code>，编辑它，新建一条，添加MinGW路径，以我的为例是<code>E:\software\codeblocks\MinGW\bin</code>。</p></li><li><p>打开Sublime Text，依次点击<code>Tools - Build System - new Build System</code>，粘贴以下代码：</p><pre><code>{  &quot;encoding&quot;: &quot;utf-8&quot;,  &quot;working_dir&quot;: &quot;$file_path&quot;,  &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,  &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,  &quot;selector&quot;: &quot;source.c++&quot;,  &quot;variants&quot;:   [      {          &quot;name&quot;: &quot;Run&quot;,          &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;      }  ]}</code></pre></li><li><p>然后<code>ctrl+s</code>保存，命名为c++11。</p></li></ul><p>这时候随便写一个C++代码，然后<code>Tools - Build System</code>选择<code>c++11</code>，然后按<code>ctrl+b</code>就可以运行啦。<br>我这配置的是控制台运行的C++，所以支持输入数据的哦！</p><h1 id="配置Java运行环境"><a href="#配置Java运行环境" class="headerlink" title="配置Java运行环境"></a>配置Java运行环境</h1><hr><ul><li>首先下载Java的编译器jdk（<a href="http://download.oracle.com/otn-pub/java/jdk/9+181/jdk-9_windows-x64_bin.exe" target="_blank" rel="noopener">传送门</a>），安装过程就不说了。</li><li>环境变量应该不用自己添加了，安装过程会帮你自动添加。</li><li>打开Sublime Text，依次点击<code>Tools - Build System - new Build System</code>，粘贴以下代码：<pre><code>{  &quot;cmd&quot;: [&quot;javac&quot;,&quot;-d&quot;,&quot;.&quot;,&quot;$file&quot;],  &quot;file_regex&quot;: &quot;^(...*?):([0-9]*):?([0-9]*)&quot;,  &quot;selector&quot;: &quot;source.java&quot;,  &quot;encoding&quot;:&quot;cp936&quot;,  //执行完上面的命令就结束  // 下面的命令需要按Ctrl+Shift+b来运行  &quot;variants&quot;:  [      {          &quot;name&quot;: &quot;Run&quot;,          &quot;shell&quot;: true,          &quot;cmd&quot; : [&quot;start&quot;,&quot;cmd&quot;,&quot;/c&quot;, &quot;java ${file_base_name} &amp;echo. &amp; pause&quot;],           //c是执行完命令后关闭cmd窗口,          //k是执行完命令后不关闭cmd窗口。          // echo. 相当于输入一个回车          // pause命令使cmd窗口按任意键后才关闭          &quot;working_dir&quot;: &quot;${file_path}&quot;,          &quot;encoding&quot;:&quot;cp936&quot;      }  ]}</code></pre></li><li>然后<code>ctrl+s</code>保存，命名为JavaC。</li></ul><p>这时候随便写一个Java代码，然后<code>Tools - Build System</code>选择<code>JavaC</code>，然后按<code>ctrl+b</code>就可以运行啦。<br>我这配置的是控制台运行的Java，所以支持输入数据的哦！</p><h1 id="配置Python运行环境"><a href="#配置Python运行环境" class="headerlink" title="配置Python运行环境"></a>配置Python运行环境</h1><hr><ul><li>强烈推荐配合Python发行版本Anaconda使用，下载地址（<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">传送门</a>），下载速度有点慢，推荐使用迅雷下载。安装过程就不多说了。一定要记得安装过程中有一步添加系统变量一定要勾上！</li><li>然后…就没有然后了，Python运行环境安装就是这么简单，直接按<code>ctrl+b</code>就能运行了，但是不支持输入数据哦，想要输入数据的话要安装<code>Sublime REPL</code>插件，请看后面的教程。</li></ul><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>Sublime Text的强大之处就是可以安装各种插件满足你的需求。<br>安装过程很简单：</p><ul><li>首先要安装插件管理工具<code>Package Control</code>，按<code>ctrl+shift+p</code>，输入<code>Install Package</code>，按回车，等待安装完毕。</li><li>然后<code>Preferences</code>选项菜单就会出现<code>Package Control</code>子菜单。</li><li>然后按<code>ctrl+shift+p</code>，输入各种插件名称就能安装啦。</li></ul><p>下面推荐几个我使用的插件，其他的可以自行百度搜索。</p><ul><li>Anaconda<br>这个需要你先安装了Anaconda，然后可以提供各种强大的功能，比如代码提示、函数文档查询、代码风格纠正等等。</li><li>SublimeREPL<br>这个是为了Python输入数据准备的插件，装完之后点击<code>Preferences - Key Bindings</code>，在<code>User</code>文件里粘贴以下代码：<pre><code>  [       { &quot;keys&quot;: [&quot;f5&quot;],          &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,          &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:          {              &quot;id&quot;: &quot;repl_python_run&quot;,              &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;          }      }  ]</code></pre>  然后运行Python代码时直接按<code>F5</code>就行啦！<br>下面两个随意装。</li><li>SublimeHighLight<br>装完之后选中你要复制的代码，右键<code>Copy as RTF</code>，然后粘贴到Word里就会保留代码格式，很漂亮的啊！</li><li>ConvertToUTF8<br>这是为了某些中文显示准备的插件，貌似不怎么用得到，随意装吧。</li></ul><p>我用的就这些啦，Sublime Text写代码还是很方便的，现在基本不用其他的IDE了，能少打开一个软件是一个嘛。</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><hr><p>直接递上<a href="http://www.jb51.net/softjc/180873.html" target="_blank" rel="noopener">传送门</a>。</p><h1 id="sublime配置"><a href="#sublime配置" class="headerlink" title="sublime配置"></a>sublime配置</h1><p><strong>Settings:</strong></p><pre><code>{    &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.sublime-color-scheme&quot;,    &quot;font_options&quot;:    [        &quot;gdi&quot;    ],    &quot;font_size&quot;: 14,    &quot;ignored_packages&quot;:    [        &quot;Vintage&quot;    ],    &quot;theme&quot;: &quot;Adaptive.sublime-theme&quot;,    &quot;translate_tabs_to_spaces&quot;: true,    &quot;expand_tabs_on_save&quot;: true,    &quot;tab_size&quot;: 4,}</code></pre><p><strong>Anaconda Settings User:</strong></p><pre><code>{    &quot;python_interpreter&quot;: &quot;E:/software/anaconda/python.exe&quot;,    &quot;suppress_word_completions&quot;: false,    &quot;suppress_explicit_completions&quot;: false,    &quot;complete_parameters&quot;: true,    &quot;complete__all_parameters&quot;: true,    &quot;anaconda_linting&quot;: false,    &quot;swallow_startup_errors&quot;: true,    &quot;auto_formatting&quot;: true,    &quot;enable_docstrings_tooltip&quot;: true,    &quot;enable_signatures_tooltip&quot;: true,    &quot;display_signatures&quot;: true,}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第二周编程练习2</title>
      <link href="/2017/09/20/dlhw2/"/>
      <url>/2017/09/20/dlhw2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这次练习是实现logistic回归模型的神经网络，来预测一张图片是不是一只猫。<br>我把代码整合在了一起，如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> h5py<span class="token keyword">import</span> scipy<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> scipy <span class="token keyword">import</span> ndimage<span class="token keyword">from</span> lr_utils <span class="token keyword">import</span> load_datasettrain_set_x_orig<span class="token punctuation">,</span> train_set_y<span class="token punctuation">,</span> test_set_x_orig<span class="token punctuation">,</span> test_set_y<span class="token punctuation">,</span> classes <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token punctuation">)</span>m_train <span class="token operator">=</span> train_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>m_test <span class="token operator">=</span> test_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>num_px <span class="token operator">=</span> train_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>train_set_x_flatten <span class="token operator">=</span> train_set_x_orig<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>train_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Ttest_set_x_flatten <span class="token operator">=</span> test_set_x_orig<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>test_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Ttrain_set_x <span class="token operator">=</span> train_set_x_flatten <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">.</span>test_set_x <span class="token operator">=</span> test_set_x_flatten <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> s<span class="token keyword">def</span> <span class="token function">initialize_with_zeros</span><span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>    w <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>shape <span class="token operator">==</span> <span class="token punctuation">(</span>dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> float<span class="token punctuation">)</span> <span class="token operator">or</span> isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> w<span class="token punctuation">,</span> bdim <span class="token operator">=</span> <span class="token number">2</span>w<span class="token punctuation">,</span> b <span class="token operator">=</span> initialize_with_zeros<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">propagate</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    A <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>w<span class="token punctuation">.</span>T<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span>    cost <span class="token operator">=</span> <span class="token operator">-</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>Y <span class="token operator">*</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> Y<span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> A<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> m    dw <span class="token operator">=</span> X<span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>A <span class="token operator">-</span> Y<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token operator">/</span> m    db <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>A <span class="token operator">-</span> Y<span class="token punctuation">)</span> <span class="token operator">/</span> m    <span class="token keyword">assert</span><span class="token punctuation">(</span>dw<span class="token punctuation">.</span>shape <span class="token operator">==</span> w<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>dtype <span class="token operator">==</span> float<span class="token punctuation">)</span>    cost <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>cost<span class="token punctuation">)</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>cost<span class="token punctuation">.</span>shape <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    grads <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"dw"</span><span class="token punctuation">:</span> dw<span class="token punctuation">,</span>             <span class="token string">"db"</span><span class="token punctuation">:</span> db<span class="token punctuation">}</span>    <span class="token keyword">return</span> grads<span class="token punctuation">,</span> costw<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>grads<span class="token punctuation">,</span> cost <span class="token operator">=</span> propagate<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">optimize</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> num_iterations<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    costs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_iterations<span class="token punctuation">)</span><span class="token punctuation">:</span>        grads<span class="token punctuation">,</span> cost <span class="token operator">=</span> propagate<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>        dw <span class="token operator">=</span> grads<span class="token punctuation">[</span><span class="token string">"dw"</span><span class="token punctuation">]</span>        db <span class="token operator">=</span> grads<span class="token punctuation">[</span><span class="token string">"db"</span><span class="token punctuation">]</span>        w <span class="token operator">=</span> w <span class="token operator">-</span> learning_rate <span class="token operator">*</span> dw        b <span class="token operator">=</span> b <span class="token operator">-</span> learning_rate <span class="token operator">*</span> db        <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            costs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cost<span class="token punctuation">)</span>        <span class="token keyword">if</span> print_cost <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Cost after iteration %i: %f"</span> <span class="token operator">%</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">)</span>    params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"w"</span><span class="token punctuation">:</span> w<span class="token punctuation">,</span>              <span class="token string">"b"</span><span class="token punctuation">:</span> b<span class="token punctuation">}</span>    grads <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"dw"</span><span class="token punctuation">:</span> dw<span class="token punctuation">,</span>             <span class="token string">"db"</span><span class="token punctuation">:</span> db<span class="token punctuation">}</span>    <span class="token keyword">return</span> params<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> costsparams<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> costs <span class="token operator">=</span> optimize<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> num_iterations<span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> learning_rate <span class="token operator">=</span> <span class="token number">0.009</span><span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    Y_prediction <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>    w <span class="token operator">=</span> w<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    A <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>w<span class="token punctuation">.</span>T<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>A<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0.5</span><span class="token punctuation">:</span>            Y_prediction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            Y_prediction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>      <span class="token keyword">assert</span><span class="token punctuation">(</span>Y_prediction<span class="token punctuation">.</span>shape <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Y_prediction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这样看起来太乱太复杂了，于是最后一个练习将训练过程合并成了一个model，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">model</span><span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> Y_test<span class="token punctuation">,</span> num_iterations <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> learning_rate <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    w<span class="token punctuation">,</span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>    parameters<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> costs <span class="token operator">=</span> optimize<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">,</span> num_iterations<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> print_cost<span class="token punctuation">)</span>    w <span class="token operator">=</span> parameters<span class="token punctuation">[</span><span class="token string">"w"</span><span class="token punctuation">]</span>    b <span class="token operator">=</span> parameters<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span>    Y_prediction_test <span class="token operator">=</span> predict<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X_test<span class="token punctuation">)</span>    Y_prediction_train <span class="token operator">=</span> predict<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X_train<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train accuracy: {} %"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>Y_prediction_train <span class="token operator">-</span> Y_train<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test accuracy: {} %"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>Y_prediction_test <span class="token operator">-</span> Y_test<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"costs"</span><span class="token punctuation">:</span> costs<span class="token punctuation">,</span>         <span class="token string">"Y_prediction_test"</span><span class="token punctuation">:</span> Y_prediction_test<span class="token punctuation">,</span>          <span class="token string">"Y_prediction_train"</span> <span class="token punctuation">:</span> Y_prediction_train<span class="token punctuation">,</span>          <span class="token string">"w"</span> <span class="token punctuation">:</span> w<span class="token punctuation">,</span>          <span class="token string">"b"</span> <span class="token punctuation">:</span> b<span class="token punctuation">,</span>         <span class="token string">"learning_rate"</span> <span class="token punctuation">:</span> learning_rate<span class="token punctuation">,</span>         <span class="token string">"num_iterations"</span><span class="token punctuation">:</span> num_iterations<span class="token punctuation">}</span>    <span class="token keyword">return</span> dd <span class="token operator">=</span> model<span class="token punctuation">(</span>train_set_x<span class="token punctuation">,</span> train_set_y<span class="token punctuation">,</span> test_set_x<span class="token punctuation">,</span> test_set_y<span class="token punctuation">,</span> num_iterations <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> learning_rate <span class="token operator">=</span> <span class="token number">0.005</span><span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第二周编程练习1</title>
      <link href="/2017/09/20/dlhw1/"/>
      <url>/2017/09/20/dlhw1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这次编程练习是吴恩达深度学习公开课第二周的配套练习，地址：<a href="https://www.coursera.org/learn/neural-networks-deep-learning" target="_blank" rel="noopener">coursera</a>。</p><h1 id="1-Building-basic-functions-with-numpy"><a href="#1-Building-basic-functions-with-numpy" class="headerlink" title="1 - Building basic functions with numpy"></a>1 - Building basic functions with numpy</h1><hr><h2 id="1-1-sigmoid-function-np-exp"><a href="#1-1-sigmoid-function-np-exp" class="headerlink" title="1.1 - sigmoid function, np.exp()"></a>1.1 - sigmoid function, np.exp()</h2><p>Exercise: Build a function that returns the sigmoid of a real number x. Use <code>math.exp(x)</code> for the exponential function.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: basic_sigmoid</span><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">basic_sigmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute sigmoid of x.    Arguments:    x -- A scalar    Return:    s -- sigmoid(x)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> sbasic_sigmoid<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exercise: Implement the sigmoid function using <code>numpy</code>.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: sigmoid</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np <span class="token comment" spellcheck="true"># this means you can access numpy functions by writing np.function() instead of numpy.function()</span><span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute the sigmoid of x    Arguments:    x -- A scalar or numpy array of any size    Return:    s -- sigmoid(x)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> sx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-Sigmoid-gradient"><a href="#1-2-Sigmoid-gradient" class="headerlink" title="1.2 - Sigmoid gradient"></a>1.2 - Sigmoid gradient</h2><p>Exercise: Implement the function <code>sigmoid_grad()</code> to compute the gradient of the sigmoid function with respect to its input x. The formula is:<br>\[sigmoid\_derivative(x) = \sigma’(x) = \sigma(x) (1 - \sigma(x))\]</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: sigmoid_derivative</span><span class="token keyword">def</span> <span class="token function">sigmoid_derivative</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute the gradient (also called the slope or derivative) of the sigmoid function with respect to its input x.    You can store the output of the sigmoid function into variables and then use it to calculate the gradient.    Arguments:    x -- A scalar or numpy array    Return:    ds -- Your computed gradient.    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 2 lines of code)</span>    s <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    ds <span class="token operator">=</span> s <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> dsx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"sigmoid_derivative(x) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>sigmoid_derivative<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-Reshaping-arrays"><a href="#1-3-Reshaping-arrays" class="headerlink" title="1.3 - Reshaping arrays"></a>1.3 - Reshaping arrays</h2><p>Exercise: Implement <code>image2vector()</code> that takes an input of shape (length, height, 3) and returns a vector of shape (length*height*3, 1). </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: image2vector</span><span class="token keyword">def</span> <span class="token function">image2vector</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Argument:    image -- a numpy array of shape (length, height, depth)    Returns:    v -- a vector of shape (length*height*depth, 1)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    v <span class="token operator">=</span> image<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> v<span class="token comment" spellcheck="true"># This is a 3 by 3 by 2 array, typically images will be (num_px_x, num_px_y,3) where 3 represents the RGB values</span>image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.67826139</span><span class="token punctuation">,</span>  <span class="token number">0.29380381</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.90714982</span><span class="token punctuation">,</span>  <span class="token number">0.52835647</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.4215251</span> <span class="token punctuation">,</span>  <span class="token number">0.45017551</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.92814219</span><span class="token punctuation">,</span>  <span class="token number">0.96677647</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.85304703</span><span class="token punctuation">,</span>  <span class="token number">0.52351845</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.19981397</span><span class="token punctuation">,</span>  <span class="token number">0.27417313</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.60659855</span><span class="token punctuation">,</span>  <span class="token number">0.00533165</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.10820313</span><span class="token punctuation">,</span>  <span class="token number">0.49978937</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.34144279</span><span class="token punctuation">,</span>  <span class="token number">0.94630077</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"image2vector(image) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>image2vector<span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-Normalizing-rows"><a href="#1-4-Normalizing-rows" class="headerlink" title="1.4 - Normalizing rows"></a>1.4 - Normalizing rows</h2><p>Exercise: Implement <code>normalizeRows()</code> to normalize the rows of a matrix. After applying this function to an input matrix x, each row of x should be a vector of unit length (meaning length 1).</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: normalizeRows</span><span class="token keyword">def</span> <span class="token function">normalizeRows</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Implement a function that normalizes each row of the matrix x (to have unit length).    Argument:    x -- A numpy matrix of shape (n, m)    Returns:    x -- The normalized (by row) numpy matrix. You are allowed to modify x.    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 2 lines of code)</span>    <span class="token comment" spellcheck="true"># Compute x_norm as the norm 2 of x. Use np.linalg.norm(..., ord = 2, axis = ..., keepdims = True)</span>    x_norm <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> keepdims <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Divide x by its norm.</span>    x <span class="token operator">=</span> x <span class="token operator">/</span> x_norm    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> xx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"normalizeRows(x) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>normalizeRows<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-Broadcasting-and-the-softmax-function"><a href="#1-5-Broadcasting-and-the-softmax-function" class="headerlink" title="1.5 - Broadcasting and the softmax function"></a>1.5 - Broadcasting and the softmax function</h2><p>Exercise: Implement a <code>softmax</code> function using numpy. You can think of softmax as a normalizing function used when your algorithm needs to classify two or more classes. You will learn more about softmax in the second course of this specialization.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: softmax</span><span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Calculates the softmax for each row of the input x.    Your code should work for a row vector and also for matrices of shape (n, m).    Argument:    x -- A numpy matrix of shape (n,m)    Returns:    s -- A numpy matrix equal to the softmax of x, of shape (n,m)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 3 lines of code)</span>    <span class="token comment" spellcheck="true"># Apply exp() element-wise to x. Use np.exp(...).</span>    x_exp <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Create a vector x_sum that sums each row of x_exp. Use np.sum(..., axis = 1, keepdims = True).</span>    x_sum <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>x_exp<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdims<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Compute softmax(x) by dividing x_exp by x_sum. It should automatically use numpy broadcasting.</span>    s <span class="token operator">=</span> x_exp <span class="token operator">/</span> x_sum    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> sx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"softmax(x) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>softmax<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-Vectorization"><a href="#2-Vectorization" class="headerlink" title="2 - Vectorization"></a>2 - Vectorization</h1><hr><h2 id="2-1-Implement-the-L1-and-L2-loss-functions"><a href="#2-1-Implement-the-L1-and-L2-loss-functions" class="headerlink" title="2.1 - Implement the L1 and L2 loss functions"></a>2.1 - Implement the L1 and L2 loss functions</h2><p>Exercise: Implement the numpy vectorized version of the <code>L1</code> loss. You may find the function <code>abs(x)</code> (absolute value of x) useful.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: L1</span><span class="token keyword">def</span> <span class="token function">L1</span><span class="token punctuation">(</span>yhat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Arguments:    yhat -- vector of size m (predicted labels)    y -- vector of size m (true labels)    Returns:    loss -- the value of the L1 loss function defined above    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    loss <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>y <span class="token operator">-</span> yhat<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> lossyhat <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"L1 = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>L1<span class="token punctuation">(</span>yhat<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exercise: Implement the numpy vectorized version of the <code>L2</code> loss. There are several way of implementing the <code>L2</code> loss but you may find the function <code>np.dot()</code> useful. As a reminder, if $x = [x_1, x_2, …, x_n]$, then <code>np.dot(x,x)</code> = $\sum_{j=0}^n x_j^{2}$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: L2</span><span class="token keyword">def</span> <span class="token function">L2</span><span class="token punctuation">(</span>yhat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Arguments:    yhat -- vector of size m (predicted labels)    y -- vector of size m (true labels)    Returns:    loss -- the value of the L2 loss function defined above    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    loss <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>y <span class="token operator">-</span> yhat<span class="token punctuation">,</span> y <span class="token operator">-</span> yhat<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> lossyhat <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"L2 = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>L2<span class="token punctuation">(</span>yhat<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第二周学习笔记</title>
      <link href="/2017/09/19/dl2/"/>
      <url>/2017/09/19/dl2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这周开始将会学到神经网络编程的基础知识。</p><h1 id="2-1-二分分类"><a href="#2-1-二分分类" class="headerlink" title="2.1 二分分类"></a>2.1 二分分类</h1><hr><p><img src="13.jpg" alt></p><p>二分类问题就是给定一个输入$x$，预测它的标签$y$是0还是1。拿预测一张图片是不是猫来举例子，一张图片大小为${\rm{64}} \times {\rm{64}}$，将它转化为三个矩阵分别代表RGB分量。再将三个矩阵合并成一个大小为${\rm{(64}} \times {\rm{64}} \times {\rm{3,1)}}$的矩阵作为输入$x$。</p><p>下面给出一些以后要用到的符号表示。</p><p>一个样本用$(x,y)$表示，其中$x \in {R^{ {n_x}}}$，$y \in \{ 0,1\} $，那么$m$个训练样本就可以用集合$\\{ ({x^{(1)}},{y^{(1)}}),({x^{(2)}},{y^{(2)}}), \ldots ,({x^{(m)}},{y^{(m)}})\\} $来表示。</p><p>我们还可以将所有样本特征值用一个矩阵表示：<br>\[X = \left[ {\begin{array}{*{20}{l}} \vdots &amp; \vdots &amp; \cdots &amp; \vdots \\\\{ {x^{(1)}}}&amp;{ {x^{(2)}}}&amp; \cdots &amp;{ {x^{(m)}}}\\\\ \vdots &amp; \vdots &amp; \cdots &amp; \vdots \end{array}} \right]\]</p><p>其中$X \in {R^{ {n_x} \times m}}$。<br>所有样本标签也可以用一个矩阵表示：<br>\[Y = \left[ {\begin{array}{*{20}{l}}{ {y^{(1)}}}&amp;{ {y^{(2)}}}&amp; \cdots &amp;{ {y^{(m)}}}\end{array}} \right]\]</p><p>其中$Y \in {R^{1 \times m}}$。</p><h1 id="2-2-logistic回归"><a href="#2-2-logistic回归" class="headerlink" title="2.2 logistic回归"></a>2.2 logistic回归</h1><hr><p>logistic回归就是用线性函数来拟合输出标签。具体定义为，输入特征$X \in {R^{n_x}}$，参数$w \in {R^{n_x}}$，$b \in {R}$。那么令输出标签<br>\[{ {\hat y}^{(i)}} = \sigma ({w^T}{x^{^{(i)}}} + b)\]<br>其中\[\sigma ({x^{^{(i)}}}) = \frac{1}{ {1 + {e^{ - {x^{^{(i)}}}}}}}\]</p><h1 id="2-3-logistic回归损失函数"><a href="#2-3-logistic回归损失函数" class="headerlink" title="2.3 logistic回归损失函数"></a>2.3 logistic回归损失函数</h1><hr><p>损失函数衡量的是输出标签${\hat y}$与真实标签$y$之间的差距，有很多种定义方法，下面是常用的两种：<br>\[L({ {\hat y}^{^{(i)}}},{y^{^{(i)}}}) = \frac{1}{2}{({ {\hat y}^{^{(i)}}} - {y^{^{(i)}}})^2}\]和<br>\[L({ {\hat y}^{^{(i)}}},{y^{^{(i)}}}) =  - [{y^{(i)}}\log ({ {\hat y}^{(i)}}) + (1 - {y^{(i)}})\log (1 - { {\hat y}^{(i)}})]\]<br>一般我们使用下面一种损失函数，具体原因最后一节课会讲到，因为它是个凸函数，方便梯度下降。</p><p>如果有$m$个样本，那么总的损失函数就定义为<br>\[J(w,b) = \frac{1}{m}\sum\limits_{i - 1}^m {L({ {\hat y}^{^{(i)}}},{y^{^{(i)}}})}  =  - \frac{1}{m}\sum\limits_{i - 1}^m {[{y^{(i)}}\log ({ {\hat y}^{(i)}}) + (1 - {y^{(i)}})\log (1 - { {\hat y}^{(i)}})]} \]</p><h1 id="2-4-梯度下降法"><a href="#2-4-梯度下降法" class="headerlink" title="2.4 梯度下降法"></a>2.4 梯度下降法</h1><hr><p>通过重复<br>\[w: = w - \alpha \frac{ {\partial J(w,b)}}{ {\partial w}}\]<br>和<br>\[b: = b - \alpha \frac{ {\partial J(w,b)}}{ {\partial b}}\]<br>来不断更新$w$和$b$，使得$w$和$b$接近最优值。</p><h1 id="2-7-计算图"><a href="#2-7-计算图" class="headerlink" title="2.7 计算图"></a>2.7 计算图</h1><hr><p><img src="14.jpg" alt></p><p>如上图所示就是一个计算图，初始结点都是输入值，中间一个结点表示一个运算，最后一个结点就是输出值。</p><h1 id="2-8-计算图的导数计算"><a href="#2-8-计算图的导数计算" class="headerlink" title="2.8 计算图的导数计算"></a>2.8 计算图的导数计算</h1><hr><p><img src="15.jpg" alt></p><p>反向传播的时候只要沿着红色的箭头利用求导链式法则来对每个参数求导就行了。</p><h1 id="2-9-logistic回归中的梯度下降"><a href="#2-9-logistic回归中的梯度下降" class="headerlink" title="2.9 logistic回归中的梯度下降"></a>2.9 logistic回归中的梯度下降</h1><hr><p><img src="16.jpg" alt></p><p>logistic回归的计算图如上图所示，导数如下：<br>\[\frac{ {\partial L(a,y)}}{ {\partial a}} =  - \frac{y}{a} + \frac{ {1 - y}}{ {1 - a}}\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial z}} = \frac{ {\partial L(a,y)}}{ {\partial a}} \cdot \frac{ {\partial a}}{ {\partial z}} = ( - \frac{y}{a} + \frac{ {1 - y}}{ {1 - a}}) \cdot a(1 - a) = a - y\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial {w_1}}} = {x_1} \cdot \frac{ {\partial L(a,y)}}{ {\partial z}} = {x_1}(a - y)\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial {w_2}}} = {x_2} \cdot \frac{ {\partial L(a,y)}}{ {\partial z}} = {x_2}(a - y)\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial b}} = \frac{ {\partial L(a,y)}}{ {\partial z}} = a - y\]</p><h1 id="2-10-m-个样本的梯度下降"><a href="#2-10-m-个样本的梯度下降" class="headerlink" title="2.10 $m$个样本的梯度下降"></a>2.10 $m$个样本的梯度下降</h1><hr><p><img src="17.jpg" alt></p><p>$m$个样本的梯度其实就是每个样本的梯度求和，如图所示的伪代码中，用一层<code>for</code>循环来对梯度进行求和。在后面的课程中我们将会摒弃这种做法，用更快速的向量化方法来进行计算。</p><h1 id="2-11-向量化"><a href="#2-11-向量化" class="headerlink" title="2.11 向量化"></a>2.11 向量化</h1><hr><p>向量化就是将例如${w^T}x$这样的矩阵点乘用python的<code>numpy</code>库函数<code>dot</code>代替普通的<code>for</code>循环。示例代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token keyword">print</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-12-向量化的更多例子"><a href="#2-12-向量化的更多例子" class="headerlink" title="2.12 向量化的更多例子"></a>2.12 向量化的更多例子</h1><hr><p>经验法则是能不使用<code>for</code>循环就尽量不要使用，用向量来代替。更多的向量化例子有<code>np.exp()</code>，<code>np.sum()</code>等等。</p><h1 id="2-13-向量化logistic回归"><a href="#2-13-向量化logistic回归" class="headerlink" title="2.13 向量化logistic回归"></a>2.13 向量化logistic回归</h1><hr><p>之前提到的算法是用<code>for</code>循环来计算所有的${ {\hat y}^{(i)}} = \sigma ({w^T}{x^{^{(i)}}} + b)$。现在可以使用向量化来加快计算速度，只要计算$Y = \sigma ({w^T}X + b)$即可。</p><h1 id="2-14-向量化logistic回归的梯度输出"><a href="#2-14-向量化logistic回归的梯度输出" class="headerlink" title="2.14 向量化logistic回归的梯度输出"></a>2.14 向量化logistic回归的梯度输出</h1><hr><p>logistic回归的梯度用向量可以表示为<br>\[dz = A - Y\]<br>\[dw = \frac{1}{m}Xd{z^T}\]<br>下面两节课都是讲的python的广播和向量的一些说明，在此就不细讲了，大家可以去查看python文档。其中讲到的一个写python程序的好习惯就是用到向量的时候如果不确定维数，那么你就<code>reshape()</code>一下，还有就是加一句<code>assert()</code>语句判断一下维数。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第一周学习笔记</title>
      <link href="/2017/09/19/dl1/"/>
      <url>/2017/09/19/dl1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>保了研暂时也没什么事干，从今天开始学一学吴恩达最近发布的深度学习课程。顺便在博客上做做笔记，梳理一下。</p><p>coursera上面的课程要钱，还贼贵。所以我就直接在网易公开课上面看免费版的了，免费版没有作业和练习，是一个很大的缺憾。因为这门课很大的一个亮点就是高质量的编程题。顺带附上这门课的地址：<a href="https://mooc.study.163.com/learn/deeplearning_ai-2001281002?tid=2001392029#/learn/content" target="_blank" rel="noopener">吴恩达深度学习公开课</a></p><h1 id="1-2-什么是神经网络？"><a href="#1-2-什么是神经网络？" class="headerlink" title="1.2 什么是神经网络？"></a>1.2 什么是神经网络？</h1><hr><p>这节课是深度学习的入门课，首先给出了深度学习的定义：深度学习就是训练神经网络。那么问题来了，什么是神经网络？这节课就介绍了神经网络的概念。<br><img src="5.jpg" alt></p><p>首先从一个房价预测的例子讲起，已知房子大小和对应的房价，用一条曲线拟合这些点。那么用一条直线就可以了，但是房价不能为负，所以左边恒为0，这个函数就是“线性修正单元”，即ReLU。</p><p><img src="6.jpg" alt></p><p>这就是最基本的神经元，输入一个房子大小也就是$x$，经过一个神经单元运算之后，输出房价也就是$y$。</p><p><img src="7.jpg" alt></p><p>更复杂的情况下，房价还取决于更多的因素，比如房子大小、房间数量、邮编、周边富裕程度。</p><p>我们不会具体指明中间一层的神经单元代表什么，神经网络想怎么算就怎么算。所以上图从左到右三层分别叫做输入层、隐含层、输出层。</p><p>值得注意的是，神经网络只要你喂给了它足够多的$(x,y)$训练数据，那么它就可以训练出一个从$x$到$y$的精准映射函数。</p><p>这就是最基本的神经网络和监督学习的例子，也就是你任意输入一个$x$，神经网络都可以预测出一个对应的$y$。</p><p>下一讲将会更加深入的讲解监督学习的相关算法。</p><h1 id="1-3-用神经网络进行监督学习"><a href="#1-3-用神经网络进行监督学习" class="headerlink" title="1.3 用神经网络进行监督学习"></a>1.3 用神经网络进行监督学习</h1><hr><p>神经网络最近被媒体炒作的沸沸扬扬，其实绝大多数神经网络创造的价值都来自于一种机器学习算法：监督学习。</p><p><img src="8.jpg" alt></p><p>可以看出，监督学习就是输入一个特征$x$，然后学习得到一个输出$y$。监督学习在很多不同领域有重要应用，比如之前提到的房价预测，还有在线广告、计算机视觉、语音识别、机器翻译和自动驾驶等等。</p><p>他们所应用的神经网络结构也都是不同的。其中房价预测和在线广告用的是标准的神经网络。而计算机视觉处理的是空间上的图像，所以用到的是卷积神经网络(CNN)。语音识别和机器翻译因为都是处理的时间相关的序列，所以用到的是循环神经网络(RNN)。而自动驾驶就更加的复杂了，既要处理图像，又要处理雷达信息，所以要用混合神经网络。</p><p><img src="9.jpg" alt></p><p>上图就是三种神经网络的基本结构，CNN擅长处理图像相关的数据，RNN擅长处理序列相关的数据。</p><p><img src="10.jpg" alt></p><p>输入的数据也分为两大类：结构化数据和非结构化数据。结构化数据就是指数据的数据库，每一个数据都是有明确的含义的，比如房子的大小，房间的数量等等。非结构化数据就是指音频、图像、文本之类的数据。</p><p>人类天生就更擅长理解非结构化数据，但是计算机就不行了。近几年来，神经网络的发展让计算机也能非常好的理解非结构化数据了。在实际应用中，最好要将结构化数据和非结构化数据结合起来，才能发挥出最好的性能。</p><p>其实神经网络几十年前就已经提出来了，那为什么最近几年才流行起来呢？下一节吴恩达老师将会给我们带来答案。</p><h1 id="1-4-为什么深度学习会兴起"><a href="#1-4-为什么深度学习会兴起" class="headerlink" title="1.4 为什么深度学习会兴起?"></a>1.4 为什么深度学习会兴起?</h1><hr><p>上节课最后提到，神经网络几十年前就有了，那为什么最近几年才兴起呢？</p><p><img src="11.jpg" alt></p><p>吴恩达通过一张图很好的解释了原因。如上图所示，$x$轴是数据量，$y$轴是机器学习算法的效率，具体来说就是图像识别的准确率等等。</p><p>可以看出，随着数据量的增大，机器学习算法的效率也随之增大。但是传统的机器学习算法比如支持向量机(SVM)在数据量大到一个程度之后会进入“平台期”，不会再上升了。而不同规模的神经网络会一直上升，只要你数据足够多。</p><p>所以在今天要想得到更好的效果，就要训练一个大规模的神经网络，这个大规模指的是两个方面：一个是神经网络的隐含层单元足够多，也就是参数足够多，一个就是数据规模要足够多。但是这最终也是有瓶颈的，因为神经网络太大了之后计算效率就会下降，训练时间会特别长。数据也会耗尽，没有无限的数据。</p><p>从技术上面来说，上图$x$轴的数据代表的是“有标签的数据”，也就是每个输入$x$都有一个标签$y$与之对应，一组数据就是一对$(x,y)$。在以后的课程中，我们都使用$m$来表示数据的规模，也就是$x$轴的数值。</p><p></p><p>在上图中我们还可以看出，在数据量比较小的时候，传统机器学习算法甚至会优于神经网络。因为它的性能基于手工设计组件的优劣和一些算法细节上面的优化，比如特征的提取等等。但是训练数据规模大了以后，神经网络就稳定优于传统机器学习方法了。</p><p><img src="12.jpg" alt></p><p>影响神经网络性能的因素主要有三点：数据规模、计算能力、算法。</p><p>数据规模之前已经提到过了。计算能力的话因为最近几年CPU和GPU的发展，计算能力得到很大的提升，所以训练时间也大大缩短。算法优化也是为了缩短训练时间，课上举了一个算法优化的例子。</p><p></p><p>以前神经网络激活函数都是用的sigmoid函数，图像如上图所示。但是存在一个问题，就是一直训练下去会出现梯度消失的问题，反映在函数图象上就是当输入太小时斜率会趋于0。所以后来换成了ReLU函数，在大于0的时候斜率恒为1。</p><p></p><p>图的右半部分是神经网络训练的流程。首先你要想出一个算法，然后你要实现代码，最后运行结果进行训练。如果训练时间很短，比如10分钟或者一天以内，那么你就可以调整算法，继续优化训练。如果训练时间要一个月，那么你就只能实现很少的想法了。</p><p></p><p>可喜的是，现在数据和硬件还在继续发展着，我们要做的就是继续研究新的算法和进行算法的优化。所以我们坚信，深度学习还会继续发展进步下去。</p><p></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Make Context More Useful? An Empirical Study on Context-Aware Neural Conversational Models</title>
      <link href="/2017/09/19/context/"/>
      <url>/2017/09/19/context/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/P/P17/P17-2036.pdf" target="_blank" rel="noopener">P17-2036</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>最近许多研究者都注意到了上下文在对话系统中的重要性，也做了很多的研究，但是没有系统的比较来分析怎么样才能有效地利用上下文。我们做了详细的研究来比较不同的模型，研究上下文在对话系统中的作用。同时，我们提出了度量上下文与查询之间相关性的方法，比其他方法性能都出色。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>对话系统有两种典型的研究设置：单轮和多轮。单轮就是只输入查询$q$，输出答案$r$。但是大多数现实的对话都是要多轮的，就是要结合上下文来做出回答。<br>很多研究者都意识到了上下文的重要性，也提出了很多方法。一种是直接将上下文和查询向量连接到一起，另一种是分层模型。有很多方法来结合上下文和查询，比如池化和连接。但是没有人对它们做过比较。<br>这篇论文里，我们在Seq2Seq的对话系统上对上下文模型做研究。我们关注两个问题：</p><ul><li>我们怎么样才能更好的利用上下文？</li><li>上下文对神经对话系统的影响是什么？</li></ul><p>未分层模型通常使用经典的encode-decoder框架，我们实验中用的是RNN+GRU，decode时beamsearch大小为5。分层模型有三种方法结合上下文和查询：池化、连接、连续整合。<br><img src="hierarchical_model.jpg" alt><br><img src="2.jpg" alt><br>但是我们发现加权后的实验结果还不如直接使用最后一个隐含层的结果，我们猜测是因为这个RNN不是很长，所以对前面的结果保存的比较好，所以我们实验直接使用最后一个隐含层作为输出。<br>衡量上下文和查询的相关程度：<br>\[{s_{ {c_i}}} = sim({c_i},q) = \frac{ { {e_{c_i} } \cdot {e_q}}}{ {\left\| {e_{c_i}} \right\| \cdot \left\| { {e_q}} \right\|}}\]<br>其中：\[{e_{c_i}} = \sum\limits_{w \in {c_i}} {e_w} ,{e_q} = \sum\limits_{w’ \in {c_i}} {e_w’} \]<br>归一化：<br>\[\alpha _{c_i} = \frac{ {\exp ({s_{ {c_i}}})}} { {\sum\nolimits_{j = 0}^n {\exp ({s_{ {c_i}}})}  + \exp ({s_q})}}\]<br>\[{ {\alpha _q} = \frac{ {\exp ({s_q})}}{ {\sum\nolimits_{j = 0}^n {\exp ({s_{ {c_i}}})}  + \exp ({s_q})}}}\]<br>两种连接方法：</p><ul><li>WSeq(sum):<br>\[{v_{enc}} = \sum\limits_{i = 0}^n { {\alpha _{ {c_i}}}{h_{ {c_i}}} + {\alpha _q}{h_q}} \]</li><li>WSeq(concat):<br>\[{v_{enc}} = \left[ { {\alpha _{ {c_0}}}{h_{ {c_0}}}; \ldots ;{\alpha _{ {c_n}}}{h_{ {c_n}}};{\alpha _q}{h_q}} \right]\]</li></ul><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>我们在百度贴吧问答数据集上做实验。<br><img src="1.jpg" alt></p><h1 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h1><hr><p>虽然BLEU不适合用来度量对话系统这种开放式的系统。但是我们没有足够的人力物力来对结果一一标注，所以还是采用BLEU。下面回到最开始提出的两个问题。</p><ul><li>我们怎么样才能更好的利用上下文？<br>首先我们发现采用上下文实验结果的确比不采用的更好了。然后分层的模型结果比不分层的更好。我们猜测原因可能是对话系统不同于其他NLP任务，对话系统句子可能出自不同的人。让每个上下文保持独立很重要，而不是简单的池化结合到一起，所以直接连接起来效果更好。上下文和查询相关性对系统有帮助。</li><li>上下文对神经对话系统的影响是什么？<br><img src="3.jpg" alt><br>可以看出，采用上下文的模型能产生更长、更有意义、更多样性的回答。我们还发现了一个有趣的现象：一个encode-decoder模型如果想要生成有意义的回答，必须要足够多的有意义的信息提供给它。这解释了为什么seq2seq在其他NLP任务表现得很好，但是在对话系统表现得不好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 问答系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研第一，我还是选择留在了本校</title>
      <link href="/2017/09/19/baoyan/"/>
      <url>/2017/09/19/baoyan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>保研去哪？其实我刚开始也纠结过。看到其他同学忙着申报各大名校，我也曾经动摇过，但是现在却没什么感觉了。很多人不理解为什么第一不去试试清北复交，我承认，这些学校是优势很大，毕竟还是高了一个档次的。<br>想当年高考时，我的梦想就是考上清华，但是最后考砸了只能来了华师。现在想来也罢了，或许本来就没有那个实力吧。从小学开始，我就一直是考上了最好的学校却去了低一个档次的学校。那时候都是因为体质不好吧，不让去太远的学校，现在反而习惯了那种拿第一的感觉。<br>暑假开始前，很多人就准备报名夏令营了，我却回家考驾照了，一个也没报。其实当时就已经打算留读本校了，当时考虑是研究生阶段学校影响没有导师和专业强了，而且其他学校导师也都不熟悉，很难找到一个人品好学术好的好导师，于是就决心本校找一个了。其他原因也都是些无关紧要的了，比如本校环境熟悉、还不用大费周折搬家等等，说起来挺幼稚，哪有前途重要。<br>现在也差不多定了吧，我觉得还是成事在人吧。既然自己选择了这条路，不去走更宽敞的路，那就要把它走好。去了好学校不能骄纵，留在差学校也不能自暴自弃吧，就当作是激励自己的动力吧。<br>还是谢谢大家的关心，让你们失望了，我不是没有梦想，也不是懒。只要你足够努力，梦想在哪里都能发芽。<br>看来不能因为保了研而放松自己了，还有那么多为了考研在奋斗的学生。下面一年三大计划：毕业论文、实习、研一的活。不管是保了研的还是还在考研的或者准备工作的，大家一起加油吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位长者关于保研的一些人生经验</title>
      <link href="/2017/09/19/recommend/"/>
      <url>/2017/09/19/recommend/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>经过三年的艰苦学习，终于也艰难保上研了，因此在此给学弟学妹们一点人生经验，粗鄙之见，大家随便看看。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><hr><ul><li>好好学习自然不用多说，自觉性是最重要的，作业不能拖拉，不要拖到最后一刻才做作业。<br>就拿我自己说吧，我每次上完课都会立即把上课讲的再看一遍，把没听懂的搞懂，不然时间长了会慢慢忘掉的，等到期末就更难搞懂了。还有就是作业，我每次都会当天就开始做，尽量提前很早做完。这样好处多多哦，既可以不至于最后一天很忙，又可以把作业完成的很好，最后自然就拿高分啦。</li><li>图书馆可以多去去的，虽然我这一年都没去过。<br>想当年大一大二在闵行的时候，那时候还是有女票的(&gt;﹏&lt;)，基本上天天都会去图书馆呆着吧，很怀念那时候的日子。</li><li>上课少玩手机，多听讲，这样期末复习起来才轻松一点。<br>不过我自己上课也玩哈哈哈，我也有很多课听不懂或者很无聊的课，都会戳一戳手机解解闷。有时下午太困了还会打个盹。但是一定要记住，课上缺的，课后一定要补回来，就算花再多时间也要弄懂。</li></ul><h1 id="竞赛项目"><a href="#竞赛项目" class="headerlink" title="竞赛项目"></a>竞赛项目</h1><hr><ul><li>有实力和天赋的话搞搞ACM竞赛也是好处极大的，奖学金和保研加分多多的，也极大提升代码能力。<br>想当年我刚高中毕业的那个暑假，还连信息学竞赛都没听说过，但是出于兴趣暑假自学了c语言和基础的算法。于是刚开学就被招进了ACM实验室。不过当时搞的人也少，于是我也就有了出去打比赛的机会。现在这几年人越来越多了，要好好加油了啊。<br>不过我后来太懒了，都没怎么训练，现在光荣的退役咯，老学长只能给你们加油了。</li><li>项目的话我没怎么搞过，真心想搞可以好好弄弄，想水一水的那就别浪费时间了，加分也不多。<br>想当年还有过打算搞搞大夏杯啥的，后来也没了音讯，毕竟ACM太忙了。</li></ul><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><hr><ul><li>也别老学习啊，多累啊，出去散散步逛逛街玩玩。<br>找个女票啊，带她一起出去玩玩。实在没有的话，和好基友出去玩也行啊！</li><li>日常开黑打打游戏啊，但别耽误了学习做作业。<br>像我就玩英雄联盟、炉石之类的啊，别玩物丧志，通宵玩伤了身体就好。室友之间有个共同爱好挺不错的。</li></ul><h1 id="恋爱"><a href="#恋爱" class="headerlink" title="恋爱"></a>恋爱</h1><hr><ul><li>这方面我很失败，就不谈经验了，谈谈教训吧。</li><li>要好好待人家，别只顾自己学习和玩乐。</li><li>别太自私，毕竟人家为你付出了青春。</li><li>为我自己加油。</li></ul><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><hr><ul><li>千万别熬夜了，大一大二你还年轻，熬得起。等到了大三大四，身体吃不消了，你会越来越感觉累的。</li><li>还是那句话，学在平时，别在考试前最后一天通宵学习。</li><li>现在想来，还是多运动运动散散步好，整天呆在宿舍太闷了，恐怕是老了吧。</li></ul><p>最后附上今年保研最终排名，见笑了（好基友非要我给他打码，那我就照办了）：<br><img src="top.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ3328. 时空交织的代价</title>
      <link href="/2017/09/19/eoj3328/"/>
      <url>/2017/09/19/eoj3328/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><hr><p>给定$n$个点和每个点在$x$轴上面的位置和每个点的权值，求出点对之间的费用总和。其中某两个点$i$，$j$之间的费用定义为$ | p_i - p_j | \times max\{v_i, v_j\} $。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr><p>对于每个点，计算它左边权值小于它的点与它点对费用之和：\[{v_i}\sum\limits_j {({p_i} - {p_j})}  = k{v_i}{p_i} - {v_i}\sum\limits_j {p_j} \]其中$k$是左边权值小于它的点的数量，$\sum\limits_j {p_j}$是它们的权值之和，可以用两个树状数组统计。右边同理。<br>首先按照$p$从小到大排序。对于每个点用树状数组分别统计出左右两边$v$比它小的$v$之和与数量，然后直接计算结果即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iterator></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;numeric></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iomanip></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;complex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bitset></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;deque></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;deque></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;new></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//#pragma comment(linker, "/STACK:102400000,102400000")</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PII<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span>PII<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PIII<span class="token punctuation">;</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span>vec<span class="token operator">></span> mat<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> PB push_back</span><span class="token macro property">#<span class="token directive keyword">define</span> MP(a, b) make_pair(a, b)</span><span class="token macro property">#<span class="token directive keyword">define</span> FI first</span><span class="token macro property">#<span class="token directive keyword">define</span> SE second</span><span class="token macro property">#<span class="token directive keyword">define</span> gcd(x, y) __gcd(x, y)</span><span class="token macro property">#<span class="token directive keyword">define</span> gcd3(x, y, z) __gcd(__gcd(x, y), z)</span><span class="token keyword">const</span> <span class="token keyword">double</span> EPS <span class="token operator">=</span> <span class="token number">1e-15</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token function">acos</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">const</span> LL INFL <span class="token operator">=</span> <span class="token number">0x3f3f3f3f3f3f3f3fLL</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">200000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>LL bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> bit1<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">;</span>LL <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">-</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> LL x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">+</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>LL <span class="token function">sum1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>s <span class="token operator">+</span><span class="token operator">=</span> bit1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">-</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> LL x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>bit1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">+</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> node <span class="token punctuation">{</span>    LL p<span class="token punctuation">,</span> v<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> node<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> p <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>node a<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL cnt <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL s <span class="token operator">=</span> <span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span>ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">-</span> s<span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL cnt <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL s <span class="token operator">=</span> <span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span>ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">-</span> cnt <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL cnt <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LL s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">(</span>ans <span class="token operator">-</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">-</span> cnt <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ans <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> eoj </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
