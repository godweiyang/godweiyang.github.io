<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【每日算法Day 72】谷歌面试题：又双叒叕是位运算，最详细的自动机推导过程</title>
      <link href="/2020/03/17/leetcode-137/"/>
      <url>/2020/03/17/leetcode-137/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/single-number-ii/" title="LeetCode 137. 只出现一次的数字 II" target="_blank" rel="noopener">LeetCode 137. 只出现一次的数字 II</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong><br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,2,3,2]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[0,1,0,1,0,1,99]输出：99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="逐位考虑"><a href="#逐位考虑" class="headerlink" title="逐位考虑"></a>逐位考虑</h3><p>我们单独看二进制某一位，先不看单独的那个数，其他所有数字都出现了 3 次，所以那一位是 1 的个数一定是 3 的倍数。</p><p>再考虑这个出现一次的数，如果这一位是 1 ，那么这一位 1 的次数模 3 为 1 ，否则的话模 3 就是 0 。</p><p>那么就很简单了，统计一下有多少个数这一位上是 1 ，然后模 3 取余数，结果就是这个单独的数这一位上的值了。</p><p>遍历 32 位整数的每一位，就可以得到这个单独的数是多少了。</p><p><strong>推广到一般情况：</strong><br>如果其他数都出现了 $k$ 次，一个数出现了一次。那么如果 $k$ 是偶数，还是把所有的数异或起来就行了。如果 $k$ 是奇数，那么统计每一位是 1 的个数，然后模 $k$ 取余数就能得到那个单独的数了。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>我们还可以用自动机来做这题，根据某一位 1 的个数，我们可以得到如下的状态自动机：<br><img src="1.png" alt><br>初始的时候在状态 0 （有 0 个 1），然后如果下一个数这一位是 1，就进入状态 1（有 1 个 1），接着如果下一个数这一位是 1，就进入状态 2（有 2 个 1），接着如果下一个数这一位是 1，就进入状态 3（有 3 个 1），最后如果再来了一个数这一位还是 1，就说明是一个新的数了，等价于回到了状态 1。而每个状态如果来的数这一位是 0 ，都会保持状态不变。</p><p>当然这个自动机还可以简化，注意观察可以发现状态 3 和状态 0 是等价的（输入 0 都保持不变，输入 1 都会进入状态 1）。所以我们将状态 1 和状态 3 合并为一个状态 0 ，得到如下的状态自动机：<br><img src="2.jpg" alt></p><p>因为一共有三个状态，所以我们需要用两个变量来表示状态。用 <code>once</code> 表示是否在状态 1，用 <code>twice</code> 来表示是否在状态 2 。那么两个变量都为 0 就表示在状态 0 。然后可以得到如下的状态转移表：<br><img src="3.jpg" alt></p><p>注意观察 <code>once</code> 只有两种情况下转移后为 1 。一种是 <code>once=0, twice=0, x=1</code> ，另一种是 <code>once=1, twice=0, x=0</code> 。其他所有情况下 <code>once</code> 都转移为 0 。这两种情况都满足 <code>x^once=1</code> 并且 <code>twice=0</code> ，所以 <code>once</code> 的转移就是 <code>once = (x^once) &amp; (~twice)</code> 。</p><p>同理，观察 <code>twice</code> 只有两种情况下转移后为 1 。一种是 <code>once=1, twice=0, x=1</code> ，另一种是 <code>once=0, twice=1, x=0</code> 。其他所有情况下 <code>twice</code> 都转移为 0 。这两种情况都满足 <code>x^twice=1</code> 并且 <code>once^twice=1</code> ，所以 <code>twice</code> 的转移就是 <code>twice = (x^twice) &amp; (once^twice)</code> 。<strong>但是</strong>！！！ <code>once</code> 已经抢先一步转移过了，所以值已经变掉了，一个解决方法就是用临时变量保存一下前一个状态的 <code>once</code> 值。另一个方法就是，这两种情况下，<code>once</code> 都会转移到 0 ，所以判断条件直接用转移后的 <code>once=0</code> 就行了，随后转移就是 <code>twice = (x^twice) &amp; (~once)</code> 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="逐位考虑（c-）"><a href="#逐位考虑（c-）" class="headerlink" title="逐位考虑（c++）"></a>逐位考虑（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> lb <span class="token operator">=</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&amp;</span>lb<span class="token punctuation">)</span> y <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&amp;</span>lb<span class="token punctuation">)</span> y <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>y<span class="token punctuation">,</span> y<span class="token operator">^</span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位运算（c-）"><a href="#位运算（c-）" class="headerlink" title="位运算（c++）"></a>位运算（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> once <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> twice <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            once <span class="token operator">=</span> <span class="token punctuation">(</span>once<span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>twice<span class="token punctuation">)</span><span class="token punctuation">;</span>            twice <span class="token operator">=</span> <span class="token punctuation">(</span>twice<span class="token operator">^</span>x<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>once<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> once<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a href="https://leetcode-cn.com/problems/single-number/" title="LeetCode 136. 只出现一次的数字" target="_blank" rel="noopener">LeetCode 136. 只出现一次的数字</a><br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" title="LeetCode 面试题56 - I. 数组中数字出现的次数" target="_blank" rel="noopener">LeetCode 面试题56 - I. 数组中数字出现的次数</a><br><a href="https://leetcode-cn.com/problems/missing-two-lcci/" title="LeetCode 面试题 17.19. 消失的两个数字" target="_blank" rel="noopener">LeetCode 面试题 17.19. 消失的两个数字</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法</title>
      <link href="/2020/03/16/leetcode-interview-17-19/"/>
      <url>/2020/03/16/leetcode-interview-17-19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/missing-two-lcci/" title="LeetCode 面试题 17.19. 消失的两个数字" target="_blank" rel="noopener">LeetCode 面试题 17.19. 消失的两个数字</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，包含从 $1$ 到 $N$ 所有的整数，但其中缺了两个数字。你能在 $O(N)$ 时间内只用 $O(1)$ 的空间找到它们吗？</p><p>以任意顺序返回这两个数字均可。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1]输出：[2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,3]输出：[1,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>$nums.length \le 30000$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>首先将数组里的数再加上 $1$ 到 $n$ 中所有的数构成一个更大的集合，那么问题就变成了<strong>一个数组里有两个数只出现了一次，其余数都出现了两次，求这两个数是多少？</strong></p><p>是不是很熟悉？这其实就是 LeetCode 另一道位运算题目：<br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" title="LeetCode 面试题56 - I. 数组中数字出现的次数" target="_blank" rel="noopener">LeetCode 面试题56 - I. 数组中数字出现的次数</a></p><p>首先还是常规套路，把所有的数异或起来，得到的值 $x$ 一定就是出现一次的两个数的异或值。</p><p>那么再回顾一道最基本的位运算题：<br><a href="https://leetcode-cn.com/problems/single-number/" title="LeetCode 136. 只出现一次的数字" target="_blank" rel="noopener">LeetCode 136. 只出现一次的数字</a></p><p>也就是<strong>一个数组里有一个数只出现了一次，其余数都出现了两次，求这个数是多少？</strong>这就很简单了，只需要全部异或起来就是这个数的值了。</p><p>那么回到本题，有没有办法将这 $2n-2$ 个数拆分成两个集合，每个集合都满足上面这种最简单的条件（只有一个数出现了一次）呢？</p><p>刚刚得到了两个只出现一次数字的异或值 $x$ ，那么 $x$ 中的 $1$ 就表示了这两个数那一位是不同的。那就很简单了啊，我们把所有 $2n-2$ 个数那一位是 $0$ 的归为一个集合，那一位是 $1$ 的归为一个集合，那么这两个只出现一次的数一定会分属两个不同的集合。而其他出现了两次的数，每个数字都会在同一个集合里。</p><p>最后对两个集合分别求异或值，就得到了两个出现一次数的值了。</p><p>这里有个关键点，就是按照 $x$ 某一位为 $1$ 来划分两个集合，其实取任意一位是 $1$ 的位都是可以的。但是最简单的方法就是取最低位 $1$ ，因为这样可以采用位运算 $x \&amp; (-x)$ 直接得到。</p><p>位运算系列还有一个进阶版：<br><a href="https://leetcode-cn.com/problems/single-number-ii/" title="LeetCode 137. 只出现一次的数字 II" target="_blank" rel="noopener">LeetCode 137. 只出现一次的数字 II</a></p><p>这题就与本题无关了，我们留着下次继续讲。</p><h3 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h3><p>首先假设缺失的两个数字为 $x, y$ 。</p><p>令 $S_1$ 为 $nums$ 数组中的元素和，$S_2$ 为 $nums$ 数组中的元素平方和。</p><p>再用 $1$ 到 $n$ 的元素和减去 $S_1$ 就得到了 $x+y$ 的值，记为 $a$。用 $1$ 到 $n$ 的元素平方和减去 $S_2$ 就得到了 $x^2+y^2$ 的值，记为 $b$。</p><p>最后只要解出下面这个二元二次方程组就行了：<br>$$<br>\begin{aligned}<br>&amp;x + y = a   \\<br>&amp;x^2 + y^2 = b<br>\end{aligned}<br>$$<br>用求根公式可以解出两个解是：<br>$$<br>\frac{a \pm \sqrt{2b-a^2}}{2}<br>$$<br>其中：<br>$$<br>\begin{aligned}<br>&amp;a = \sum_{i=1}^n{i} - \sum_{i=0}^{n-3}{nums[i]} = \frac{n(n+1)}{2}  - \sum_{x \in nums}{x}  \\<br>&amp;b = \sum_{i=1}^n{i^2} - \sum_{i=0}^{n-3}{(nums[i])^2} = \frac{n(n+1)(2n+1)}{6} - \sum_{x \in nums}{x^2}<br>\end{aligned}<br>$$</p><h3 id="下标哈希"><a href="#下标哈希" class="headerlink" title="下标哈希"></a>下标哈希</h3><p>一个很直觉的方法就是，我新开辟一个大小为 $n+1$ 的数组，然后把 $nums$ 数组中的元素都放在新数组中下标对应的位置，最后看哪两个位置没有数就行了。但是现在要用原地算法，不允许新开辟空间，那我们就只能直接放在原数组里面了。</p><p>首先我们还是得把原数组扩展到大小为 $n+1$，也就是在末尾增加 $3$ 个空间，数字就放 $-1$。</p><p>然后遍历数组，对于 $nums[i]$ 来说，它的位置上最后放的应该是数字 $i$ 才对，而 $nums[i]$ 应该被放在下标为 $nums[i]$ 的位置。所以我们把 $nums[i]$ 移动到下标为 $nums[i]$ 的位置上去，但是 $nums[i]$ 位置上的数字怎么办呢？不能直接覆盖，不然就再也无法访问了，所以我们把它移动到下标 $i$ 的位置就行了。也就是说交换下标 $i$ 和 $nums[i]$ 位置上的两个数。</p><p>那么问题接着来了，位置 $nums[i]$ 上面的数对了，但是位置 $i$ 上面的数还是错的啊。那么只要继续重复交换操作，直到位置 $i$ 位置上面的数是 $i$ ，或者是 $-1$ 就行了。</p><p>最后所有数都摆回正确位置了，再扫描一遍数组，如果 $nums[i] = -1$ ，就说明 $i$ 这个数不在数组里。</p><p>这个方法理论上适合缺任意 $k$ 个数，只需要一开始在数组后面补上 $k+1$ 个 $-1$ 就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="位运算（c-）"><a href="#位运算（c-）" class="headerlink" title="位运算（c++）"></a>位运算（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> lb <span class="token operator">=</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&amp;</span>lb<span class="token punctuation">)</span> y <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&amp;</span>lb<span class="token punctuation">)</span> y <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>y<span class="token punctuation">,</span> y<span class="token operator">^</span>x<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学法（c-）"><a href="#数学法（c-）" class="headerlink" title="数学法（c++）"></a>数学法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> S1 <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> S2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> S2 <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">*</span>x<span class="token punctuation">;</span>        <span class="token keyword">long</span> a <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span>S1<span class="token punctuation">;</span>        <span class="token keyword">long</span> b <span class="token operator">=</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">6</span><span class="token operator">-</span>S2<span class="token punctuation">;</span>        <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>b<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>b<span class="token operator">-</span>a<span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下标哈希（c-）"><a href="#下标哈希（c-）" class="headerlink" title="下标哈希（c++）"></a>下标哈希（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">missingTwo</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 70】图解算法：小学生都会的数块数问题，你会吗？</title>
      <link href="/2020/03/15/leetcode-959/"/>
      <url>/2020/03/15/leetcode-959/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/" title="LeetCode 959. 由斜杠划分区域" target="_blank" rel="noopener">LeetCode 959. 由斜杠划分区域</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 \ 用 “\\” 表示。）。</p><p>返回区域的数目。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  " /",  "/ "]输出：2解释：2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="1.png" alt></p><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  " /",  "  "]输出：1解释：2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="2.png" alt></p><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  "\\/",  "/\\"]输出：4解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3.png" alt></p><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  "/\\",  "\\/"]输出：5解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="4.png" alt></p><p><strong>示例5</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  "//",  "/ "]输出：3解释：2x2 网格如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="5.png" alt></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题如果不用写代码，直接让你数的话，那就非常简单了。但是要想实现代码，还是有点麻烦的。</p><p>最主要的麻烦点在于，如果表示出斜杠的划分？这里我提供了三种不同的方法。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p><img src="6.jpg" alt><br>如上图所示，首先将每个格子划分成 3 x 3 的更小的网格，然后对角线上填充 1 来表示斜杠，其余地方全部填充 0 。</p><p>那么问题就转化为了求一个 3N x 3N 的网格上的 0 的连通块一共有几块，这就用普通的 dfs 搜一遍就知道了。</p><p>那么这里有个问题，为什么不能每个格子划分成 2 x 2 呢？如下图所示，这样会导致两个格子中的 0 无法只用上下左右四个方向来联通：<br><img src="9.jpg" alt></p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><p><img src="7.jpg" alt><br>如上图所示，这种方法采用了并查集的思想。</p><p>首先将一个格子用 X 划分成四块，上图左半部分是各自之间的连通性，两个格子的相邻部分是一定连通的。</p><p>而右半部分是格子内部的连通性。如果有斜杠，那就将斜杠两边的两小块都连起来。如果没有斜杠，那就将四小块都连起来，而这只需要三条线就够了。</p><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><p><img src="8.jpg" alt><br>如上图所示，这个方法还是采用了并查集的思想。这次我们不以格子为计算单元了，我们来看格点。</p><p>初始的时候，四周一圈的格点都是连通的（红色线），而内部的格点都是孤立的。这时候只有一个区域，也就是整个平面。</p><p>然后一个格子一个格子添加斜杠。首先添加绿色斜杠，也就是连接 0 和 5 格点，这时候发现这两个点不在一个连通块里，那么就没有产生区域。</p><p>然后添加蓝色斜杠，也就是连接 2 和 5 格点，这时候发现这两个点在同一个连通块里，那么就产生了一个新的区域（也就是灰色部分）。</p><p>这样遍历完所有斜杠，就能知道增加了几块新的区域了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法-1（c-）"><a href="#方法-1（c-）" class="headerlink" title="方法 1（c++）"></a>方法 1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">regionsBySlashes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">new_grid</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'\\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>new_grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                    new_grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> new_grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法-2（c-）"><a href="#方法-2（c-）" class="headerlink" title="方法 2（c++）"></a>方法 2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">==</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> fu <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> fv <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fu <span class="token operator">==</span> fv<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>fv<span class="token punctuation">]</span> <span class="token operator">=</span> fu<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">regionsBySlashes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>n<span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token operator">*</span>n<span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">*</span>n<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s<span class="token number">-4</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">4</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">,</span> s<span class="token number">-3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token operator">*</span>n<span class="token operator">*</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法-3（c-）"><a href="#方法-3（c-）" class="headerlink" title="方法 3（c++）"></a>方法 3（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> f<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">==</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> fu <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> fv <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fu <span class="token operator">==</span> fv<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>fv<span class="token punctuation">]</span> <span class="token operator">=</span> fu<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">regionsBySlashes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    u <span class="token operator">=</span> i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    v <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    u <span class="token operator">=</span> i<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token punctuation">;</span>                    v <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">merge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 69】面试经典题：分发糖果问题</title>
      <link href="/2020/03/14/leetcode-135/"/>
      <url>/2020/03/14/leetcode-135/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/candy/" title="LeetCode 135. 分发糖果" target="_blank" rel="noopener">LeetCode 135. 分发糖果</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老师想给孩子们分发糖果，有 $N$ 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 $1$ 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,0,2]输出：5解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,2]输出：4解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题虽然难度定义成<strong>困难</strong>，但其实代码不长，思路也比较简单清晰。</p><p>首先明确一下题目中的两个条件，我们可以把所有人的分数在坐标轴中连起来，这样就形成了一个波形图（<strong>图片来自官方题解</strong>）：<br><img src="1.png" alt><br>那么这就像一座一座山峰一样，在谷底（左右两边分数都大于等于它）糖果数一定是 $1$ 。从谷底往两侧扩展，糖果数逐渐加 $1$ 就行了。</p><p>要注意的一点是图中 pt.13 那个位置也是一个谷底，因为它右边的分数等于它。</p><p>那么问题的关键就是如何找到这些谷底了。</p><h3 id="两次遍历"><a href="#两次遍历" class="headerlink" title="两次遍历"></a>两次遍历</h3><p>首先初始化所有人都分到 $1$ 个糖果。</p><p>然后从左向右遍历一次所有分数，如果发现分数小于等于前一个人分数，那暂时不用管，因为你从左向右是没法知道下坡的点距离谷底还有多远的。而如果发现分数大于前一个人分数，那么就在前一个人糖果数基础上，再多分一个给他，因为是上坡，所以谷底一定在左边已经遍历过了，是知道距离的。</p><p>接着就是遍历下坡了，也就是从右向左遍历所有分数，同理如果发现分数大于后一个人分数，那么就在后一个人糖果数基础上，再多分一个给他。</p><p>但是这里要处理一个冲突，那就是峰顶既是上坡，又是下坡，其实只要两次遍历完取上坡和下坡中糖果数较大的那个就行了。</p><p>总结一下就是<strong>一次从左向右遍历所有上坡，一次从右向左遍历所有下坡，峰顶取两次较大值</strong>。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>从上面方法中可以看出，本题求解的难点就在于从左向右遍历的时候，下坡到底有多长没法知道，必须全部遍历完了才能知道。还有就是山峰的值必须看左右两边的上坡下坡有多长。</p><p>为了解决这个问题，我们可以用变量 <code>up</code> 记录上坡的长度，<code>down</code> 记录下坡的长度。</p><p>当遇到谷底的时候，就表明一座山遍历结束了，那么我们只需要比较 <code>up</code> 和 <code>down</code> 的大小就知道峰顶取值了。</p><p>而如何判断一座山遍历结束呢？假设现在遍历到了第 $i$ 个学生，我们再用两个变量，<code>ns</code> 表示 $i-1$ 到 $i$ 的变化趋势（$1$：上升，$-1$：下降，$0$：不变），<code>os</code> 表示前一个时刻 $i-2$ 到 $i-1$ 的变化趋势。那么谷底只有下面三种情况：</p><ul><li>$os &lt; 0$ 且 $ns &gt; 0$ 。也就是前一个时刻在下降，当前时刻上升了，那显然第 $i-1$ 个学生是谷底。</li><li>$os &lt; 0$ 且 $ns = 0$ 。也就是前一个时刻在下降，当前时刻不变，这种情况下第 $i-1$ 个学生也是谷底，因为根据题意，他的糖果数没必要比第 $i$ 个学生多。</li><li>$os &gt; 0$ 且 $ns = 0$ 。也就是前一个时刻在上升，当前时刻不变。这种情况下，山峰只有上坡（到峰顶 $i-1$ 结束），没有下坡，所以这座山也遍历结束了，得计算糖果数了。</li></ul><p>这座山峰的的糖果数可以表示为三部分之和：上坡、下坡和峰顶。上坡就是 $1+2+\ldots+up$，下坡就是 $1+2+\ldots+down$，峰顶就是 $\max{\{up, down\}}+1$ 。算完了之后，这座山峰就再也不用考虑了， <code>up</code> 和 <code>down</code> 都清零。</p><p>在具体实现的时候，这个方法细节有点多，一不小心就会错，直接看代码注释吧。</p><p>继续看下面这张图：<br><img src="1.png" alt><br>贴一段官方的样例解释：<br><img src="2.jpg" alt></p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(1)$ 。</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>我们用一个单调栈来保存单调下降的得分，也就是下坡。</p><p>当遍历到第 $i$ 个学生时，如果栈顶元素 $j$ 的得分小于等于 $i$ 的得分，也就是遇到谷底了，那么就出栈，直到栈空。</p><p>最后用一个很大的数将栈里所有元素顶出来就行了。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ 。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>第一种解法最容易理解和实现，也不用考虑什么特殊情况。但是后两种方法处理起来就稍稍有点麻烦了，需要结合样例和代码来理解。但是本质上都是一样的，都是从谷底（糖果数为 $1$）开始，向两周扩展。方法一是先从每个谷底向右边上坡扩展，再向左边下坡扩展。方法二是计算出相邻两个谷底之间的上坡下坡长度，然后直接计算。第三个方法是从每个谷底先向左边下坡扩展，再向右边上坡扩展。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="两次遍历（c-）"><a href="#两次遍历（c-）" class="headerlink" title="两次遍历（c++）"></a>两次遍历（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一次遍历（c-）"><a href="#一次遍历（c-）" class="headerlink" title="一次遍历（c++）"></a>一次遍历（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> up <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> down <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> os <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ns <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ns <span class="token operator">=</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ratings<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>ratings<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这座山峰遍历结束，计算糖果数。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>os <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> os <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ns <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这里看似好像峰顶没有加 1，其实是 count(down) 减去了 1。</span>                <span class="token comment" spellcheck="true">// 因为谷底是共享的，所以将谷底给了下一座山峰的上坡。</span>                sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> down<span class="token punctuation">)</span><span class="token punctuation">;</span>                up <span class="token operator">=</span> down <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ns <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> up<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ns <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> down<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果是平原，说明谷底不会共享，之前少加的 1 再补上。</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ns<span class="token punctuation">)</span> sum<span class="token operator">++</span><span class="token punctuation">;</span>            os <span class="token operator">=</span> ns<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 最后一座山峰循环里不会计算到，再加上。</span>        sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">count</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span> down<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈（c-）"><a href="#单调栈（c-）" class="headerlink" title="单调栈（c++）"></a>单调栈（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ratings<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> ratings<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> j <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token number">-1</span> <span class="token operator">&amp;&amp;</span> ratings<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ratings<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    sum <span class="token operator">+</span><span class="token operator">=</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 68】脑筋急转弯：只要一行代码，但你会证吗？</title>
      <link href="/2020/03/13/leetcode-1227/"/>
      <url>/2020/03/13/leetcode-1227/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/" title="LeetCode 1227. 飞机座位分配概率" target="_blank" rel="noopener">LeetCode 1227. 飞机座位分配概率</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 位乘客即将登机，飞机正好有 $n$ 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p><p>剩下的乘客将会：</p><ul><li>如果他们自己的座位还空着，就坐到自己的座位上。</li><li>当他们自己的座位被占用时，随机选择其他座位。</li></ul><p>第 $n$ 位乘客坐在自己的座位上的概率是多少？</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 1输出：1.00000解释：第一个人只会坐在自己的位置上。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 2输出：0.50000解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题呢代码相当之简单，但是我看了看题解区能真正理解的也不是很多，很多都是揣着糊涂装明白，稀里糊涂就当证过了。</p><p>首先题目并没有说第一个乘客座位号就是 $1$ 啊？也没说最后一个乘客座位号就是 $n$ 啊？所以大家的假设是怎么来的？这一点没有说清。其实很简单，不管每个乘客编号是多少，我们不用管，我们只要看他入场的次序就行了，所以我们就按照入场次序给他们重新编个号，这样的话就是按照 $1$ 到 $n$ 的编号入场了（也就是这里的编号代表的是入场的次序，而不是实际的座位号）。</p><p>然后就是 $1$ 号进场了，可以分为下面几种情况：</p><ul><li>他有 $\frac{1}{n}$ 的概率选择坐在 $1$ 号座位上。这样 $2$ 到 $n$ 号位置都不会被占，那么 $n$ 号坐在自己座位的概率就是 $1.0$ 。</li><li>他有 $\frac{1}{n}$ 的概率选择坐在 $n$ 号座位上。这样 $2$ 到 $n-1$ 号位置都不会被占，而 $n$ 号只能坐在 $1$ 号座位上，那么概率就是 $0.0$ 。</li><li>他有 $\frac{1}{n}$ 的概率选择坐在 $i$ 号座位上，其中 $2 \le i \le n-1$。这样 $2$ 到 $i-1$ 号位置都不会被占，他们都坐在自己的的位置上。而 $i$ 号乘客就犯难了，他的座位被 $1$ 号占了，他不知道坐哪了。这时候，如果他选择坐 $1$ 号座位，那么 $i+1$ 到 $n$ 号乘客还是坐在自己位置，相安无事。而如果他选择坐在 $i+1$ 到 $n$ 号中的某个位置，那么必然又会产生新的冲突，这样就不好求解了啊！</li></ul><p>对于第三种情况，我们可以换个角度看问题。现在面临的问题是，$i$ 号选择坐在哪？这时候还没入场的有 $i$ 到 $n$ 号乘客，而座位还剩 $1$ 和 $i+1$ 到 $n$ 号。那既然 $i$ 号乘客坐在 $1$ 号座位的话，后面的人都能坐回原位，那我们就把 $1$ 号座位当作是 $i$ 号乘客原本的座位就行了嘛，反正我最后又不要求 $i$ 号乘客坐回原位的概率，你坐哪都没事，只要别影响到其他人就行了。那么问题的规模就被缩小到了 $n-i+1$ ，我们递归求解就行了。</p><p>令 $f(n)$ 表示 $n$ 个人的情况下，最后一个人坐回原位的概率，按照上面的分析，我们可以列出递推式：<br>$$<br>f(n) = \frac{1}{n}\left(1 + \sum_{i=2}^{n-1}{f(n-i+1)}\right)<br>$$<br>这个递推式想必大家高中就会求了，令 $n = n-1$再写出一项：<br>$$<br>f(n-1) = \frac{1}{n-1}\left(1 + \sum_{i=2}^{n-2}{f(n-i)}\right)<br>$$<br>然后两式相减得到：<br>$$<br>nf(n) - (n-1)f(n-1) = f(n-1)<br>$$<br>即：<br>$$<br>f(n) = f(n-1) = \cdots = f(2)<br>$$<br>那么我们就可以得到最终的答案了，对任意的 $n \ge 2$ 都有 $f(n) = f(2) = 0.5$ 。</p><p>还有一个特例就是 $f(1) = 1.0$ ，这样这题就证好了。</p><p>这题最关键的一步就是 $1$ 号坐在了 $i$ 号座位后，$i$ 号何去何从？如果你能换个角度，把 $1$ 号座位给 $i$ 号（因为给他之后，对后面的乘客座位没有任何影响，那么就能把 $1$ 号座位看成就是 $i$ 号乘客的），那么问题就能递归下去了。题解区许多人这一步为什么能递归下去？根本没有讲清楚。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">nthPersonGetsNthSeat</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-py"><code class="language-py">class Solution:    def nthPersonGetsNthSeat(self, n: int) -> float:        return 1 if n==1 else .5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 67】经典面试题：手动开根号，你知道几种方法？</title>
      <link href="/2020/03/12/leetcode-69/"/>
      <url>/2020/03/12/leetcode-69/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/" title="LeetCode 69. x 的平方根" target="_blank" rel="noopener">LeetCode 69. x 的平方根</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现 <code>int sqrt(int n)</code> 函数。</p><p>计算并返回 $n$ 的平方根，其中 $n$ 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：4输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：8输出：2解释：8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>为了更加通用，我们这里直接实现 <code>double sqrt(double n)</code> 函数。也就是求出 $\sqrt{n}$ 的精确值，然后取整就行了。</p><p>今天要教给大家的主要有三种方法：<strong>牛顿法</strong>、<strong>二分法</strong>和<strong>梯度下降法</strong>，速度上是依次下降的。</p><p>首先令 $\sqrt{n} = x$ ，也就是 $x^2 - n = 0$ ，也就是我们要求 $x^2 - n$ 的零点。</p><p>如果我们把 $x^2 - n$ 当作某个函数的导数，那么原函数就是 $f(x) = \frac{1}{3}x^3 - nx$ ，它的导数就是 $f’(x) = x^2 - n$ 。</p><p>现在问题很明朗了，要求 $\sqrt{n}$ 的值，等价于求 $f’(x) = 0$ 的根，等价于求 $f(x)$ 的极小值点（因为导数在非负数区间上零点唯一）。</p><h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>求 $f’(x) = 0$ 的根可以采用牛顿法。</p><p>首先选取一个初值 $x_0$ ，然后在函数 $(x_0, f’(x_0))$ 处作切线，求出切线与 $x$ 轴交点 。接着将交点坐标作为新的 $x_0$ ，然后重复上面步骤，直到 $f’(x_0)$ 和 $0$ 差值小于某个阈值。</p><p>直接给出计算得到的更新公式吧，大家也可以自己通过切线方程推导一下：<br>$$<br>x_0 \leftarrow x_0 - \frac{f’(x_0)}{f’’(x_0)} = \frac{1}{2}(x_0+\frac{n}{x_0})<br>$$<br>还可以通过泰勒展开得到这个公式，这里就不详细阐述了。</p><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>求 $f(x)$ 的极小值点可以采用梯度下降法。</p><p>首先选取一个初值 $x_0$ ，然后按照 $f(x_0)$ 的导数的逆方向更新 $x_0$ ，具体更新多少取决于你设置的学习率 $lr$ 。</p><p>更新公式就是：<br>$$<br>x_0 \leftarrow x_0 - lr \cdot f’(x_0) = x_0 - lr \cdot (x_0^2 - n)<br>$$</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>这就是很普通的二分方法了，因为 $f’(x)$ 在 $[0,\infty)$ 区间上是单调递增的，所以可以采用二分法求出零点，这里就不赘述了。</p><h3 id="速度比较"><a href="#速度比较" class="headerlink" title="速度比较"></a>速度比较</h3><p>我运行了一下从 $100$ 到 $10000$ 每 $100$ 个数开根号的结果，统计了一下三种方法需要的计算次数，如下图所示：<br><img src="1.jpg" alt><br>可以发现，牛顿法和二分法都是速度很快的，随着 $n$ 增大，需要的次数越来越多。但是梯度下降法的次数和学习率关系很大，学习率大了可能收敛次数变小，但是可能不收敛（左右振荡）。随着 $n$ 的增大，梯度下降法所需要的次数反而下降了，因为 $n$ 越大，函数越陡峭， $x_0$ 处的导数就越大，这样 $x_0$ 的更新幅度特别大。但是 $n$ 特别大了以后，梯度下降法需要的时间就非常长了，学习率不是很好设置了。而导数也已经超出了 <code>int</code> 范围，实现上也不是很方便。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>具体实现上这题有几个注意的点，因为这题只要求你返回取整结果，所以要特别当心浮点数误差。</p><p>而梯度下降法实现时，学习率不能太大，不然会产生振荡，此外还会导致 $x_0$ 更新幅度过大，直接变成负数，然后就陷入了死循环。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> y <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token function">newtonSqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> y<span class="token operator">*</span>y <span class="token operator">></span> x <span class="token operator">?</span> y<span class="token number">-1</span> <span class="token operator">:</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">newtonSqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> x0 <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1e-6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            x0 <span class="token operator">=</span> <span class="token number">0.5</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">/</span>x0<span class="token operator">+</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x0<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">binarySqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">>=</span> <span class="token number">1e-6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">double</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token operator">*</span>m <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> l <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 超时</span>    <span class="token keyword">double</span> <span class="token function">gdSqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> x0 <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1e-6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">double</span> lr <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token number">1e-3</span><span class="token punctuation">,</span> <span class="token number">1e-1</span><span class="token operator">*</span>x0<span class="token operator">/</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            x0 <span class="token operator">=</span> x0<span class="token operator">-</span>lr<span class="token operator">*</span><span class="token punctuation">(</span>x0<span class="token operator">*</span>x0<span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x0<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 66】经典面试题：不用四则运算如何做加法？</title>
      <link href="/2020/03/11/leetcode-interview-65/"/>
      <url>/2020/03/11/leetcode-interview-65/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" title="LeetCode 面试题65. 不用加减乘除做加法" target="_blank" rel="noopener">LeetCode 面试题65. 不用加减乘除做加法</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 $+,-,*,/$ 四则运算符号。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：a = 1, b = 1输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$a, b$ 均可能是负数或 $0$</li><li>结果不会溢出 $32$ 位整数</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为不允许采用四则运算，所以只能考虑位运算了。</p><p>其实就是用二进制来模拟加法操作。首先将两个数最低位相加，如果都是 $1$ ，那么就得到 $0$ ，并且进位 $1$ ，然后接着算下一位。</p><p>但是这样一位一位模拟不方便实现，更简单的实现方法是直接把两个数对应位相加，不管进位。然后进位单独计算，如果某一位两个数都是 $1$ ，那么进位就会对下一位产生影响。然后接着算不进位求和加上进位的值，再计算新的进位，依次重复下去，直到进位为 $0$ 为止。</p><p>用一个实际的例子来演示一下，计算 $3+7$ 的值，其中 $s$ 表示每一步不考虑进位的求和，$c$ 表示每一步的进位，最后得到结果 $1010$ ，也就是十进制的 $10$ ：<br><img src="1.jpg" alt></p><p>但是这里还是用到了加法怎么办呢？因为是二进制，所以不考虑进位求和的话，可以直接采用<strong>异或</strong>运算。而计算进位的话，直接用<strong>位与</strong>和<strong>左移一位</strong>就行了。</p><p>在 c++ 和 python 具体实现中，还有几个注意事项：</p><ul><li>LeetCode c++ 不允许负数左移操作，所以要转换成无符号整数。</li><li>python 因为位数没有限制，所以负数补码会很长，所以要位与 0xffffffff 处理成 $32$ 位整型数。</li><li>c++ 还可以写成递归形式，也就是 $a+b$ 可以递归成 $s+c$ ，其中 $s$ 表示不进位求和结果，$c$ 表示进位的值。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="非递归（c-）"><a href="#非递归（c-）" class="headerlink" title="非递归（c++）"></a>非递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>            a <span class="token operator">^</span><span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> carry<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归（c-）"><a href="#递归（c-）" class="headerlink" title="递归（c++）"></a>递归（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> b <span class="token operator">?</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">^</span>b<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非递归（python）"><a href="#非递归（python）" class="headerlink" title="非递归（python）"></a>非递归（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        a <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xffffffff</span>        b <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token number">0xffffffff</span>        <span class="token keyword">while</span> b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            carry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span>            a <span class="token operator">^</span><span class="token operator">=</span> b            b <span class="token operator">=</span> carry        <span class="token keyword">return</span> a <span class="token keyword">if</span> a <span class="token operator">&lt;</span> <span class="token number">0x80000000</span> <span class="token keyword">else</span> <span class="token operator">~</span><span class="token punctuation">(</span>a<span class="token operator">^</span><span class="token number">0xffffffff</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="投机取巧（python）"><a href="#投机取巧（python）" class="headerlink" title="投机取巧（python）"></a>投机取巧（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 65】你能顺利救出地下城里的公主吗？</title>
      <link href="/2020/03/10/leetcode-174/"/>
      <url>/2020/03/10/leetcode-174/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/dungeon-game/" title="LeetCode 174. 地下城游戏" target="_blank" rel="noopener">LeetCode 174. 地下城游戏</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><table><thead><tr><th align="center">-2（K）</th><th align="center">-3</th><th align="center">-3</th></tr></thead><tbody><tr><td align="center">-5</td><td align="center">-10</td><td align="center">1</td></tr><tr><td align="center">10</td><td align="center">30</td><td align="center">-5（P）</td></tr></tbody></table><p><strong>提示：</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="错误解法"><a href="#错误解法" class="headerlink" title="错误解法"></a>错误解法</h3><p>首先我们肯定想到的是从左上到右下动态规划，那么对于 $(i, j)$ 这个格子来说，它有两个选择，可以从 $(i-1, j)$ 或者 $(i, j-1)$ 过来。</p><p>我们令 $dp[i][j]$ 表示从左上角走到 $(i, j)$ 这个格子所需要的最小生命值，那么我们选择 $\min{\{dp[i-1][j], dp[i][j-1]\}}$ ，也就是两个<strong>来向</strong>中较小的那个走过来。但是考虑了当前格子的数值之后，路线上所需生命的最小值是可能增大的，而这时候可能选择两个来向中较大的那个反而更好（因为那个来向数值之和比较大），所以这里就产生了矛盾，无法求解。</p><p>举个简单的例子：</p><table><thead><tr><th align="center">1（K）</th><th align="center">-3</th><th align="center">3</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">-2</td><td align="center">0</td></tr><tr><td align="center">-3</td><td align="center">-3</td><td align="center">-3（P）</td></tr></tbody></table><p>这个例子中如果只看走到格子 $(1, 2)$ 的结果的话，肯定是 下 -&gt; 右 -&gt; 右 最好，因为这样初始生命只需要 2 就够了。而另一条路 右 -&gt; 右 -&gt; 下 则需要初始生命 3 。</p><p>但是如果继续走到格子 $(2, 2)$ ，那么最优方向一定是从 $(1, 2)$ 过来（另一个方向负数太多）。但是到 $(1, 2)$ 的最优路线保存的是 下 -&gt; 右 -&gt; 右 这一条，走到终点总和是 -4 ，初始所需最小生命增大为 5 。而另一条原本不怎么好的路线 右 -&gt; 右 -&gt; 下 总和是 -2 ，初始所需最小生命 3 ，所以仍然保持不变。</p><p>这样看来原本不好的路线在最后的结果里是可能会变好的，所以不好保存下来直接递推。</p><h3 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h3><p>既然从左上到右下没法动态规划，我们不妨从右下到左上动态规划看看。</p><p>我们令 $dp[i][j]$ 表示从 $(i, j)$ 这个格子走到右下角所需要的最小生命值，同样我们选择两个<strong>去向</strong>中的较小值 $\min{\{dp[i+1][j], dp[i][j+1]\}}$ 。然后考虑了格子 $(i, j)$ 之后， $dp[i][j]$ 就更新为：<br>$$<br>dp[i][j] = \max{\{1, \min{\{dp[i+1][j], dp[i][j+1]\}} - dungeon[i][j]\}}<br>$$<br>为什么这里选择两个去向中所需初始生命较小的那个就没问题了呢？</p><h3 id="严格证明"><a href="#严格证明" class="headerlink" title="严格证明"></a>严格证明</h3><p><img src="1.jpg" alt><br>考虑上图这种情况，这里我把 $(i, j)$ 抽象为了 $x$ ，右边一格抽象为了 $s$ ，右下角抽象为了 $t$ 。然后 $s \to t$ 走下面这条路所需初始生命值最小，路径上格子记为 $d$ ，另一条路径上格子记为 $d’$ 。</p><p>因为走路径 $d$ 所需的初始生命值更小，所以我们有：<br>$$<br>\max{\left\{ \max_k{\left\{ -\sum_{i=1}^k{d_i} \right\}}, 1 \right\}} &lt; \max{\left\{ \max_k{\left\{ -\sum_{i=1}^k{d’_i} \right\}}, 1 \right\}}<br>$$<br>等价于：<br>$$<br>\max_k{\left\{ -\sum_{i=1}^k{d_i} \right\}} &lt; \max_k{\left\{ -\sum_{i=1}^k{d’_i} \right\}}<br>$$<br>这时候我们在两边 $\max{\{\cdot\}}$ 里面同时加上 $-x$ ，大小关系是不会变的。</p><p>而错误解法中，考虑下图这种情况：<br><img src="2.jpg" alt><br>同样我们可以得到：<br>$$<br>\max_k{\left\{ -\sum_{i=1}^k{d_i} \right\}} &lt; \max_k{\left\{ -\sum_{i=1}^k{d’_i} \right\}}<br>$$</p><p>到这里为止和上面正确解法是一模一样的。但是，加上 $-x$ 之后，和上面正解的区别就是，<strong>正解求和里每一项都加了，所以大小关系不变，但是错解只有一项加了（就是所有值全加起来），大小关系无法确定</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calculateMinimumHP</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> dungeon<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> dungeon<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> dungeon<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> minn<span class="token operator">-</span>dungeon<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 64】LeetCode 861. 翻转矩阵后的得分</title>
      <link href="/2020/03/09/leetcode-861/"/>
      <url>/2020/03/09/leetcode-861/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个二维矩阵 $A$ 其中每个元素的值为 $0$ 或 $1$。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 $0$ 都更改为 $1$，将所有 $1$ 都更改为 $0$。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出：39解释：转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$1 \le A.length \le 20$</li><li>$1 \le A[0].length \le 20$</li><li>$A[i][j]$ 是 $0$ 或 $1$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要明确一个显而易见的事实：</p><ul><li>每一行、每一列要么不翻转，要么翻转一次，再多是等价的，没有意义。</li></ul><h3 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h3><p>因为行列数最多 $20$ ，所以我们可以枚举每一行的翻转状态（$0$：不翻转，$1$：翻转）。</p><p>然后对于每一列，我们只需要看不翻转的 $1$ 多，还是翻转后 $1$ 多就行了。</p><p>这样的时间复杂度是 $O(2^{R}C)$，极限情况下是 $2e^7$ 左右，还是可能会超时的。</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>再仔细观察，我们可以发现要想最终和最大，第一列必须全为 $1$ 。</p><p>证明很简单，对于任意一行，如果它的第一位是 $1$ ，那么这一位的二进制数值就是 $2^{C-1}$ 。反之如果这一位是 $0$ ，那么即使后面所有位全为 $1$ ，总数值也只能达到 $2^{C-1}-1$ 。所以第一位是一定要为 $1$ 的。</p><p>这样就很简单了，每一行的翻转情况其实是确定的。如果第一位是 $1$ ，就不翻转，否则就翻转。</p><p>然后每一列还是看不翻转的 $1$ 多，还是翻转后 $1$ 多。</p><p>这样的时间复杂度只有 $O(RC)$ 。</p><p>那么可能有人会问：为啥不把每行第一位全翻转为 $0$ ，然后翻转第一列使得每行第一位全 $1$ 呢？其实这样是等价的，完全就相当于将之前的方法倒转过来（翻转不翻转操作颠倒）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">matrixScore</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cnt <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> n<span class="token operator">-</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> cnt<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 63】LeetCode 第 179 场周赛题解</title>
      <link href="/2020/03/08/leetcode-week-179/"/>
      <url>/2020/03/08/leetcode-week-179/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>起床打开 leetcode，准备看看今天搞点啥题目水一水的，突然发现周赛还剩 1 小时整。看了眼题目也都挺简单的，就把 4 道题都做掉了。</p></blockquote><h2 id="LeetCode-5352-生成每种字符都是奇数个的字符串"><a href="#LeetCode-5352-生成每种字符都是奇数个的字符串" class="headerlink" title="LeetCode 5352. 生成每种字符都是奇数个的字符串"></a>LeetCode 5352. 生成每种字符都是奇数个的字符串</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题就没什么好说的了，如果 $n$ 是奇数，那就生成 $n$ 个 $a$ 。如果 $n$ 是偶数，那就生成 $n-1$ 个 $a$ ，再加上 $1$ 个 $b$ 。</p><h3 id="代码（python）"><a href="#代码（python）" class="headerlink" title="代码（python）"></a>代码（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">generateTheString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">"a"</span><span class="token operator">+</span><span class="token string">"b"</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token string">"a"</span><span class="token operator">*</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5353-灯泡开关-III"><a href="#LeetCode-5353-灯泡开关-III" class="headerlink" title="LeetCode 5353. 灯泡开关 III"></a>LeetCode 5353. 灯泡开关 III</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher-iii/</a></p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>如果某一个时刻灯都是蓝色的，等价于所有的亮灯都连续排列在数组最左边，没有间断。所以只需要判断当前时刻亮灯的最大编号是否等于亮灯的数量就行了。</p><p>比赛的时候傻 x 了，第一个想到的竟然是树状数组，于是直接把模板套过来过了。</p><h3 id="代码（c-）"><a href="#代码（c-）" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numTimesAllBlue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> light<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> light<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> light<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxx <span class="token operator">==</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>树状数组：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">50010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">numTimesAllBlue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> light<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> light<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add</span><span class="token punctuation">(</span>light<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> light<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>maxx<span class="token punctuation">)</span> <span class="token operator">==</span> maxx<span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5354-通知所有员工所需的时间"><a href="#LeetCode-5354-通知所有员工所需的时间" class="headerlink" title="LeetCode 5354. 通知所有员工所需的时间"></a>LeetCode 5354. 通知所有员工所需的时间</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/</a></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先根据 $manager$ 数组来建图，边权就是父结点到子结点的通知时间。然后从根结点开始做 dfs ，求出根结点到每个叶子结点的路径长度的最大值。</p><h3 id="代码（c-）-1"><a href="#代码（c-）-1" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">numOfMinutes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> headID<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> manager<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> informTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>manager<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                G<span class="token punctuation">[</span>manager<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>headID<span class="token punctuation">,</span> informTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> headID<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> informTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>informTime<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> informTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxx<span class="token operator">+</span>informTime<span class="token punctuation">[</span>headID<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-5355-T-秒后青蛙的位置"><a href="#LeetCode-5355-T-秒后青蛙的位置" class="headerlink" title="LeetCode 5355. T 秒后青蛙的位置"></a>LeetCode 5355. T 秒后青蛙的位置</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/frog-position-after-t-seconds/</a></p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>首先建图，然后从 $1$ 号结点开始，还是用 dfs 。每往下走一次，时间 $t$ 减 $1$ 。如果 $t = 0$ 或者到了叶子结点了，就判断结点是否为 $target$ ，是就返回 $1$ ，不是就返回 $0$ 。每次概率除以当前结点的子结点个数，然后再乘上所有子结点 dfs 结果的最大值（因为结果不是 $0$ 就是正确概率）。</p><h3 id="代码（c-）-2"><a href="#代码（c-）-2" class="headerlink" title="代码（c++）"></a>代码（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">frogPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">G</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> target<span class="token punctuation">,</span> G<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">||</span> <span class="token punctuation">(</span>fa <span class="token operator">&amp;&amp;</span> sz <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">double</span> p <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>fa <span class="token operator">?</span> sz<span class="token number">-1</span> <span class="token operator">:</span> sz<span class="token punctuation">)</span><span class="token punctuation">,</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> fa<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">,</span> t<span class="token number">-1</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> G<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token operator">*</span>maxx<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 62】LeetCode 815. 公交路线</title>
      <link href="/2020/03/07/leetcode-815/"/>
      <url>/2020/03/07/leetcode-815/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们有一系列公交路线。每一条路线 $routes[i]$ 上都有一辆公交车在上面循环行驶。例如，有一条路线 $routes[0] = [1, 5, 7]$，表示第一辆（下标为 $0$）公交车会一直按照 $1 \to 5 \to 7 \to 1 \to 5 \to 7 \to 1 \to \ldots$ 的车站路线行驶。</p><p>假设我们从 $S$ 车站开始（初始时不在公交车上），要去往 $T$ 站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回 $-1$ 表示不可能到达终点车站。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6输出：2解释：最优策略是先乘坐第一辆公交车到达车站 7, 然后换乘第二辆公交车到车站 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$1 \le routes.length \le 500$.</li><li>$1 \le routes[i].length \le 500$.</li><li>$0 \le routes[i][j] &lt; 10 ^ 6$.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们可以将每一条线路视作一个点，对于任意两条线路，如果它们经过的车站有交集，那么就在两点之间连一条边，这样就构成了一张图。</p><p>图中有些点（路线）是包含起点 $S$ 的，我们把它们都作为起点。而有些点（路线）是包含终点 $T$ 的，我们把它们都作为终点。</p><p>那么问题就转化为了求起点到终点的最短路径。因为起点和终点数量可能有多个，所以我们新建两个结点，一个起点用来指向所有包含 $S$ 的点，一个终点用来指向所有包含 $T$ 的点。接下来问题就变成了单源最短路径问题了。</p><p>因为本题中边并没有权值（或者说都是 $1$），那么我们就可以直接用 BFS 来进行求解最短路。</p><p>建图的时候，对于任意两条路线，我们要判断它们车站是否存在交集。可以事先对每条线路的车站编号进行排序，然后用双指针法判断。最好排完序还要去重，防止数据有重复。不过实际运行中，就算不排序也能通过，说明数据给的就是有序的了。</p><p>最终时间复杂度由几部分决定。假设路线数量是 $N$，每条路线最多有 $M$ 个车站。那么排序复杂度为 $O(NM \log M)$，建图复杂度为 $O(N^2M)$，BFS 复杂度为 $O(N^2)$。因此总的时间复杂度忽略低阶项之后为 $O(N^2M)$。看起来貌似还是有点高，但其实建图的时候，大多数情况下双指针法并不会遍历完所有的车站，所以达不到 $O(M)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numBusesToDestination</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> routes<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>S <span class="token operator">==</span> T<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> routes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">sort</span><span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        routes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>S<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        routes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>T<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> G <span class="token operator">=</span> <span class="token function">buildGraph</span><span class="token punctuation">(</span>routes<span class="token punctuation">,</span> S<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">BFS</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">buildGraph</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> routes<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> routes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">G</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> su <span class="token operator">=</span> routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sv <span class="token operator">=</span> routes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>u <span class="token operator">&lt;</span> su <span class="token operator">&amp;&amp;</span> v <span class="token operator">&lt;</span> sv<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> routes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>u<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> routes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>v<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">{</span>                        G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                        G<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> G<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">BFS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> S <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> T <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dis</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>        dis<span class="token punctuation">[</span>S<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> v <span class="token operator">=</span> G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                    dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> T<span class="token punctuation">)</span> <span class="token keyword">return</span> dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【每日算法Day 61】LeetCode 672. 灯泡开关 Ⅱ</title>
      <link href="/2020/03/06/leetcode-672/"/>
      <url>/2020/03/06/leetcode-672/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一个房间，墙上挂有 $n$ 只已经打开的灯泡和 $4$ 个按钮。在进行了 $m$ 次未知操作后，你需要返回这 $n$ 只灯泡可能有多少种不同的状态。</p><p>假设这 $n$ 只灯泡被编号为 $[1, 2, 3 …, n]$，这 $4$ 个按钮的功能如下：</p><ul><li>将所有灯泡的状态反转（即开变为关，关变为开）</li><li>将编号为偶数的灯泡的状态反转</li><li>将编号为奇数的灯泡的状态反转</li><li>将编号为 $3k+1$ 的灯泡的状态反转（$k = 0, 1, 2, \ldots$)</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 1, m = 1.输出：2解释：状态为: [开], [关]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 2, m = 1.输出：3解释：状态为: [开, 关], [关, 开], [关, 关]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：n = 3, m = 1.输出：4解释：状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$n$ 和 $m$ 都属于 $[0, 1000]$.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们要知道，<strong>一个操作做两次就等于没做</strong>，所以一个操作只有<strong>没做</strong>和<strong>做了</strong>两种状态，也就是说有效操作数量最多 $4$ 次：$m = \min{\{m, 4\}}$。</p><p>然后我们观察每一个操作对灯状态（初始都开着，状态都为 $1$）的影响：</p><ul><li>操作 $1$ 每 $1$ 个灯状态就要反转一次，也就是灯的状态按照周期 $1$ 重复（与 $(1,\ldots)$ 异或）。</li><li>操作 $2$ 每 $2$ 个灯状态就要反转一次，也就是灯的状态按照周期 $2$ 重复（与 $(0,1,\ldots)$ 异或）。</li><li>操作 $3$ 每 $2$ 个灯状态就要反转一次，也就是灯的状态按照周期 $2$ 重复（与 $(1,0,\ldots)$ 异或）。</li><li>操作 $4$ 每 $3$ 个灯状态就要反转一次，也就是灯的状态按照周期 $3$ 重复（与 $(1,0,0,\ldots)$ 异或）。</li></ul><p>综上，我们只需要取周期的最小公倍数 $6$ 就行了。也就是<strong>只需要看前 $6$ 盏灯的最终状态，就能唯一确定后面所有灯的最终状态</strong>。</p><p>形式化表示，用 $a_i = \{0, 1\}$ 表示第 $i$ 个操作是否用过。那么对于第 $i$ 盏灯来说，它的最终状态可以表示为：<br>$$<br>s_i = 1 \oplus a_1 \oplus a_2 [i \% 2 = 0] \oplus a_3 [i \% 2 = 1] \oplus a_4 [i \% 3 = 1]<br>$$<br>由此可以推出： $s_i = s_{i+6}$，也就是灯的最终状态以 $6$ 为周期。</p><p>到此其实可以直接暴力枚举 $1 \le n \le 6, 1 \le m \le 4$ 的所有状态了，但是还是有优化空间的。</p><p>如果我们列出前 $6$ 盏灯的状态：</p><ul><li>$s_1 = 1 \oplus a_1 \oplus a_3 \oplus a_4$</li><li>$s_2 = 1 \oplus a_1 \oplus a_2$</li><li>$s_3 = 1 \oplus a_1 \oplus a_3$</li><li>$s_4 = 1 \oplus a_1 \oplus a_2 \oplus a_4$</li><li>$s_5 = 1 \oplus a_1 \oplus a_3$</li><li>$s_6 = 1 \oplus a_1 \oplus a_2$</li></ul><p>我们可以看出，<strong>如果前 $3$ 盏灯状态确定了，可以唯一确定出后 $3$ 盏灯状态</strong>。因此，我们只需要计算前 $3$ 盏灯有多少种状态就行了。</p><p>最终经过枚举计算（$1 \le n \le 3, 0 \le m \le 4$）：</p><ul><li>如果 $m = 0$ ，那么就只有 $1$ 种状态（灯都开着）。</li><li>否则如果 $n = 1$ ，那么有 $2$ 种状态。</li><li>否则如果 $n = 2$ ，若 $m = 1$，就有 $3$ 种状态；若 $m \ge 2$ ，就有 $4$ 种状态。</li><li>否则如果 $n \ge 3$ ，若 $m = 1$，就有 $4$ 种状态；若 $m = 2$ ，就有 $7$ 种状态；若 $m \ge 3$ ，就有 $8$ 种状态。</li></ul><p>如果你实在不想手动计算，那你可以枚举所有的 $16$ 种操作状态，然后保存前三盏灯的状态到一个集合中，最终输出集合大小就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">flipLights</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipLights</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span>        m <span class="token operator">=</span> min<span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python（枚举）"><a href="#python（枚举）" class="headerlink" title="python（枚举）"></a>python（枚举）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">flipLights</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>        seen <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> cand <span class="token keyword">in</span> itertools<span class="token punctuation">.</span>product<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repeat <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> sum<span class="token punctuation">(</span>cand<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> m <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">and</span> sum<span class="token punctuation">(</span>cand<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>                A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>min<span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    light <span class="token operator">=</span> <span class="token number">1</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">2</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span>                    light <span class="token operator">^</span><span class="token operator">=</span> cand<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span>                    A<span class="token punctuation">.</span>append<span class="token punctuation">(</span>light<span class="token punctuation">)</span>                seen<span class="token punctuation">.</span>add<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>seen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 319】灯泡开关</title>
      <link href="/2020/03/05/leetcode-319/"/>
      <url>/2020/03/05/leetcode-319/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>初始时有 $n$ 个灯泡关闭。 第 $1$ 轮，你打开所有的灯泡。 第 $2$ 轮，每两个灯泡你关闭一次。 第 $3$ 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 $i$ 轮，每 $i$ 个灯泡切换一次开关。 对于第 $n$ 轮，你只切换最后一个灯泡的开关。 找出 $n$ 轮后有多少个亮着的灯泡。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：3输出：1解释：初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先有 $n$ 个灯泡，假设编号为 $1$ 到 $n$ 。第 $1$ 轮，所有编号是 $1$ 的倍数的灯泡被开关了一次。第 $2$ 轮，所有编号是 $2$ 的倍数的灯泡被开关了一次。类推下去，第 $i$ 轮，所有编号是 $i$ 的倍数的灯泡被开关了一次。</p><p>综上，对于编号为 $i$ 的灯泡来说，它最终被开关的次数取决于 $i$ 有几个因数。如果有奇数个因数，那么它最后就是开着的，否则就是关着的。</p><p>那么我们有一个定理：<strong>如果一个正整数有奇数个因数，那么它一定是完全平方数</strong>。</p><p>最浅显的证明就是，一个数 $i$ 的因数按照从小到大排个序，首尾两两一对之积一定等于 $i$ 。而如果因数只有奇数个，最中间一个因数 $x$ 只会出现一次，那么 $i = x^2$ 。</p><p>严格证明也不难，首先将 $i$ 质因数分解为：<br>$$<br>i = p_1^{c_1}p_2^{c_2}\cdots p_k^{c_k}<br>$$<br>那么 $i$ 的因数个数就是：<br>$$<br>(c_1+1)(c_2+1)\cdots (c_k+1)<br>$$<br>因为 $i$ 的因数个数是奇数，所以任意 $c_j + 1$ 必定是奇数，即任意 $c_j$ 必定是偶数。</p><p>那么 $i$ 就可以写作：<br>$$<br>i = (p_1^{c_1/2}p_2^{c_2/2}\cdots p_k^{c_k/2})^2<br>$$<br>这就证明了 $i$ 一定是一个完全平方数。</p><p>所以问题就转化为了<strong>求 $1$ 到 $n$ 之间有多少个完全平方数</strong>。答案就是 $\left\lfloor\sqrt{n}\right\rfloor$ 。</p><p>在具体实现的时候，为了防止出现浮点数误差（比如 $\sqrt{9}$ 算出来是 $2.9999$ ，取整得到 $2$），我们可以计算 $\left\lfloor\sqrt{n+0.5}\right\rfloor$ 的结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">bulbSwitch</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1363】形成三的最大倍数</title>
      <link href="/2020/03/04/leetcode-1363/"/>
      <url>/2020/03/04/leetcode-1363/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 digits，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。</p><p>由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。</p><p>如果无法得到答案，请返回一个空字符串。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [8,1,9]输出："981"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [8,6,7,1,0]输出："8760"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [1]输出：""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：digits = [0,0,0,0,0,0]输出："0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= digits.length &lt;= 10^4</li><li>0 &lt;= digits[i] &lt;= 9</li><li>返回的结果不应包含不必要的前导零。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要知道一个小学生都知道的定理：<strong>如果一个数可以被 $3$ 整除，那么它的每一位上的数之和也可以被 $3$ 整除，反之也成立。</strong></p><p>那么问题就转化为了挑选出最多的数，使得和是 $3$ 的倍数。我们可以先求出所有数之和，记为 $sum$ ，然后有如下三种情况：</p><ul><li>如果 $sum \% 3 = 0$ ，那么所有数都选中就行了。</li><li>如果 $sum \% 3 = 1$ ，那么必须删掉一个模 $3$ 余 $1$ 的数（按照从小到大顺序删除 1、4、7）。如果这三个数都没有，那就要删除两个模 $3$ 余 $2$ 的数（按照从小到大顺序删除 2、5、8，删除两次）。</li><li>如果 $sum \% 3 = 2$ ，那么必须删掉一个模 $3$ 余 $2$ 的数（按照从小到大顺序删除 2、5、8）。如果这三个数都没有，那就要删除两个模 $3$ 余 $1$ 的数（按照从小到大顺序删除 1、4、7，删除两次）。</li></ul><p>最终将剩下的数按照从小到大顺序排序，拼接在一起就行了。</p><p>注意如果有前导 $0$ ，就说明答案就是 $0$ 。</p><p>时间复杂度为 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">del</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cnt<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">==</span> q <span class="token operator">&amp;&amp;</span> cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">--</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string <span class="token function">largestMultipleOfThree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            sum <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">&amp;&amp;</span> <span class="token function">del</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> q<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">del</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">-</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">del</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">-</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">+</span><span class="token operator">=</span> i<span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"0"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 128】最长连续序列</title>
      <link href="/2020/03/03/leetcode-128/"/>
      <url>/2020/03/03/leetcode-128/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 $O(n)$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[100, 4, 200, 1, 3, 2]输出：4解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>因为题目要求 $O(n)$ 的时间复杂度，所以不能排序。</p><p>我们可以遍历每个数 $x$，假设它是某个连续序列的开头，那么首先要满足 $x-1$ 不在数组中，然后从 $x+1$ 开始逐渐增大，看最大多少还在数组里。</p><p>实现上查询数字在不在数组里可以采用哈希表，复杂度是 $O(1)$ 的。虽然看起来遍历每个数是 $O(n)$ ，以它为开头逐渐增大又是 $O(n)$ ，但是我们其实只会对开头的数遍历最大能达到多少。这样两层循环总的遍历次数其实还是 $O(n)$ 的。</p><p>总的时间复杂度就是 $O(n)$ 。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>我们可以把任意两个相差为 $1$ 的数之间连上边，那么数组就变成了若干个子树，我们只需要求结点数量最多的那个子树就行了。</p><p>用并查集可以实现连接两个连续序列，合并成一个连续序列，并且快速查询这个序列长度是多少。</p><p>首先初始的时候，数组中的每个数都自成一个子树（它自己就是根结点）。然后遍历每一个数 $x$ ，如果 $x+1$ 也在数组中，那就合并这两个数所在的子树，并且统计合并后的子树大小。</p><p>总的时间复杂度也是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="哈希表（c-）"><a href="#哈希表（c-）" class="headerlink" title="哈希表（c++）"></a>哈希表（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">++</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> y<span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并查集（c-）"><a href="#并查集（c-）" class="headerlink" title="并查集（c++）"></a>并查集（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> fa<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">==</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        y <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>        cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> cnt<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>            cnt<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fa<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">merge</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析【EMNLP19】多粒度自注意力机制（MG-SA）</title>
      <link href="/2020/03/02/emnlp19-mgsa/"/>
      <url>/2020/03/02/emnlp19-mgsa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="http://arxiv.org/abs/1909.02222" title="Multi-Granularity Self-Attention for Neural Machine Translation" target="_blank" rel="noopener">Multi-Granularity Self-Attention for Neural Machine Translation</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在主流的机器翻译模型基本都是采用多头注意力机制来对句子进行编码解码，但是有一些研究表明，这么多 head 其实并不是都有用的，有些 head 的信息是冗余的，所以本文就想充分利用一下这些冗余的 head 。</p><p>此外，统计机器翻译的研究也表明了，对短语的翻译效果可能要好于对单个单词的翻译，所以本文将一些 head 用来建模短语（比如 2-gram 或者 3-gram）。</p><p>最后本文在两个翻译任务（WMT14 英译德和 NIST 中译英）上做了实验，效果都要好于普通的 Transformer ，但是运行速度上慢了许多。</p><h2 id="多粒度自注意力机制（MG-SA）"><a href="#多粒度自注意力机制（MG-SA）" class="headerlink" title="多粒度自注意力机制（MG-SA）"></a>多粒度自注意力机制（MG-SA）</h2><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>首先将单词级别的输入 $H = h_1, \ldots, h_n \in \mathbb{R}^{n \times d}$ 映射为短语级别的表示 $H_g \in \mathbb{R}^{p \times d_g}$：<br>$$<br>H_g = F_h(H)<br>$$<br>其中 $F_h$ 是第 $h$ 个 head 对应的映射函数，针对不同的短语粒度有不同的映射函数。而 $p$ 是短语的个数，不同粒度个数也是不同的。</p><p>然后对于第 $h$ 个 head 来说，将 $H, H_g, H_g$ 分别做线性变换，得到自注意力机制的 query、key 和 value：<br>$$<br>Q^h, K^h, V^h = HW^h_Q, H_gW^h_K, H_gW^h_V<br>$$<br>这样三种向量都被映射到了相同的维度：$Q_h \in \mathbb{R}^{n \times d_h}, K_h \in \mathbb{R}^{p \times d_h}, V_h \in \mathbb{R}^{p \times d_h}$ 。</p><p>接着做 self-attention 得到每个单词的输出：<br>$$<br>O^h = \text{ATT}(Q^h, K^h)V^h<br>$$<br>最后将 $N$ 个 head 输出拼接起来得到了最后的输出：<br>$$<br>\text{MG-SA}(H) = [O^1, \ldots, O^N]<br>$$</p><h3 id="短语划分"><a href="#短语划分" class="headerlink" title="短语划分"></a>短语划分</h3><p>短语划分有两种方式，一种是 n-gram ，一种是根据句法树划分。n-gram 划分方式就是将句子 $x$ 等分为 $M$ 个短语得到 $P_x = (p_1, \ldots. p_M)$ 。而句法树划分就是按照句法树的不同层次得到不同粒度的短语，如下图所示：<br><img src="1.png" alt><br>绿色框是第一层，有 2 个短语，粒度比较大。红色框是第二层，有 4 个短语，粒度小一点。</p><h3 id="短语组合"><a href="#短语组合" class="headerlink" title="短语组合"></a>短语组合</h3><p>每个短语 $p_m$ 的表示可以用不同的网络来得到：<br>$$<br>g_m = \text{COM}(p_m)<br>$$<br>这里 $\text{COM}$ 函数可以用 CNN、LSTM 或者自注意力网络（SAN）。</p><p>最后所有短语的表示记为 $G_x = (g_1, \ldots, g_M)$ 。</p><h3 id="短语交互"><a href="#短语交互" class="headerlink" title="短语交互"></a>短语交互</h3><p>这些短语之间也像单词一样做一下上下文表示，效果可能会更好：<br>$$<br>H_g = \text{REC}(G_x)<br>$$<br>这里 $\text{REC}$ 可以选择 LSTM 或者编码结构能力好的 <a href="http://arxiv.org/abs/1810.09536" title="Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks" target="_blank" rel="noopener">ON-LSTM</a> 。</p><p>最后如下图所示，通过<strong>短语划分</strong>、<strong>短语组合</strong>、<strong>短语交互</strong>，模型得到了不同粒度的各个短语表示：<br><img src="2.png" alt></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>这里添加了一个辅助任务用来增强效果：短语标签预测。也就是对于 $G_x = (g_1, \ldots, g_M)$ 而言，在句法树中对应着 $M$ 个短语标签 $T_x = (t_1, \ldots, t_M)$ 。然后用一个线性变换接 softmax 来预测标签的概率：<br>$$<br>p = softmax(W_t g_i + b_t)<br>$$<br>最后标签预测的损失函数就是：<br>$$<br>\mathcal{L}_{tag} = -\sum_{i=1}^M{t_i \log p(t_i)}<br>$$</p><p>最终的损失函数还得再加上机器翻译的损失：<br>$$<br>\mathcal{L} = -\sum_{i=1}^L{y_i \log P(y_i)} + \lambda \mathcal{L}_{tag}<br>$$<br>这里的 $y_i$ 就是机器翻译的输出单词，$\lambda$ 在实验中设置为了 $0.001$。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>模型是在 Transformer 基础上修改的，把四分之一的 head 还用来做单词级别的 self-attention 。对于 n-gram 划分来说，四分之三的 head 分别用来做 2-gram、3-gram 和 4-gram 短语的 self-attention 。对于句法树短语划分来说，四分之三的 head 正好对应了最高的三层短语的 self-attention 。</p><p>实验主要得出了三点结论，如果不想看细节的，可以只看结论了：</p><ul><li>融入了 MG-SA 的 Transformer 的确提高了机器翻译的 BLUE 得分。</li><li>MG-SA 确实可以促进目标短语的生成。</li><li>MG-SA 确实可以捕捉到不同粒度的短语信息。</li></ul><h3 id="不同短语组合策略"><a href="#不同短语组合策略" class="headerlink" title="不同短语组合策略"></a>不同短语组合策略</h3><p><img src="3.jpg" alt><br>可以看出三种策略效果都比普通的 Transformer 好，SAN 的效果最好，所以后面实验都用 SAN 。</p><h3 id="不同-encoder-层"><a href="#不同-encoder-层" class="headerlink" title="不同 encoder 层"></a>不同 encoder 层</h3><p><img src="4.jpg" alt><br>MG-SA 用的层数越低效果越好，只用在最低层上效果最好（可能是因为直接和单词表示接触，对短语建模更有利），所以后面实验都只用到最低层上。</p><h3 id="短语划分、标签监督和短语交互策略影响"><a href="#短语划分、标签监督和短语交互策略影响" class="headerlink" title="短语划分、标签监督和短语交互策略影响"></a>短语划分、标签监督和短语交互策略影响</h3><p><img src="5.jpg" alt><br>这个也不用过多解释，说明了句法树划分短语比 n-gram 划分短语效果好，短语标签预测辅助任务确实有用，用 ON-LSTM 融合短语确实要更好。</p><h3 id="输出-n-gram-性能提升"><a href="#输出-n-gram-性能提升" class="headerlink" title="输出 n-gram 性能提升"></a>输出 n-gram 性能提升</h3><p><img src="6.jpg" alt><br>通过对翻译结果的 n-gram 的 BLEU 得分进行分析，可以看出几种 MG-SA 的变体效果都是好于普通的 Transformer 的，说明了确实可以促进目标短语的生成。</p><h3 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h3><p><img src="7.jpg" alt><br>无论是 Transformer 的 base 还是 large 版本，加上 MG-SA 之后效果都有较大提升，base 版本加上去之后效果甚至逼近了 large 版本，同时参数量并没有多太多。</p><h3 id="attention-可视化"><a href="#attention-可视化" class="headerlink" title="attention 可视化"></a>attention 可视化</h3><p><img src="8.jpg" alt><br>可以看出，普通的 Transformer（左边）每个词主要聚焦于前后一个词和句子结束标记，而 MG-SA 则大多聚焦于句子的关键词“三峡工程”和“首要任务”。</p><h3 id="多粒度标签预测任务"><a href="#多粒度标签预测任务" class="headerlink" title="多粒度标签预测任务"></a>多粒度标签预测任务</h3><p><img src="9.jpg" alt><br>做了 5 个探测任务：Voice（主动被动）、Tense（时态）、TSS（根结点下层标签序列预测）、SPC（单词的最小包含短语标签）和 POS（词性标注）。</p><p>模型就是在 MG-SA 的 encoder 上面接了一个 MLP ，然后做分类。encoder 分为两种，一种是固定参数，用 NMT 训练好的 encoder ，一种是重新训练 encoder 。</p><p>主要得到以下几点结论：</p><ul><li>重新训练 encoder 结果比直接用 NMT 的 encoder 效果提升大（除了 SPC 和 POS）。</li><li>用句法树划分短语效果比 n-gram 划分短语效果好。</li><li>用 NMT 的 encoder 时，只有 SPC 和 POS 效果提升大（主要这两个任务粒度小，都是单词级别的，任务很简单）。</li><li>重新训练 encoder 时前三个任务有提升（因为粒度比较大，而后两个仅靠 MLP 就能学的很好了）。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文提出了一种多粒度的自注意力机制，将其加入到了 Transformer 的 encoder 中。不仅仅是机器翻译任务，其他许多任务例如阅读理解、语言推理、情感分类等都可以用上这种方法，更好的融入短语结构信息。</p><p>其实这篇和 <a href="http://arxiv.org/abs/1909.06639" title="Tree Transformer: Integrating Tree Structures into Self-Attention" target="_blank" rel="noopener">Tree Transformer: Integrating Tree Structures into Self-Attention</a> 挺类似的，都是在 Transformer 的 self-attention 上面做了手脚，加入了一些结构上的信息，增强 encoder 的编码能力。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 329】矩阵中的最长递增路径</title>
      <link href="/2020/03/02/leetcode-329/"/>
      <url>/2020/03/02/leetcode-329/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [  [9,9,4],  [6,6,8],  [2,1,1]]输出：4解释：最长递增路径为 [1, 2, 6, 9]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [  [3,4,5],  [3,2,6],  [2,2,1]]输出：4解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="DFS-记忆化搜索"><a href="#DFS-记忆化搜索" class="headerlink" title="DFS+记忆化搜索"></a>DFS+记忆化搜索</h3><p>对于点 $[x, y]$ 来说，以它为终点的最长递增路径一定会经过上下左右四个点其一。所以如果它四周的点小于 $[x, y]$ ，就递归遍历四周的点，然后以 $[x, y]$ 为终点的最长递增路径长度就是以四周小于它的点为终点的最长递增路径长度加 $1$ ：<br>$$<br>dfs(x, y) = \max{\{dfs(x-1, y), dfs(x+1, y), dfs(x, y-1), dfs(x, y+1)\}} + 1<br>$$<br>注意这里四周的点首先不能超过边界，然后数值上必须小于 $[x, y]$ 。</p><p>但是直接这样会有很多重复计算，所以我们必须用记忆化搜索，用 $dp[x][y]$ 保存搜索结果。如果发现已经计算过了，就不再递归，直接返回结果。</p><p>最终每个格子最多遍历一遍，时间复杂度是 $O(nm)$ 。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>把每个格子当作一个点，然后从数值小的点向四周比它大的点连一条有向边，最终一定会形成一个有向无环图，问题就转变成了求有向无环图中的最长路径。</p><p>方法是先找到所有入度为 $0$ 的结点，然后放入一个队列，依次从队列里取出结点，从图中删除这些结点。然后图中就出现了新的入度为 $0$ 的结点了，它们路径长度加 $1$ 。接着重复上面的操作，直到最后没有结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="DFS-记忆化搜索（c-）"><a href="#DFS-记忆化搜索（c-）" class="headerlink" title="DFS+记忆化搜索（c++）"></a>DFS+记忆化搜索（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">longestIncreasingPath</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> dp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="拓扑排序（c-）"><a href="#拓扑排序（c-）" class="headerlink" title="拓扑排序（c++）"></a>拓扑排序（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">longestIncreasingPath</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">degree</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> Q<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> nx <span class="token operator">=</span> i <span class="token operator">+</span> dx<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> j <span class="token operator">+</span> dy<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>degree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span> j<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">,</span> y <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">></span> matrix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">--</span>degree<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    dp<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【kentln供题】模糊的数字</title>
      <link href="/2020/03/01/kentln-0/"/>
      <url>/2020/03/01/kentln-0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>感谢 <strong>kentln</strong> 供题，题目的出处已经不记得了，只能凭印象描述一下题意。</p></blockquote><p>大致意思就是给你一个字符串 $s$ ，表示一个正整数，但是有些位已经模糊了（用 $x$ 表示）。现在知道它一定能被 $n$ 整除，求 $s$ 表示的正整数一共有多少种可能？注意，不允许出现前导 $0$ 。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：8x4171x 5输出：20解释：第一个 x 可以取 0 到 9 一共 10 个数，第二个 x 只能取 0 或者 5 ，所以一共有 10 * 2 = 20 种可能。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：x9953xx 1输出：900解释：第一个 x 可以取 1 到 9 一共 9 个数，后面两个 x 随便取，所以一共有 9 * 10 * 10 = 900 种可能。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$6 \le s.length \le 9$</li><li>$1 \le n \le 100$</li><li>输入数据可能不止一组，请输入到文件结束为止</li><li>数据组数 $T = 10000$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题最暴力的方法就是枚举所有的数，然后判断每个数是否是 $n$ 倍数就行了，时间复杂度是 $O(10^{s.length} \cdot T)$ ，最大可以达到 $10^{13}$ 级别，无法接受！</p><p>那么我们从 $s$ 的最低位（也就是第 0 位）开始考虑，假设当前已经考虑到了第 $i$ 位。我们用数组 $c[k]$ 表示前面 $i-1$ 位表示的所有数字中余数为 $k$ 可能有几种，初始的时候 $c[0] = 1$ ，其它都为 $0$ （因为一位都没有的话，就当作 $0$ 处理）。</p><p>如果第 $i$ 位不是 $x$ ，那就说明第 $i$ 位上面已经有数字了。否则的话可以取 $0$ 到 $9$ 之间任意数（如果 $x$ 在最高位，排除掉 $0$）。</p><p>假设第 $i$ 位取 $j$ ，那么第 $i$ 位上面的数字在整个数字中的大小就是 $j \cdot 10^i$ 。假设它对 $n$ 取模结果是 $q = (j \cdot 10^i) \% n$ ，那么对于前 $i-1$ 位来说，余数为 $k$ 的答案有 $c[k]$ 种。加上第 $i$ 位之后，余数变成了 $(q+k)\%n$ ，所以前 $i$ 位余数为 $(q+k)\%n$ 的答案要加上 $c[k]$ 。</p><p>最后整个 $s$ 的可能情况种数就是 $c[0]$ 。</p><p>时间复杂度为 $O(s.length \cdot 10 \cdot n \cdot T)$ ，极限情况下会达到 $9 \cdot 10^{7}$ 级别，还可以接受。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">c</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pow <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> lb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rb <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                lb <span class="token operator">=</span> rb <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lb <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">tc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> lb<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> rb<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">*</span> pow<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    tc<span class="token punctuation">[</span><span class="token punctuation">(</span>q<span class="token operator">+</span>k<span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> c<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            c <span class="token operator">=</span> tc<span class="token punctuation">;</span>            pow <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p>因为这题忘了出处了，所以评测的话得靠自己运行，然后和正确答案比较。</p><p>输入数据和标准输出在 <strong>公众号后台回复【kentln-0】</strong> 下载，步骤如下：</p><ul><li>首先在你的 c++ 程序 <code>main</code> 函数开头加上如下两句：<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>作用就是重定向输入输出，从 <code>in.txt</code> 读入数据，输出答案到 <code>out.txt</code> 中。</li><li>编译你的 c++ 程序 <code>g++ 代码文件名.cpp -o test</code> ，并运行 <code>./test</code> 。</li><li>然后比较你的输出和标准输出区别，采用命令 <code>comp ans.txt out.txt</code> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个函数解决【LeetCode 买卖股票的最佳时机】系列所有题目！</title>
      <link href="/2020/03/01/leetcode-btbss/"/>
      <url>/2020/03/01/leetcode-btbss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目和题解汇总"><a href="#题目和题解汇总" class="headerlink" title="题目和题解汇总"></a>题目和题解汇总</h2><p>之前介绍了【LeetCode 买卖股票的最佳时机】系列一共六道题目，这里把之前的题解还有题目链接汇总一下，方便大家查找。</p><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" title="LeetCode 121. 买卖股票的最佳时机" target="_blank" rel="noopener">LeetCode 121. 买卖股票的最佳时机</a><br><a href="https://zhuanlan.zhihu.com/p/108895299" title="每日算法系列【LeetCode 121】买卖股票的最佳时机" target="_blank" rel="noopener">每日算法系列【LeetCode 121】买卖股票的最佳时机</a></p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" title="LeetCode 122. 买卖股票的最佳时机 II" target="_blank" rel="noopener">LeetCode 122. 买卖股票的最佳时机 II</a><br><a href="https://zhuanlan.zhihu.com/p/108902700" title="每日算法系列【LeetCode 122】买卖股票的最佳时机 II" target="_blank" rel="noopener">每日算法系列【LeetCode 122】买卖股票的最佳时机 II</a></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" title="LeetCode 123. 买卖股票的最佳时机 III" target="_blank" rel="noopener">LeetCode 123. 买卖股票的最佳时机 III</a><br><a href="https://zhuanlan.zhihu.com/p/108908636" title="每日算法系列【LeetCode 123】买卖股票的最佳时机 III" target="_blank" rel="noopener">每日算法系列【LeetCode 123】买卖股票的最佳时机 III</a></p><h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" title="LeetCode 188. 买卖股票的最佳时机 IV" target="_blank" rel="noopener">LeetCode 188. 买卖股票的最佳时机 IV</a><br><a href="https://zhuanlan.zhihu.com/p/108925381" title="每日算法系列【LeetCode 188】买卖股票的最佳时机 IV" target="_blank" rel="noopener">每日算法系列【LeetCode 188】买卖股票的最佳时机 IV</a></p><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" title="LeetCode 714. 买卖股票的最佳时机含手续费" target="_blank" rel="noopener">LeetCode 714. 买卖股票的最佳时机含手续费</a><br><a href="https://zhuanlan.zhihu.com/p/108930022" title="每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费" target="_blank" rel="noopener">每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费</a></p><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" title="LeetCode 309. 买卖股票的最佳时机" target="_blank" rel="noopener">LeetCode 309. 最佳买卖股票时机含冷冻期</a><br><a href="https://zhuanlan.zhihu.com/p/108931927" title="每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期" target="_blank" rel="noopener">每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期</a></p><h2 id="通用解法"><a href="#通用解法" class="headerlink" title="通用解法"></a>通用解法</h2><p>上面六道题目中，前四题限制了买卖的次数，第五题加入了手续费，第六题加入了冻结时间。所以我们提出一般性的问题：</p><p><strong>给定每天的价格 $prices$，最大买卖次数 $k$，手续费 $fee$，冻结时间 $freeze$，求最大利润。</strong></p><p>观察前面六题的代码，我们可以在第四题基础上进行修改，这样代码量比较小。</p><p>首先是增加手续费，这个很简单，只需要在 $dp1$ 更新时减去一个手续费 $fee$ 就行了。</p><p>有点麻烦的是冻结时间。在第六题代码中，增加了一个维度用来保存每一只股票之前（包含）的最大利润，目的是为了获取相隔一个冻结时间之前的股票以前可以获得的最大利润。但是通用情况下不能这么保存，不然的话空间复杂度就变成了 $O(nk)$ ，极限情况下会爆掉。</p><p>解决方法就是，因为对于第 $i$ 只股票来说，只需要访问它与 $dp1[i-freeze-1]$ 之间的数值，那么我们只需要保存 $freeze + 1$ 大小的数组就行了。在访问的时候，采用取模的方法，来让数组滚动起来。</p><p>还有一些细节，比如如果 $k \ge n / 2$，那么问题就退化为了没有买卖次数限制，也就是第五题和第六题的情况。如果不这样处理的话，按照上面方法做，时间复杂度和空间复杂度都是 $O(nk)$ ，可能会吃不消。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        limit <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> k <span class="token operator">>=</span> n<span class="token operator">//</span><span class="token number">2</span> <span class="token keyword">else</span> <span class="token number">1</span>        k <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">if</span> k <span class="token operator">>=</span> n<span class="token operator">//</span><span class="token number">2</span> <span class="token keyword">else</span> k        dp0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp0<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span> <span class="token keyword">if</span> limit <span class="token keyword">else</span> j<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp1<span class="token punctuation">[</span>i<span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp0<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>fee<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>freeze<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第五题-1"><a href="#第五题-1" class="headerlink" title="第五题"></a>第五题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> fee<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> fee<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="第六题-1"><a href="#第六题-1" class="headerlink" title="第六题"></a>第六题</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>prices<span class="token punctuation">,</span> k<span class="token operator">=</span>len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> fee<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> freeze<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 309】最佳买卖股票时机含冷冻期</title>
      <link href="/2020/02/29/leetcode-309/"/>
      <url>/2020/02/29/leetcode-309/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,0,2]输出：3解释：对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第六题。</p><p>这题其实就是在系列题目第二题基础上加了个限制条件，也就是每次卖了之后，隔一天才能继续买。</p><p>模仿第五题，还是采用动态规划。令 $dp0[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是买）可以获得的最大利润， $dp1[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是卖）可以获得的最大利润。那么类似的有如下转移方程：<br>$$<br>\begin{aligned}<br>dp0[i] &amp;= \max{\left\{dp0[i-1], dp1[i-2] - price[i]\right\}} \\<br>dp1[i] &amp;= \max{\left\{dp1[i-1], dp0[i-1] + price[i]\right\}}<br>\end{aligned}<br>$$</p><p>初始情况就是 $dp0[0] = -price[0]$ 和 $dp1[0] = 0$ 。</p><p>和第二、五题区别就是 $dp0[i]$ 的转移方程中有个 $dp1[i-2]$ ，也就是得隔一项，去算前前一天之前（包含）的买卖最大利润。</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">:</span>                dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp0<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp1<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 714】买卖股票的最佳时机含手续费</title>
      <link href="/2020/02/28/leetcode-714/"/>
      <url>/2020/02/28/leetcode-714/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润:  在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第五题。</p><p>这题其实就是在系列题目第二题基础上加了个手续费，也就是无限次买卖股票，但是每次卖的时候都得交一笔手续费。</p><p>这时候就不能和第二题一样，每次连续上升子区间都买卖一次了，因为如果买卖一次都不够交手续费的话，就不能进行买卖。或者一段连续下降子区间的差值小于手续费，那么就得把这段下降子区间也包含进去，前后只卖买一次。</p><p>所以我们换个思路，还是沿用第四题的动态规划思路。令 $dp0[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是买）可以获得的最大利润， $dp1[i]$ 为第 $i$ 只股票之前（包含）买卖（最后一次操作是卖）可以获得的最大利润。那么类似的有如下转移方程：<br>$$<br>\begin{aligned}<br>dp0[i] &amp;= \max{\left\{dp0[i-1], dp1[i-1] - price[i]\right\}} \\<br>dp1[i] &amp;= \max{\left\{dp1[i-1], dp0[i-1] + price[i] - fee\right\}}<br>\end{aligned}<br>$$</p><p>初始情况就是 $dp0[0] = -price[0]$ 和 $dp1[0] = 0$ 。</p><p>此外这里还可以优化去掉一个维度，因为每个时刻状态只与前一个时刻有关。</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> fee<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        dp0<span class="token punctuation">,</span> dp1 <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp1 <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">,</span> dp0<span class="token operator">+</span>p<span class="token operator">-</span>fee<span class="token punctuation">)</span>            dp0 <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">,</span> dp1<span class="token operator">-</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> dp1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 188】买卖股票的最佳时机 IV</title>
      <link href="/2020/02/27/leetcode-188/"/>
      <url>/2020/02/27/leetcode-188/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[2,4,1], k = 2输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,6,5,0,3], k = 2输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第四题。</p><p>这题是最一般的情况了，也就是最多可以买卖 $k$ 次。那么我们采用动态规划来求解。</p><p>令 $dp0[i][j]$ 为第 $i$ 只股票之前（包含）买卖 $j$ 次（且最后一次操作为<strong>买入</strong>）可以获得的最大利润，$dp1[i][j]$ 为第 $i$ 只股票之前（包含）买卖 $j$ 次（且最后一次操作为<strong>卖出</strong>）可以获得的最大利润。</p><p>那么对于 $dp0[i][j]$ 来说，最后一次操作是买入，所以分为两种情况。</p><ul><li>一种是不买第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为买入）的最大利润：<br>$$dp0[i][j] = dp0[i-1][j]$$</li><li>一种是买第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j-1$ 次（且最后一次操作为卖出）的最大利润：<br>$$dp0[i][j] = dp1[i-1][j-1] - price[i]$$</li></ul><p>而对于 $dp1[i][j]$ 来说，最后一次操作是卖出，所以分为两种情况。</p><ul><li>一种是不卖第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为卖出）的最大利润：<br>$$dp1[i][j] = dp1[i-1][j]$$</li><li>一种是卖第 $i$ 只股票，那么最大利润就是前 $i-1$ 只股票买卖 $j$ 次（且最后一次操作为买入）的最大利润：<br>$$dp1[i][j] = dp0[i-1][j] + price[i]$$</li></ul><p>综上转移方程就是：<br>$$<br>\begin{aligned}<br>dp0[i][j] &amp;= \max{\left\{dp0[i-1][j], dp1[i-1][j-1] - price[i]\right\}} \\<br>dp1[i][j] &amp;= \max{\left\{dp1[i-1][j], dp0[i-1][j] + price[i]\right\}}<br>\end{aligned}<br>$$</p><p>初始情况就是 $n = 0$ 和 $k = 0$ 时，单独计算一下就行了。</p><p>此外本题还可以优化成一维数组，就不展开介绍了，大家可以参考代码。</p><p>时间复杂度是 $O(nk)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> k <span class="token operator">>=</span> n<span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> max<span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> res        dp0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> p <span class="token keyword">in</span> prices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>p<span class="token punctuation">)</span>                dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span>p<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp1<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 123】买卖股票的最佳时机 III</title>
      <link href="/2020/02/26/leetcode-123/"/>
      <url>/2020/02/26/leetcode-123/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,6,4,3,1]输出：0解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第三题。</p><p>本题中买卖次数变成了最多两次，那么我们可以照搬之前只能买卖一次的做法。首先如果我们假设第一只股票卖出去时价格是 $price[i]$ ，那么它之前的最优买入价格（也就是最低的价格）计算方法和第一题相同，只需要用一个变量存储就行了。而第二次买卖我们只需要知道 $price[i]$ 右边进行一次买卖最多能赚到多少钱就行了。这可以通过从右向左倒过来预处理处理，方法和第一题完全相同。</p><p>记第 $i$ 只股票左边（包含）买卖一次最大利润为 $left[i]$ ，右边（包含）买卖一次最大利润为 $right[i]$ ，那么最终的答案就是：<br>$$<br>\sum_{0 &lt; i &lt; n-2}{left[i] + right[i+1]}<br>$$</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        minn <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minn<span class="token punctuation">)</span>            minn <span class="token operator">=</span> min<span class="token punctuation">(</span>minn<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        maxx<span class="token punctuation">,</span> maxp<span class="token punctuation">,</span> res <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxp <span class="token operator">=</span> max<span class="token punctuation">(</span>maxp<span class="token punctuation">,</span> maxx<span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxx <span class="token operator">=</span> max<span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>maxp<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 122】买卖股票的最佳时机 II</title>
      <link href="/2020/02/25/leetcode-122/"/>
      <url>/2020/02/25/leetcode-122/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第二题。</p><p>这题买卖次数变成了不限，但是仍然要求在买之前必须先卖掉股票。那么观察股票的价格曲线，最优策略就是在每一段单调上升的子区间里，区间开始时购买，区间结束时卖出。这样就能保证所有的上升区间全部充分利用到了。正确性证明也不难，假设买卖过程中包含了一段下降的子区间，那么去掉它，在下降区间开头卖出，在下降区间末尾买入，得到的利润一定大于包含这段下降区间。</p><p>在具体实现时，我们可以计算相邻两个股票价格差，如果价格是上升的，那就在利润上加上它，否则就不用管。</p><p>最终的答案就是：<br>$$<br>\sum_{0 &lt; i &lt; n}{\max{\left\{price[i] - price[i-1], 0\right\}}}<br>$$</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> max<span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 121】买卖股票的最佳时机</title>
      <link href="/2020/02/24/leetcode-121/"/>
      <url>/2020/02/24/leetcode-121/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是 <strong>【买卖股票的最佳时机】</strong> 系列题目的第一题。</p><p>这道题目要求只能买卖一次股票。所以最佳策略一定是挑一个最低的价格买入，再挑一个最高的价格卖出。但是还有另一个限制条件，那就是你得先买，然后才能卖出去。</p><p>所以我们只需要枚举每个股票，把它当作卖出的那一只股票，然后只需要求出它之前价格最低的那一只股票就行了。价格最低的股票可以用一个变量来进行维护，然后枚举所有卖出的股票，减去它之前价格最低的那一只股票，然后和最优答案进行比较，最终就能得到最多能赚多少钱了。</p><p>最终答案就是：<br>$$<br>\max_{0 \le i &lt; n}{\left\{price[i] - \min_{0 \le j &lt; i}{\left\{price[j]\right\}}\right\}}<br>$$</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> prices<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>prices<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        minn<span class="token punctuation">,</span> res <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minn<span class="token punctuation">)</span>            minn <span class="token operator">=</span> min<span class="token punctuation">(</span>minn<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 面试题 17.05】字母与数字</title>
      <link href="/2020/02/22/leetcode-interview-17-05/"/>
      <url>/2020/02/22/leetcode-interview-17-05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。</p><p>返回该子数组，若不存在这样的数组，返回一个空数组。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]输出：["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["A","A"]输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>array.length &lt;= 100000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>回忆之前做过的一道题目：<a href="https://godweiyang.com/2020/02/02/leetcode-523/">每日算法系列【LeetCode 523】连续的子数组和</a>，是不是有点相似？那道题是要求是否含有总和为 $k$ 的整数倍的连续子数组。而本题要求的是最长的子数组，满足数字和字母个数相等。</p><p>我们可以把字母抽象成 $-1$ ，数字抽象成 $1$ ，那么子数组的总和含义就是数字个数与字母个数的差值。假设子数组 $[l, r]$ 是满足字母个数和数字个数相等的，那么这段子数组总和必然是 $0$ 。如果我们用前缀和来进行优化的话，$sum[r] - sum[l-1] = 0$ ，也就是说 $sum[r]$ 和 $sum[l-1]$ 的值是相等的。</p><p>所以我们只需要求一遍前缀和，如果 $sum[i]$ 没有在之前出现过，那就保存一下 $sum[i]$ 最开始出现的下标是 $i$ 。否则的话就看一下当前子数组长度 $i - sum[i]$ 和历史最优的长度 $r - l$ 谁大，然后决定更不更新。</p><p>实际实现中 c++ 还是可以采用 <code>unordered_map</code> 来当作哈希表保存下标。</p><p>时间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">findLongestSubarray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        mp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">isdigit</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">&lt;</span> i<span class="token operator">-</span>mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    l <span class="token operator">=</span> mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> array<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findLongestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> array<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        mp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span>        cnt<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> s <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token keyword">in</span> mp<span class="token punctuation">:</span>                <span class="token keyword">if</span> r<span class="token operator">-</span>l <span class="token operator">&lt;</span> i<span class="token operator">-</span>mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                    r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                mp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> array<span class="token punctuation">[</span>l<span class="token punctuation">:</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.2.4时GitHub超过15个粉丝就可以领取3000元啦！</title>
      <link href="/2020/02/22/hs-airdrop/"/>
      <url>/2020/02/22/hs-airdrop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了标题，你可能会觉得这又是个诈骗或者广告，但是这次确实是在送钱。白嫖一时爽，一直白嫖一直爽。</p><p>怎么回事呢，官网在这：<a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a>，原话是这么说的：</p><blockquote><p>The Handshake Organization raised money from top Silicon Valley investors including A16Z and Sequoia. They donated $10.2mm to GNU, Mozilla, and other internet foundations. Now they’re giving away ~4662 Handshake coins to qualifying developers on GitHub.</p></blockquote><p>翻译成中文，大致意思就是握手（handshake）组织筹集到了一笔资金，分给了好几个组织，还给 github 每个符合要求的用户捐了 4662 个握手币。握手币可以兑换成比特币，再换成人民币。具体多少呢？<strong>大概也就 0.05 个左右比特币，人民币三五千左右吧</strong>。</p><p>那么重点来了，要符合什么要求呢？要求如下，主要有两点：</p><ul><li>你的 github 账号在 2019 年 2 月 4 号那一周之前拥有 <strong>15 个及以上的粉丝</strong>。</li><li>你的 github 账号在 2019 年 2 月 4 号那一周之前创建过 <strong>SSH key</strong>，并且现在还保留着。</li></ul><p>如果你不知道是否符合要求，也不要紧，按照下面步骤做就是了，不符合会弹出提示的。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><blockquote><p>本人电脑系统 Windows 10 专业版 1909，Node.js 版本 10.16.0，npm 版本 6.13.7，其他环境操作大致相同，可能会有小问题，欢迎评论区留言。</p></blockquote><p>首先你电脑里需要 Node.js 和 python 2 的运行环境，安装地址在下面：</p><p><strong>Node.js：</strong><br><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><p><strong>python2：</strong><br><a href="https://www.anaconda.com/distribution/#download-section" target="_blank" rel="noopener">https://www.anaconda.com/distribution/#download-section</a></p><h2 id="下载-hs-airdrop"><a href="#下载-hs-airdrop" class="headerlink" title="下载 hs-airdrop"></a>下载 hs-airdrop</h2><p>运行下面命令：</p><pre><code>git clone https://github.com/handshake-org/hs-airdrop.git</code></pre><h2 id="安装-hs-airdrop-需要的依赖"><a href="#安装-hs-airdrop-需要的依赖" class="headerlink" title="安装 hs-airdrop 需要的依赖"></a>安装 hs-airdrop 需要的依赖</h2><pre><code>cd hs-airdrop &amp;&amp; npm install</code></pre><h2 id="找到你的-SSH-key-存放目录"><a href="#找到你的-SSH-key-存放目录" class="headerlink" title="找到你的 SSH key 存放目录"></a>找到你的 SSH key 存放目录</h2><p>如果你是 Linix ，存放目录一般是 <code>~/.ssh</code> 。如果你跟我一样是 Windows 10，存放目录一般是 <code>C:\Users\你的用户名\.ssh</code> 。</p><p>然后在目录下找到你的 SSH key 文件，注意一定要是符合要求（2019 年 2 月 4 号之前）的那个。例如我的文件路径是 <code>C:\Users\godweiyang\.ssh\id_rsa</code> 。</p><h2 id="生成你的握手币钱包地址"><a href="#生成你的握手币钱包地址" class="headerlink" title="生成你的握手币钱包地址"></a>生成你的握手币钱包地址</h2><p>打开 <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a>，跳转到第 4 步，点击 <code>Click To Show Your Handshake Wallet Address</code> ，然后就会生成出一串如下字符，就是你的钱包地址：</p><p><img src="1.jpg" alt></p><h2 id="生成加密证明"><a href="#生成加密证明" class="headerlink" title="生成加密证明"></a>生成加密证明</h2><p>直接运行如下命令：</p><pre><code>./bin/hs-airdrop &lt;path to key&gt; &lt;address&gt; &lt;fee&gt;</code></pre><p>其中 <code>&lt;path to key&gt;</code> 是刚刚 SSH key 文件路径，<code>&lt;address&gt;</code> 是上一步生成的钱包地址，<code>&lt;fee&gt;</code> 是手续费（单位是握手币），设为默认 0.01 就行了。</p><p>例如我的命令是：</p><pre><code>./bin/hs-airdrop C:\Users\godweiyang\.ssh\id_rsa hs1qxxxxxxxxxxx 0.01</code></pre><p>然后会让你输入 <code>Passphrase</code> ，一般都是空，直接回车就行了。</p><p>运行成功了之后界面是这样的：<br><img src="2.jpg" alt></p><p><strong>报错解决 1 ：</strong><br>如果你是 Windows，你可能会遇到 <code>TypeError: stdin.setRawMode is not a function</code> 错误，不用担心，只需要将命令修改为下面这样：</p><pre><code>node bin/hs-airdrop &lt;path to key&gt; &lt;address&gt; &lt;fee&gt;</code></pre><p>也就是前面加一个 <code>node</code> ，并且运行程序路径最前面去掉 <code>./</code> 就行了。</p><p><strong>报错解决 2 ：</strong><br>可能运行了三四分钟之后，会弹出 <code>Error: read ECONNRESET</code> 错误，这是因为要下载一个 github 仓库，太大了下不下来。</p><p>解决方法就是先下载 <a href="https://gitee.com/shidenggui/hs-tree-data" target="_blank" rel="noopener">https://gitee.com/shidenggui/hs-tree-data</a> 这个仓库内容，然后将仓库内容复制到 <code>C:\Users\你的用户名\.hs-tree-data</code> 目录下。这样运行的时候就不需要下载了，直接就能运行。</p><h2 id="复制-base64-代码"><a href="#复制-base64-代码" class="headerlink" title="复制 base64 代码"></a>复制 base64 代码</h2><p>等待三五分钟，如果成功了，你有资格，那么就会生成一串下面这样的 base64 代码：<br><img src="4.png" alt></p><p>将它复制到 <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a> 最后一步如下框框里（<strong>注意一定要去除 base64 代码中的换行符，让它只有一行！</strong>）：<br><img src="3.jpg" alt></p><h2 id="到账后提现"><a href="#到账后提现" class="headerlink" title="到账后提现"></a>到账后提现</h2><p>到账时间不好说，至少需要 16 个小时，至多你就等着吧，到账的是 HNS 币，也就是握手币。</p><p>然后打开 <a href="https://www.namebase.io/kyc/basic" target="_blank" rel="noopener">https://www.namebase.io/kyc/basic</a> 进行实名认证（不然没法转成比特币），提供身份证、驾照或者护照都可以。</p><p>打开 <a href="https://www.namebase.io/sell" target="_blank" rel="noopener">https://www.namebase.io/sell</a> 将握手币兑换成比特币。</p><p>具体比特币钱包地址如何获取、比特币怎么转换成人民币等操作就不介绍了，网上教程很多。</p><blockquote><p>笔者写这篇文章的时候还没到账，就不截图了，我先去等着了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 685】冗余连接 II</title>
      <link href="/2020/02/22/leetcode-685/"/>
      <url>/2020/02/22/leetcode-685/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着 $N$ 个节点（节点值不重复 $1, 2, …, N$）的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 $[u, v]$，用以表示有向图中连接顶点 $u$ 和 $v$ 和顶点的边，其中父节点 $u$ 是子节点 $v$ 的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有 $N$ 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [1,3], [2,3]]输出：[2,3]解释：  1 / \v   v2-->3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [2,3], [3,4], [4,1], [1,5]]输出：[4,1]解释：5 <- 1 -> 2     ^    |     |    v     4 <- 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>输入的二维数组大小在 $3$ 到 $1000$。</li><li>二维数组中的整数在 $1$ 到 $N$ 之间，其中 $N$ 是输入数组的大小。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题是上一道题<a href="https://zhuanlan.zhihu.com/p/108220276" target="_blank" rel="noopener">LeetCode 685. 冗余连接</a>的进阶版，区别就是无向图变成了有向图。</p><p>上一道题解说过，无向图能构成一棵树的条件是没有环，那么有向图的条件是什么呢？</p><p>首先还是得没有环，其次因为是边是有向的，所以一个结点只能有一个父结点（也就是入度为 $1$）。那么这题解法就有了。</p><ul><li>首先判断有没有入度为 $2$ 的结点，如果有的话，那两条边一定有一条得删掉。</li><li>按照出现时间从后到前看那两条边，删掉其中一条之后是否能构成一棵树（也就是无环）。如果删掉了无环，那就直接返回这条边作为答案。</li><li>如果入度全是 $1$ ，那就直接按照出现时间从前到后看添加了哪一条边之后开始出现了环，那么那条边就是答案。</li></ul><p>判断能否构成一棵树的话还是用并查集，唯一区别就是不需要用<strong>按秩合并</strong>的优化了，而且给定有向边 $[u, v]$，只能把 $v$ 接在 $u$ 下面。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> degree<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">=</span> edges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>degree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> degree<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token operator">++</span>degree<span class="token punctuation">[</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>degree<span class="token punctuation">[</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">wrongEdge</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">wrongEdge</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wrongEdge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> except<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> except<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">same</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> u<span class="token operator">==</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">?</span> u <span class="token operator">:</span> f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> edges<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>n <span class="token operator">=</span> len<span class="token punctuation">(</span>edges<span class="token punctuation">)</span>        degree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            degree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> edges<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> degree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>wrongEdge<span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>wrongEdge<span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrongEdge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> edges<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> u<span class="token punctuation">,</span> v <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">==</span> ex<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>same<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>join<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> u        self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">join</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> v<span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u    <span class="token keyword">def</span> <span class="token function">same</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 684】冗余连接</title>
      <link href="/2020/02/21/leetcode-684/"/>
      <url>/2020/02/21/leetcode-684/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着 $N$ 个节点（节点值不重复 $1, 2, …, N$）的树及一条附加的边构成。附加的边的两个顶点包含在 $1$ 到 $N$ 中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对 $[u, v]$ ，满足 $u &lt; v$，表示连接顶点 $u$ 和 $v$ 的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着 $N$ 个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 $[u, v]$ 应满足相同的格式 $u &lt; v$。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [1,3], [2,3]]输出：[2,3]解释：  1 / \2 - 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1,2], [2,3], [3,4], [1,4], [1,5]]输出：[1,4]解释：5 - 1 - 2    |   |    4 - 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>输入的二维数组大小在 $3$ 到 $1000$。</li><li>二维数组中的整数在 $1$ 到 $N$ 之间，其中 $N$ 是输入数组的大小。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先因为这是一个无向图，所以不需要考虑谁是树根。</p><p>那么我们一条条边加入到图里去，直到出现了环为止，那么这条边就是冲突的边，需要删除掉。</p><p>那么怎么判断是否出现了环呢？如果加入一条边 $[u, v]$ 的时候，两个结点所在的连通块不是同一个，那么一定没有环。否则的话，两个结点连在了同一棵子树上，那么一定会产生一个环。</p><p>如何高效的判断两个结点是否在同一棵子树上呢？这就需要用到一个数据结构——<strong>并查集</strong>。</p><p>并查集采用一个数组 $f[i]$ 来表示结点 $i$ 的父结点。那么初始的时候没有任何边，定义所有结点的父结点等于它自身： $f[i] = i$ 。</p><p>当加入一条边 $[u, v]$ 的时候，可以沿着 $u \to f[u] \to f[f[u]] \to \cdots$ 的路径递归找到 $u$ 所在子树的根结点 $ru$（$v$ 同理得到 $rv$），然后只需要判断两个根结点是否相同就行了。如果根结点相同，那么就产生环了，直接输出这个冲突边就行。否则的话就要把这两棵子树连到一起，最简单的做法就是直接把 $ru$ 连到 $rv$ 下面，当作它的子结点，那么就需要更新 $f[ru] = rv$ 。</p><p>下面讲两个常用的并查集优化。</p><p><strong>路径压缩：</strong><br>因为我们无需关注每一棵子树结构是什么样的，我们只关注它的根结点是谁。所以为了减小查找根结点的时间，每个结点离根结点要尽量近。</p><p>那么我们定义查找根结点函数 $find(u)$ ，如果 $u = f[u]$ ，那么不用找了，它自己就是根结点。否则的话调用 $find(f[u])$ 递归寻找子树的根结点。最后做一步路径压缩的优化，把根结点当作 $u$ 的父结点：$f[u] = find(f[u])$ 。这样下次再查找的时候，路径长度就变为了 $1$ ，一步就能找到根结点了。</p><p><strong>按秩合并：</strong><br>合并两棵子树的时候，为了使得合并后的子树高度尽量小，我们需要把高度小的那棵子树接在高度高的那棵下面，当作儿子。</p><p>所以我们定义一个 $rank[i]$ 数组，用来记录 $i$ 这个结点作为根结点的子树高度，初始时全都是 $1$ 。那么在合并的时候，把 $rank$ 值小的接到大的下面去，如果一样怎么办呢？随便接，然后把合并后的根结点 $rank$ 值加 $1$ 就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> rank<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findRedundantConnection</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v <span class="token operator">=</span> e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">same</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>u<span class="token punctuation">,</span> v<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> u<span class="token operator">==</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">?</span> u <span class="token operator">:</span> f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> v<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findRedundantConnection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> edges<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>edges<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>f <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>rank <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>same<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>u<span class="token punctuation">,</span> v<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>join<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> u        self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">join</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">if</span> u <span class="token operator">==</span> v<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>f<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u            <span class="token keyword">if</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>rank<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">same</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>        u<span class="token punctuation">,</span> v <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">return</span> u <span class="token operator">==</span> v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1006】笨阶乘</title>
      <link href="/2020/02/20/leetcode-1006/"/>
      <url>/2020/02/20/leetcode-1006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p><p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：<code>乘法(*)，除法(/)，加法(+)和减法(-)</code>。</p><p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（floor division），所以 <code>10 * 9 / 8</code> 等于 11。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：4输出：7解释：7 = 4 * 3 / 2 + 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：10输出：12解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$1 \le N \le 10000$</li><li>$-2^{31} \le answer \le 2^{31} - 1$  （答案保证符合 32 位整数。）</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>笨方法我就不写了，按照运算顺序模拟一遍，数量比较少的话，应该也不会超时。</p><p>这道题可以用简单的数学计算来优化一下，首先笨阶乘数学形式是下面这样的：<br>$$<br>clumsy(n) = \left\lfloor\frac{n(n-1)}{n-2}\right\rfloor + (n-3) - \left\lfloor\frac{(n-4)(n-5)}{n-6}\right\rfloor + \cdots<br>$$</p><p>好像看不出什么东西，那么我们先去掉取整符号看看：<br>$$<br>\left\lfloor\frac{n(n-1)}{n-2}\right\rfloor = \left\lfloor\frac{(n-2)(n-2)+3(n-2)+2}{n-2}\right\rfloor = \left\lfloor n+1+\frac{2}{n-2}\right\rfloor<br>$$</p><p>所以当 $n \ge 5$ 时，取整符号可以直接去掉：<br>$$<br>\left\lfloor\frac{n(n-1)}{n-2}\right\rfloor = n + 1<br>$$</p><p>所以我们就讨论 $n \ge 5$ 时的情况，笨函数可以写成：<br>$$<br>clumsy(n) = n+1 + n-3 - (n-3) + \cdots = n+1 + d(n)<br>$$</p><p>也就是第一个取整（$3$ 项）结果是 $n+1$ ，而后面每 $4$ 项结果是 0 ，最后还剩余不足 $4$ 项的结果 $d(n)$ 。</p><p>那么 $d(n)$ 的取值有 $4$ 种情况：</p><ul><li>$n \% 4 = 0$ ，也就是最后剩余 $1$ 项时，$d(n) = 1$ 。</li><li>$n \% 4 = 1$ ，也就是最后剩余 $2$ 项时，$d(n) = 2 - 1 = 1$ 。</li><li>$n \% 4 = 2$ ，也就是最后剩余 $3$ 项时，$d(n) = 3 - 2 \times 1 = 1$ 。</li><li>$n \% 4 = 3$ ，也就是最后剩余 $0$ 项时，$d(n) = 0$ 。</li></ul><p>但是考虑到取整函数只有在 $n \ge 5$ 时才等于 $n+1$ ，也就是最后剩余的项数大于 $2$ 时才行。那么上面的 $4$ 种情况的 $1、4$ 两种，就要特殊处理一下前一个取整结果：</p><ul><li>$n \% 4 = 0$ ，也就是最后剩余 $1$ 项时，$d(n) = 5 - 4 \times 3 / 2 + 1 = 0$ 。</li><li>$n \% 4 = 1$ ，也就是最后剩余 $2$ 项时，$d(n) = 2 - 1 = 1$ 。</li><li>$n \% 4 = 2$ ，也就是最后剩余 $3$ 项时，$d(n) = 3 - 2 \times 1 = 1$ 。</li><li>$n \% 4 = 3$ ，也就是最后剩余 $0$ 项时，$d(n) = 4 - 3 \times 2 / 1 = -2$ 。</li></ul><p>综上，$n &lt; 5$ 时的结果直接算出来就行了，$n \ge 5$ 时结果就是 $n+1+d(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">clumsy</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> q <span class="token operator">=</span> N <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> N<span class="token operator">>=</span><span class="token number">5</span> <span class="token operator">?</span> N<span class="token operator">+</span>d<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">:</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">clumsy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        q <span class="token operator">=</span> N <span class="token operator">&amp;</span> <span class="token number">3</span>        a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>        d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> N<span class="token operator">+</span>d<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token keyword">if</span> N<span class="token operator">>=</span><span class="token number">5</span> <span class="token keyword">else</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 287】寻找重复数</title>
      <link href="/2020/02/19/leetcode-287/"/>
      <url>/2020/02/19/leetcode-287/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含 $n + 1$ 个整数的数组 $nums$，其数字都在 $1$ 到 $n$ 之间（包括 $1$ 和 $n$），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>说明</strong></p><ul><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 $O(1)$ 的空间。</li><li>时间复杂度小于 $O(n^2)$ 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ul><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,3,4,2,2]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,3,4,2]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>根据抽屉原理，如果大小为 $m$ 的抽屉里放了大于 $m$ 个数，那么一定有一个抽屉里至少放了两个数。</p><p>那我们不妨统计一下数组中有多少个数满足 $1 \le nums[i] \le m$ ，数量记为 $cnt$ 。</p><p>如果 $cnt &gt; m$ ，那么根据抽屉原理，$1$ 到 $m$ 中一定有一个数出现了至少两次。</p><p>反之如果 $cnt \le m$ ，那么说明满足 $m+1 \le nums[i] \le n$ 的数的数量是 $n+1-cnt \ge n-m+1$ ，而抽屉大小是 $n-m$ ，所以根据抽屉原理，$m+1$ 到 $n$ 中一定有一个数出现了至少两次。</p><p>综上，可以采用二分法，不断缩小 $m$ 的范围，最终得到这个出现至少两次的数的值。</p><p>时间复杂度 $O(n \log n)$ 。</p><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>因为 $nums$ 中数据范围是 $1$ 到 $n$ ，所以 $nums[0] = x \neq 0$ 。那么接着用 $x$ 作为下标来索引值，得到 $nums[x] = y$ 。如果 $y$ 已经出现过了 ，那么重复值已经找到了。否则的话 $y$ 还没出现过的话，继续用 $y$ 作为下标来索引，直到出现重复值。</p><p>可以发现按照这种方法索引下去，形成了一个链，也就是 $0 \to x \to y \to \cdots$ 。最终这条链末端一定会产生出一个环，那么环的入口一定就是那个重复的数。</p><p>举个例子，如下图所示，最终环产生在了 $2 \to 4 \to 2$ 上面，而 $2$ 又是链进入环的入口，所以重复的数就是 $2$ 。</p><p><img src="1.png" alt></p><p>那么如何求<strong>链表中的环</strong>呢？这其实是一道面试经常会问到的经典题，标准解法就是用两个<strong>快慢指针</strong>。</p><p>初始时两个指针指着链表头结点，然后同时移动。慢指针一次移动一个结点，快指针一次移动两个结点。当下一次快指针又和慢指针相遇时，停止移动。然后用第三个指针指着头结点，慢指针留在原地，两者同时移动，都是一次移动一个结点，直到相遇。这时两者指着的结点就是环的入口了。</p><p>大家可以用上面的例子自己画图演示一下，我下面严格证明一下为什么这样是对的。</p><p>假设如下图所示，链表中链的长度是 $m$ ，环的长度是 $n$ 。</p><p><img src="4.jpg" alt></p><p>假设慢指针和快指针第一次相遇时，慢指针移动的距离是 $x$ ，那么快指针移动距离就是 $2x$ 。</p><p>可以列出等式 $2x - x = kn$ ，也就是两者距离差值一定是环长度的正整数 $k$ 倍，同时 $k$ 是使得 $x = kn \ge m$ 的最小正整数，即 $(k-1)n &lt; m \le kn$。这时候慢指针离入口的距离是 $n - (x - m) = m - (k - 1)n$ ，也就是说，慢指针只需要再多绕 $k-1$ 个环的长度，就能恰好和从头结点而来的指针相遇在入口处。</p><p>时间复杂度 $O(n)$ 。</p><p><strong>扩展：</strong>  </p><p>那有人可能会问了，那要是链最后回到了 $0$ ，不就没有链，只有环了吗？哪来的入口？这是对的，所以本题中限制了 $nums$ 数组里都是大于 $0$ 的，如果范围是 $0$ 到 $n-1$ 的话，不能直接用数值但下标索引了，不然会出现下面这种情况，也就是 $0$ 也在环里了。</p><p><img src="2.jpg" alt></p><p>其实这种情况我们只需要稍稍修改一下索引，让 $0$ 不可能出现在环里就行了，也就是让 $nums[i] + 1$ 当作索引，如下图所示。最终重复的数只需要减去 $1$ 就行了。</p><p><img src="3.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="二分法（c-）"><a href="#二分法（c-）" class="headerlink" title="二分法（c++）"></a>二分法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> m<span class="token punctuation">)</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快慢指针法（c-）"><a href="#快慢指针法（c-）" class="headerlink" title="快慢指针法（c++）"></a>快慢指针法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> find <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>find <span class="token operator">!=</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span><span class="token punctuation">;</span>            find <span class="token operator">=</span> nums<span class="token punctuation">[</span>find<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> find<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分法（python）"><a href="#二分法（python）" class="headerlink" title="二分法（python）"></a>二分法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            cnt <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token operator">&lt;=</span>m <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> cnt <span class="token operator">></span> m<span class="token punctuation">:</span>                r <span class="token operator">=</span> m            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快慢指针法（python）"><a href="#快慢指针法（python）" class="headerlink" title="快慢指针法（python）"></a>快慢指针法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> slow <span class="token operator">==</span> fast<span class="token punctuation">:</span>                <span class="token keyword">break</span>        find <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> find <span class="token operator">!=</span> slow<span class="token punctuation">:</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            find <span class="token operator">=</span> nums<span class="token punctuation">[</span>find<span class="token punctuation">]</span>        <span class="token keyword">return</span> find<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【EOJ 3031】二进制倒置</title>
      <link href="/2020/02/18/eoj-3031/"/>
      <url>/2020/02/18/eoj-3031/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 $n(0 \le n \le 10^{100})$ 、将 $n$ 的 334 位二进制表示形式（不包括开头可能的值为 0 的位，$n=0$ 表示为 1 位 0）前后倒置，输出倒置后的二进制数对应的整数。</p><p>例如： $n=10$ ，其二进制表示为（330 个 0）1010 ，倒置后为 0101 ，对应输出就是 5 。</p><p><strong>题目链接</strong><br><a href="https://acm.ecnu.edu.cn/problem/3031/" target="_blank" rel="noopener">https://acm.ecnu.edu.cn/problem/3031/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题考查的主要是大数的进制转换，其他没有什么算法技巧，但是对代码实现要求还是挺高的，适合用来锻炼你的<strong>耐心</strong>和<strong>代码风格</strong>。</p><p>整体思路非常简单，不就是先把输入的 10 进制数 $x$ 转化成 2 进制数 $b$ ，再把 $b$ 所有位颠倒过来，最后再把 $b$ 转化成 10 进制输出就行了。</p><p>所以整体代码拆分成了三步，先从 10 进制转 2 进制，再颠倒 2 进制，最后从 2 进制转 10 进制。</p><p>为了代码的普适性，我这里直接实现了从任意 $a$ 进制 转化为任意 $b$ 进制的算法，这样更加方便调用。</p><p>这就涉及到了<strong>大数的任意进制转换</strong>问题，假设 $x$ 是 $a$ 进制数，我们要把它转化为 $b$ 进制的 $y$ （初始时为空）。那么转化步骤如下：</p><ul><li>求 $x \% b$ ，并把余数接在 $y$ 的最高位。</li><li>令 $x = \left\lfloor x / b \right\rfloor$ 。</li><li>重复步骤 1 ，直到 $x = 0$ 。</li></ul><p>部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    y<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">mod</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来非常简单，但是步骤 1 和 2 都涉及到了<strong>大数的求余</strong>和<strong>大数的除法</strong>算法，所以我们还得实现这两个算法。</p><p>大数求余只要从 $x$ 最高位开始计算 $x$ 的大小，并同时对 $b$ 求余，然后由于求余的加法和乘法定理，我们可以始终保持 $x &lt; b$ ，这样就能用一个 <code>int</code> 类型保存余数了。</p><p>部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">mod</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">*</span> a <span class="token operator">+</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大数除法类似，从 $x$ 最高位开始除 $b$ ，并注意要把余数带到下一位，最后还得去掉前导 0 。</p><p>部分代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">div</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> q <span class="token operator">*</span> a<span class="token punctuation">;</span>        q <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span><span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// string转化为vector&lt;int>，倒序存储</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">s2i</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> idx <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> idx<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a进制下x%b，x倒序存储</span><span class="token keyword">int</span> <span class="token function">mod</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        q <span class="token operator">=</span> <span class="token punctuation">(</span>q <span class="token operator">*</span> a <span class="token operator">+</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a进制下x/b，x倒序存储</span><span class="token keyword">void</span> <span class="token function">div</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> q <span class="token operator">*</span> a<span class="token punctuation">;</span>        q <span class="token operator">=</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> b<span class="token punctuation">;</span>        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span><span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        x<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// a进制下s转化为b进制string</span>string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token function">s2i</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> y<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        y<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">mod</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'0'</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    cin <span class="token operator">>></span> T<span class="token punctuation">;</span>    string x<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> T<span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> x<span class="token punctuation">;</span>        string x2 <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>x2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string res <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"case #"</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"case #%d:"</span> <span class="token operator">%</span>i<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>int<span class="token punctuation">(</span>str<span class="token punctuation">(</span>bin<span class="token punctuation">(</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eoj </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 658】找到 K 个最接近的元素</title>
      <link href="/2020/02/15/leetcode-658/"/>
      <url>/2020/02/15/leetcode-658/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5], k=4, x=3输出：[1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5], k=4, x=-1输出：[1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>k 的值为正数，且总是小于给定排序数组的长度</li><li>数组不为空，且长度不超过 10^4</li><li>数组里的每个元素与 x 的绝对值不超过 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>这题要找离 $x$ 最近的 $k$ 个元素，又因为数组是排好序的，所以离 $x$ 最远的元素一定在数组两端。</p><p>那么我们只需要用两个指针，一个指针 $l$ 指着第一个元素，一个指针 $r$ 指着最后一个元素。如果 $r - l \ge k$ ，那就说明窗口中元素个数大于 $k$ ，那么就要删除一个元素。删除哪个呢？就看 $arr[l]$ 和 $arr[r]$ 谁离 $x$ 更远，就删除谁。如果一样远，就删除大的元素 $arr[r]$ 。就这样删到窗口中只剩 $k$ 个元素为止。</p><p>这个方法时间复杂度是 $O(n)$ 。</p><h3 id="二分-滑动窗口"><a href="#二分-滑动窗口" class="headerlink" title="二分+滑动窗口"></a>二分+滑动窗口</h3><p>如果 $n$ 太大，那么仅仅靠滑动窗口显然不行。注意观察答案所在的窗口可以发现，这个长度为 $k$ 的窗口一定是靠近 $x$ 的，也就是 $x$ 要么在窗口前一个位置，要么在窗口后一个位置，要么在窗口中间某个位置。 $x$ 和窗口中间绝对不可能有其他的数组元素。</p><p>那么我们可以二分找到第一个比 $x$ 大的元素（找第一个比它小的元素也行），然后左右各伸展出 $k$ 的长度，最终答案窗口一定就在这个范围之内。然后继续使用上面的滑动窗口来求解。</p><p>这个方法时间复杂度缩减到了 $O(\log n + k)$ 。</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>如果 $k$ 太大，那么上面的方法又没有意义了，还是会退化到 $O(n)$ 。</p><p>上面两个方法都是先把窗口范围定到某一个区间里，然后一点一点的缩小窗口大小，最终得到答案的。那么能否直接判断出长度为 $k$ 的答案窗口位置在哪里呢？</p><p>按照上面的思路，长度为 $k$ 的窗口一定是通过长度为 $k+1$ 的窗口删除首尾之一元素得到的。那么我们观察某一个特定的长度为 $k+1$ 的窗口 $[l, l+k]$ ，如果 $arr[l]$ 离 $x$ 距离比 $arr[l+k]$ 离 $x$ 更远的话，那就要删除 $arr[l]$ ，同时说明 $l$ 以及它左边的所有元素都不可能是答案窗口的左边界。反之如果 $arr[l]$ 离 $x$ 距离小于等于 $arr[l+k]$ 离 $x$ 的距离，那么就要删除 $arr[l+k]$ 了，同时说明 $l$ 右边的元素都不可能是答案窗口的左边界。</p><p>综上，我们可以用二分直接寻找答案窗口的左边界。这样时间复杂度就降到了 $O(\log n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="滑动窗口（c-）"><a href="#滑动窗口（c-）" class="headerlink" title="滑动窗口（c++）"></a>滑动窗口（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token operator">+</span>k<span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分-滑动窗口（c-）"><a href="#二分-滑动窗口（c-）" class="headerlink" title="二分+滑动窗口（c++）"></a>二分+滑动窗口（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        l <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token operator">+</span>k<span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分（c-）"><a href="#二分（c-）" class="headerlink" title="二分（c++）"></a>二分（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token operator">-</span>k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>m<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>l<span class="token operator">+</span>k<span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="滑动窗口（python）"><a href="#滑动窗口（python）" class="headerlink" title="滑动窗口（python）"></a>滑动窗口（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span>        <span class="token keyword">while</span> r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">:</span>            <span class="token keyword">if</span> x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">:</span>l<span class="token operator">+</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分-滑动窗口（python）"><a href="#二分-滑动窗口（python）" class="headerlink" title="二分+滑动窗口（python）"></a>二分+滑动窗口（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m        r <span class="token operator">=</span> min<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span>k<span class="token number">-1</span><span class="token punctuation">)</span>        l <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l<span class="token operator">-</span>k<span class="token punctuation">)</span>        <span class="token keyword">while</span> r<span class="token operator">-</span>l <span class="token operator">>=</span> k<span class="token punctuation">:</span>            <span class="token keyword">if</span> x<span class="token operator">-</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">:</span>l<span class="token operator">+</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分（python）"><a href="#二分（python）" class="headerlink" title="二分（python）"></a>二分（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span>k        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> x<span class="token operator">-</span>arr<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>m<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">:</span>l<span class="token operator">+</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 328】奇偶链表</title>
      <link href="/2020/02/14/leetcode-328/"/>
      <url>/2020/02/14/leetcode-328/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：1->2->3->4->5->NULL输出：1->3->5->2->4->NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：2->1->3->5->6->4->7->NULL输出：2->3->6->7->1->5->4->NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题要求使用原地算法，也就是不允许额外新建一个链表，只能使用常数的空间复杂度来实现。</p><p>要把奇数位置串起来，再把偶数位置串起来，最后把偶数位置链表接到奇数位置链表末尾。因为 <code>head</code> 表示的就是奇数位置链表的第一个结点，所以我们只需要再新建一个变量 <code>even_head</code> 指向 <code>head-&gt;next</code> ，也就是偶数位置链表的第一个结点。</p><p>此外还需要新建两个指针 <code>odd</code> 和 <code>even</code> 分别指向当前遍历到的奇偶结点，初始时分别指向奇偶头结点。</p><p>接下来只需要分成奇偶两条链，各自串联下去就行了。也就是每次把 <code>odd-&gt;next</code> 指向 <code>odd-&gt;next-&gt;next</code> ，把 <code>even-&gt;next</code> 指向 <code>even-&gt;next-&gt;next</code> 。也就是隔了一个元素，把当前结点下一个结点指向它的下一个和它奇偶位置相同的结点。注意的是，这里一定要先改变 <code>even-&gt;next</code> ，再改变 <code>odd-&gt;next</code> 。因为 <code>odd</code> 是在 <code>even</code> 前一个的，先改变它指向的下一个元素并不会影响 <code>even</code> 后面的元素。但是如果你先改变了 <code>even</code> 指向的下一个元素，那么 <code>odd-&gt;next-&gt;next</code> 就变了，就无法指向正确的结点了。</p><p>如果我们换个写法，先把 <code>odd-&gt;next</code> 指向 <code>even-&gt;next</code> ，再把 <code>even-&gt;next</code> 指向 <code>even-&gt;next-&gt;next</code> ，你就能很清楚的看出来了，必须先改变 <code>odd-&gt;next</code> ，因为它依赖于 <code>even-&gt;next</code> 。</p><p>最后把 <code>odd</code> 指向 <code>odd-&gt;next</code> ，把 <code>even</code> 指向 <code>even-&gt;next</code> ，继续遍历下一个结点。</p><p>什么时候停止呢？链表的最后一个结点要么是奇数结点，要么是偶数结点。如果是偶数结点，那么最后 <code>even</code> 不为空，但是它的下一个结点 <code>even-&gt;next</code> 为空，这时候结束遍历。如果是奇数结点，那么最后 <code>odd</code> 不为空，但是 <code>even</code> 为空，那么也结束遍历。综上，如果 <code>even</code> 或者 <code>even-&gt;next</code> 为空的时候，结束遍历。</p><p>最后只需要把 <code>odd</code> 的下一个结点指向 <code>even_head</code> 就能把两个链表串起来了。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ ，因为只用到了 3 个额外指针。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> even_head <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> odd <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> even <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>even <span class="token operator">&amp;&amp;</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            odd<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            even<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            odd <span class="token operator">=</span> odd<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            even <span class="token operator">=</span> even<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        odd<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> even_head<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        even_head<span class="token punctuation">,</span> odd<span class="token punctuation">,</span> even <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> even <span class="token keyword">is</span> <span class="token operator">not</span> None <span class="token operator">and</span> even<span class="token punctuation">.</span>next <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next            even<span class="token punctuation">.</span>next <span class="token operator">=</span> even<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            odd <span class="token operator">=</span> odd<span class="token punctuation">.</span>next            even <span class="token operator">=</span> even<span class="token punctuation">.</span>next        odd<span class="token punctuation">.</span>next <span class="token operator">=</span> even_head        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 926】将字符串翻转到单调递增</title>
      <link href="/2020/02/13/leetcode-926/"/>
      <url>/2020/02/13/leetcode-926/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是单调递增的。</p><p>我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 S，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。</p><p>返回使 S 单调递增的最小翻转次数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："00110"输出：1解释：我们翻转最后一位得到 00111.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："010110"输出：2解释：我们翻转得到 011111，或者是 000111。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入："00011000"输出：2解释：我们翻转得到 00000000。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 中只包含字符 ‘0’ 和 ‘1’</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要想把字符串变成递增的，只有两种可能，一种就是从某一处开始全是 1 ，之前都是 0 或者没有，另一种就是全 0 。那么我们只需要遍历这个 1 开始的位置就行了。</p><p>对于位置 i ，我们假设从它开始后面都是 1 ，前面都是 0 ，那么需要修改的的次数就是它后面 0 的数量减去它前面 1 的数量。</p><p>如果我们用数组预处理出来位置 i 开始到最后 1 的数量，记为 $dp[i]$ 。那么它后面 0 的数量就可以表示为 $n - i - dp[i]$ ，也就是后面的长度减去 1 的数量。而它前面 1 的数量可以表示为 $dp[0] - dp[i]$ ，也就是 1 的总数量减去 i 后面 1 的数量。</p><p>那么总的修改次数就是 $n - i - dp[i] + dp[0] - dp[i]$ ，我们只需要遍历所有的 i ，找出最小值就行了。</p><p>另外还需要比较一下 $dp[0]$ 的大小，也就是把所有的 1 都修改为 0 。</p><p>最终时间复杂度是 $O(n)$ ，空间复杂度也是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minFlipsMonoIncr</span><span class="token punctuation">(</span>string S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>n<span class="token operator">-</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minFlipsMonoIncr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> S<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>S<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'1'</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>n<span class="token operator">-</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1186】删除一次得到子数组最大和</title>
      <link href="/2020/02/12/leetcode-1186/"/>
      <url>/2020/02/12/leetcode-1186/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。</p><p>换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p><p>注意，删除一个元素后，子数组 不能为空。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：arr = [1,-2,0,3]输出：4解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：arr = [1,-2,-2,3]输出：3解释：我们直接选出 [3]，这就是最大和。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：arr = [-1,-1,-1,-1]输出：-1解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= arr.length &lt;= 10^5</li><li>-10^4 &lt;= arr[i] &lt;= 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先回顾一道很相似的题目，也就是求连续子数组的最大值，并不需要删除元素。</p><p>这其实只需要用动态规划就能实现了，也就是计算以 $arr[i]$ 结尾的连续子数组的最大值，记为 $dp[i]$ 。那么它一定要取 $arr[i]$ ，而前面的元素的话，如果 $dp[i-1] &gt; 0$ ，也就是以 $arr[i-1]$ 为结尾的连续子数组最大值大于 0 ，那就加上前面的最大值，否则的话只取 $arr[i]$ 就行了。最终答案就是取所有 $dp[i]$ 中最大的，状态转移方程是：<br>$$<br>dp[i] = arr[i] + max(dp[i-1], 0)<br>$$</p><p>回到本题，如果一个元素都不删除的话，那么做法就和上面一模一样。如果删除一个元素的话，那么它的左右两边就分成了两个连续的子数组了。</p><p>那么我们假设删除的是 $arr[i]$ ，那么我们只要求左右两边子数组的最大值之和，也就是以 $arr[i-1]$ 结尾和以 $arr[i+1]$ 开头的两个连续子数组的最大值之和。以 $arr[i-1]$ 结尾上面已经求过了，以 $arr[i+1]$ 开头和上面方法类似，从后往前求一遍就行了。这样预处理完两个动态规划数组之后，遍历删除的元素，就能 $O(n)$ 时间内算出最大值。</p><p>具体实现的时候，注意到删除的元素是有限制的，其实只需要遍历删除 $arr[1]$ 到 $arr[n-2]$ 就行了，因为删除首尾两个元素的话，剩下来一个子数组，答案已经包含在开始的预处理之中了。</p><p>空间方面，从右往左求以 $arr[i]$ 开头的连续子数组最大值的时候，没有必要保存到数组里了，直接用变量保存，然后同时计算删除 $arr[i]$ 之后最大值就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maximumSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> arr<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maximumSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        res<span class="token punctuation">,</span> last <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>last<span class="token punctuation">)</span>            last <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> max<span class="token punctuation">(</span>last<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 927】三等分</title>
      <link href="/2020/02/11/leetcode-927/"/>
      <url>/2020/02/11/leetcode-927/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。</p><p>如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来：</p><ul><li>A[0], A[1], …, A[i] 组成第一部分；</li><li>A[i+1], A[i+2], …, A[j-1] 作为第二部分；</li><li>A[j], A[j+1], …, A[A.length - 1] 是第三部分。</li><li>这三个部分所表示的二进制值相等。</li></ul><p>如果无法做到，就返回 [-1, -1]。</p><p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,0,1,0,1]输出：[0,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,1,0,1,1]输出：[-1,-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>3 &lt;= A.length &lt;= 30000</li><li>A[i] == 0 或 A[i] == 1</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题虽然名义上是个难题，其实基本没有用到什么算法，只是代码实现上略微繁琐了一点。</p><p>想象如果这个数组能分成三个子数组，每个子数组表示的数字都相同，那么首先<strong>每个子数组中 1 的数量一定要相等！</strong></p><p>所以我们先统计 1 的数量，如果它不是 3 的倍数，那么一定不存在划分方式，直接返回无解就行了。如果数量是 0 ，就说明数组全 0 ，那么随便划分都是合理的，任意返回就行了。</p><p>接下来将 1 的数量等分为 3 份 ，然后遍历数组，找出 3 个子数组的左右边界（注意这个边界表示的是每个子数组第一个 1 和最后一个 1 的位置）。这时候还没结束，因为最后一个子数组末尾会多出来很多 0 。所以我们需要在前两个子数组后面加上等量的 0 。</p><p>最后遍历一遍三个子数组，判断是否完全相等就行了。</p><p>听起来是很简单，代码实现的时候还是有几个小细节的。比如求边界的时候，可以利用求余操作，保存到两个数组里，这样写起来美观方便。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">threeEqualParts</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt1 <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cnt1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        cnt1 <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> l<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> r<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeEqualParts</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        cnt1 <span class="token operator">=</span> sum<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">if</span> cnt1<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>        cnt1 <span class="token operator">//=</span> <span class="token number">3</span>        cnt <span class="token operator">=</span> <span class="token number">0</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">3</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">continue</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                l<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">//</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i            <span class="token keyword">if</span> cnt<span class="token operator">%</span>cnt1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                r<span class="token punctuation">[</span><span class="token punctuation">(</span>cnt<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">//</span>cnt1<span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">or</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 503】下一个更大元素 II</title>
      <link href="/2020/02/10/leetcode-503/"/>
      <url>/2020/02/10/leetcode-503/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,1]输出：[2,-1,2]解释：第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong><br>输入数组的长度不会超过 10000。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题中循环数组其实不用管，只需要再复制一遍数组接在后面就行了，那么关键还是如何求每个数后面第一个比它大的数。</p><p>我们可以从右往左遍历数组，如果遍历到某个数，那么它右边所有比它小的数都不用再考虑了。因为再继续遍历下去的话，它右边比它还小的数是绝对不可能成为第一个大的数的。</p><p>这样我们只需要保存每个数右边比它大的数就行了，这就需要用到单调栈了。对于 $nums[i]$ 来说，我们只需要不断出栈，直到栈顶元素大于它就行了，那么这时候栈顶元素就是 $nums[i]$ 右边第一个比它大的数。如果栈是空的，就说明它右边没有更大的数了。</p><p>而在具体实现的时候，没必要真的把数组复制一遍接在后面，只需要用求余操作就能解决了。</p><p>最终每个元素出栈入栈一次，时间复杂度是 $O(n)$ ，空间复杂度是 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">>=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        stack<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token number">-2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">>=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">else</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 16】最接近的三数之和</title>
      <link href="/2020/02/09/leetcode-16/"/>
      <url>/2020/02/09/leetcode-16/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [-1，2，1，-4], target = 1.输出：2解释：与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最暴力的方法就是直接枚举三个不同的数，然后求出差值最小的和，但是这样时间复杂度是 $O(n^3)$ ，太高了。</p><p>那么我们先枚举一个数试试，并且假设它是最小的数，然后寻找比它大的两个数就行了，这就需要我们先对数组进行排序（假设排序后数组是 $a$ ）。</p><p>如果枚举的数是 $a[i]$ ，那么我们只需要寻找和 $t - a[i]$ 差值最小的两个数之和就行了。</p><p>如果用双指针的方法，初始时令 $l = i + 1$ ，同时 $r = n - 1$ 。那么如果 $a[i] + a[l] + a[r] &gt; t$ ，就说明 $r$ 太大了，需要左移。否则的话如果 $a[i] + a[l] + a[r] &lt; t$ ，就说明 $l$ 太小了，需要右移。在不断移动的过程中更新最小差值就行了，因为 $l$ 和 $r$ 最终一共只移动了 $O(n)$ 步，所以总的时间复杂度只有 $O(n \log n + n^2)$ ，忽略低阶项之后只有 $O(n^2)$ ，还是可以接受的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> sum<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>sum<span class="token operator">-</span>target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">abs</span><span class="token punctuation">(</span>res<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> res <span class="token operator">=</span> sum<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10000000</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            l<span class="token punctuation">,</span> r <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token number">-1</span>            <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>                s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> s <span class="token operator">==</span> target<span class="token punctuation">:</span>                    <span class="token keyword">return</span> s                <span class="token keyword">if</span> abs<span class="token punctuation">(</span>s<span class="token operator">-</span>target<span class="token punctuation">)</span> <span class="token operator">&lt;</span> abs<span class="token punctuation">(</span>res<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>                    res <span class="token operator">=</span> s                <span class="token keyword">if</span> s <span class="token operator">></span> target<span class="token punctuation">:</span>                    r <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 719】找出第 k 小的距离对</title>
      <link href="/2020/02/08/leetcode-719/"/>
      <url>/2020/02/08/leetcode-719/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,3,1]k = 1输出：0解释：所有数对如下：(1,3) -> 2(1,1) -> 0(3,1) -> 2因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>2 &lt;= len(nums) &lt;= 10000.</li><li>0 &lt;= nums[i] &lt; 1000000.</li><li>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>注意到这题 $n$ 比较大，所以不能算出所有的数对差值，然后排序，这样时间复杂度就是 $O(n^2 \log {n^2})$ 了。</p><p>直觉上应该先给数组从小到大排个序，那么差值最小值就是 0 ，最大值就是 $nums[n-1] - nums[0]$ ，答案肯定也就在这个区间里了。</p><p>那么我们可以从最大的差值开始，看是否有数对满足这个差值，并且这个差值还得是第 $k$ 小的。对于差值 $m$ ，如果它是第 $k$ 小的，说明所有数对中差值小于等于 $m$ 的数对个数 $c$ 一定大于等于 $k$ 。因为如果第 $k$ 小的差值只有一个数对满足，那么 $c = k$ ，否则的话就有多个数对差值都是 $m$ ，那就有 $c &gt; k$ 。于是我们找到第一个满足 $c &lt; k$ 的差值就行了，再加 1 就是最终的答案。</p><p>那么怎么求小于等于 $m$ 的数对个数 $c$ 呢？因为排过序了，所以可以采用双指针的方法，初始时 $l = r = 0$ ，对于每个右指针 $r$ ，我们移动左指针 $l$ ，直到 $nums[r] - nums[l] \le m$ 。那么最终 $r - l$ 就是以 $nums[r]$ 作为较大数的数对个数。因为两个指针都是向右移动的，所以每次计算个数只需要 $O(n)$ 的时间复杂度。</p><p>所以这个方法最终总的时间复杂度为 $O(Wn + n \log n)$ ，因为最大差值 $W$ 还是太大，所以还是没有办法直接遍历。</p><p>又注意到随着 $m$ 的减小， $c$ 也是单调减小的，所以可以二分寻找 $m$ 。如果 $c \ge k$ ，那么说明答案小于等于 $m$ ，于是令 $r = m$ 。如果 $c &lt; k$ ，那么说明答案一定大于 $m$ ，于是令 $l = m + 1$ ，最终答案就是 $l$ 。</p><p>这样二分优化之后，最终的时间复杂度为 $O(n\log W + n\log n)$ ，可以接受。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">smallestDistancePair</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> nums<span class="token punctuation">)</span> <span class="token operator">>=</span> k<span class="token punctuation">)</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> K<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> r <span class="token operator">-</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">smallestDistancePair</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>K<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>            cnt<span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>            <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r <span class="token operator">and</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> K<span class="token punctuation">:</span>                    l <span class="token operator">+=</span> <span class="token number">1</span>                cnt <span class="token operator">+=</span> r <span class="token operator">-</span> l            <span class="token keyword">return</span> cnt        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> count<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">>=</span> k<span class="token punctuation">:</span>                r <span class="token operator">=</span> m            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 289】生命游戏</title>
      <link href="/2020/02/07/leetcode-289/"/>
      <url>/2020/02/07/leetcode-289/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ul><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ul><p>根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[  [0,1,0],  [0,0,1],  [1,1,1],  [0,0,0]]输出：[  [0,0,0],  [1,0,1],  [0,1,1],  [0,1,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进阶</strong></p><ul><li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li><li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题要求你根据数组每个元素四周的状态来更新数组元素。如果使用一个辅助数组，遍历原数组，然后保存更新后的状态到辅助数组里。这样的话轻轻松松，没有任何难度。但是这题意思是让你不使用辅助数组，直接修改原数组元素，达到一样的目的。</p><p>这样的话就不能直接修改原数组元素了，不然当你遍历下一个元素的时候，它周围的值都变掉了，还怎么看它要不要变呢？所以我们应该想办法把变化前变化后的元素都保存下来。</p><p>因为这题只有两个状态 0 和 1 ，所以我们可以用两位二进制来表示变化前和后的状态，第一位表示变化后，第二位表示变化前。 00，10，01，11 分别表示 0 不变、0 变到 1 、1 变到 0 、1 不变四种变化情况。这样的话就算你直接修改了元素值，也能获取到它的原来的值。最后只需要进行第二遍扫描，取出变化后的值，也就是第一位就行了。</p><p>判断和修改都可以通过位运算来完成。判断修改前是否为 1 可以通过 $x\&amp;1$ 来看。用 m 表示修改（1）或者不修改（0），那么更新后元素就变成了 $x + (m &lt;&lt; 1)$ 。最后更新后的数组元素就是 $x &gt;&gt; 1$ 了。</p><p>而边界问题很好处理，只需要判断一下有没有超出边界就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        cnt<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        dx <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>        dy <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                cnt <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    nx<span class="token punctuation">,</span> ny <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&lt;</span> n <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&lt;</span> m <span class="token operator">and</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                        cnt <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> cnt<span class="token operator">==</span><span class="token number">2</span> <span class="token operator">or</span> cnt<span class="token operator">==</span><span class="token number">3</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> cnt<span class="token operator">==</span><span class="token number">3</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 556】下一个更大元素 III</title>
      <link href="/2020/02/06/leetcode-556/"/>
      <url>/2020/02/06/leetcode-556/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：12输出：21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：21输出：-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先要发现一个性质，如果调换两个数位之后，整个数字变大了，那说明第一个数位的数字小于第二个数位的数。所以我们只需要找到一个顺序对，调换它俩顺序就行了。</p><p>但是如果存在两个顺序对 $(i_1, j_1)$ 和 $(i_2, j_2)$ ，那我们就要找 $i$ 更大的那个，因为前面的尽量不动才会使调换后的数字最小。</p><p>如果 $i$ 相同的话，就要在 $i$ 右边找最小的使得 $nums[j] &gt; nums[i]$ 的数，这样 $i$ 处的数字才是最小的，同时整体数字还会变大。</p><p>最后因为 $i$ 处已经变大了，所以 $i$ 后面的数字全部都要升序排列，这样整体数字才是最小的。</p><p>所以整体算法就有了，我们从右往左找，找到第一个上升的位置 $i$ ，也就是 $nums[i] &lt; nums[j]$ 。这样 $i$ 右边就是降序了，不存在顺序对。然后在 $i$ 右边的数字中二分查找最小的大于 $nums[i]$ 的数 $nums[j]$ ，调换它俩位置。最后把 $i$ 右边的数字变成升序即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span><span class="token operator">++</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            n <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> ok <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span>i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> a<span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                ok <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res <span class="token operator">></span> INT_MAX <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        s <span class="token operator">=</span> str<span class="token punctuation">(</span>n<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> res            <span class="token keyword">if</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span> <span class="token operator">and</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                res <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                        res <span class="token operator">=</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>                        <span class="token keyword">break</span>                s <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> res                <span class="token keyword">return</span> int<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">if</span> int<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;</span> pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还可以直接用 c++ 标准库函数 <code>next_permutation</code> 直接生成下一个更大的字符串排列，然后转换成整数就行了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">next_permutation</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token function">stoll</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res <span class="token operator">></span> INT_MAX <span class="token operator">||</span> res <span class="token operator">&lt;=</span> n <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1039】多边形三角剖分的最低得分</title>
      <link href="/2020/02/05/leetcode-1039/"/>
      <url>/2020/02/05/leetcode-1039/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。</p><p>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。</p><p>返回多边形进行三角剖分后可以得到的最低分。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3]输出：6解释：多边形已经三角化，唯一三角形的分数为 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong><br><img src="1.png" alt></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,7,4,5]输出：144解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,3,1,4,1,5]输出：13解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>3 &lt;= A.length &lt;= 50</li><li>1 &lt;= A[i] &lt;= 100</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一个凸 $n$ 边多边形，不停切割下去，最终一定是能切割成 $n-2$ 个三角形。那么按照什么顺序切割才能方便求解呢？</p><p>可以发现，一刀下去，两个多边形只有一条边是在内部，其他边都是连续的外围的边，如下图所示：</p><p><img src="2.jpg" alt></p><p>所以右边的多边形我们可以用 $(i, j)$ 二维状态来表示。</p><p>那么继续切割下去，例如切割左边那块多边形，我们应该先把 $(i, j)$ 这条边对应的三角形给找出来，那就是在 $(i, j)$ 之间找到第三个点 $k$ ，如下图所示：</p><p><img src="3.jpg" alt></p><p>这样右边多边形就被划分为了 3 块，其中除了 $(i, j, k)$ 这个三角形外，两外两块多边形仍然满足只有一条内边的性质，所以可以继续用二位状态表示为 $(i, k)$ 和 $(k, j)$。</p><p>那如果不先找三角形 $(i, j, k)$ 会怎么样呢。如下图所示：</p><p><img src="4.jpg" alt></p><p>这样的话，多边形 $(i, k_1, k_2, j)$ 就会出现两条内边，那么这种多边形就很难用简单的二维状态来表示了，程序中很难实现。</p><p>最后就能用二维动态规划来递归求解了。用 $(i, j)$ 表示多边形 $i \to i+1 \to \cdots j$ ，其中只有 $j \to i$ 是内边。设 $dp[i][j]$ 表示多边形 $(i, j)$ 切割后最小得分，那么只需要找到上面所说的切割点 $k$ 就行了，转移方程为：<br>$$<br>dp[i][j] = \min(dp[i][k] + dp[k][j] + A[i] \cdot A[j] \cdot A[k])<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    tmp <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span>                tmp <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>                    tmp <span class="token operator">=</span> min<span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">*</span>A<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>k<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">%</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 495】提莫攻击</title>
      <link href="/2020/02/04/leetcode-495/"/>
      <url>/2020/02/04/leetcode-495/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p><p><img src="1.jpg" alt="兔宝宝提莫"></p><p>现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。</p><p>你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,4], 2输出：4解释：在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。在第 4 秒开始时，提莫再次攻击艾希，使得艾希获得另外 2 秒的中毒时间。所以最终输出 4 秒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2], 2输出：3解释：在第 1 秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒钟结束。但是在第 2 秒开始时，提莫再次攻击了已经处于中毒状态的艾希。由于中毒状态不可叠加，提莫在第 2 秒开始时的这次攻击会在第 3 秒钟结束。所以最终输出 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为数组是时间序列，所以是给你排好序的，不需要你自己排序。</p><p>那么对于 $t[i]$ 来说，如果 $t[i-1]+d \le t[i]$ 的话，就说明前一时刻的中毒效果已经过去了，那么当前时刻的中毒效果持续时间都是属于当前时刻的，答案加上 $d$ 就行了。但是如果 $t[i-1]+d &gt; t[i]$ ，那么前一时刻的中毒效果还在，等前一时刻的中毒效果过去了，剩下的中毒时间才能算是当前时刻的，而扣除掉上一时刻剩余的时间为 $t[i] - t[i-1]$ 。所以最后属于当前时刻的中毒时间只要取 $t[i] - t[i-1]$ 和 $d$ 的最小值就行了。</p><p>最终时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findPoisonedDuration</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> timeSeries<span class="token punctuation">,</span> <span class="token keyword">int</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> timeSeries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> n <span class="token operator">?</span> duration <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>timeSeries<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findPoisonedDuration</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> timeSeries<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>timeSeries<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> n<span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">else</span> duration        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> min<span class="token punctuation">(</span>timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>timeSeries<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> duration<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这题难度其实称不上中等，选取这道题完全是因为有我最爱的小提莫！</p><p>如果有同样喜爱英雄联盟的召唤师（小姐姐最棒了），可以加我好友一起开黑呀。本人<strong>艾欧尼亚</strong>（<strong>ID：godweiyang</strong>）黄金水平，虽然很菜，但是打字速度快！</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏！编码器中如何融入结构信息？这几篇论文一定不要错过</title>
      <link href="/2020/02/03/encoder-syntactic/"/>
      <url>/2020/02/03/encoder-syntactic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>编码器已经成为了很多 NLP 模型中的基本结构。不管你是做机器翻译，还是做句法分析，不管你是需要得到单词的上下文表示，还是需要得到句子的表示，你都需要一个强有力的编码器。输入一个句子，编码器最终输出每个单词的表示或者整个句子的表示。</p><p>而近些年来 NLP 领域用的比较多的编码器有 CNN ，RvNN ，RNN （尤其是 LSTM）和 Transformer 等等，今天我们主要关注最后两个。在编码器中加入结构信息有很多种用途。一是利用结构信息增强编码器的结构表示，进而提高下游任务的性能。二可以无监督学习出句子的句法树（如果融入的是句法结构信息的话）。</p><p>下面就给大家简要分享几篇融入了结构信息的编码器的论文。</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p><a href="http://arxiv.org/abs/1711.02013" title="ICLR18: Neural Language Modeling by Jointly Learning Syntax and Lexicon" target="_blank" rel="noopener">Neural Language Modeling by Jointly Learning Syntax and Lexicon</a></p><p><img src="1.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/yikangshen/PRPN" target="_blank" rel="noopener">https://github.com/yikangshen/PRPN</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2019/03/31/iclr18-prpn/">https://godweiyang.com/2019/03/31/iclr18-prpn/</a></p><p>本文提出了一种新的语言模型叫做 PRPN ，隐式地建模句法树信息。具体实现上，模型分为了三个部分：Parsing 模块、Reading 模块和 Predict 模块。其中 Parsing 模块用 CNN 来预测相邻两个单词的句法距离（概念详见 <a href="http://aclweb.org/anthology/P18-1108" title="ACL18: Straight to the Tree: Constituency Parsing with Neural Syntactic Distance" target="_blank" rel="noopener">Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</a>），通过句法距离就可以还原出句子的句法树了。Reading 模块用来建模上下文，同时还融入了前面时刻预测出来的句法距离信息。Predict 模块用来预测下一个单词是什么，做语言模型。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p><a href="https://www.aclweb.org/anthology/N19-1116/" title="NAACL19: Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders" target="_blank" rel="noopener">Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders</a></p><p><img src="3.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/iesl/diora" target="_blank" rel="noopener">https://github.com/iesl/diora</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2019/07/25/diora/">https://godweiyang.com/2019/07/25/diora/</a></p><p>这篇论文提出了 DIORA 模型，主要使用 inside-outside 算法来计算每个 span 的表示和得分。其中 inside 过程其实就是自底向上计算所有 span 的得分和表示，而 outside 过程自顶向下计算 span 表示。最后目标函数也和其他模型有所不同，一般目标函数不是语言模型就是下游任务，但是这里用 outside 过程得到的所有单词的表示和得分来计算损失函数，也就是最大化每个单词的所有可能的句法树的得分总和。</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p><a href="http://arxiv.org/abs/1904.03746" title="NAACL19: Unsupervised Recurrent Neural Network Grammars" target="_blank" rel="noopener">Unsupervised Recurrent Neural Network Grammars</a></p><p><img src="4.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/harvardnlp/urnng" target="_blank" rel="noopener">https://github.com/harvardnlp/urnng</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2019/04/20/naacl19-urnng/">https://godweiyang.com/2019/04/20/naacl19-urnng/</a></p><p>本文提出了 URNNG 模型，用变分方法和 RNNG 来做无监督句法分析。具体实现上是用两个网络，第一个是 inference 网络，来推理出句子对应的隐变量（也就是句法树）的条件概率。然后再用生成网络 RNNG 来建模句子和隐变量的联合概率。最后对这个联合概率求和得到句子的概率，也就是用语言模型来作为目标任务。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p><a href="http://arxiv.org/abs/1810.09536" title="ICLR19: Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks" target="_blank" rel="noopener">Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks</a></p><p><img src="5.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/yikangshen/Ordered-Neurons" target="_blank" rel="noopener">https://github.com/yikangshen/Ordered-Neurons</a></p><p><strong>论文解读：</strong><br><a href="https://kexue.fm/archives/6621" target="_blank" rel="noopener">https://kexue.fm/archives/6621</a></p><p>这篇论文是 ICLR2019 的最佳论文之一，主要思想是赋予 LSTM 的神经元层级信息，对神经元排序（有序神经元），同时引入两个新的门控单元（主遗忘门和主输入门），来建模句子的层级结构信息。模型基于的最主要的指导思想就是：<strong>层级越高，颗粒度越粗，那么它在句子中的跨度就越大</strong>。输入一个单词之后，判断单词的层级和历史层级之间的大小关系，然后看情况更新参数的不同维度，低层保留历史信息，高层直接用输入信息覆盖，中间部分就用普通的 LSTM 更新。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p><a href="http://arxiv.org/abs/1909.02134" title="EMNLP19: PaLM: A Hybrid Parser and Language Model" target="_blank" rel="noopener">PaLM: A Hybrid Parser and Language Model</a></p><p><img src="7.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/Noahs-ARK/PaLM" target="_blank" rel="noopener">https://github.com/Noahs-ARK/PaLM</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2020/01/09/emnlp19-palm/">https://godweiyang.com/2020/01/09/emnlp19-palm/</a></p><p>本文在 LSTM 中融入 attention ，对于每个单词，都计算它和左边所有单词的 attention ，然后利用这个 attention 来融合历史信息，增强当前时刻的上下文表示。在解码句法树的时候，自顶向下解码，对于某个 span ，只需要贪心地找出使右儿子 span 得分最大的那个 split 就行了。至于这个 attention ，有没有句法树监督都是可以的，实际上没有句法树监督的话对语言模型效果更好。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p><a href="http://arxiv.org/abs/1909.06639" title="EMNLP19: Tree Transformer: Integrating Tree Structures into Self-Attention" target="_blank" rel="noopener">Tree Transformer: Integrating Tree Structures into Self-Attention</a></p><p><img src="6.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/yaushian/Tree-Transformer" target="_blank" rel="noopener">https://github.com/yaushian/Tree-Transformer</a></p><p><strong>论文解读：</strong><br><a href="https://godweiyang.com/2020/01/06/emnlp19-tree-transformer/">https://godweiyang.com/2020/01/06/emnlp19-tree-transformer/</a></p><p>本文和 Transformer 主要区别就是在每一层的 attention 之外还添加了一个成分 attention ，用来表示两个单词属于同一个短语之内的概率。最后总的 attention 就是原来的 attention 和成分 attention 做元素乘，这样的话同一个短语之间的 attention 就比较大，而不同短语之间的 attention 就很小。最后要想解码句法树的话，就还是用句法距离的算法，自顶向下解码句法树。</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p><a href="http://arxiv.org/abs/1909.02222" title="EMNLP19: Multi-Granularity Self-Attention for Neural Machine Translation" target="_blank" rel="noopener">Multi-Granularity Self-Attention for Neural Machine Translation</a></p><p><img src="10.jpg" alt></p><p>本文提出了多粒度的 Self-Attention 网络，也就是把原始的 Transformer 中的不同的 head 变成了不同的粒度。将一个句子分成了多个不重叠的短语，然后用 CNN 之类网络得到每个短语的表示，然后把单词当作 query ，短语当作 key ，做 self-attention 得到每个单词的粗粒度上下文表示。不同的短语切分方式对应着不同的粒度，可以用 n-gram 方式切分短语，也可以用句法树的不同层来切分短语。最后把不同粒度的单词表示拼在一起就行了。</p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p><a href="https://www.aclweb.org/anthology/P19-1030/" title="ACL19: You Only Need Attention to Traverse Trees" target="_blank" rel="noopener">You Only Need Attention to Traverse Trees</a></p><p><img src="2.jpg" alt></p><p>这篇论文思想也不复杂，论文目的是要设计一个能够编码句法树的网络，最终得到句子的向量表示，来给下游任务用。对于成分句法树，某个结点的表示可以由它的所有子结点做 self-attention ，然后经过一系列变换得到。对于依存句法树，某个单词的表示可以由它的父亲单词和所有儿子单词做 self-attention ，然后经过一系列变换得到。其实网络结构整体上看和递归神经网络是很像的，只是结点的结合函数借用了 Transformer 中的 self-attention ，模型名字作者也称为了 Tree-Transformer 。</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p><a href="http://arxiv.org/abs/1908.00449" title="CoRR19: Tree-Transformer: A Transformer-Based Method for Correction of Tree-Structured Data" target="_blank" rel="noopener">Tree-Transformer: A Transformer-Based Method for Correction of Tree-Structured Data</a></p><p><img src="9.jpg" alt></p><p>这篇文章并没有发出来，只是挂在了 arxiv 上，所以写的也是有很多错误的。主要提出了一个 Tree to Tree 的模型（类比 seq to seq 模型），按照 top-down 的顺序对一个句法树（或者代码的语法树等等）进行编码，然后 decoder 再按照 top-down 的顺序生成出一棵句法树。和普通的 Transformer 区别就是把中间的 feed-forward network 替换成了他这里的 tree conv block ，用来结合一个结点、它的父亲结点和所有兄弟结点的表示，如果没有的话就用零向量替代。</p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><a href="https://openreview.net/pdf?id=HJxK5pEYvr" title="ICLR20: Tree-Structured Attention with Hierarchical Accumulation" target="_blank" rel="noopener">Tree-Structured Attention with Hierarchical Accumulation</a></p><p><img src="11.jpg" alt></p><p><strong>代码地址：</strong><br><a href="https://github.com/nxphi47/tree_transformer" target="_blank" rel="noopener">https://github.com/nxphi47/tree_transformer</a></p><p>这篇论文 reviewer #1 也说了，写的公式符号有点晦涩难懂，不是很清楚。结构复杂，如果不公开源码很难实现。反正我也是看得云里雾里的，一头雾水。大致思想就是用一个矩阵，列数正好就是句子长度，每一行就对应了句法树的一个结点，外加一行叶子结点。矩阵中某一行，如果对应结点子树包含了某个单词，那一列就是有结点的特征向量的，否则就是零向量。然后对矩阵先按行做累和，再按列做加权求和，最后得到每个结点的向量表示。然后就是怎么把它融入到 Transformer 中了，写的是真的晦涩难懂，有兴趣的去看原论文吧。</p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p><a href="https://openreview.net/pdf?id=BJgQ4lSFPH" title="ICLR20: StructBERT: Incorporating Language Structures into Pre-training for Deep Language Understanding" target="_blank" rel="noopener">StructBERT: Incorporating Language Structures into Pre-training for Deep Language Understanding</a></p><p><img src="12.jpg" alt></p><p><strong>论文解读：</strong><br><a href="https://zhuanlan.zhihu.com/p/103207343" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103207343</a></p><p>这是阿里巴巴司罗老师团队改进的一种 BERT 模型，叫做 StructBERT 。主要就是在原本的 BERT 基础上新增加了两个预训练任务。一个是单词级别的，最大化长度为 K 的一段子句的正确词序的概率。一个是句子级别的，分为预测下一个句子、上一个句子和不同文档的随机句子三种。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> encoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 233】数字 1 的个数</title>
      <link href="/2020/02/03/leetcode-233/"/>
      <url>/2020/02/03/leetcode-233/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：13输出：6解释：数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题是我搜数位 dp 题目搜出来的，于是我直接用数位 dp 方法把它过了，后来发现其实没必要这么麻烦，简单的计算就能算出来了，这里两个方法我都讲一下。</p><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>我们不妨用 n = 12345 来举个例子。要求小于等于 n 的数字里有多少个 1 ，我们不妨转换个角度，看某一位数字是 1 的话，有多少数字小于 n 。</p><p>例如从右向左数第 i = 2 位（数字 3 ），如果这一位取 1 ，那么左边 2 位如果取 0-11 ，那么右边 2 位就没有任何限制，从 0 取到 99 都行。如果左边 2 位如果取 12 ，那么就得考虑 n 中第 i 位是几了，如果大于 1 ，那么右边 2 位还是没有限制；如果等于 1 ，那么右边 2 位只能取 0-45 ；如果等于 0 ，那就没得取了。</p><p>下面这张图是我打的草稿，看的更清楚一点：</p><p><img src="1.jpg" alt></p><p>一般化描述就是，考虑从右往左数第 i 位是 1 的数字数量。那么 n 中第 i 位左边部分的数字是 $\left\lfloor \frac{n}{10^{i+1}} \right\rfloor$ ，而右边可以取的数量是 $10^i$ ，相乘就是总的数量 $\left\lfloor \frac{n}{10^{i+1}} \right\rfloor \cdot 10^i$ 。如果左边直接取最大值，那么就要考虑第 i 位数字是几了，计算可以得到第 i 位数字为 $\left\lfloor \frac{n}{10^{i}} \right\rfloor \% 10$ ，记为 x 。如果 $x &gt; 1$ ，那么右边无限制，有 $10^i$ 种取法；如果 $x = 1$ ，那么右边有 $n \% 10^i + 1$ 种取法；如果 $x = 0$ ，那么右边无法取，因为第 i 位都没法取 1 。</p><p>综上，令 $x = \left\lfloor \frac{n}{10^{i}} \right\rfloor \% 10$ ，那么答案就是：<br>$$<br>\left\lfloor \frac{n}{10^{i+1}} \right\rfloor \cdot 10^i + 10^i \cdot [x &gt; 1] + (n \% 10^i + 1) \cdot [x = 1]<br>$$</p><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p>数位 dp 就麻烦许多了，不想看的可以直接跳过了。</p><p>首先我们从最高位开始往右递归计算，用 pos, count, limit 来表示计算到第 pos 位（从左往右，和数学方法不一样）时，已经出现了 count 个 1 ，并且之后的数字有无限制（也就是能否取遍 0-9 ），这种状态之下方法数是多少。</p><p>那么第 pos 位我们可以取的数字有哪些呢？如果 limit = 1 也就是有限制，那么只能取 0-n中第pos位，如果没有限制那就取 0-9 。</p><p>假设第 pos 位取 1 ，那么 pos 就转移到了 pos+1 ，count 转移到了 count+1 ，limit 呢？只有当原来有限制，并且第 pos 位正好取了最大值也就是 n 中第 pos 位数字时，limit 还是 1 ，否则的话限制取消，后面的数字随便取。如果第 pos 位不取 1 ，那么除了 count 不变以外，其他两个状态还是跟上面一样转移。</p><p>终止状态的话，如果遍历到了最后一位结束，就返回 count 数量就行了，表示当前数字中有 count 个 1 。</p><p>这样的话会有很多重复计算的状态，所以需要用到记忆化搜索，用 dp[pos][count] 来保存 pos, count, limit=0 状态下的答案。为什么只保存 limit=0 的答案呢？因为只有无限制的情况下，后面的数字才能随便取，跟 n 是多少没有关系。否则的话 n 变了后面的值就会受限于 n ，那么就不是一个定值了，没法保存。</p><p>那么 limit=1 不保存的话会不会超时呢？不会的，因为每一位只有一种取法会使得后面的数字继续有限制，所以整体上来看，有限制的状态个数是个常数，并不需要担心超时。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="数学方法（c-）"><a href="#数学方法（c-）" class="headerlink" title="数学方法（c++）"></a>数学方法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> x <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> i <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数位dp（c-）"><a href="#数位dp（c-）" class="headerlink" title="数位dp（c++）"></a>数位dp（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pos<span class="token punctuation">)</span> <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>limit <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ub <span class="token operator">=</span> limit <span class="token operator">?</span> a<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ub<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pos<span class="token number">-1</span><span class="token punctuation">,</span> count<span class="token operator">+</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limit<span class="token operator">&amp;&amp;</span>i<span class="token operator">==</span>a<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> limit <span class="token operator">?</span> res <span class="token operator">:</span> dp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token punctuation">[</span><span class="token operator">++</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            n <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学方法（python）"><a href="#数学方法（python）" class="headerlink" title="数学方法（python）"></a>数学方法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countDigitOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            res <span class="token operator">+=</span> n <span class="token operator">//</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> i            x <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">//</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span>            res <span class="token operator">+=</span> i <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> x            i <span class="token operator">*=</span> <span class="token number">10</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 523】连续的子数组和</title>
      <link href="/2020/02/02/leetcode-523/"/>
      <url>/2020/02/02/leetcode-523/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[23,2,4,6,7], k = 6输出：True解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[23,2,6,4,7], k = 6输出：True解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>数组的长度不会超过 10000 。</li><li>你可以认为所有数字总和在 32 位有符号整数范围内。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>直接枚举所有的区间，然后求出每个区间的和，看是不是 k 的整数倍就行了。这种方法时间复杂度是 $O(n^3)$ ，一定过不了的。</p><h3 id="前缀和优化"><a href="#前缀和优化" class="headerlink" title="前缀和优化"></a>前缀和优化</h3><p>还是枚举所有区间，但是预处理的时候把所有的前缀和保存到数组里，这样区间求和就可以直接计算出来了。最后时间复杂度是 $O(n^2)$ ，理论上应该还是没法通过，但是这题数据太弱，竟然勉强通过了。</p><h3 id="求余优化"><a href="#求余优化" class="headerlink" title="求余优化"></a>求余优化</h3><p>假设前缀和为 sum ，那么区间 [i, j] 的和就可以表示为 sum[j]-sum[i-1] ，如果它是 k 的倍数，就说明了 sum[j] 和 sum[i-1] 模 k 的余数是相同的。</p><p>那么我们就可以提前把 sum 数组里的每个数都对 k 求余，然后看有没有两个余数是相同的，并且距离大于等于 2 就行了。</p><p>这只需要用一个哈希表就可以判断一个数有没有在之前出现过了。如果一个数没有出现过，就把它的下标放进哈希表。否则的话就判断当前下标和哈希表中的下标差值，如果大于等于 2 ，就找到合法区间了，直接返回 true 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">checkSubarraySum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        mp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>sum <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">==</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">checkSubarraySum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        mp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        mp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            sum <span class="token operator">%=</span> k            <span class="token keyword">if</span> sum <span class="token operator">not</span> <span class="token keyword">in</span> mp<span class="token punctuation">:</span>                mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> mp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>c++ 有多种实现方法，可以用 map 、hash_map 、unordered_map 等多种数据结构。其中 hash_map 不在标准库里，这里没法使用。理论上 unordered_map 比 map 会快一点，但是实际运行中没有发现差别。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 115】不同的子序列</title>
      <link href="/2020/02/01/leetcode-115/"/>
      <url>/2020/02/01/leetcode-115/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。</p><p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：S = "rabbbit", T = "rabbit"输出：3解释：如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。(上箭头符号 ^ 表示选取的字母)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：S = "babgbag", T = "bag"输出：5解释：如下图所示, 有 5 种可以从 S 中得到 "bag" 的方案。 (上箭头符号 ^ 表示选取的字母)babgbag^^ ^babgbag^^    ^babgbag^    ^^babgbag  ^  ^^babgbag    ^^^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="dfs-记忆化搜索"><a href="#dfs-记忆化搜索" class="headerlink" title="dfs+记忆化搜索"></a>dfs+记忆化搜索</h3><p>这题要求字符串 s 中有多少子序列正好等于字符串 t ，那么我们不如从最后一个字符看起，假设 s 和 t 的长度分别为 n 和 m 。</p><p>如果 s[n-1] 和 t[m-1] 不相等，那么显然只能在 s[0] 到 s[n-2] 之中寻找 t 。</p><p>如果 s[n-1] 和 t[m-1] 相等，那么有两种选择。一种是这两个字符对应上，然后在 s[0] 到 s[n-2] 之中寻找 t[0] 到 t[m-2] 。另一种是不用 s[n-1] ，还是和上一种情况一样，在 s[0] 到 s[n-2] 之中寻找 t 。两种选择的方案数加起来就是答案了。</p><p>那么递归终止条件是什么呢？如果发现 s 已经空了，但是 t 还有字符没有对应上，那么方案数一定为 0 。如果 t 空了，那么不管 s 还剩多少字符，都说明 t 已经找到对应的子序列了，方案数加 1 。</p><p>为了防止重复计算，还要加上记忆化搜索，用数组记录一下每个状态的方案数。状态 (i, j) 就表示在 s[0] 到 s[i] 中寻找 t[0] 到 t[j] 的方案数。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>当然一般上面那种 dfs 都可以转化成动态规划的写法。</p><p>这里动态规划就是从长度比较短的字符串开始求解。初始状态是 dp[i][0] ，表示 s[0] 到 s[i] 之中有多少个 t[0] ，这很容易求出来。</p><p>然后两层循环遍历两个的字符串的结尾，跟上面 dfs 方法一样，如果 s[i] 和 t[j] 不相等，那么 dp[i][j] = dp[i-1][j] ；否则的话再加上一个 dp[i-1][j-1] 就行了。</p><h3 id="动态规划-空间优化"><a href="#动态规划-空间优化" class="headerlink" title="动态规划+空间优化"></a>动态规划+空间优化</h3><p>上面动态规划方法有个问题就是字符串如果太长的话，空间会吃不消。而仔细观察就会发现，当循环到 i ，然后遍历 j 的时候，其实只会用到 i-1 的状态。那么我们就可以去掉第一维，只保存 j 的所有状态就行了。</p><p>但是有个注意的点是，第二层循环 j 的顺序要变一下，要从大往小遍历。因为 j 需要用到 (i-1, j-1) 时刻的状态值，如果你从小到大遍历，那么 (i, j-1) 的方案数就会把 (i-1, j-1) 的方案数覆盖掉，之后你获取到的就不是 i-1 时刻的方案数了。</p><p>另一个小区别是 dp[i][0] 的计算被移到了第一层循环的最后，而不是初始化就计算好了。这是因为第一维 i 被去掉了，所以只能在用到的时候再更新计算。</p><h3 id="动态规划-空间优化-时间优化"><a href="#动态规划-空间优化-时间优化" class="headerlink" title="动态规划+空间优化+时间优化"></a>动态规划+空间优化+时间优化</h3><p>其实上面一个方法速度已经不错了，但是时间上还是有优化的余地的。</p><p>可以发现，只有当 s[i] = t[j] 的时候，才需要更新 (i, j) 的方案数。所以我们只需要提前预处理出来每个字母 s[i] 在 字符串 t 中的哪些位置出现过就行了。然后遍历的时候只需要直接取出这些位置来更新就行了。</p><p>而实际运行中也会发现， dfs 要比动态规划快很多！这是因为 dfs 只会遍历合法的那些状态，而动态规划会把所有状态都计算出来，不管对最后的答案有没有帮助。</p><p>举个例子，s = “abcbbbb” ， t = “abc” ，因为 t 只在 s 的前三个字母中出现了，所以如果我们寻找 t 的子串 “ab” 在 s 中出现次数的时候，从第二个 b 开始都是没有任何意义的，因为后面都没有 c 给你匹配了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="dfs-记忆化搜索（c-）"><a href="#dfs-记忆化搜索（c-）" class="headerlink" title="dfs+记忆化搜索（c++）"></a>dfs+记忆化搜索（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span><span class="token operator">&amp;</span> dp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化（c-）"><a href="#动态规划-空间优化（c-）" class="headerlink" title="动态规划+空间优化（c++）"></a>动态规划+空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化-时间优化（c-）"><a href="#动态规划-空间优化-时间优化（c-）" class="headerlink" title="动态规划+空间优化+时间优化（c++）"></a>动态规划+空间优化+时间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">pos</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pos<span class="token punctuation">[</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> sz<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> p <span class="token operator">=</span> pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>p<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dfs-记忆化搜索（python）"><a href="#dfs-记忆化搜索（python）" class="headerlink" title="dfs+记忆化搜索（python）"></a>dfs+记忆化搜索（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>m <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（python）"><a href="#动态规划（python）" class="headerlink" title="动态规划（python）"></a>动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>m <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化（python）"><a href="#动态规划-空间优化（python）" class="headerlink" title="动态规划+空间优化（python）"></a>动态规划+空间优化（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> m        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化-时间优化（python）"><a href="#动态规划-空间优化-时间优化（python）" class="headerlink" title="动态规划+空间优化+时间优化（python）"></a>动态规划+空间优化+时间优化（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> m        pos <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>            pos<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>j<span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> pos<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这题还有个坑爹的地方，就是用动态规划写的时候，数组数据类型必须定义成 long 类型，否则会爆 int 范围，但是最终的答案又在 int 范围内。这其实就是因为动态规划计算了很多无用的状态，这些状态里有超出 int 范围的。而 dfs 用 int 就完全没有问题。</p><p>本题还是非常不错的，带你一步步从最好写的 dfs ，然后转化成动态规划，然后优化空间，减少数组维度，最后优化时间。优化时间在 c++ 上面提升不明显，但是 python 提升非常大，直接超过了 100% 的方法。</p><p>时间上还有一些小 trick ，我这里没有考虑，留给大家思考。比如对于状态 (i, j) ，如果 n-i &lt; m-j ，那么就没必要更新了，因为 s 中剩下来的字符串都不够 t 剩下来的去匹配的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 239】滑动窗口最大值</title>
      <link href="/2020/01/31/leetcode-239/"/>
      <url>/2020/01/31/leetcode-239/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong><br>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双端单调队列"><a href="#双端单调队列" class="headerlink" title="双端单调队列"></a>双端单调队列</h3><p>本题要找长度为 k 的区间的最大值。模拟这个区间的移动过程，可以发现，右边增加一个数，左边必然会去掉一个数。</p><p>那么最大的数有什么性质呢？可以发现，如果扫描区间末尾，在已经遍历过的数之中，一个数 a 在 b 前面，并且 a 还比 b 小，那么 a 在之后的区间里永远无法成为最大值。</p><p>所以我们遍历到一个数时，它之前的所有比它小的数都可以去掉了，只保留比它大的数就行了。这就让人想到了之前介绍过的单调栈，但是本题中是先进先出，所以要改用单调队列。此外队列末尾不仅要增加元素，还得维护单调递减，适当去除一些元素，所以队列两端都得有插入和删除的功能。所以本题要使用双端队列，而队列中的元素又是单调递减的，所以又是双端单调队列。</p><p>这样思路就很明确了：</p><ul><li>遍历元素 nums[i] ，然后跟队列尾部元素比较，如果比尾部元素大，就出队，然后继续比较，直到 nums[i] 小于尾部元素，然后将它入队。</li><li>然后用一下队列首部元素的下标，计算出队列中区间的长度，如果大于 k 了，那么队首元素就要出队。</li><li>最后队首元素就是当前区间的最大值。</li></ul><h3 id="分块法"><a href="#分块法" class="headerlink" title="分块法"></a>分块法</h3><p>试想如果我们将数组划分为相同大小的若干块，每一块中最大值都是知道的话，那么要求区间最大值，只需要看它在哪几块里就行了。</p><p>那么块的大小应该设成多少呢？</p><p>如果块大小为 k ，就可以发现长度为 k 的区间 [i, j] 要么正好就是一个完整的块，要么跨越了两个相邻块。那么我们只需要知道 i 到它那块末尾元素中最大值，以及 j 到它那块开头最大值就行了，两个部分合并求最大值就是区间的最大值了。而每个元素到它自己那块的开头和末尾的最大值都可以预处理出来，方法和求前缀和类似。</p><p>那为什么块大小不能是其他值呢？如果块大小大于 k ，那么会出现区间完全包含于一块之中的情况，那就和不分块一样了。如果块大小小于 k ，那么就会出现区间横跨了好几块，那么还得遍历中间块的最大值。极端情况下如果块大小为 1 ，那么就等于暴力求解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="双端单调队列（c-）"><a href="#双端单调队列（c-）" class="headerlink" title="双端单调队列（c++）"></a>双端单调队列（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">)</span> Q<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端单调队列-数组实现（c-）"><a href="#双端单调队列-数组实现（c-）" class="headerlink" title="双端单调队列+数组实现（c++）"></a>双端单调队列+数组实现（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Q</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-</span>l <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>r<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            Q<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分块法（c-）"><a href="#分块法（c-）" class="headerlink" title="分块法（c++）"></a>分块法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lmax</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rmax</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">==</span> n<span class="token number">-1</span><span class="token punctuation">)</span> rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端单调队列（python）"><a href="#双端单调队列（python）" class="headerlink" title="双端单调队列（python）"></a>双端单调队列（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collections<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        Q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>Q<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                Q<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            Q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">-</span> Q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">:</span>                Q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双端单调队列-数组实现（python）"><a href="#双端单调队列-数组实现（python）" class="headerlink" title="双端单调队列+数组实现（python）"></a>双端单调队列+数组实现（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collections<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        Q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> r<span class="token operator">-</span>l <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>r<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>            Q<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> i            r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> i <span class="token operator">-</span> Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>             <span class="token keyword">if</span> i <span class="token operator">>=</span> k<span class="token number">-1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>Q<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分块法（python）"><a href="#分块法（python）" class="headerlink" title="分块法（python）"></a>分块法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> collections<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        lmax<span class="token punctuation">,</span> rmax <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i<span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>k <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">==</span> n<span class="token number">-1</span><span class="token punctuation">:</span>                rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                rmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>rmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>max<span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>双端队列在 c++ 和 python 中都有 deque 的实现，如果你不会用的话，也可以用一个数组自己模拟一下，我觉得反而更加方便一点。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 312】戳气球</title>
      <link href="/2020/01/30/leetcode-312/"/>
      <url>/2020/01/30/leetcode-312/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] <em> nums[i] </em> nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,5,8]输出：167解释：nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="dfs-记忆化搜索"><a href="#dfs-记忆化搜索" class="headerlink" title="dfs+记忆化搜索"></a>dfs+记忆化搜索</h3><p>对于区间 [l, r] ，我们考虑最后一个被戳破的气球 k ，那么之前的步骤我们可以分为两步，也就是求 [l, k-1] 和 [k+1, r] 之间的最大分数。</p><p>那么为什么不考虑先戳破 k 呢？因为这样的话 [l, k-1] 和 [k+1, r] 就会连接在一起，两个子状态就不能独立计算了，互相会产生影响。</p><p>两个子区间的最大的分算完之后，最后 k 的得分就是 nums[l-1] <em> nums[k] </em> nums[r+1] ，取使得总得分最高的 k 就行了。</p><p>有一个小技巧就是，提示里也说了，就是刚开始的时候在首尾各添加一个分数为 1 的虚拟气球。</p><p>但是直接这样递归会超时，因为有很多的子状态都重复计算了，所以可以用一个全局的数组保存每个状态的分数。初始化为 -1 ，如果某个状态计算过了，就直接返回它的值就行了，不然就递归计算。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>上面的方法是自顶向下的，其实也可以转化成自底向上的，也就是从小的区间开始算起，最后算最大的，这就是动态规划的方法，具体的实现细节和上面是一模一样的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="dfs-记忆化搜索（c-）"><a href="#dfs-记忆化搜索（c-）" class="headerlink" title="dfs+记忆化搜索（c++）"></a>dfs+记忆化搜索（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> k<span class="token number">-1</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">+</span>len<span class="token number">-1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dfs-记忆化搜索（python）"><a href="#dfs-记忆化搜索（python）" class="headerlink" title="dfs+记忆化搜索（python）"></a>dfs+记忆化搜索（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token keyword">if</span> l <span class="token operator">></span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>l<span class="token punctuation">,</span> k<span class="token number">-1</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（python）"><a href="#动态规划（python）" class="headerlink" title="动态规划（python）"></a>动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxCoins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">-</span>l<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> i <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 424】替换后的最长重复字符</title>
      <link href="/2020/01/29/leetcode-424/"/>
      <url>/2020/01/29/leetcode-424/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：s = "ABAB", k = 2输出：4解释：用两个'A'替换为两个'B',反之亦然。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：s = "AABABBA", k = 1输出：4解释：将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。子串 "BBBB" 有最长重复字母, 答案为 4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong><br>字符串长度和 k 不会超过 10^4。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题和之前做过的一题非常类似：<a href="https://godweiyang.com/2020/01/09/leetcode-1004/">每日算法系列【LeetCode 1004】最大连续1的个数 III</a>，只不过这题字符数量变成了 26 个。</p><p>方法和那题类似，都是用滑动窗口。用数组 count 记录每个字母出现的次数，并且用变量 cmax 记录窗口中出现次数最多的字母数量。</p><p>当前窗口是 [l, r] ，如果保留窗口中出现次数最多的字母，将其他字母全部替换为这个字母，那么替换次数就是 $r - l + 1 - cmax$ 。如果它大于 k ，那就说明不能继续向右扩展，而是需要左端点右移，缩小窗口了。缩小的过程中时刻更新 cmax 的值就行了，直到 $r - l + 1 - cmax$ 再次小于等于 k ，然后继续右移 r 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>cmax<span class="token punctuation">,</span> <span class="token operator">++</span>count<span class="token punctuation">[</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> cmax <span class="token operator">></span> k<span class="token punctuation">)</span>                count<span class="token punctuation">[</span>s<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> cmax<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> r <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            cmax <span class="token operator">=</span> max<span class="token punctuation">(</span>cmax<span class="token punctuation">,</span> count<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> cmax <span class="token operator">></span> k<span class="token punctuation">:</span>                count<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>ord<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            r <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>注意这里代码实现上面有个很大的问题，就是右移左端点缩小窗口的时候， cmax 并没有跟着减小，这样为什么还是对的呢？这种情况下， cmax保存的其实是历史出现次数最多的字母的次数。而你不改变 cmax ，就会导致中间过程中出现很多不符合题意的窗口，也就是实际要修改的数量大于 k 的窗口，但是因为你 cmax 偏大，算下来修改数量偏小，它又是符合题意的。不过不影响，这些错误的窗口的长度一定是小于你之前算到的正确窗口的长度的（如果大于了，那么 cmax 一定会被更新）。</p><p><strong>下面解释来自于algsCG：</strong></p><blockquote><p>因为我们只对最长有效的子字符串感兴趣，所以我们的滑动窗口不需要收缩，即使窗口可能覆盖无效的子字符串。我们可以通过在右边添加一个字符来扩展窗口，或者将整个窗口向右边移动一个字符。而且我们只在新字符的计数超过历史最大计数（来自覆盖有效子字符串的前一个窗口）时才增长窗口。也就是说，我们不需要精确的当前窗口的最大计数;我们只关心最大计数是否超过历史最大计数;这只会因为新字符而发生。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 42】接雨水</title>
      <link href="/2020/01/28/leetcode-42/"/>
      <url>/2020/01/28/leetcode-42/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="1.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[0,1,0,2,1,0,1,3,2,1,2,1]输出：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法1（按列算）"><a href="#方法1（按列算）" class="headerlink" title="方法1（按列算）"></a>方法1（按列算）</h3><p>这也是最容易理解的一种方法，我们计算每一个柱子上方的水最多有多高就行了，而这个高度取决于它的左右两边最高的柱子分别是多高。</p><p>当然可以暴力求左右两端最高的高度了，不过其实只需要预处理一下，用数组保存一下每个位置左右两端最高的高度就行了。</p><p>最后答案的话就是用左右两边最高高度的较小值，减去这根柱子的高度。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ ，需要扫描两遍数组。</p><h3 id="方法2（按行算）"><a href="#方法2（按行算）" class="headerlink" title="方法2（按行算）"></a>方法2（按行算）</h3><p>我们可以发现，每一行水左右肯定都会被柱子卡住（显然是废话）。那么从左向右遍历柱子，如果高度在下降，那么显然不会蓄水。如果高度上升了，那就说明中间是个低点，这之间可以蓄水。而这个下降的高度用单调栈来维护就行了，栈里我们只放下标。</p><p>那到底蓄水多少呢？假设 q 是栈顶下标，p 是栈顶第二个元素下标，那么一定有 $h[p] \ge h[q]$ 。现在进来一个 $h[i] &gt; h[q]$ ，那么 q 就是一个低点，而 p ， q ， i 之间的蓄水（比 $h[q]$ 高，比 $h[p]$ 和 $h[i]$ 都低的部分）可以计算为 $(\min(h[p], h[i]) - h[q])\cdot(i - p - 1)$ 。然后把 q 出栈，继续用栈顶两个元素计算。</p><p>那么为什么这里只需要计算 p 和 i 之间比 $h[q]$ 高的那部分矩形就行了呢？因为比它低的部分在之前都已经算过了，而比它高的部分在之后还会计算到。</p><p>用下面这张示意图可以看的更清楚一点：</p><p><img src="1.jpg" alt></p><p>红色表示栈里的元素，白色表示已经出栈了，绿色表示当前准备进栈的元素。那么这时候我们上面求的就是 3 号水块的面积，而 1 和 2 水块在之前进栈操作中就已经求出来了， 4 水块的话在之后（q 出栈，p 和 i 进行比较）也会被计算到。</p><p>时间复杂度 $O(n)$ ，空间复杂度 $O(n)$ ，需要扫描一遍数组，但是每个元素会入栈再出栈，所以操作次数和方法1其实是一样的。</p><h3 id="方法3（双指针优化方法1）"><a href="#方法3（双指针优化方法1）" class="headerlink" title="方法3（双指针优化方法1）"></a>方法3（双指针优化方法1）</h3><p>方法 1 中，我们需要用到一个额外数组来保存左右两边的最大值，其实我们可以用双指针法来规避这个问题。</p><p>考虑用两个指针 l 和 r 分别从最左和最右端往中间靠拢，同时用 lmax 记录 l 左边的最高高度，用 rmax 记录 r 右边的最高高度。</p><p>此时如果 $h[l] &lt; h[r]$ ，那么我们计算 l 处能蓄水多高，如果 $h[l] \ge h[r]$ ，我们计算 r 处蓄水多高。这样我们时刻只计算低的那边的答案，就能保证 l 两边的最高处较小值一定是 lmax ，r 两边同理。为什么呢？你模拟一遍左右切换的过程就会发现，当 $h[l] &gt; h[r]$ 的时候，切换到计算 r 那边去了，再继续等到 $h[r] &gt; h[l]$ 的时候，又切回计算 l 这边了，所以两端 l 和 r 的值始终保证：当它固定不动，计算另一端高度时，它一定是这一边最高的。</p><p>那么如果 $h[l] &lt; h[r]$ ，我们怎么计算 $h[l]$ 处蓄水多高呢？如果 $h[l] \ge lmax$ ，那么 l 处根本就没法蓄水，因为它是最高的，所以更新 lmax 就行了。否则的话 l 两边最大高度较小值一定是 lmax ，还是按照方法 1 那样计算就行了。</p><p>这样的话，就不需要额外维护一个高度数组了。时间复杂度 $O(n)$ ，空间复杂度 $O(1)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1（c-）"><a href="#方法1（c-）" class="headerlink" title="方法1（c++）"></a>方法1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lmax</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> rmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rmax<span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（c-）"><a href="#方法2（c-）" class="headerlink" title="方法2（c++）"></a>方法2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法3（c-）"><a href="#方法3（c-）" class="headerlink" title="方法3（c++）"></a>方法3（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">,</span> lmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">>=</span> lmax<span class="token punctuation">)</span> lmax <span class="token operator">=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> res <span class="token operator">+</span><span class="token operator">=</span> lmax <span class="token operator">-</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>=</span> rmax<span class="token punctuation">)</span> rmax <span class="token operator">=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> res <span class="token operator">+</span><span class="token operator">=</span> rmax <span class="token operator">-</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法1（python）"><a href="#方法1（python）" class="headerlink" title="方法1（python）"></a>方法1（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        lmax <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> lmax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        rmax<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rmax <span class="token operator">=</span> max<span class="token punctuation">(</span>rmax<span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">+=</span> min<span class="token punctuation">(</span>lmax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rmax<span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（python）"><a href="#方法2（python）" class="headerlink" title="方法2（python）"></a>方法2（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                mid <span class="token operator">=</span> st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                st<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> len<span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span>                res <span class="token operator">+=</span> <span class="token punctuation">(</span>min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> st<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            st<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法3（python）"><a href="#方法3（python）" class="headerlink" title="方法3（python）"></a>方法3（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> lmax<span class="token punctuation">,</span> rmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">>=</span> lmax<span class="token punctuation">:</span>                    lmax <span class="token operator">=</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> lmax <span class="token operator">-</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>=</span> rmax<span class="token punctuation">:</span>                    rmax <span class="token operator">=</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> rmax <span class="token operator">-</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题方法还是很多的，最好需要画个示意图，模拟一下运行过程。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 810】黑板异或游戏</title>
      <link href="/2020/01/27/leetcode-810/"/>
      <url>/2020/01/27/leetcode-810/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个黑板上写着一个非负整数数组 nums[i] 。小红和小明轮流从黑板上擦掉一个数字，小红先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p><p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p><p>假设两个玩家每步都使用最优解，当且仅当小红获胜时返回 true。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1, 1, 2]输出：false解释：小红有两个选择: 擦掉数字 1 或 2。如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么小明可以擦掉任意数字，因为小红会成为擦掉最后一个数字的人，她总是会输。如果小红擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。小红仍然会输掉游戏。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= N &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 2^16</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>小红获胜的条件就是，某一步轮到她的时候，所有数异或等于 0 。</p><p>而反过来，她输的条件就是，面对 n 个数，无论她选哪个数，去掉这个数之后剩下的数的异或都等于 0 。</p><p>假设 n 个数的异或为 S ，也就是令：<br>$$<br>S = x_1 \oplus x_2 \oplus \dots \oplus x_n<br>$$<br>因为两个相同的数的异或为 0 ，所以去掉任意一个数 $x_i$ 之后的异或为 $S \oplus x_i = 0$ ，所以 $S = x_i$ ，也就是所有的数都相等。</p><p>此时如果 n 是偶数，那么 n 个数的异或必为 0 ，和小红必输矛盾了，所以 n 一定要是奇数。</p><p>也就是说，如果 n 是偶数，那么小红总有办法去掉一个数，然后使得剩下的数异或不为 0 ，这时小明就没办法获胜。而不管小明擦除哪个数，轮到小红的时候个数又变成了偶数，小红就可以继续不输擦除下去。直到最后，一定是小红面对着空的数集，最终获胜。</p><p>而 n 是奇数的时候，无论小红选什么数，小明面对的都是偶数个数，那么小明必胜。</p><p>综上，n 是偶数小红必胜，或者刚开始 n 个数异或就是 0 ，这样不管奇偶，小红都能获胜。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">xorGame</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> x <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">!</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> reduce<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">xorGame</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> reduce<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>xor<span class="token punctuation">,</span> nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>官方题解是这么说的：如果 n 是偶数，那么小红有很大概率获胜，因为如果游戏能够一直进行下去，小明将会是擦除最后一个数的人，轮到小红时黑板上已经没有数，小红获胜。然后再推测 n 是偶数情况下的必胜条件，但是这样带有一点先猜后验证的成分。</p><p>所以我的推测方法直接从必胜条件出发，推测出 n 是偶数，这样过渡自然，更符合思考的路线。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 153】寻找旋转排序数组中的最小值</title>
      <link href="/2020/01/26/leetcode-153/"/>
      <url>/2020/01/26/leetcode-153/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>(例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2])。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,4,5,1,2]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[4,5,6,7,0,1,2]输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题如果直接遍历一遍的话，时间复杂度是 $O(n)$ ，也能过。但是这题显然想要你更快，也就是用 $O(\log n)$ 的时间复杂度来做出来，那我们只能选择用二分法。</p><p>因为序列从中间切开来，然后调换过顺序，所以是先上升，再下降一下，然后再上升。并且第二段上升的最大值 $nums[n-1]$ 是一定小于第一段上升的最小值 $nums[0]$ 的，所以最小值一定是第二段的第一个数。</p><p>假设我们二分的时候，左端点 l ，右端点 r ，中间点是 m 。</p><p>如果 $nums[l] &gt; nums[r]$ ，那说明左端点在第一段，右端点在第二段。这时如果 $nums[m] \ge nums[l]$ ，那么 m 也在第一段，所以 l 需要右移；否则的话 m 在第二段， r 需要左移。</p><p>如果 $nums[l] \le nums[r]$ ，那么两个端点都在第二段，是单调上升的，那最小值一定就是 l 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    r <span class="token operator">=</span> m<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> l<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> m            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> l        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 386】字典序排数</title>
      <link href="/2020/01/26/leetcode-386/"/>
      <url>/2020/01/26/leetcode-386/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 n, 返回从 1 到 n 的字典顺序。</p><p>例如，给定 n = 13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。</p><p>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h3><p>首先把 1 到 n 所有整数的字符串形式放进数组，然后对这个字符串数组进行排序，最后把所有字符串转换成对应的整数就行了。</p><p>时间复杂度是 $O(n \log n)$ ，空间复杂度是 $O(n)$。</p><h3 id="字典树法"><a href="#字典树法" class="headerlink" title="字典树法"></a>字典树法</h3><p>还可以按从小到大顺序直接生成所有整数，首先观察如下的字典树：</p><p><img src="1.jpg" alt="字典树"></p><p>可以看出来，这是一棵 10 叉的字典树，第一层根节点，第二层没有 0 （因为不能有前导 0 ），后面的每一层都是在上一层的基础上添加一位 0 到 9 。</p><p>而如果按照前序遍历的顺序遍历这棵树，得到的整数序列就是字典序从小到大的。但是这棵树深度是没有限制的啊，所以如果遍历到的数字 x 大于 n 的话，就要结束遍历，回溯到上一层。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="排序法（c-）"><a href="#排序法（c-）" class="headerlink" title="排序法（c++）"></a>排序法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> s<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            s<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序法（python）"><a href="#排序法（python）" class="headerlink" title="排序法（python）"></a>排序法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> res<span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字典树法（c-）"><a href="#字典树法（c-）" class="headerlink" title="字典树法（c++）"></a>字典树法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字典树法（python）"><a href="#字典树法（python）" class="headerlink" title="字典树法（python）"></a>字典树法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">></span> n<span class="token punctuation">:</span>            <span class="token keyword">return</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>i<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>字典序法的递归需要耗费更大的空间，而在实际运行中， python 代码排序法的运行速度甚至比字典序法更快，这说明了 python 递归是真的慢。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 825】适龄的朋友</title>
      <link href="/2020/01/25/leetcode-825/"/>
      <url>/2020/01/25/leetcode-825/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>人们会互相发送好友请求，现在给定一个包含有他们年龄的数组，ages[i] 表示第 i 个人的年龄。</p><p>当满足以下条件时，A 不能给 B（A、B不为同一人）发送好友请求：</p><ul><li>age[B] &lt;= 0.5 * age[A] + 7</li><li>age[B] &gt; age[A]</li><li>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</li></ul><p>否则，A 可以给 B 发送好友请求。</p><p>注意如果 A 向 B 发出了请求，不等于 B 也一定会向 A 发出请求。而且，人们不会给自己发送好友请求。 </p><p>求总共会发出多少份好友请求?</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[16,16]输出：2解释：二人可以互发好友申请。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[16,17,18]输出：2解释：好友请求可产生于 17 -> 16, 18 -> 17.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[20,30,100,110,120]输出：3解释：好友请求可产生于 110 -> 100, 120 -> 110, 120 -> 100.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= ages.length &lt;= 20000.</li><li>1 &lt;= ages[i] &lt;= 120.</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>仔细观察一下这三个条件，我们把 $age[A]$ 简写为 a ，把 $age[B]$ 简写为 b ，那么如果 a 可以向 b 发送邀请的话，必须同时满足下面三个条件：</p><ul><li>$a \le 2b-15$</li><li>$a \ge b$</li><li>$a \ge 100 || b \le 100$</li></ul><p>可以发现，如果满足了条件 2 ，那么一定会满足条件 3 ，所以最终只需要满足 $b \le a \le 2b-15$ 就行了。</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>这题最暴力的方法显然就是遍历任意数对 a 和 b ，看两个数是否符合这个条件，但是时间复杂度太高，不可行。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>另一个方法是先对数组进行排序，然后遍历每一个数作为 b ，然后二分寻找 $2b-15$ 在哪就行了，中间的数字都可以作为 a ，这样最终的时间复杂度是 $O(n \log n)$ 。</p><h3 id="计数法"><a href="#计数法" class="headerlink" title="计数法"></a>计数法</h3><p>有没有更好的办法呢？注意到年龄的范围最大只有 120 ，那么我们可以统计每个年龄出现的人数，用 $c[i]$ 来表示 i 岁的人数。那么 b 岁的人数就有 $c[b]$ 个，而符合条件的 a 在 $[b, 2b-15]$ 之间。其中 $a = b$ 需要单独讨论，因为包含了自己邀请自己的情况，这种情况邀请的数量是 $c[b] \cdot (c[b] - 1)$ 。而 a 在 $[b+1, 2b-15]$ 范围内的话，数量是 $\sum_{b+1 \le a \le 2b-15}{c[b] \cdot c[a]}$ 。所以最终的总数量就是：<br>$$<br>\begin{aligned}<br>S_b &amp;= \sum_{b+1 \le a \le 2b-15}{c[b] \cdot c[a]} + c[b] \cdot (c[b] - 1)    \\<br>&amp;= c[b] \cdot (\sum_{b \le a \le 2b-15}{c[a]} - 1)<br>\end{aligned}<br>$$<br>如果用前缀和 $sum$ 来预处理 $c$ 数组的话，可以进一步简化为：<br>$$<br>S_b = c[b] \cdot (sum[2b-15] - sum[b-1] - 1)<br>$$<br>考虑到 $2b-15$ 可能会大于数组中年龄的最大值，所以我们设置一个阈值来截断它。最终的总数量就是 $\sum_{b}{S_b}$ ，这里 b 的取值范围是有讲究的。因为不等式需要满足 $b \le 2b-15$ ，所以 $b \ge 15$ 。这样最终的时间复杂度降到了 $O(MA)$ ，其中 MA 表示年龄的最大值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numFriendRequests</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ages<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> MA <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ages<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>ages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> MA<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span> b <span class="token operator">&lt;=</span> MA<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>sum<span class="token punctuation">[</span><span class="token function">min</span><span class="token punctuation">(</span>MA<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>b<span class="token number">-15</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>b<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numFriendRequests</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ages<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        MA <span class="token operator">=</span> <span class="token number">120</span>        count<span class="token punctuation">,</span> S <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        n<span class="token punctuation">,</span> res <span class="token operator">=</span> len<span class="token punctuation">(</span>ages<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">for</span> age <span class="token keyword">in</span> ages<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>age<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> MA<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> count<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>min<span class="token punctuation">(</span>MA<span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>b<span class="token number">-15</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-</span> S<span class="token punctuation">[</span>b<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心有所鼠，鼠年快乐~</title>
      <link href="/2020/01/24/happy-shu-year/"/>
      <url>/2020/01/24/happy-shu-year/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><blockquote><p>首先，新的一年祝大家鼠年快乐啦。不要问我心有所鼠到底是什么意思，我心里只有学习~ 虽然这个年发生了很多事情，可能不是很好过，但是我相信一切都会过去的。我们应该微笑着面对困难，奥里给~</p></blockquote><p>今年因为武汉新型冠状病毒的传播，哪里都不敢去了呢。大家最好还是宅在家里，不要去拜年串门了。但是长辈们说了不听啊，特别是广大农村里的老人们，他们可不在意，一口一个没事，劝了也不听呢。反正我是打算好了，初一开始哪里都不去了，死宅在家里啦~</p><p><img src="4.jpg" alt="钟南山院士友情提示"></p><p>不过我还是恰了顿百人年夜饭，现在新闻都劝人别聚会，别串门，想想都有点怕，希望没事！</p><p>也不知道来吃饭的有没有武汉回来的，应该没有吧。老人特别多，抵抗力差，疾病多，希望一切安康~</p><p><img src="1.jpg" alt="村里的农家乐，还有小舞台可以K歌"></p><p><img src="2.jpg" alt="一共11桌，估摸着一百多号人，后怕！"></p><p>两个表外甥女也越长越可爱啦，也在上海读书，这次回来过年了~</p><p><img src="3.jpg" alt="卡哇伊的小妹妹"></p><p>很多武汉小伙伴都逃到上海去了，我马上也要“逃回去”了，这不票都买好了。</p><p><img src="5.jpg" alt="大年初七就溜咯"></p><p>都说大城市传染源更多，看起来更危险。而我这苏北农村，情况可能好很多，也没有太多武汉务工回来的人。但是我更相信上海的防护措施，相信上海的医疗条件，相信我们学校的封闭管理。我觉得我宿舍-实验室两点一线，死宅着应该问题不大。</p><p>现在口罩是真的难买，我爸街上药店逛了几圈才买到了10个普通医用口罩，还限购。幸亏我哥给我留了几个N95和一次性无纺布的。这下去上海的路上安心多了，希望到时候能平安到达！</p><p><img src="7.jpg" alt="今年过节不收礼，收礼只收N95"></p><p><img src="6.jpg" alt="不要问我头发哪里去了，问就是没有了"></p><p>最后在鼠年，我只有四个愿望：</p><ul><li>疫情快快好，大家都安康~</li><li>ACL 2020 accepted~</li><li>粉丝up up up~</li><li>心有所鼠~（暗示属老鼠的？）</li></ul><p>最后衷心的祝愿大家鼠年心想事成~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新年 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 376】摆动序列</title>
      <link href="/2020/01/24/leetcode-376/"/>
      <url>/2020/01/24/leetcode-376/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 [6,-3,5,-7,3] 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3,4,5,6,7,8,9]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题题面说的啰里啰唆的，其实就一句话：给你一个序列，找出最长的一个子序列，其中子序列相邻两个数的大小是波形的（也就是大小大小大等等这样的）。</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>用 dfs 枚举所有可能的子序列，然后看最长的是多少，这种方法显然会超时。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>其实看到这道题，我第一个想到了最长上升子序列，这不就变了个形式嘛，于是动态规划解法直接就有了。</p><p>用 $dp[i][s]$ 表示以 $nums[i]$ 结尾的符合条件的最长子序列长度，其中 s 取 1 表示在 $nums[i]$ 处子序列上升，取 0 表示下降。那么我们只需要遍历之前的所有 j ，如果 $nums[j] &lt; nums[i]$ ，那么在 j 处必须是要下降的，更新：<br>$$<br>dp[i][1] = \max_j{\{dp[j][0]\}}<br>$$<br>如果 $nums[j] &gt; nums[i]$ ，那么在 j 处必须是要上升的，更新：<br>$$<br>dp[i][0] = \max_j{\{dp[j][1]\}}<br>$$<br>然后取数组中最大值就是答案了，时间复杂度 $O(n^2)$ 。</p><h3 id="动态规划-时间优化"><a href="#动态规划-时间优化" class="headerlink" title="动态规划+时间优化"></a>动态规划+时间优化</h3><p>换个定义，用 $dp[i][s]$ 表示 $nums[i]$ 之前的最长子序列，注意和上面的区别就是不一定以 $nums[i]$ 结尾了。 s 取 1 表示最后两个数是上升的，取 0 表示最后两个数是下降的。</p><p>这里分为几种情况：</p><ul><li>$nums[i-1] &lt; nums[i]$ :<ul><li>考虑 $dp[i][0]$ ，也就是最后两个数下降的，那肯定不能取 $nums[i]$ ，因为 $nums[i-1]$ 比它更小、更优，所以直接更新为 $dp[i-1][0]$ 。</li><li>考虑 $dp[i][1]$ ，也就是最后两个数上升的，那如果不取 $nums[i]$ ，那更新为 $dp[i-1][1]$ ；如果取的话，我们就要保证 i-1 之前最后两个数是下降的，并且之前的最后一个数小于 $nums[i]$ 。我们可以证明， i-1 之前的最后两个下降的数一定满足：第二个数 $nums[j]$ 是小于 $nums[i]$ 的，因为如果 $nums[j] &gt;= nums[i]$ ，那么 j 到 i 之间的数一定是单调下降的，否则存在更长的子序列，那么就和 $nums[i-1] &lt; nums[i]$ 矛盾了。综上，取的话 $dp[i][1]$ 更新为 $dp[i-1][0]+1$ 。</li></ul></li><li>$nums[i-1] &gt; nums[i]$ :<br>  同样考虑最后两个数上升还是下降，分析和上面一样。</li></ul><p>综上考虑，时间复杂度可以降为 $O(n)$ ，空间复杂度是 $O(n)$ 。</p><h3 id="动态规划-空间优化"><a href="#动态规划-空间优化" class="headerlink" title="动态规划+空间优化"></a>动态规划+空间优化</h3><p>在上面优化的基础上，我们还可以观察到，每一次 $dp[i][s]$ 其实只会用到 $dp[i-1][s]$ ，所以我们只需要保存当前和前一时刻的状态就行了，空间复杂度可以降为 $O(1)$ 。</p><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>其实这题还可以直接贪心做，考虑一段连续的上升序列，最优子序列一定是包括了首尾两个数的，因为首是最小的数，选了它才能给前一个数留出更大的上升空间，而尾是最大的数，选了它才能给下一个数留出更多的下降空间。</p><p>所以我们贪心的扫描一遍数组，遇到上升或者下降的转折点就选取这个数。而如果数组不升不降，也就是不变的话，就不用管它，因为这些相同的数里面只需要选取一个就行了。</p><p>时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-时间优化（c-）"><a href="#动态规划-时间优化（c-）" class="headerlink" title="动态规划+时间优化（c++）"></a>动态规划+时间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划-空间优化（c-）"><a href="#动态规划-空间优化（c-）" class="headerlink" title="动态规划+空间优化（c++）"></a>动态规划+空间优化（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="贪心（c-）"><a href="#贪心（c-）" class="headerlink" title="贪心（c++）"></a>贪心（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">wiggleMaxLength</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> pre_ord <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> ord <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ord <span class="token operator">!=</span> pre_ord<span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>            pre_ord <span class="token operator">=</span> ord<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>鼠年快乐，新年献给大家的第一道题，尽量写的详细一点。</p><p>官方题解没有严谨的证明，虽然方法也是这 5 种，但是没有说清楚，不能令人信服。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 943】最短超级串</title>
      <link href="/2020/01/23/leetcode-943/"/>
      <url>/2020/01/23/leetcode-943/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。</p><p>我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["alex","loves","leetcode"]输出："alexlovesleetcode"解释："alex"，"loves"，"leetcode" 的所有排列都会被接受。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：["catg","ctaagt","gcta","ttca","atgcatc"]输出："gctaagttcatgcatc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 12</li><li>1 &lt;= A[i].length &lt;= 20</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>这是每日算法系列更新以来，做过最难的一道题目了，也是第一次涉及到字符串类型的题目。如果觉得难，可以忽略今天这题。</p></blockquote><p>这题意思就是，给你 n 个字符串，任意两个字符串如果拼接在一起的话，首尾可能会有重合的部分，那么就按照最长的重合部分拼接上去。要求的是 n 个字符串怎么排列，然后依次拼接，得到的最终字符串长度最短？</p><p>最暴力的方法当然就是枚举所有排列，然后把他们拼起来看长度，这样的话光是阶乘的复杂度就不可接受了。</p><p>这题就要用到<strong>状态压缩动态规划</strong>了，按照字面意思理解就是动态规划的状态是经过压缩的，那具体什么意思呢？</p><p>首先我们用二进制来表示每个字符串选取状态， 1 表示选取， 0 表示没有选取。比如 4 个字符串 ，我们选取了第 0 个和第 2 个，那么我们就可以用 1010 来表示这个选取状态，而 1010 转化成 10 进制就是 10 ，所以我们就可以用 10 这个数字来表示这种选取状态。状态最小值是 0 ，表示一个都没有选取，最大值是 $2^n-1$ ，表示所有的字符串都选取了。</p><p>然后定义 $dp[s][i]$ 表示选取状态为 s 的情况下，最后一个字符串是第 i 个的情况下，最短的长度是多少。那么去掉第 i 个字符串，选取状态就变成了 $s \oplus 2^i$ ，其中 $\oplus$ 表示异或操作。然后遍历所有的 $dp[s \oplus 2^i][j]$ ，也就是看前一个状态以哪个字符串结尾长度最短。那么状态更新就是：<br>$$<br>dp[s][i]=\min{\{dp[s \oplus 2^i][j]+A[i].length-o[j][i]\}}<br>$$<br>其中 $o[j][i]$ 表示 $A[j]$ 和 $A[i]$ 最大重合的长度，可以预处理出来。</p><p>与此同时，我们还需要一个数组 $path[s][i]$ ，用来保存 s 状态下结尾是 $A[i]$ 时，前一个字符串最优是哪个。在做完动态规划之后，再进行回溯，找出整个最优序列是什么。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">shortestSuperstring</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                o<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">overlap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> INF<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> s <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">>></span>j<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                            path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                last <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> seq <span class="token operator">=</span> <span class="token punctuation">{</span>last<span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token number">-1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> last<span class="token punctuation">;</span>            last <span class="token operator">=</span> path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">;</span>            seq<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>            s <span class="token operator">=</span> s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>seq<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> seq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string res <span class="token operator">=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>o<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">overlap</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> na <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nb <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>na<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span> <span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>na<span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">overlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>        na<span class="token punctuation">,</span> nb <span class="token operator">=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>min<span class="token punctuation">(</span>na<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> a<span class="token punctuation">[</span>na<span class="token operator">-</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">shortestSuperstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>        n<span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        M <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>n        o <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                o<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>overlap<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>INF<span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> s <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> i <span class="token operator">!=</span> j <span class="token operator">and</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">>></span>j<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>len<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                            dp<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>len<span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>o<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>                            path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j        last <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>M<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">:</span>                last <span class="token operator">=</span> i        seq <span class="token operator">=</span> <span class="token punctuation">[</span>last<span class="token punctuation">]</span>        s <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tmp <span class="token operator">=</span> last            last <span class="token operator">=</span> path<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>last<span class="token punctuation">]</span>            seq<span class="token punctuation">.</span>append<span class="token punctuation">(</span>last<span class="token punctuation">)</span>            s <span class="token operator">=</span> s<span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>tmp<span class="token punctuation">)</span>        seq <span class="token operator">=</span> seq<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> A<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>o<span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>seq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还是有点难度的，我还是看了答案后才自己写出来的，如果实在不会，不要勉强。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 881】救生艇</title>
      <link href="/2020/01/22/leetcode-881/"/>
      <url>/2020/01/22/leetcode-881/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：people = [1,2], limit = 3输出：1解释：1 艘船载 (1, 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：people = [3,2,2,1], limit = 3输出：3解释：3 艘船分别载 (1, 2), (2) 和 (3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：people = [3,5,3,4], limit = 5输出：4解释：4 艘船分别载 (3), (3), (4), (5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题第一直觉就是，对于一个人 people[i] 来说，装了他之后船上还剩 limit-people[i] 的空间，所以第二个人要尽量装能装得下的人中最重的那个。</p><p>那如果直接这么遍历显然不行，时间复杂度是 $O(n^2)$ 的。所以我们先对重量进行排序，然后从最轻的人开始看，如果他能和最重的坐一个船，那就去掉他们俩，在剩下的人里继续找；如果不能的话，那么最重的人只能单独坐船，然后看能不能和第二重的人坐一个船，依次下去。</p><p>具体实现上，只需要用两个指针，一个指着最小的数，一个指着最大的数就行了，时间复杂度是 $O(n)$ ，但是由于还得调用一次快速排序，所以最终时间复杂度是 $O(n \log n)$ 。</p><p>当然，因为这题重量范围比较小，所以如果采用计数排序，可以进一步降低时间复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="双指针（c-）"><a href="#双指针（c-）" class="headerlink" title="双指针（c++）"></a>双指针（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> people<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> people<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>people<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> people<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双指针（python）"><a href="#双指针（python）" class="headerlink" title="双指针（python）"></a>双指针（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        people<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>people<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> people<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> people<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序（c-）"><a href="#计数排序（c-）" class="headerlink" title="计数排序（c++）"></a>计数排序（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> people<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>limit<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> limit<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sp<span class="token punctuation">[</span>count<span class="token punctuation">[</span>people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token punctuation">[</span>people<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sp<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> sp<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序（python）"><a href="#计数排序（python）" class="headerlink" title="计数排序（python）"></a>计数排序（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numRescueBoats</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> people<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> limit<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        sp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>people<span class="token punctuation">)</span>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>limit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> people<span class="token punctuation">:</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> limit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> people<span class="token punctuation">:</span>            sp<span class="token punctuation">[</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        res<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>people<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            res <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> sp<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> sp<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题注意写循环的时候也有技巧的，我们实现的时候，对于最大值 people[r] ，先给他分配一条船，再看最小的人能否和他一条船，如果可以，那就顺便带上（ l 加 1 ），如果不可以的话，那就 r 减 1 ，继续看下一个更重的人。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 829】连续整数求和</title>
      <link href="/2020/01/21/leetcode-829/"/>
      <url>/2020/01/21/leetcode-829/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数 N ，试求有多少组连续正整数满足所有数字之和为 N ?</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：5输出：2解释：5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：9输出：3解释：9 = 9 = 4 + 5 = 2 + 3 + 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：15输出：4解释：15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= N &lt;= 10^9</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道非常经典的数学题，挺基础的，不知道为什么这也能算困难难度的题目？</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>遍历所有的连续数字区间 (i, j) ，然后求和看等不等于 N 。这种方法时间复杂度是 $O(n^2)$ ，显然不可行。</p><h3 id="暴力法优化"><a href="#暴力法优化" class="headerlink" title="暴力法优化"></a>暴力法优化</h3><p>遍历所有的连续数字区间的左端点 i。然后假设区间长度为 n ，那么根据求和公式有 (2i+n-1)n/2=N ，然后只需要看这个方程的解是否是整数就行。时间复杂度可以降到 $O(n)$ ，但还是太高了。</p><h3 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h3><p>根据上面的求和公式，对于起点 i 和长度 n ，求和得到 (2i+n-1)n/2=N 。我们可以先粗略推算一下 i 和 n 的范围，起点 i 的范围是 [1, N]毋庸置疑，而区间长度 n 的范围就可以考究一下了，一个出发点是：上面式子可以解出 i=(N-n(n-1)/2)/n ，而 i&gt;=1 ，可以解出 (n+1)n&lt;=2N ，所以 n 的范围其实只有根号 N 级别，可以直接遍历。另一个出发点是最小的 n 个数加起来就是 1 加到 n 等于 n(n+1)/2 ，这个要小于等于 N ，解出来也是 (n+1)n&lt;=2N 。</p><p>所以我们只需要从 1 开始遍历 n ，直到 (n+1)n&gt;2N 为止，然后判断 (N-n(n-1)/2)/n 是否是整数就行了（前面终止条件可以保证 i 一定大于 0 ）。</p><p>最终时间复杂度降到了 $O(\sqrt(N))$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="数学方法（c-）"><a href="#数学方法（c-）" class="headerlink" title="数学方法（c++）"></a>数学方法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">consecutiveNumbersSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>N <span class="token operator">-</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数学方法（python）"><a href="#数学方法（python）" class="headerlink" title="数学方法（python）"></a>数学方法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">consecutiveNumbersSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> N<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">*</span> N<span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">-</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还可以用质因数分解等方法进一步优化，但是没有必要。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 907】子数组的最小值之和</title>
      <link href="/2020/01/20/leetcode-907/"/>
      <url>/2020/01/20/leetcode-907/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。</p><p>由于答案可能很大，因此返回答案模 10^9 + 7。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 30000</li><li>1 &lt;= A[i] &lt;= 30000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题意思是，遍历所有的连续子数组，然后求所有子数组中最小值之和。</p><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>遍历所有区间，然后对于每个区间找出最小值求和。这种方法时间复杂度是 $O(n^3)$ ，显然不可行。</p><h3 id="暴力法优化"><a href="#暴力法优化" class="headerlink" title="暴力法优化"></a>暴力法优化</h3><p>对于区间左端点 i ，遍历所有的右端点 j ，然后维护最小值，时间复杂度可以降到 $O(n^2)$ ，但还是太高了。</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>既然我们不能先遍历区间，然后找最小值，那么我们不如顺序倒过来，对于每个值，我们找有多少区间里面，它是最小值。</p><p>对于一个数字 A[i] 来说，如果在某个区间 [j, k] 里面它是最小值，那么 [j, k] 包含 A[i] 的子数组的最小值也一定是 A[i] 。所以我们只需要找出最大的那个区间，使得 A[i] 是最小值就行了。</p><p>另一个性质是，左右端点 j 和 k 是相互独立的，不会影响，因为 [i, k] 的改变并不会改变 [j, i] 的最小值。所以我们只需要分别求出 A[i] 往左和往右的最远距离就行了。</p><p>因为往左和往右求解方法是类似的，所以我们只需要看一个方向就行了。同样不能遍历一遍，不然就和暴力法没区别了嘛。这时候就要介绍神器了——<strong>单调栈</strong>。</p><p>单调栈是一个栈，后进先出，里面的元素是单调递增或递减的。而在这题里面，我们要求的是 A[i] 左边最远的距离，等价于求左边第一个比它小的数字 A[j] 。而 A[j+1], …, A[i] 都大于等于 A[i] ，所以都可以作为符合要求区间的左端点。</p><p>这里单调栈只需要维护一个单调上升的子序列就行了，遍历到一个数 A[i] 的时候，如果栈顶的元素大于等于 A[i] ，那么就出栈，直到第一个小于 A[i] 的数 A[j] 为止，那么 A[i] 为最小值的区间左端点可选择数量为 j - i。为什么这样是对的呢？因为 A[j] 是栈里面第一个小于 A[i] 的数，而 A[j] 后面的数都大于 A[j] ，这样才不会把 A[j] 顶出栈。而如果栈是空的，就说明 A[i] 前面的所有元素都大于等于它，那么所有区间都符合条件了。</p><p>而右边最大的范围同理可以求得，但是这里有个需要注意的地方！如果存在两个相同的数，这么算不是会导致同一个区间在两个数的位置处计算两次吗？所以要稍稍改进一下，既然向左计算的时候，已经包含了相等的值了，那么向右计算就要排除掉了。也就是从右往左计算右边最远范围的时候，只能计算右边第一个小于等于它的位置，而向左是计算第一个小于它的位置。这样就不会重复计算了。</p><h3 id="单调栈-动态规划"><a href="#单调栈-动态规划" class="headerlink" title="单调栈+动态规划"></a>单调栈+动态规划</h3><p>上面的方法不仅要考虑两端的范围，还得考虑去重，真是麻烦又容易写错。下面介绍一种更加好写又不容易写错的方法，只是不那么容易想到。</p><p>我们定义 sum[i] 为所有以 i 为右端点的区间的最小值之和，同样用单调队列的方法来寻找左边最远的距离，使得区间内 A[i] 是最小值。假设用单调队列找到了左边第一个比 A[i] 小的数是 A[j] ，那么 sum[i] 就可以加上 (i - j) * A[i] ，因为 A[j] 往右都是 A[i] 最小。而 A[j] 再往左呢？这些区间最小值等价于直接以 A[j] 为右端点的最小值，因为 A[j] 往右的数都比它大，没有影响，所以 sum[i] 再加上 sum[j] 就行了。</p><p>上面两种方法时间复杂度都是 $O(n)$ 的，因为进栈出栈最多也只需要 2n 次。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单调栈（c-）"><a href="#单调栈（c-）" class="headerlink" title="单调栈（c++）"></a>单调栈（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">nxt</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp<span class="token punctuation">,</span> sn<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> sp<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> i <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sn<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>sn<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> sn<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sn<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> n <span class="token operator">-</span> i <span class="token operator">:</span> sn<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>            sn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>res <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈（python）"><a href="#单调栈（python）" class="headerlink" title="单调栈（python）"></a>单调栈（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        pre <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        nxt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        sp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        sn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                sp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> i <span class="token operator">-</span> sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            sp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>sn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>sn<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                sn<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">-</span> i <span class="token keyword">if</span> len<span class="token punctuation">(</span>sn<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> sn<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> i            sn<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        res <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD        <span class="token keyword">return</span> int<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈-动态规划（c-）"><a href="#单调栈-动态规划（c-）" class="headerlink" title="单调栈+动态规划（c++）"></a>单调栈+动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> sp<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span>  A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>sp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>            sp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span>res <span class="token operator">+</span><span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单调栈-动态规划（python）"><a href="#单调栈-动态规划（python）" class="headerlink" title="单调栈+动态规划（python）"></a>单调栈+动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sumSubarrayMins</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        summ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        sp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> A<span class="token punctuation">[</span>sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                sp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            summ<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> summ<span class="token punctuation">[</span>sp<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            sp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        res <span class="token operator">=</span> sum<span class="token punctuation">(</span>summ<span class="token punctuation">)</span> <span class="token operator">%</span> MOD        <span class="token keyword">return</span> int<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题虽然是个中等难度的题，但是还是比一些难题难做一些的，通过这题主要去学会单调栈的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 875】爱吃香蕉的珂珂</title>
      <link href="/2020/01/19/leetcode-875/"/>
      <url>/2020/01/19/leetcode-875/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：piles = [3,6,7,11], H = 8输出：4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：piles = [30,11,23,4,20], H = 5输出：30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：piles = [30,11,23,4,20], H = 6输出：23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= piles.length &lt;= 10^4</li><li>piles.length &lt;= H &lt;= 10^9</li><li>1 &lt;= piles[i] &lt;= 10^9</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>简单复述一下题意，就是有 N 堆香蕉，每堆有 piles[i] 个，现在要求一个整数速度 K ，吃一堆香蕉要的时间是 piles[i] / K （不是整数要上取整），问使得吃完所有香蕉所需总时间小于等于 H 的最小速度 K 是多少？</p><p>显然 K 越小，吃每堆香蕉所需要的时间就越长，总时间也就越长，那么自然而然可以想到二分答案 K 。</p><p>对于当前的 K ，我们遍历数组，算出总时间，如果总时间大于 H ，那就说明 K 太小了，还得提速；如果总时间小于等于 H ，那就说明速度 K 还可以降一点，总时间可能不变（因为存在上取整），也可能变大。</p><p>这样最终的时间复杂度仅仅只有 $O(n log \mathcal{M})$ ，其中 $\mathcal{M}$ 是数组中的最大值，也就是二分上界。但其实这里还可以优化一下二分的上下界，比如上界，最大其实就是数组中的最大元素大小， K 再大也没有意义了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minEatingSpeed</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> piles<span class="token punctuation">,</span> <span class="token keyword">int</span> H<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>piles<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> piles<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> piles<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> maxv<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> l<span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span>piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> H<span class="token punctuation">)</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minEatingSpeed</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> piles<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> H<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        maxv <span class="token operator">=</span> max<span class="token punctuation">(</span>piles<span class="token punctuation">)</span>        l <span class="token operator">=</span> <span class="token number">1</span>        r <span class="token operator">=</span> maxv        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> l            cnt <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> p <span class="token keyword">in</span> piles<span class="token punctuation">:</span>                cnt <span class="token operator">+=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> m            <span class="token keyword">if</span> cnt <span class="token operator">></span> H<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>注意上面的代码还是有几个小细节的：</p><ul><li>二分终止条件设置的是 l &gt;= r ，所以 l 的更新必须是 l = m + 1 ，因为如果 l = r - 1 的话，m 会等于 l 。</li><li>为了防止整型溢出，计算 l 和 r 均值的时候不要写 (l + r) / 2 。</li><li>上取整简单写法就是 (p + m - 1) / m 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 470】用 Rand7() 实现 Rand10()</title>
      <link href="/2020/01/18/leetcode-470/"/>
      <url>/2020/01/18/leetcode-470/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。</p><p>不要使用系统的 Math.random() 方法。</p><p><strong>思考</strong></p><ul><li>rand7()调用次数的 期望值 是多少 ?</li><li>你能否尽量少调用 rand7() ?</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>刚看到这题觉得挺有意思的，再看一脸懵逼，这怎么做？后来看了题解才懂了，原来是这个意思。</p><p>题目要求只能给你用 rand7 函数，也就是均匀生成 1 到 7 之间的整数。但是现在要求你生成 1 到 10 之间的整数，那么肯定只生成一次是不够的，因为状态数都不够嘛，那就生成多次看看。</p><p>如果生成两次，那么就得到了两个 1 到 7 之间的整数，然后怎么转换为 1 到 10 呢。如果这两个数两两组合，那么可以得到 49 种状态，可以用来表示 1 到 49 这 49 个数字，如果想要让 1 到 10 均匀分布，那么每个数字最多只能分配 4 次。具体分配情况如下所示：</p><pre class="line-numbers language-text"><code class="language-text">1  2  3  4  5  6  78  9  10 1  2  3  45  6  7  8  9  10 12  3  4  5  6  7  89  10 1  2  3  4  56  7  8  9  10 .  ..  .  .  .  .  .  .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：每行下标代表第一个随机数 1 到 7 （r1 表示），每列下标代表第二个随机数 1 到 7 （r2 表示）。而转换后的随机数可以表示为 $(7 (r1 - 1) + r2 - 1) % 10 + 1$ ，注意到最后 9 个数没有用到，因为它们不足以表示 1 到 10 这 10 个数，如果表示了概率就不等了。</p><p>那么如果根据上面式子算出来落在了最后 9 个数范围内怎么办呢？这时候我们就拒绝它，重新生成两个数就行了，直到落在前 40 个数范围里。这种方法的期望采样次数是多少呢？<br>$$<br>    \begin{aligned}<br>        E &amp;= 2 + 2 \cdot \frac{9}{49} + 2 \cdot (\frac{9}{49})^2 + \cdots \<br>        &amp;= 2 \sum_{n=0}^{\infty}{(\frac{9}{49})^n} \<br>        &amp;= 2 \cdot \frac{1}{1-\frac{9}{49}} \<br>        &amp;=2.45<br>    \end{aligned}<br>$$</p><p>所以平均只需要 2.45 次就可以均匀的采样到 1 到 10 之间的整数啦。那么这背后的数学原理是什么呢？其实就是<strong>拒绝采样</strong>。</p><p>蒙特卡洛方法大家应该都很熟悉了，就是采样来求分布，比如求一个直径为 1 的圆的概率，我们可以用一个边长为 1 的正方形包住它，然后随机往里面扔豆子，扔 10000 个，看最后有多少落在了圆里面，那么除以 10000 就是圆的面积了。</p><p>而拒绝采样跟这类似，就是一个分布 $p(x)$ 形式比较复杂，累积分布函数不好求，所以不好采样。那么我们可以用一个标准分布 $q(x)$ 来近似它，并且用系数 $k$ 来控制 $q(x)$ 的大小，使得 $k \cdot q(x) \ge p(x)$ ，这就类似于上面的用正方形包住了圆形嘛。 然后 $q(x)$ 是好采样的嘛，所以根据 $q(x)$ 采样出一个 $x’$ ，然后再在 0 到 $k \cdot q(x’)$ 之间采样一个数 $t$，如果 $t$ 落在了 0 到 $p(x’)$ 之间，那就接受这个采样，否则就拒绝它，重新采样。这种方法采出来的 $x’$ 是服从分布 $p(x)$ 的，因为你采样得到 $x’$ 的概率是 $q(x’)$ ，而接受的概率是 $\frac{p(x’)}{k \cdot q(x’)}$ ，所以最终接受 $x’$ 的概率就是 $\frac{p(x’)}{k}$ 。因此 $k$ 要设置的尽量小，这样接受的概率才大，期望的采样次数才少。但是又不能设置太小，因为要满足 $k \cdot q(x) \ge p(x)$ 的前提条件才行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// The rand7() API is already defined for you.</span><span class="token comment" spellcheck="true">// int rand7();</span><span class="token comment" spellcheck="true">// @return a random integer in the range 1 to 7</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> num<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            r1 <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r2 <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            num <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">+</span> r2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题题目虽简单，背后的思想还是很有意思的，拒绝采样可以用在深度学习中的很多应用场景里，特别是你的分布很难进行采样的时候，就可以用拒绝采样来模拟。</p><p>当然这题还有其他采样方法可以缩小期望采样次数，比如如何利用这 9 个被拒绝的点呢？留给大家思考（其实是我懒得写了）。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 827】最大人工岛</title>
      <link href="/2020/01/17/leetcode-827/"/>
      <url>/2020/01/17/leetcode-827/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维地图上， 0 代表海洋， 1 代表陆地，我们最多只能将一格 0 海洋变成 1 变成陆地。</p><p>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1, 0], [0, 1]]输出：3解释：将一格 0 变成 1 ，最终连通两个小岛得到面积为 3 的岛屿。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1, 1], [1, 0]]输出：4解释：将一格 0 变成 1 ，岛屿的面积扩大为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[[1, 1], [1, 1]]输出：4解释：没有 0 可以让我们变成 1 ，面积依然为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= grid.length = grid[0].length &lt;= 50</li><li>0 &lt;= grid[i][j] &lt;= 1</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>没有做过这种类型题目的强烈建议自己动手实现一遍，对提升代码能力有很大帮助。</strong></p><p>这题虽然是 hard 难度，但其实没有什么算法，只用到了 dfs 求连通块而已。我们只需要知道填充了一个 0 之后，它上下左右跟它相邻的 4 块连通块是多大。</p><p>首先普及一下什么是连通块，就是一块由 1 组成的区域，其中任意两块 1 都可以由一条 1 组成的路径走过去（只能上下左右走）。那么这题我们遍历所有的 0 ，把它四周的连通块大小加起来就是填充了这块 0 之后的连通块大小了。那么问题是怎么知道它周围连通块的大小呢？</p><p>首先我们得求出所有连通块的大小，然后存下来，这就得用到 dfs 了。</p><p>用二维数组 index （初始化为 -1）记录方块是否被搜索过。然后遍历所有的方块，如果是 1 ，并且 index 为 -1 （也就是没被搜索过），那么它的 index 设为 1 ，表示被搜索过了。然后从它开始向四周进行 dfs ，直到跟它相连的所有 1 的连通块都被搜索完毕。这时候整块连通块里面的 1 方块的 index 都被设成了 1 ，就算以后被遍历到了也不会被搜索了。那么大小怎么记录呢？只需要设置一个变量 cnt 初始为 1 ，然后 dfs 的时候遇到一个未被搜索的块就加 1 ，最后 cnt 就是当前连通块的大小了。</p><p>光知道了每个连通块的大小还不行，对于一个 0 块，四周的 1 方块万一属于同一个连通块怎么办？得区分它们，不然就会被重复计算。所以在上面的 dfs 之前，给那块连通块一个唯一的编号（从 0 开始），遇到下一个连通块就加 1 。这样 index 数组就可以用来存连通块的编号了，同时还能表示方块是否被搜索过。</p><p>具体的细节还得看代码，有很多实现的技巧，当然我写的还有一些优化余地。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> area<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token punctuation">[</span>N<span class="token operator">*</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">largestIsland</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>area<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> index<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    index<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                    area<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                            tmp <span class="token operator">+</span><span class="token operator">=</span> area<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            flag<span class="token punctuation">[</span>index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> cnt<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inside</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> <span class="token operator">++</span>cnt<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>dfs 求连通块是常规操作，必须要学会，很考验代码功底，要细心，不然很容易写错。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 354】俄罗斯套娃信封问题</title>
      <link href="/2020/01/16/leetcode-354/"/>
      <url>/2020/01/16/leetcode-354/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>说明:</strong><br>不允许旋转信封。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目要求矩形一个套着一个，然后求出最多套多少个，而一个矩形能套在另一个矩形上面的条件是长宽都大于另一个。</p><p>那么我们可以按照长度从小到大排个序，这样只有排在后面的矩形可以套在前面的矩形上。但是宽度也有限制条件，也得大于前面的矩形，那么问题就转化成了，把宽度看成一个序列，找到一个最长的上升序列，序列的长度就是我们要的答案。但是这里有个问题，就是矩形如果是相同长度，它们的宽度按照什么来排序呢？如果也是从小到大排，那么可能会出现多个相同长度的矩形套在一起，这是不符合题意的。所以我们对相同长度的矩形采取宽度降序的方法排序，这样它们之中最多只会被选中一个了。</p><p>那么问题就变成了经典的<strong>最长上升子序列问题了</strong>。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>用 dp[i] 表示以第 i 个元素 a[i] 结尾的最长子序列的长度，那么我们可以遍历所有 a[i] 之前的元素 a[j] ，如果 a[j] 小于 a[i] ，那就说明 a[i] 可以加在 a[j] 后面，然后长度就变成了 dp[j] + 1 。所以遍历所有符合条件的 j ，找到长度最长的，然后更新 dp[i] = dp[j] + 1 。最后的答案就是 dp 数组中最大的值。</p><p>这种方法时间复杂度是 $O(n^2)$，如果序列太长会超时。本题中 c++ 没有超时，但是 python 超时了。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>那么有什么方法来优化呢？下面介绍一种二分优化方法。</p><p>这次假设 dp[len] 表示长度为 len 的上升子序列最后一个元素的最小值。这个值要尽量小，什么意思呢？也就是相同长度的上升序列，最后一个元素小的那个序列，后面可以加的元素可选择余地肯定更大。那么这个数组怎么更新呢？</p><p>初始的时候 len 就是 0 ，因为没有找到任何上升子序列。如果现在找到了长度为 len 的子序列，然后最后一个元素最小值是 dp[len] ，这时候来了一个新元素 a[i] ，如果它比 dp[len] 大，说明 a[i] 可以加在 dp[len] 后面，那么 len 就变成了 len + 1 ， 并且 dp[len + 1] 更新为 a[i]。那如果 a[i] 小于等于 dp[len] 呢？那就继续往前遍历，找到第一个 dp[l] &lt; a[i] &lt;= dp[l+1] 的位置，这个位置说明了什么呢？说明了 a[i] 可以加在 dp[l] 后面构成长度为 l + 1 的子序列，并且 dp[l+1] 可以变得更小，所以更新为 a[i] 。这样 a[i] 就处理完了，最后 len 就是答案。</p><p>但是这样看起来复杂度没有变啊，其实这里有一个很好的性质，因为长度越大的序列，最后一个元素的最小值一定是大于长度小的序列最后一个元素的，所以 dp 数组是单调递增的，这样我们就可以用二分来寻找 a[i] 适合插入的位置。时间复杂度降到了 $O(n\log n)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1（c-）"><a href="#方法1（c-）" class="headerlink" title="方法1（c++）"></a>方法1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> envelopes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>envelopes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法1（python）"><a href="#方法1（python）" class="headerlink" title="方法1（python）"></a>方法1（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        arr<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（c-）"><a href="#方法2（c-）" class="headerlink" title="方法2（c++）"></a>方法2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> envelopes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> envelopes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> envelopes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            len <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（python）"><a href="#方法2（python）" class="headerlink" title="方法2（python）"></a>方法2（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> bisect <span class="token keyword">import</span> bisect_left<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEnvelopes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        arr<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        nums <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">]</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">=</span> bisect_left<span class="token punctuation">(</span>dp<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> idx <span class="token operator">==</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">:</span>                dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还有智障解法：就是两两遍历每一个矩形对，根据包含关系建立一个拓扑图，然后求图上的最长距离。没错，我刚开始就是这么想的，我是智障。这个方法没有错，还真能过这题，就是时间太慢了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1031】两个非重叠子数组的最大和</title>
      <link href="/2020/01/15/leetcode-1031/"/>
      <url>/2020/01/15/leetcode-1031/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2输出：20解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2输出：29解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3输出：31解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>L &gt;= 1</li><li>M &gt;= 1</li><li>L + M &lt;= A.length &lt;= 1000</li><li>0 &lt;= A[i] &lt;= 1000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题意思就是找到两段给定长度的、不重合的、连续的区间，使得两段区间和最大。</p><p>因为长度是给定的，所以我们只需要预处理好前缀和 sum ，然后给定区间右端点，就可以直接算出区间和。<br>那么如果枚举两段区间的右端点，时间复杂度也才 $O(n^2)$ ，极限情况下也就 1e6 左右，貌似也还可以接受。</p><p>那有没有更快的方法呢？试试动态规划！因为两段区间有前后顺序，我们不妨假设长度为 L 的区间在后面。<br>用 dpm[i] 表示前 i 个数中长度为 M 的区间和的最大值。<br>那么 dpm[i] = max{dpm[i-1], sum[i] - sum[i-M]} ，也就是要么取最后 M 个数，要么最后一个数不取，在前 i - 1 个数里面找答案。<br>然后 dpm 全部处理完之后，遍历数组，假设长度为 L 的区间以 A[i] 结束，那么我们只需要在 A[0] 到 A[i-L] 中间找长度为 M 的区间最大和就行了，那答案不就是上面求好的 dpm[i-L] 吗？这样最终时间复杂度就是 $O(n)$ 了。</p><p>结束了吗？并没有！空间还能不能优化呢？其实当我们遍历长度为 L 的区间时，长度为 M 的区间不用每次都重新遍历，可以重复利用之前的结果，每次向右移动直到和长度为 L 的区间衔接上为止。这样就等于用了两个指针，分别指向了两个区间的右端点，总共最多移动 2n 次就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划（c-）"><a href="#动态规划（c-）" class="headerlink" title="动态规划（c++）"></a>动态规划（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dpl<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> dpm<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dpl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dpl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dpm<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dpm<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dpl<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">;</span>        dpm<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dpl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dpm<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">+</span> dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动态规划（python）"><a href="#动态规划（python）" class="headerlink" title="动态规划（python）"></a>动态规划（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">:</span> int<span class="token punctuation">,</span> M<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        N <span class="token operator">=</span> <span class="token number">1010</span>        dpl <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        dpm <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        dpl<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>L<span class="token punctuation">]</span>        dpm<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>M<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> L<span class="token punctuation">:</span>                dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dpl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">+</span> dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> i <span class="token operator">>=</span> M<span class="token punctuation">:</span>                dpm<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dpm<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>                res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">+</span> dpl<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针法（c-）"><a href="#指针法（c-）" class="headerlink" title="指针法（c++）"></a>指针法（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token operator">+</span>M<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            lmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>lmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>mmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> lmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> mmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针法（python）"><a href="#指针法（python）" class="headerlink" title="指针法（python）"></a>指针法（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSumTwoNoOverlap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">:</span> int<span class="token punctuation">,</span> M<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        N <span class="token operator">=</span> <span class="token number">1010</span>        sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        lmax <span class="token operator">=</span> mmax <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>L<span class="token operator">+</span>M<span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            lmax <span class="token operator">=</span> max<span class="token punctuation">(</span>lmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>            mmax <span class="token operator">=</span> max<span class="token punctuation">(</span>mmax<span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> lmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>M<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> mmax <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token operator">-</span>L<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>思考问题要从简单往困难思考，先想想暴力怎么做？再想想怎么优化它。就算做出来了，也不要拘泥于一种解法，还有代码上能否优化？变量、写法上能否更优美一点？</p><p>当然很熟练了之后这些都不用考虑了，上来像我一样直接一步到位就行了，嘻嘻。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 330】按要求补齐数组</title>
      <link href="/2020/01/15/leetcode-330/"/>
      <url>/2020/01/15/leetcode-330/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的正整数数组 nums ，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,3], n = 6输出：1解释：根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。所以我们最少需要添加一个数字。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,5,10], n = 20输出：2解释：我们需要添加 [2, 4]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [1,2,2], n = 5输出：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先这题没有说数据范围，根据正解的时间复杂度，推测出 nums.length 的大小在 1e5 左右，而 n 的大小在 int 的最大值左右。</p><p>而不考虑数据范围，我刚开始的想法是，首先考虑简化问题：<strong>用 nums 数组中的数字可以表示出多少个不同的正整数？</strong><br>这可以用动态规划来解决，令 dp[S][i] 表示用前 i 个数凑出和 S 是否可行，那么状态转移方程就是： dp[S][i] = dp[S-nums[i]][i-1] || dp[S][i-1] 。<br>然后遍历 dp[i][nums.length-1] ，如果发现等于 0 ，就说明 nums 数组无法凑出 i 这个和，于是新增加一个数 i ，并且将 [i, 2i)中的所有 dp 值都改成 1，直到 [1, n] 全部被覆盖了。<br>后来看了才发现，我弱智了，这样不仅没必要，而且 n 太大会炸裂。</p><p>正解很简单。首先题目中有个词“已排序”，其实不是很重要，没排序的话我排个序也不怎么耗时间。那排完序怎么办呢，思路还是刚刚的思路，只是不用动态规划了。</p><p>试想从最小的 1 开始，如果 1 不在数组里，那一定要补上一个 1 的，然后 [1, 2) 范围里的数都可以被表示出来了。然后看下一个数，如果大于 2 ，那么 2 是没有办法通过数组里的数表示出来的，因为比它小的数只能凑出 [1, 2) ，所以 2 也要补上。如果下一个数小于等于 2 ，那么我们可以利用目前的数凑出 [1, 4) 里面的数，然后继续往下遍历，直到能够凑出 [1, n+1) 里面的数。</p><p>一般情况下，如果遍历到 nums[i-1] 时，可以表示出 [1, S) 范围内的数，那么如果 nums[i] &gt; S ，那么需要补上 S ，并且可表示范围更新为 [1, 2S)，然后继续看 nums[i] ；否则的话可表示范围更新为 [1, S+nums[i]) ，然后看 nums[i+1] 就行了。</p><p>这样就比原来的思路简化了很多了，那么时间复杂度怎么样呢？<br>因为 S 每次更新有两种情况，要么乘以 2 ，要么加上了 nums[i] ，所以最终时间复杂度是 $O(m + \log n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPatches</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>                r <span class="token operator">+</span><span class="token operator">=</span> r<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minPatches</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        length <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        idx <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> idx <span class="token operator">&lt;</span> length <span class="token operator">and</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>                r <span class="token operator">+=</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>                idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> r        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5W2H | 关于写博客的七点反思</title>
      <link href="/2020/01/14/5w2h-godweiyang/"/>
      <url>/2020/01/14/5w2h-godweiyang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h2><p>第一次写博客是 2015 年了，在 CSDN 和博客园上面，当时写文章是为了记录 ACM 竞赛的题解，陆陆续续写了几十篇。但是最后还是没有坚持下去，主要还是因为 CSDN 和博客园的体验太差了，写起文章来很难受，又丑又慢。另一个原因是， CSDN 发个文章还需要审核，定制主题自由度也太差。</p><p>第二次就是 2017 年暑假了，当时自己建了个人博客，域名是：<a href="https://godweiyang.com/">godweiyang.com</a>。当时的想法是，个人博客好好看，有各种主题，如果会点前端知识，还能自己魔改。个人博客主要更新的就是自然语言处理的知识了，主要都是些论文的阅读赏析。另外还更新一些计算机相关的基础知识，主要考虑到绝大多数人并不会对枯燥又专业的自然语言处理感兴趣。算法题解的话最近也开始更新起来了，主要写一些 LeetCode上面的题解。</p><p>最后就是知乎专栏和微信公众号了，这两个平台是最近才搞的，主要把个人博客的文章同步更新过去，内容都差不多。微信公众号本来不想搞的，不支持 markdown ，写起来挺麻烦的。但是考虑到以后的发展，以及可能会有一些变现的操作，还是重操旧业了（其实我公众号两年前就注册过了，只是一直没有更新）。</p><h2 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h2><p>其实刚开始写博客，主要还是为了记录自己平时学到的一些东西，以后可能还能翻出来复习复习。但是现在看来，基本不会再去翻以前写的东西了。</p><p>另一个目的，也是我写博客最主要的目的，还是想分享我知道的一些东西，能够让更多的人因此受益。因为写博客，其实还是认识了不少天南地北的朋友的，有各个高校甚至初高中的学生，也有工作了很多年想学习学习编程的，也有国外一些名校的学生。不管是谁，我觉得都可以扩展我的人脉，现在微信好友人数上限扩展到了 5000 人了，而我才用了十分之一多一点，什么时候能达到上限也算是圆满了。</p><p>最后，有句话叫做：“不以盈利为目的的博客最后都死亡了”。因为如果不能因此获得任何的收入的话，极少有人有这个毅力坚持更新博客。虽然我也想因此获利，但是暂时我并不想因此改变了初衷，去写一些刻意迎合大众的水文，从而获得粉丝。</p><h2 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h2><p>主要都是与我相关的一些计算机相关知识。最主要的就是深度学习和自然语言处理了，但是因为我是做句法分析的，这个方向受众比较小，如果纯粹写这个方向的内容的话，看的人可能会很少。而如果写深度学习和自然语言处理的入门普及或者综合一点热门一点的方向的话，看得人应该会很多。但是这样又有一个弊端，非常的浪费我时间，因为过于基础的知识对我的提升微乎其微，只适合以后我面试前看看补补基础。而主要我现在重心还在发论文，继续搞学术，所以只能写一些结合我最近所学知识的文章。</p><p>还会写一些算法题解，现在主要在做 LeetCode 上面的中等和困难题目，然后每日一更。尽管网上各种 LeetCode 的题解已经太多了，但是我觉得，大多数的题解都非常的模糊，讲解的很不清楚，抄来抄去的有什么意思？而他们的代码风格，更是让我看不下去，最基本的美观都做不到，代码的简洁精炼就更不用谈了。所以我的目的还是尽量用美观精炼的代码来让更多人的算法思想和代码能力得到提升。</p><p>偶尔，我还会分享一些计算机基础知识，比如怎么搭博客（这是我阅读量最高的一篇博客了）、好用的软件、常用的一些软件的安装配置等等。其实讲道理，我是不愿意写这一类文章的，因为非常的费时费力，需要自己动手模拟一遍，确保能够正确完成才能写进文章。不然就会像很多网上的教程那样，抄来抄去一堆错误，根本没有自己动手实践过。但是这种文章其实对很多人帮助还挺大的，大家也乐意去看，如果你在知乎发的话，你会发现这类文章收藏量都挺高的。如果我以后用空了，我还是会经常把我平时的一些经验分享给大家的，比如 LaTeX 常用写作技巧之类的。</p><p>那么其他火的博客都写些什么呢？我觉得当代人闲暇时候、上厕所刷手机的时候，那些碎片时间是没办法好好学习一些知识的，最爱看的还是有趣的故事，例如 99 行代码做出冰雪奇缘特效、程序员脱发、程序员单身狗啦之类的。这些故事背后的技术可能是很深奥的，但是大多数人并不会去关心，只是会看完惊叹一句“卧槽”而已。其他的吸引人的内容还有资料下载、课程学习（当然基本都是广告）等等。不过我个人目前并不想写这些东西，首先这些新闻类的文章很多地方都有了，写来写去就那么些东西，同质化严重。而资料下载确实是个不错的主意，可以分享好东西给大家，但是我个人最近也没有太多值得珍藏的好资料，况且大多数网上都有现成的，我不赞同为了增加粉丝而不放出链接，把资料放在公众号后台的行为。</p><p>总之，不忘初心，粉丝什么的随缘吧。我非常佛系，即使没人看我也会日常更新，就当记日记不是吗？</p><h2 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h2><p>大多数看我博客的都是自然语言处理相关的学生。就拿我在知乎专栏的粉丝来看，大多数人是来看我的论文赏析的，而少部分人是看到了那篇博客搭建教程来的。至于算法题解，貌似并没有很多人看，可能这一类文章网上实在是太多了，没有什么独特的吸引力。而公众号粉丝，目前为止还很少，绝大多数还都是好友粉丝。主要原因还是公众号太封闭了，很难让好友之外的人知道并且关注你。一个方法可以在知乎等平台引流，但是现在这属于违规操作，最好还是不要干了。</p><p>其实我目标的受众群体还是包括但不仅限于计算机系的学生，像一些计算机基础知识，就算你是个小白，也可以从这里学到很多东西。甚至还有很多考研的学生来咨询我问题，虽然我是保研的，但是很多导师选取、学习方面的问题我还是愿意给出我自己的建议的。我这个人向来喜欢分享，也喜欢倾听，如果别人来问我问题，我基本是会耐心回答的。曾经有啥都不会的小白来问我怎么搭建博客，我得从最基本的命令行教他，讲道理这其实很烦，我都不想教，但我还是会尽量把关键点都告诉他。有人会觉得，我这样最后会得到什么呢？是的，也不赚钱，最多偶尔有些朋友会打赏个红包，我还浪费了大把时间（其实还好，白天工作的时候我都简单回复，晚上一般会详细点），但是认识的人多了，许多人还是多少知道我这个名字的，虽然没啥用，但是也算是种隐形财富吧，以后有什么用再说。</p><h2 id="Where？都在什么平台写博客呢？"><a href="#Where？都在什么平台写博客呢？" class="headerlink" title="Where？都在什么平台写博客呢？"></a>Where？都在什么平台写博客呢？</h2><p>这个其实上面都说过了，我现在文章主要更新在个人博客、知乎专栏、微信公众号和 CSDN 上面，我简要说一些这些平台的优缺点吧。</p><p>个人博客可以个性化定制主题，想怎么好看就怎么好看，还不用发文章审核，想发什么就发什么。但是缺点就是发文章麻烦一点的，步骤略多，并且搜索引擎收录很慢的。</p><p>知乎专栏是我比较喜欢的一个平台，主要是它支持markdown，还可以把公式变成矢量图片，还是挺不错的。但是发知乎文章要注意千万别带着营销、引流等内容，不然容易被人举报被删除甚至禁言。</p><p>微信公众号是我最近才开始运营的，相对而言，它的编辑界面是最不友好的一个，只支持富文本编辑，连markdown都没有。但是也有解决方法，比如我现在用<a href="https://mdnice.com/" target="_blank" rel="noopener">mdnice.com</a>这个网站，把markdown转换成微信公众号的富文本格式，还是非常好用的。公众号还有个缺点，太封闭了，很难宣传出去，刚开始只能亲朋好友关注关注，但是如果你真的做大了知名度，还是可以借助微信的优势，赚得不少广告钱的。</p><p>CSDN因为几年前被永久封过号，然后现在不知道为什么又被解封了，所以用的不是特别多，主要都是通过知乎专栏自动同步文章过去的。CSDN 好处就是流量大，很多人都在上面搜东西，百度搜出来也基本都是 CSDN ，但是排版是真的真的烂，不过现在好多了，也支持 markdown 了。但是还是谈不上喜欢，广告什么的都太多了，除非迫不得已，我一般不去 CSDN 看技术文章，我一般都是个人博客或者知乎看论文解读之类的。</p><h2 id="How？按照什么流程来写博客？"><a href="#How？按照什么流程来写博客？" class="headerlink" title="How？按照什么流程来写博客？"></a>How？按照什么流程来写博客？</h2><p>其实同时维护好几个平台还是挺累的，你得找到一个最佳的顺序来发布文章，这样才能事半功倍。我一般都是先在个人博客上写好 markdown 文章，然后发布完之后，打开<a href="https://mdnice.com/" target="_blank" rel="noopener">mdnice.com</a>在线编辑网站，把 markdown 粘贴进去，转成微信公众号和知乎专栏的格式，最后分别发布在两个地方就行了。 CSDN 就不用管了，它会每天自动同步知乎专栏的文章的，倒是为我省了不少事。markdown 写作也挺轻松的，完全不用管排版之类的问题，安安心心写内容就行了。</p><p>微信公众号现在设置的是每天早上 8:05 推送，其实稍微晚一点比较好，这样别人的都推送完了，你的就会置顶在最上面。而知乎专栏和个人博客我就随性发布了，想什么时候发就什么时候发，经常会前一天就写好内容，早早的发布出去了。</p><p>我个人现在来看，写一篇博客最累的是敲公式和找图片，当然像我这篇就一个公式和图都没有，是最最轻松的了。我这个人有强迫症，公式一定要手打 LaTeX 公式，然后转成矢量图才行，这样看着又清楚又舒服。遇到复杂的矩阵公式，能把我敲的头晕。这也是我为什么不喜欢 CSDN 的一个原因，上面很多文章公式全是截图，看的我头都大了。</p><h2 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h2><p>写博客挺花时间的，特别是现在还在为发论文而忙活的时候，可能论文截稿前那段时间甚至我会停更好久哈哈。不过现在放假了，还算比较闲，有功夫搞搞这些。我个人是倾向于白天还是老老实实学习吧，晚上把部分的游戏时间抽出来写会儿文章，更新一波。这样也不算太浪费时间，毕竟就算不写，时间也都用来打游戏了，游戏输了还坏了心情（我的亚索怎么会输？）。</p><p>那什么时候做 LeetCode 呢？我一般都是白天吃饭时，或者走在路上时，手机 app 上随机选一道题，然后吃个饭的时间就能想出个解法，回到实验室后敲一顿代码通过了就行了。这样看来也节约了不少时间嘛，还能和室友一起讨论讨论，帮他提高一波算法能力。</p><p>金钱的话就基本没有花销了，除了开了个素材设计网站的会员（我是真的睿智，用 PS 不就行了嘛，脑子瓦特了充钱了）以外，其他不需要啥了，偶尔还能吃点打赏钱，粉丝太少了，没有广告。</p><p>因为写文章这上面花时间比较多，写出好的文章、不水文章的话花的时间更多，所以很容易坚持不下去。而又要迎合大众的口味，众口难调嘛，又要坚持自己的初心，尽量写对自己提升大的内容，还是比较难以平衡的。特别是粉丝特别少，没有什么人看的时候，你会很想放弃。</p><p>但是，总会有人在你坚持不下去的时候，给你鼓励的目光，支持你继续走下去的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 124】二叉树中的最大路径和</title>
      <link href="/2020/01/13/leetcode-124/"/>
      <url>/2020/01/13/leetcode-124/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,3]      1     / \    2   3输出：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[-10,9,20,null,null,15,7]     -10     / \    9  20      /  \     15   7输出：42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是一道<strong>树形 dp</strong> 入门题，也就是树上的动态规划。</p><p>首先要理解它这个输入什么意思，虽然写代码的时候不用你管，已经给你处理成结构体了。<br>输入是一个数组，其实是二叉树的层次遍历，也就是从第一层（根结点）开始，往下一层一层遍历结点，同一层从左往右遍历。</p><p>这题要求的是一条路径，路径上的数字之和要最大。<br>我们采用递归来做这题，<strong>假设<code>dfs(r)</code>表示以 r 为根结点的子树中最长路径的和，而左右子结点用 l 和 r 来表示</strong>。</p><p>那么有人可能会说，这不是很简单了嘛。<br>一共就下面几种情况：</p><ol><li>只取根结点：<code>r-&gt;val</code></li><li>只取左子树：<code>dfs(l)</code></li><li>只取右子树：<code>dfs(r)</code></li><li>取根结点和左子树：<code>r-&gt;val + dfs(l)</code></li><li>取根结点和右子树：<code>r-&gt;val + dfs(r)</code></li><li>取根结点和左子树和右子树：<code>r-&gt;val + dfs(l) + dfs(r)</code></li></ol><p>最后的答案就是<code>dfs(root)</code>。</p><p>然而这样对吗？其实是错的，刚开始我也犯了这样的错误（好久没做树形 dp 了，见笑了）。<br>为什么是错的呢？试想这么一种情况，万一左子树的最优解是不经过左子结点的话，怎么与根结点连接起来呢？<br>这种情况下你的计算就有问题了，所以我们必须加强一下之前的假设。</p><p>这次我们假设<code>dfs(r)</code>表示以 r 为根结点的子树中<strong>经过根结点 r</strong> 的最长路径的和。<br>现在继续分成上面的几种情况讨论，然而最后的<code>dfs(root)</code>意思变了，指的是必须经过根结点 root 的最优路径之和。<br>那怎么办呢？很好办，只需要用一个全局变量，每次递归的时候都更新一下最大值就行了，因为总有一个结点是最优路径所在子树的根结点。</p><p>分析到这里，貌似都对了，但是还有问题吗？<br>注意看上面的第<code>2、3、6</code>三种情况，如果最优情况是这三种，然后用它们更新<code>dfs(r)</code>，会出现什么情况？<br>情况<code>2、3</code>会导致回溯之后，在根结点 r 处断开了，也就是不经过 r 了，那再高层也就没法求解了。<br>而情况<code>6</code>会导致路径出现左右分叉，这也是不允许的。<br>所以递归的最后更新时，只能用其他三种情况更新。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l_max_sum <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r_max_sum <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> l_max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> r_max_sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> l_max_sum<span class="token punctuation">,</span> r_max_sum<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token operator">-</span>sys<span class="token punctuation">.</span>maxsize    <span class="token keyword">def</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> root <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        l_max_sum <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        r_max_sum <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        sum <span class="token operator">=</span> root<span class="token punctuation">.</span>val        sum <span class="token operator">=</span> max<span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> l_max_sum<span class="token punctuation">)</span>        sum <span class="token operator">=</span> max<span class="token punctuation">(</span>sum<span class="token punctuation">,</span> sum <span class="token operator">+</span> r_max_sum<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l_max_sum<span class="token punctuation">,</span> r_max_sum<span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题虽然是困难题，但是也是树形 dp 的入门题，思考起来和实现起来 trick 还是挺多的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 357】计算各个位数不同的数字个数</title>
      <link href="/2020/01/12/leetcode-357/"/>
      <url>/2020/01/12/leetcode-357/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数 n ，计算各位数字都不同的数字 x 的个数，其中 $0 \le x &lt; 10^n$ 。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：2输出：91解释：答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题要求所有数位数字都不相同的数字个数，那么我们可以将答案分成不同长度。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>对于长度为 n 的数字，第一位取值有 1<del>9 一共 9 种情况，而后面 n - 1 位可以从 0</del>9 中随机取出 n - 1 个不同数字，然后随机排列。因为要和第一位不同，所以后面的数字选择只有 9 种情况，所以方案数是排列数 $A_{9}^{n-1}$。</p><p>然后一直累和到长度为 1 的数字，最后还有个特例，就是 0 ，它是首位可以为 0 的唯一情况。</p><p>所以最终答案就是 $\sum_{i=0}^{n-1}{A_{9}^{i}} + 1$ 。具体实现的时候可以将阶乘预处理好，然后直接用就行了。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>因为 n 不会太大，所以我们可以本地将每个 n 对应的答案算出来，然后保存到数组里，提交的时候直接取答案就行了。这种方法非常投机取巧，适合直接做会超时，但是答案数量又不是太多的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1（c-）"><a href="#方法1（c-）" class="headerlink" title="方法1（c++）"></a>方法1（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> fact<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">,</span> <span class="token number">5040</span><span class="token punctuation">,</span> <span class="token number">40320</span><span class="token punctuation">,</span> <span class="token number">362880</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">-</span>n<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>           res <span class="token operator">+</span><span class="token operator">=</span> fact<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">/</span> fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> res <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法1（python）"><a href="#方法1（python）" class="headerlink" title="方法1（python）"></a>方法1（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        fact <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">,</span> <span class="token number">720</span><span class="token punctuation">,</span> <span class="token number">5040</span><span class="token punctuation">,</span> <span class="token number">40320</span><span class="token punctuation">,</span> <span class="token number">362880</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">-</span>n<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">+=</span> int<span class="token punctuation">(</span>fact<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">/</span> fact<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（c-）"><a href="#方法2（c-）" class="headerlink" title="方法2（c++）"></a>方法2（c++）</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> res<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">739</span><span class="token punctuation">,</span> <span class="token number">5275</span><span class="token punctuation">,</span> <span class="token number">32491</span><span class="token punctuation">,</span> <span class="token number">168571</span><span class="token punctuation">,</span> <span class="token number">712891</span><span class="token punctuation">,</span> <span class="token number">2345851</span><span class="token punctuation">,</span> <span class="token number">5611771</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> res<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法2（python）"><a href="#方法2（python）" class="headerlink" title="方法2（python）"></a>方法2（python）</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countNumbersWithUniqueDigits</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">739</span><span class="token punctuation">,</span> <span class="token number">5275</span><span class="token punctuation">,</span> <span class="token number">32491</span><span class="token punctuation">,</span> <span class="token number">168571</span><span class="token punctuation">,</span> <span class="token number">712891</span><span class="token punctuation">,</span> <span class="token number">2345851</span><span class="token punctuation">,</span> <span class="token number">5611771</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> res<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题还可以用递归、解出和式的通式等方法求解，本质上没有太大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 992】K个不同整数的子数组</title>
      <link href="/2020/01/11/leetcode-992/"/>
      <url>/2020/01/11/leetcode-992/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）</p><p>返回 A 中好子数组的数目。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>1 &lt;= A[i] &lt;= A.length</li><li>1 &lt;= K &lt;= A.length</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题最暴力的方法就是用一个字典维护每个数出现的次数，然后遍历所有的区间，求出不同整数个数正好等于 K 的区间个数。<br>但是这种方法时间复杂度是 $O(n^2)$，一定会超时，所以考虑其他方法。</p><p>现在考虑右边界为 j 的情况，左边界 i 有什么规律呢？<br>我们可以证明，满足 [i, j] 正好包含 K 个不同整数的 i 的取值是一段连续的区间。<br>假设 [i, j]包含 K 个不同整数，同时 [i’, j] 也包含 K 个不同整数（i &lt; i’），因为从 i 移动到 i’ 每个数的数量是非增的，所以这过程中没有增加新的数，也没有任何一个数的数量降到了0。</p><p>有了这个性质之后，对于任意的 j ，我们只需要求出左边界 i 的取值范围就行了。同样这里还是不能暴力求，不然就和一开始没区别了嘛。<br>既然这样，想想如果 j 的左边界 i 的范围得到了，这时候我们继续求 j + 1 的左边界范围，能不能利用一下之前得到的结果？而不用重新计算。<br>很容易发现，如果 j 右移了， i 的取值范围也会右移，因为 j 右移有两种结果：一是引入了新的数，二是某个存在的数的数量加 1 。<br>第一种情况对左边界没有任何影响，因为不同整数数量没有变化，还是 K 。第二种情况不同整数数量变成 K + 1 了，这时候左边界一定要右移，删掉点数，才可能使区间符合题意。</p><p>有了上述的性质之后就好做了，因为左边界的取值范围也是不断右移的，所以我们只需要维护两个指针 l 和 r 就行了，一个保存取值范围的最小值，一个保存最大值。然后每次对于一个 j ，符合题意的子区间数量就是 r - l + 1 。而 j 右移一个数之后， l 需要右移，直到 [l, j] 中正好有 K 个不同整数， r 也继续右移，直到[r + 1, j] 中正好有 K - 1 个不同整数。</p><p>因为 l 和 r 最多只会移动 n 次，而 j 也只移动了 n 次，所以总体时间复杂度降到了 $O(n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">subarraysWithKDistinct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cl<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cr<span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nl <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nl<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nl <span class="token operator">></span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nl<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nr<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nr <span class="token operator">>=</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>r<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> nr<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">+</span><span class="token operator">=</span> r <span class="token operator">-</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">subarraysWithKDistinct</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> K<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        cl <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        cr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        l <span class="token operator">=</span> r <span class="token operator">=</span> nl <span class="token operator">=</span> nr <span class="token operator">=</span> res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                nl <span class="token operator">+=</span> <span class="token number">1</span>            cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> nl <span class="token operator">></span> K<span class="token punctuation">:</span>                cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> cl<span class="token punctuation">[</span>A<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    nl <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                nr <span class="token operator">+=</span> <span class="token number">1</span>            cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> nr <span class="token operator">>=</span> K<span class="token punctuation">:</span>                cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">if</span> cr<span class="token punctuation">[</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    nr <span class="token operator">-=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">+=</span> r <span class="token operator">-</span> l        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实这题想起来可能好想，但是写起来容易写错，因为区间范围需要好好琢磨。这一类问题统称为“窗口滑动”问题，都是不特别难，想清楚了两个状态之间窗口如何滑动就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1250】检查「好数组」</title>
      <link href="/2020/01/10/leetcode-1250/"/>
      <url>/2020/01/10/leetcode-1250/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="https://godweiyang.com/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数数组 nums ，你需要从中任选一些子集，然后将子集中每一个数乘以一个任意整数，并求出他们的和。</p><p>假如该和结果为 1 ，那么原数组就是一个「好数组」，则返回 True ；否则请返回 False 。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [12,5,7,23]输出：true解释：挑选数字 5 和 7 。5*3 + 7*(-2) = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [29,6,10]输出：true解释： 挑选数字 29 , 6 和 10 。29*1 + 6*(-3) + 10*(-1) = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：nums = [3,6]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^9</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题名义上是困难难度，实际上只要知道一些数学知识，就非常的简单。</p><p>首先题目中要求挑选出一些数，然后给每个数分配整数系数，加权求和等于 1 。<br>仔细想一想就不对劲，全选不是一样嘛？有些数系数分配 0 就行了。</p><p>假设系数分别是 $x_1, x_2, \ldots, x_n$ ，那么问题就变成了求解下面的多元一次方程有整数解的条件：<br>$$<br>    a_1 x_1 + a_2 x_2 + \dots + a_n x_n = 1<br>$$<br>如果你数学基础不错的话，一眼就会发现条件就是<strong>所有非零数的最大公约数为 1</strong> ：<br>$$<br>    gcd(a_1, a_2, \ldots, a_n) = 1, a_i \neq 0<br>$$</p><p>证明参见 n 个数的<a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity," title="维基百科：裴蜀定理" target="_blank" rel="noopener">裴蜀定理</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isGoodArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">%</span>y <span class="token operator">?</span> <span class="token function">gcd</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token operator">%</span>y<span class="token punctuation">)</span> <span class="token operator">:</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后不管是用时还是空间消耗都超越了100%的用户。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1004】最大连续1的个数 III</title>
      <link href="/2020/01/09/leetcode-1004/"/>
      <url>/2020/01/09/leetcode-1004/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="https://godweiyang.com/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由若干 0 和 1 组成的数组 A ，我们最多可以将 K 个值从 0 变成 1 。</p><p>返回仅包含 1 的最长（连续）子数组的长度。</p><p><strong>示例1</strong></p><pre><code>输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释：[1,1,1,0,0,1,1,1,1,1,1]A[5] 和 A[10] 从 0 翻转到 1，最长的子数组长度为 6。</code></pre><p><strong>示例2</strong></p><pre><code>输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3输出：10解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]A[4] 、A[5] 和 A[9] 从 0 翻转到 1，最长的子数组长度为 10。</code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>0 &lt;= K &lt;= A.length</li><li>A[i] 为 0 或 1 </li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题可以采用滑动窗口方法来求解。<br>也就是用头尾指针 l 和 r ，初始化都是 l = r = 0 ，然后向右移动指针 r 。<br>用变量 cnt0 记录 [l, r] 区间内有几个 0 ，用 res 保存答案。</p><p>如果 A[r] = 0 ，那就 0 的数量 cnt0 加 1 。<br>并且 0 的数量和 K 判断，如果 cnt0 &lt;= K ，那就说明 [l, r] 中间的 0 不多，可以用至多 K 次机会填充，那就继续向右移动 r 。<br>但是如果 cnt0 &gt; K ，那就说明 0 的数量太多了，得删掉点 0 了，这时候就得向右移动 l 。<br>这时候看情况，如果 A[l] = 0 ，就要减小 cnt0 ，直到 cnt0 &lt;= K 为止，不再移动 l 。<br>然后继续移动 r ，重复上面过程即可。过程中时刻更新最长的距离 res 。</p><p>因为 l 和 r 分别最多移动 n 次，所以最终的时间复杂度是 $O(n)$ 的。</p><p>那么为什么这样是正确的呢？不会漏掉正确答案所在的区间吗？<br>我们看看漏掉的是哪些区间。<br>对于一个固定的 r ，移动 l 直到 0 的数量小于等于 K （记为 l’ ）的过程中，漏掉的是 [&lt;l, r] 和 [&gt;l’, r] 这些区间。<br>前者 0 数量太多，不符合题意；后者长度更小，显然不是答案。<br>然后继续右移 r ，直到第一个 0 数量大于 K 的位置，漏掉了 [&lt;l, &gt;r] 和 [&gt;l, &gt;r] 区间。<br>前者 0 的数量一定大于 K ，为什么呢？因为右端点在 r 的时候， l 已经是最靠左使得 0 数量小于等于 K 的位置了，而现在 r 向右移动了， l 更不可能左移了；后者长度更小，不予考虑。<br>综上考虑，最优的区间一定被考虑充分了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestOnes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt0<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>cnt0 <span class="token operator">></span> K <span class="token operator">&amp;&amp;</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> cnt0<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析【EMNLP19】语言模型效果不好？也许你可以给它添加一点句法信息</title>
      <link href="/2020/01/09/emnlp19-palm/"/>
      <url>/2020/01/09/emnlp19-palm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="http://arxiv.org/abs/1909.02134" title="PaLM: A Hybrid Parser and Language Model" target="_blank" rel="noopener">PaLM: A Hybrid Parser and Language Model</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文介绍了如何将一个句法分析器融入到神经网络语言模型中，这样在利用了句法信息增强语言模型效果的同时，还可以去掉句法上的监督信号，用来无监督地生成句法树。</p><p>其实将句法信息加入到语言模型中地思想之前就有了，比如PRPN（<a href="http://arxiv.org/abs/1711.02013" title="Neural Language Modeling by Jointly Learning Syntax and Lexicon" target="_blank" rel="noopener">Shen et al.</a>）和ON-LSTM（<a href="http://arxiv.org/abs/1810.09536" title="Ordered Neurons: Integrating Tree Structures into Recurrent Neural Networks" target="_blank" rel="noopener">Shen et al.</a>）。而本文提出了一种新的融入句法信息的方法，相比于之前的两个模型，主要有如下优点：</p><ul><li>更加符合直觉、更加轻巧，不需要很复杂的解码算法。</li><li>在LSTM中加入的attention信息可以用句法信息来监督，可解释性更强，可以和语言模型联合训练。</li><li>如果没有句法信息监督也不要紧，模型可以无监督预测出句法树。</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="span-attention"><a href="#span-attention" class="headerlink" title="span attention"></a>span attention</h3><p>模型中的attention是怎么做的呢？在 $t$ 时刻，模型关注以 $t - 1$ 结尾的所有 span 。但是为了减少运算量，这里只考虑最短的 $m$ 个 span ，也就是 $\{[i, t - 1]\}_{i = t - m}^{t - 1}$ 。</p><p>首先采用普通的 RNN 来获得 $t$ 时刻的隐层表示 $h_t$，然后采用双向 WFSA-RRNN （<a href="https://arxiv.org/abs/1808.09357" title="Rational Recurrences" target="_blank" rel="noopener">Peng et al.</a>）进一步得到表示， WFSA-RRNN 的单元更新公式如下：<br>$$<br>    \begin{aligned}<br>        f_t &amp;= \sigma(W_f h_t) \\<br>        u_t &amp;= (1 - f_t) \odot \tanh(W_u h_t) \\<br>        c_t &amp;= f_t \odot c_{t-1} + u_t<br>    \end{aligned}<br>$$</p><p>然后 span $[i, j]$ 的表示 $c_{i, j}$ 可以计算为：<br>$$<br>    c_{i, j} = c_j - c_{i-1}\odot_{k=i}^{j}f_k<br>$$<br>这个式子其实是从下面这个式子推算而来的：<br>$$<br>    c_{i, j} = u_j + \sum_{k=i}^{j-1}{u_k \odot_{l=k+1}^{j}f_l}<br>$$<br>具体计算过程就不在这里看了，详见论文附录，其实就是用的 WSFA-RRNN 的单元更新公式化简得到的。</p><p><strong>注意上面向量都省略了前向箭头！</strong></p><p>下面就是计算所有 span 表示的算法伪代码：<br><img src="1.jpg" alt></p><p>可以看出复杂度还是挺高的，但是可以用 GPU 并行加速。</p><p>然后就是计算attention了。<br>首先令 $g([i, j])$ 为向量 $c_{ij}$前后向拼接得到，表示 span [i, j] 的最终向量表示。<br>那么在 $t + 1$ 时刻，上下文向量 $a_{t + 1}$ 可以表示为：<br>$$<br>    \begin{aligned}<br>        a_{t+1} &amp;= \sum_{i=0}^{m-1}{w_{t,i}g([t-i,t])} \\<br>        w_{t,i} &amp;= \frac{\exp{s_{t,i}}}{\sum_{j=0}^{m-1}{\exp{s_{t,j}}}}<br>    \end{aligned}<br>$$<br>其中 $s_{t, i}$ 定义为：<br>$$<br>    s_{t,i} = \text{MLP}(h_{t+1};g([t-i, t]))<br>$$<br>最后拼接 $h_{t+1}$ 和 $a_{t+1}$ 作为最后的隐层输出。</p><p>总结一下，计算步骤是这样的：</p><ul><li>首先用一个标准的RNN计算得到隐层表示 $h_t$ 。</li><li>然后将 $h_t$ 输入到一层的双向 WSFA-RRNN 中，得到表示 $c_t$ ，并且用上述算法进一步得到 span 的表示。</li><li>最后对所有以 $t$ 结尾的 span 表示加权求和，得到下一时刻的隐层表示，并预测下一个单词。</li></ul><h3 id="生成句法树"><a href="#生成句法树" class="headerlink" title="生成句法树"></a>生成句法树</h3><p>这就和以往自顶向下解码句法树的算法一样了，对于 span $[i, j]$，寻找使得右儿子得分最高的 split $k$ 即可：<br>$$<br>    k = \text{argmax}_{k \in \{0,\ldots,m-1\}}s_{j,k}<br>$$<br>而如果是有监督的话，对于每个位置 $t$ ，都会预测一个 attention $w_t$，并且有一个 gold 的左边界 $y_t$。<br>注意<strong>这里的 $y_t$ 不一定是 one-hot 的</strong>，因为在一棵句法树中，一个右端点可能对应着很多不同的左端点。<br>最终的损失函数为：<br>$$<br>    \mathcal{L} = \mathcal{L}_{\text{LM}}+\frac{\lambda}{N}\sum_{t=1}^{N}{\mathcal{H}(y_t, w_t)}<br>$$<br>而这里的句法树监督其实可以用现成的 parser ，或者直接用左右二叉树之类的就行了，主要目的是为了提升语言模型性能。</p><p>下图就是一个简单的例子：<br><img src="2.jpg" alt></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>这是一篇短文，所以实验就很简单了。</p><p>首先是PTB上的语言模型困惑度：<br><img src="3.jpg" alt></p><p>然后是WikiText2上的语言模型困惑度：<br><img src="4.jpg" alt></p><p>两个实验都可以看出加了句法树监督的语言模型效果更好，而无监督隐式的语言模型效果也还可以。注意这里的AWD-LSTM指的是之前提出的一种LSTM变体（<a href="https://arxiv.org/abs/1708.02182" title="Regularizing and Optimizing LSTM Language Models" target="_blank" rel="noopener">Merity et al.</a>）。看得出来这些模型参数量其实没多大差别，而如果句法信息乱加监督（比如用右二叉树），效果反而会变差。</p><p>接着是无监督句法分析的效果：<br><img src="5.jpg" alt></p><p>可以发现效果还是很差的，只比随机的二叉树好了那么一丢丢。比之前的 PRPN 差许多，和 DIROA 相比就更不用谈了（<a href="http://arxiv.org/abs/1904.02142" title="Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders" target="_blank" rel="noopener">Drozdov et al.</a>）。这也说明了对语言模型有用的句法信息可能并不符合 PTB 句法树结构。</p><p>最后还分析了左结合多还是右结合多：<br><img src="6.jpg" alt></p><p>可以看出，基本全部都是右结合，也就是attention基本都聚焦在了 span 的最左边的单词。具体原因作者也不知道，留着未来探索。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote><p>其实这篇短文和我 ACL 的工作挺像的，着实让我惊了一身冷汗（<strong>希望 ACL 能中，加油！</strong>）。</p></blockquote><p>不过这篇还是有些小瑕疵的，比如最大考虑长度 $m$ ，这个值在语言模型的训练时用到了，但是分析无监督句法树的时候就去掉限制了，其实会影响无监督句法分析性能的。不过也不要紧，毕竟本文任务不是做句法分析。</p><p>再比如算 attention 是要对所有分数做归一化的，但是句法分析又采用了没有归一化的得分来解码，原因是因为一个右边界对应着多个左边界，所以不能用 attention 解码。但其实这个 attention 在做有监督句法信息的时候， gold 的就不是归一化的，也就是非 one-hot 的。总之这里做的挺粗糙的，也没有设计的很优雅。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 语言模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 1053】交换一次的先前排列</title>
      <link href="/2020/01/09/leetcode-1053/"/>
      <url>/2020/01/09/leetcode-1053/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="https://godweiyang.com/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。</p><p>如果无法这么操作，就请返回原数组。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,2,1]输出：[3,1,2]解释：交换 2 和 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,1,5]输出：[1,1,5]解释： 这已经是最小排列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例3</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,9,4,6,7]输出：[1,7,4,6,9]解释：交换 9 和 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例4</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[3,1,1,3]输出：[1,3,1,3]解释：交换 1 和 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= A[i] &lt;= 10000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题主要出发点有以下几点：</p><ul><li>首先要求交换后的字典序变小，那么一定要<strong>大的和小的交换，并且大的在前</strong>。</li><li>其次要求交换后的字典序尽量大，那么在满足第一点的情况下，<strong>大的元素要尽量靠后</strong>。</li><li>最后<strong>小的元素要尽量大，并且靠左</strong>。</li></ul><p>满足这几点条件，也就是要从最右边开始往左寻找，找到<strong>第一个上升</strong>的数字 A[i]（从左往右看是下降，即 A[i] &gt; A[i+1]）。<br>这一点只为了保证上面的条件1，也就是 A[i] 右边存在比它小的元素。</p><p>然后在 A[i+1] 到 A[n-1] 之间所有比 A[i] 小的数字中找最大的那个就行了。如果最大的有多个相同的，取最左边的一个。</p><p>因为 A[i+1] 到 A[n-1] 子数组是单调递增的，所以不用全部遍历一遍，只需要从最右边开始往左找到第一个比 A[i] 小的数就行了。<br>然后从这个数开始，继续往左找和它相等的数，直到最左边一个相等的数 ，就是答案了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">prevPermOpt1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j<span class="token punctuation">;</span> k <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token function">swap</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> A<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后不管是用时还是空间消耗都超越了100%的用户：<br><img src="1.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 315】计算右侧小于当前元素的个数</title>
      <link href="/2020/01/08/leetcode-315/"/>
      <url>/2020/01/08/leetcode-315/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[5,2,6,1]输出：[2,1,1,0]解释：5 的右侧有 2 个更小的元素 2 和 1 。2 的右侧仅有 1 个更小的元素 1 。6 的右侧有 1 个更小的元素 1 。1 的右侧有 0 个更小的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题没有给数据范围，但是用脚想也知道不能暴力做（ $O(n^2)$ ）。</p><p>这题其实有多种解法，这里简单介绍三种解法。</p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>如果你不熟悉这个数据结构的话，你只需要记住它的功能就行。</p><p>树状数组是一个数组，有两种操作。<br>一个是对某个位置的元素加值或减值，一个是查询第一个位置到某个位置的元素之和。<br>暴力的话每次查询操作复杂度都是 $O(n)$ ，而树状数组可以做到 $O(\log n)$ 。</p><p>具体细节不介绍了，有现成的模板，会用就行了。</p><p>有了这等好东西，就可以把问题这么转化了：<br>新建一个数组 bit ，其中 bit[i] 表示i这个数出现的次数。<br>从右边最后一个数开始向左遍历，每遇到一个数 nums[i] ，就把 bit[nums[i]] 加 1 ，表示这个数多了一个。<br>然后查询 bit[0] 到 bit[nums[i]-1] 中的所有次数之和，就表明了当前时刻有多少数比 nums[i] 小。<br>这一步查询操作正好用到树状数组，最后总的时间复杂度为 $O(n \log n)$ 。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序算法想必大家应该很熟悉了。<br>就是将数组划分为左右两个长度相等的子数组，然后分别递归排序，得到左右两个有序的子数组。<br>然后就是合并了，只要用两个头指针，分别指着两个子数组的开头，然后分别向右移动合并就行了。</p><p>那么在这题中怎么用呢？<br>假设左右两个子数组为 a[l], …, a[m] 和 a[m+1], …, a[r] ，头指针分别为 i = l 和 j = m + 1 。<br>然后开始合并，首先 j 向右移动，直到 a[j] &gt;= a[i] ，也就是在右半部分子数组中找到所有小于 a[i] 的数。<br>然后把这些数依次放入临时数组中，并得到结论：右半部分子数组中比 a[i] 小的数有 j - m - 1 个。<br>然后把 a[i] 也推进临时数组里，重复进行上述过程，直到 i &gt; m 。<br>最后如果右半部分数组还剩一些数，说明它们是最大的，推入临时数组就行了，最后把临时数组里的数复制进原数组，这部分就排好序了。</p><p>要注意的是排序后原来的下标会丢失，所以用一个 pair 类型保存每一个数和它原来的下标。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>这种方法也很显然。<br>从最右边一个数开始构建二叉搜索树，结点保存这个数和右边比它小的数的数量。<br>如果新插入一个数，就插入到二叉搜索树中，沿途记得要更新经过的每个结点的数量。<br>如果经过一个结点，并且插入的数比结点的数小，那么就在左子树中继续寻找插入位置，并且结点数量加 1 。<br>如果插入的数比结点的数大，那么就在右子树中寻找，并且插入的数对应的答案加上该结点的数量。</p><p>具体这里就不实现了，主要考察的是数据结构，不想写了。。。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSmaller</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">sort</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> y <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> y <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> y<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> y <span class="token operator">+</span> len<span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">=</span> x<span class="token punctuation">;</span>            i <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i <span class="token operator">-</span><span class="token operator">=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> x<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSmaller</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> cnt<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idl <span class="token operator">=</span> l<span class="token punctuation">,</span> idr <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idl <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>idr <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">[</span>idr<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">&lt;</span> x<span class="token punctuation">[</span>idl<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>                y<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>idr<span class="token punctuation">]</span><span class="token punctuation">;</span>                idr<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cnt<span class="token punctuation">[</span>x<span class="token punctuation">[</span>idl<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> idr <span class="token operator">-</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            y<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>idl<span class="token punctuation">]</span><span class="token punctuation">;</span>            idl<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idr<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些自用软件，学妹们用了都说好用！</title>
      <link href="/2020/01/07/software-share/"/>
      <url>/2020/01/07/software-share/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天我给大家分享一些我平时自用的软件，有学习的、编程的、娱乐的、工具类的等等。</p><p>有些软件是破解版的，去除了广告，都很实用！</p><h1 id="迅雷极速版"><a href="#迅雷极速版" class="headerlink" title="迅雷极速版"></a>迅雷极速版</h1><p>迅雷我一直用的是纯净版（极速版），相比于最新的迅雷9，这个版本没有广告和在线视频等没用的功能。</p><blockquote><p>注意会经常弹出来让你更新，千万别点确定，点取消就行了。</p></blockquote><p>界面看起来就很简洁：<br><img src="thunder.jpg" alt></p><p><strong>下载地址：</strong><br><a href="http://xiazai.zol.com.cn/detail/43/428424.shtml" target="_blank" rel="noopener">http://xiazai.zol.com.cn/detail/43/428424.shtml</a></p><h1 id="QQ影音"><a href="#QQ影音" class="headerlink" title="QQ影音"></a>QQ影音</h1><p>QQ影音是腾讯少有的几款良心软件了，没有任何广告，也不会流氓捆绑。</p><p>功能也够用了，比如视频转gif、转码、截取视频等常用功能都用了。</p><blockquote><p>QQ影音可以用来作为迅雷的边下边播的播放器，然后就可以舒舒服服看一些你喜欢看的电影了。</p></blockquote><p>界面：<br><img src="qqplayer.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://player.qq.com/" target="_blank" rel="noopener">https://player.qq.com/</a></p><h1 id="7zip"><a href="#7zip" class="headerlink" title="7zip"></a>7zip</h1><p>7zip是一款轻量的压缩软件，最开始用它是在学校的机房里。</p><p>安装包才1兆，常用的压缩格式都支持，速度也还不错，还不像国内某些压缩软件那么流氓。</p><blockquote><p>注意，下载完之后用到的运行程序是安装目录下的7zFM.exe，可以右键任意压缩包用此方式默认打开，以后就方便了。</p></blockquote><p>界面：<br><img src="7zip.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.7-zip.org/" target="_blank" rel="noopener">https://www.7-zip.org/</a></p><h1 id="SumatraPDF"><a href="#SumatraPDF" class="headerlink" title="SumatraPDF"></a>SumatraPDF</h1><p>SumatraPDF是一款轻量的pdf阅读器，没有任何功能，只能看pdf。</p><p>安装包只有几兆，功能比较单一，如果你喜欢做批注或者编辑pdf，那就不推荐用这个。<br>像我平时只需要看pdf，用这个再合适不过了，打开速度极快，不占用内存。</p><blockquote><p>这个软件有绿色版和安装版，如果你用ctex写论文，它自带的pdf阅读器就是SumatraPDF。</p></blockquote><p>界面：<br><img src="pdf.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.sumatrapdfreader.org/download-free-pdf-viewer.html" target="_blank" rel="noopener">https://www.sumatrapdfreader.org/download-free-pdf-viewer.html</a></p><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Typora是一款跨平台的markdown写作软件，可见即可得。</p><p>支持插入表格、图片，实时显示公式等功能，非常的方便。<br>另一大好处是可以导出pdf文档，提供了多种风格，我比较喜欢github风格。</p><blockquote><p>不过我已经很久没用了，我现在选择vscode直接写markdown，要啥实时预览嘛。</p></blockquote><p>界面：<br><img src="typora.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><h1 id="Zotero"><a href="#Zotero" class="headerlink" title="Zotero"></a>Zotero</h1><p>Zotero是一款跨平台的文献管理软件，对于经常看论文的同学很有用。</p><p>你是不是还在用文件夹分类保存论文呢？多麻烦哟，赶紧用Zotero吧。<br>Zotero支持实时同步pdf到云端服务器，还可以管理你喜欢的网页之类的。<br>Zotero还提供了浏览器插件，还可以自动识别论文的作者等信息，给你安排得明明白白。</p><blockquote><p>Zotero目前免费版云端只能保存300兆文件，一般也够用了。如果满了，支持第三方网盘保存。</p></blockquote><p>界面：<br><img src="zotero.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://www.zotero.org/" target="_blank" rel="noopener">https://www.zotero.org/</a></p><h1 id="Marp"><a href="#Marp" class="headerlink" title="Marp"></a>Marp</h1><p>Marp是一款跨平台的markdown制作ppt的软件，非常的方便快捷。</p><p>如果你不要求炫酷的动画，只是简简单单的做个组会报告的话，用Marp再合适不过了，做好整个ppt只需要几分钟。<br>Marp支持几乎所有markdown语法和部分html语法，还支持插入emoji，支持编辑公式。<br>最后支持导出为pdf、html和pptx。</p><blockquote><p>Marp是开源的免安装版，所以下载完直接打开运行程序就行，最好自己建一个快捷方式。</p></blockquote><p>界面：<br><img src="marp.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://marp.app/" target="_blank" rel="noopener">https://marp.app/</a></p><h1 id="Mathpix-Snipping-Tool"><a href="#Mathpix-Snipping-Tool" class="headerlink" title="Mathpix Snipping Tool"></a>Mathpix Snipping Tool</h1><p>这是一款跨平台的识别图片公式，并转化为latex公式的软件，准确率非常高。</p><p>但是每个月只有免费的50次识别，可以换不同邮箱注册。</p><blockquote><p>少用这种软件，好好练练latex公式语法，熟练了打的很快的。</p></blockquote><p>界面：<br><img src="mathpix.jpg" alt></p><p><strong>下载地址：</strong><br><a href="https://mathpix.com/" target="_blank" rel="noopener">https://mathpix.com/</a></p><blockquote><p>我平时常用的软件基本就是这些了，其他都是些大家比较熟悉的软件了，就不介绍了。<br>如果大家还有什么好用、提高效率的实用软件，欢迎评论留言！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法系列【LeetCode 689】三个无重叠子数组的最大和</title>
      <link href="/2020/01/07/leetcode-689/"/>
      <url>/2020/01/07/leetcode-689/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组 $nums$ 由正整数组成，找到三个互不重叠的子数组的最大和。<br>每个子数组的长度为 $k$ ，我们要使这 $3k$ 个项的和最大化。<br>返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。</p><p><strong>示例1</strong></p><pre class="line-numbers language-text"><code class="language-text">输入：[1,2,1,2,6,7,5,1], 2输出：[0, 3, 5]解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示</strong></p><ul><li>$nums.length$ 的范围在[1, 20000]之间。</li><li>$nums[i]$ 的范围在[1, 65535]之间。</li><li>$k$ 的范围在 [1, floor(nums.legth / 3)]之间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先看数据范围，这题不能使用暴力，暴力时间复杂度是 $O(n^3)$ ，一定会超时，所以考虑使用动态规划求解。</p><p>下面考虑一般情况，也就是求解划分成 $N$ 个不重叠数组的最大和。</p><p>假设到第 $i$ 个元素为止，一共已经产生了 $j$ 个不重叠数组，那么令 $dp[i][j]$ 表示这$j$个不重叠数组的最大和。</p><p>然后就要寻找状态转移方程。对于第 $i$ 个元素，分为两种情况，可取可不取。</p><p>如果取，那就说明 $nums[i]$ 是第 $j$ 个子数组的最后一个元素，那么转移方程为：</p><p>$$<br>    dp[i][j] = dp[i-k][j-1] + nums_{i-k+1:i}<br>$$</p><p>也就是说，从 $i-k+1$ 到 $i$ ，这 $k$ 个元素构成了第 $j$ 个子数组，那我们只需要求到第 $i-k$ 个元素为止，产生 $j-1$ 个不重叠数组的最大和即可。</p><p>如果不取，那问题就变成了求到第 $i-1$ 个元素为止，产生 $j$ 个不重叠数组的最大和，那么转移方程为：</p><p>$$<br>    dp[i][j] = dp[i-1][j]<br>$$</p><p>当然这题还需要你还原出最大和的情况下，所有子数组的起始元素下标，所以需要另外用一个数组保存一下每一步的最优下标。</p><p>同样，假设到第 $i$ 个元素为止，一共已经产生了 $j$ 个不重叠数组，用 $path[i][j]$ 表示第 $j$ 个子数组的末尾元素下标。</p><p>那么按照上面的推断，如果取第 $i$ 个元素，那么 $path[i][j]=i$ ；否则的话 $path[i][j]=path[i-1][j]$ 。</p><p>最后就是根据 $path$ 数组还原答案了。</p><p>首先最后一个子数组的末尾元素下标一定是 $idx=path[len-1][N]$ ，那么它的起始元素下标就是 $idx-k+1$ ，然后前一个子数组末尾元素下标就是 $idx=path[idx-k][N-1]$ ，依次下去，直到第一个子数组被求解完毕。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">maxSumOfThreeSubarrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> N <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sum<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>            sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        path<span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> path<span class="token punctuation">[</span>len<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>idx <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            idx <span class="token operator">=</span> path<span class="token punctuation">[</span>idx<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>idx <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><img src="1.jpg" alt></p><p>可以看到，时间和空间还有提升的余地。想到的可能优化方法是类似于0-1背包那样，去掉动态规划数组的第二个维度，来优化空间复杂度。</p><p>但是这是有些问题的，暂时并没有想到不增加时间复杂度下减少空间开销的方法，欢迎大家提出自己的想法。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[EMNLP19]如何在Transformer中融入句法树信息？这里给出了一种解决方案</title>
      <link href="/2020/01/06/emnlp19-tree-transformer/"/>
      <url>/2020/01/06/emnlp19-tree-transformer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/D19-1098.pdf" target="_blank" rel="noopener">Tree Transformer: Integrating Tree Structures into Self-Attention</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>之前其实有很多工作将句法信息融入到了RNN中，例如ON-LSTM和PRPN，用来隐式建模句法结构信息，同时提升语言模型的准确率。本文尝试将句法信息融入到Transformer中，用来赋予attention更好的解释性。同时可以无监督的预测出句子的句法树，并且相比于一般的Transformer，语言模型的性能有所提高。</p><h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><p><img src="1.jpg" alt><br>上面这张是模型结构，最主要的区别就是在multi-head attention操作基础上新增了一个成分的attention，用来表示一段span能否构成一个短语。<br>比如上图中，“cute dog”构成一个短语，所以第0层中这两个单词的attention较大。<br>而“the cute dog”构成了一个更大的短语，所以第1层中“the”和“dog”的attention较大。</p><p>回顾self-attention的操作，主要是计算两个单词的向量点积：<br>$$<br>    E = \text{softmax}(\frac{QK^{\top}}{d})<br>$$<br>这里$d$一般取$\sqrt{d_k}$。但是在本文中，新增加了一个成分先验$C$，其中$C_{i,j}$表示$w_i$和$w_j$在一个短语内的概率。<br>然后与原来的self-attention做元素乘即可：<br>$$<br>    E = C \odot \text{softmax}(\frac{QK^{\top}}{d})<br>$$<br>注意不同的head之间共享$C$。</p><p>那么这个成分先验$C$怎么算呢？<br>这里把它拆成若干相邻单词在同一短语内概率的乘积。<br>也就是定义$a_i$为单词$w_i$和$w_{i+1}$在同一短语内的概率，那么$C_{i,j}$就可以表示为：<br>$$<br>    C_{i, j} = \prod_{k=i}^{j-1}{a_k}<br>$$<br>这样只有$w_i$到$w_j$中所有单词都有较大概率在同一短语中，$C_{i, j}$取值才比较大。<br>当然在实现中会取对数，来避免数值太小。</p><p>那么问题又来了，$a$怎么算？<br>首先类似self-attention，计算相邻两个单词属于同一短语的得分：<br>$$<br>    s_{i, i+1} = \frac{q_i \cdot k_{i+1}}{d}<br>$$<br>这里$d$取$\frac{h \cdot d_k}{2}$，$h$是head数。</p><p>注意这里区分了方向，也就是还存在得分$s_{i+1, i}$，并且两者虽然意义是一样的，但是分数不一定相同。<br>为了防止出现一种问题，也就是所有得分全部相同，然后算出来概率全是1，那就没有意义了，所以要给得分加上限制，也就是归一化。<br>这里选择归一化一个单词和左右邻居两者的得分：<br>$$<br>    p_{i,i+1}, p_{i, i-1} = \text{softmax}(s_{i,i+1}, s_{i, i-1})<br>$$</p><p>然后由于$p_{i, i+1}$和$p_{i+1, i}$值不一样，所以取平均：<br>$$<br>    \hat{a}_i = \sqrt{p_{i, i+1} \times p_{i+1, i}}<br>$$<br>这样的话，如果两个相邻单词互相之间连接的概率很大，就会导致$\hat{a}_i$很大，也就说明了这两个单词大概率属于同一个短语。</p><p>从第一张模型图中可以看到，成分attention不只计算了一层。<br>低层可以用来表示两两相邻单词之间属于同一短语的概率，而高层可以表示属于更大的短语的概率。<br>注意还得满足一个性质，也就是如果两个单词在低层大概率属于同一个短语，那他们高层肯定更大概率属于一个更大的短语。<br>所以计算方式如下：<br>$$<br>    a_i^l = a_i^{l-1} + (1 - a_i^{l-1})\hat{a}_i^l<br>$$<br>初始化的时候$a_i^{-1}$都设为0。这样对于每一层都可以得到一个成分先验$C^l$。</p><h1 id="无监督句法分析"><a href="#无监督句法分析" class="headerlink" title="无监督句法分析"></a>无监督句法分析</h1><p><img src="2.jpg" alt><br>上图是句法树解码算法，类似于句法距离那篇论文的解码算法。<br>因为$a^l$表示的是相邻两个单词属于同一个短语的概率，所以首先找最小的$a_k^l$，然后从这里将短语划分为两个子短语，然后递归划分下去。<br>但是这样效果可能不是很好，因为单个一层表示的短语范围其实是有限的，并不能很好的囊括所有的短语。<br>所以像上图一样，从最高层开始递归开始解码。<br>首先找到最小值$a_b^l$，如果$a_b^l$大于阈值（实验中为0.8），那说明这个分割点不可信。<br>如果这时候已经到了第$m$层（实验中设为3），那没办法了，说明了这些单词没有分割点，全当作一个短语就行了。<br>如果还没到第$m$层，那就继续往下一层找分割点。<br>而如果小于阈值，说明分割点可信，那就这么划分下去好了。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>首先是在WSJ测试集上的无监督句法分析结果：<br><img src="3.jpg" alt><br>可以看到Tree-Transformer效果还是好于之前的ON-LSTM和PRPN的，虽然比在NLI上训练的DIORA略差，但也情有可原，毕竟人家训练集大，而且是全局解码，<br>甚至还达到了URNNG的效果。而层数选择10层是效果最好的。</p><p>然后是在WSJ10测试集上的无监督句法分析结果：<br><img src="4.jpg" alt><br>可以看到，长度很短的时候Tree-Transformer效果就甚至不如PRPN了，和ON-LSTM相比其实也半斤八两。<br>论文并没有分析原因，甚至都没有提这个。</p><p>然后是采用不同的层做出来的无监督句法分析结果：<br><img src="5.jpg" alt><br>可以看到，最小递归到第三层的时候结果最好，而看的层数越少，也就是只看高层的，效果非常的差。<br>只看单独一层的效果也不大行，这都说明了高层的表示更加的抽象，其实不大适宜句法信息的表示。<br>而低层又太接近单词层面了，都是表面信息。<br>这其实和最近的一篇解释bert中attention含义的论文结果一致，中间层的attention表示的是句法信息。</p><p>最后是语言模型的困惑度结果：<br><img src="6.jpg" alt><br>这里就只和普通的Transformer相比了，结果还是更好的。<br>因为这里得用masked LM做目标函数，所以没法和ON-LSTM、PRPN等语言模型相比。</p><p>其他关于attention解释性等讨论详见论文，我觉得没有多大意思，attention的可解释性最近争论一直很大，强行解释没有意义。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文提出的Tree Transformer用成分先验表示两个单词属于同一个短语的概率，然后和self-attention联合决定两个单词之间的attention。<br>并且提出了一种解码出句法树的算法，但是还存在着一些问题。</p><p>文中说尝试过用Transformer预训练Tree Transformer，这样loss下降的更低了，拟合的更好，但是解码出的句法树效果更差了。<br>这其实是有道理的，之前见过一篇分析论文，提到了语言模型训练的好，并不一定代表着句法树学的好，这两者不能划等号。<br>所以今后如何选择更好更合适的损失函数，值得研究。</p><p>这里面还有一些文章可以做，我总感觉本文模型的attention计算方式还是挺牵强的，特别是得分归一化那里，强行将单词左右邻居视为两种不同的角色。<br>下一步工作我可以在上面进行改进，换一种全新的attention计算方式试试，另外损失函数上面考虑到前一篇文章提到的乱序问题，可以尝试用还原词序作为目标任务。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 生成模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[TACL19]生成模型还在用自左向右的顺序？这篇论文教你如何自动推测最佳生成顺序</title>
      <link href="/2020/01/05/tacl19-indigo/"/>
      <url>/2020/01/05/tacl19-indigo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/abs/1902.01370" target="_blank" rel="noopener">Insertion-based Decoding with automatically Inferred Generation Order</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>大多数的生成模型（例如seq2seq模型），生成句子的顺序都是从左向右的，但是这不一定是最优的生成顺序。<br>可能有人要说，反正最终都是生成一个句子，跟生成顺序有啥关系？<br>但是大量实验确实表明了从左向右生成不一定是最好的，比如先生成句子中的核心词（出现词频最高的词，或者动词等）可能效果会更好。</p><p>于是这篇论文就提出了自动推测最佳的生成顺序，考虑所有顺序的概率，优化概率之和。<br>但是对于任意一个生成顺序，如何还原原本的句子呢？<br>本文又提出了一个相对位置编码的方案，并且融合到了Transformer里。</p><h1 id="传统序列生成模型"><a href="#传统序列生成模型" class="headerlink" title="传统序列生成模型"></a>传统序列生成模型</h1><p>给定一个输入句子$x$，生成的句子$y$的概率可以被建模为：<br>\[<br>        p_{\theta}(y | x) = \prod_{t=0}^{T}{p_{\theta}(y_{t+1}|y_{0:t}, x_{1:T’})}<br>\]<br>其中规定输出句子的首尾单词$y_{0}$和$y_{T+1}$是特殊记号。</p><p>那么模型最大化正确输出的概率就行了。<br>解码的时候在每个时刻取概率最大的输出单词就行了，当然也可以加上beam search等方法提高性能。</p><h1 id="InDIGO"><a href="#InDIGO" class="headerlink" title="InDIGO"></a>InDIGO</h1><p>本文将生成顺序看作隐变量$\pi$，那么对于一个输出句子$y$，他的隐变量可能取值是阶乘级别的。<br>我们取所有顺序的概率之和，作为输出$y$的概率：<br>\[<br>    p_{\theta}(y|x) = \sum_{\pi \in \mathcal{P}_{T}}{p_{\theta}(y_{\pi}|x)}<br>\]<br>而每个生成顺序的概率被定义为：<br>\[<br>    p_{\theta}(y_{\pi}|x) = p_{\theta}(y_{T+2}|y_{0:T+1}, z_{0:T+1}, x_{1:T’}) \cdot \prod_{t=1}^T{p_{\theta}(y_{t+1}, z_{t+1}|y_{0:t}, z_{0:t}, x_{1:T’})}<br>\]<br>这里多了一个变量$z$，用来表示生成的单词在原句子中的绝对位置。<br>还多了一项$y_{T+2}$，表示句子生成结束。<br>为什么要用这一项呢？因为原来的结束符号&lt; /s&gt;被当作第二项输入进序列了。</p><p>这里就会出现一个问题，在每一步预测的时候，都不知道最终句子长度是多少。<br>那么怎么知道绝对位置$z$是多少呢？所以要用相对位置$r$来进行编码。</p><p>假设在$t$时刻，对于第$i$个单词$w_i$，采用一个向量来表示它的相对位置，每个维度取值只有-1，0和1三种。<br>$r_{i,j}$定义为：如果$w_i$绝对位置在$w_j$的左边，就取-1；如果是一个词，就取0；如果在右边，就取1。<br>可以观察到这个时刻向量长度其实只有$t+1$，而且下个时刻长度就会加1。<br>将这些向量拼接成一个矩阵$R$，每一列表示一个单词的位置向量，这个矩阵关于主对角线对称的元素其实是相反数。</p><p>那么下一个时刻是不是这个矩阵得重算呢？不需要。<br>因为下一个单词无论插在哪里，都不会影响之前的单词的相对顺序，所以只要给这个矩阵$R$新增一行一列即可：<br><img src="1.jpg" alt></p><p>但是$r_{t+1}$不能随便取值，不然可能是非法的，没办法还原到绝对位置。<br>所以这里定义$r_{t+1,j}$这么算：<br>首先预测一个单词$y_{k}$，然后预测$y_{t+1}$插入到它的左边还是右边。<br>如果$j = k$，那么如果插入到左边，值取-1，插入到右边取1。<br>如果$j \neq k$，那么$y_{t+1}$和前面单词的相对顺序其实是和$y_k$和他们的相对顺序完全相同的，那么直接取$r_{k, j}$就行了。</p><p>伪代码如下：<br><img src="2.jpg" alt></p><p>最后得到了相对位置之后，怎么还原为绝对位置呢？<br>只需要用下面式子就行了：<br>\[<br>    z_i = \sum_{j}{\max\{0, r_{i, j}\}}<br>\]<br>也就是看每个单词前面有多少单词。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>本文只修改了Transformer的解码器部分，因为对于随机的生成顺序，解码的时候绝对位置未知，所以传统的绝对位置编码行不通。</p><p>稍稍修改attention的计算方式：<br>\[<br>    e_{i, j} = \frac{(u_i^{\top}Q)\cdot(u_j^{\top}K + A_{[r_{i,j}+1]})^{\top}}{\sqrt{d_{\text{model}}}}<br>\]<br>其中$u$是输出的隐层表示，$Q, K, A$是参数，$A$根据相对位置不同分为三个向量表示。</p><p>经过attention计算之后，得到了当前已预测词的表示矩阵$H$，那么下一个词和对应相对位置概率为：<br>\[<br>    p(y_{t+1}, r_{t+1}|H) = p(y_{t+1}|H)\cdot p(r_{t+1}|y_{t+1}, H)<br>\]<br>也就是先预测下一个单词是什么，再预测它的相对位置。当然也可以倒过来，只是实验效果不如这个。</p><p>预测单词的概率：<br>\[<br>    p_{\text{word}}(y|H) = \text{softmax}((h_t^{\top}F)\cdot W^{\top})<br>\]</p><p>预测下一个词应该插在哪个位置：<br>\[<br>    p_{\text{pointer}}(k|y_{t+1}, H) = \text{softmax}((h_t^{\top}E + W_{[y_{t+1}]})\cdot [H^{\top}C; H^{\top}D]^{\top})<br>\]<br>注意到这里不仅拼接上了下一个词的词向量，还区分了每个词左边和右边的隐层表示。</p><blockquote><p>其实这里有个问题，一个词在$w_i$的右边不就等价于在$w_{i+1}$的左边吗？那其实这两个预测结果都是对的。虽然最后的$r$向量都是一样的。</p></blockquote><h1 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h1><p>因为一个句子的可能排列顺序太多了，不可能一一枚举，所以这里最大化ELBO来代替最开始的概率之和。<br>对于输入$x$和生成$y$，首先定义一个生成顺序$\pi$的近似后验$q(\pi|x, y)$。<br>然后ELBO可以表示为：<br><img src="4.jpg" alt><br>注意这里如果近似后验训练中固定不变的话，第二项可以忽略。</p><p>然后就可以根据近似后验来进行采样，优化这个函数了，那么这个近似后验怎么定义呢？</p><p>第一种方法是定义为一个常见的确定的顺序，比如从左向右、从右向左等等，详见下表：<br><img src="5.jpg" alt><br>这种情况下，模型其实就变成了和普通的序列生成模型差不多了，只用最大化一个生成顺序的概率就行了，区别就是多了相对位置编码。</p><p>第二种方法是用beam search，这里称作Searched Adaptive Order (SAO)。<br>传统的序列生成模型其实也有beam search，不过那是在每个时刻解码概率最大那些子序列。<br>而这里的beam search空间更大，搜索的是整个排列的空间。<br>也就是在每个时刻，遍历所有的下一个单词和它的相对位置，找出最大的$B$个子序列。<br>最后的目标函数变为了：<br>\[<br>    \mathcal{L}_{\text{SAO}} = \frac{1}{B} \sum_{\pi \in \mathcal{B}}{\log{p_{\theta}(y_{\pi}|x)}}<br>\]<br>这里近似后验被定义为了：如果$\pi$在$\mathcal{B}$中，概率为$\frac{1}{B}$，否则为0。</p><p>还有一些小trick，比如beam search加入噪声，这样可能采样到概率比较小的那些排列。<br>还有位置预测模块收敛的比单词预测模块更快，这就会导致模型最后总是先预测出高频词或功能词（大雾。。。）。<br>解决方法是先用给定的顺序（例如从左向右）预训练一遍模型，然后再训练beam search模型。</p><p>最终解码还是用上面的伪代码，只是加入了beam search。<br>但是这里是先预测的单词，再预测的位置，和训练时的beam search略有不同。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>实验主要做了几组机器翻译、词序还原、代码生成和图像标签生成，这里就简单看一下机器翻译结果，其他的详见论文。</p><p>机器翻译结果如下：<br><img src="6.jpg" alt></p><p>可以看出beam search的提升还是挺大的，而用随机顺序生成序列效果很差，用句法树的遍历顺序生成也挺差的。</p><p>其他的实验细节和结果详见论文，这里就不展开分析了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇论文提出了考虑多种序列生成的顺序，以此提升最终生成的效果，实验证明还是有效的。<br>为了记住这种顺序，还提出了相对位置表示，用来解决原始Transformer无法表示随机排列的问题。</p><p>但是总感觉beam search和相对位置表示的矩阵不是很优雅，很繁琐。<br>后续工作也提到了直接预测排列，而不是用beam search。<br>还有这种相对位置表示能否用在其他任务上，比如做成通用的位置表示？<br>不过这种“打乱顺序”的思想倒是挺不错的，很多地方可以用，毕竟人类看句子第一眼可能也会看到核心关键词嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> TACL </tag>
            
            <tag> 生成模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信聊天记录深度分析，看看这一年你和谁最亲密</title>
      <link href="/2019/12/29/wechat-analysis/"/>
      <url>/2019/12/29/wechat-analysis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>2019年就要过去了，想知道你平时用的最多的词是什么吗？想知道你一天中哪个时间段聊天最多吗？想知道这一年谁和你聊的最多吗？<br>本文将会一步一步地教你如何导出微信聊天记录，并且对它们进行深入分析。</p></blockquote><h1 id="导出微信聊天数据"><a href="#导出微信聊天数据" class="headerlink" title="导出微信聊天数据"></a>导出微信聊天数据</h1><p>这一步是最为关键的，没有数据何谈分析？<br>在之前的教程中，我已经教过了如何导出微信聊天记录到电脑（仅限安卓）。<br>详见之前的博文：<a href="https://godweiyang.com/2019/08/09/wechat-explore/">https://godweiyang.com/2019/08/09/wechat-explore/</a>。</p><p>下载所需要的两个python处理脚本：<br><a href="https://github.com/godweiyang/wechat-analysis" target="_blank" rel="noopener">https://github.com/godweiyang/wechat-analysis</a></p><h1 id="表格结构分析"><a href="#表格结构分析" class="headerlink" title="表格结构分析"></a>表格结构分析</h1><p>在第9个步骤之后，你就会得到下面这样的一张excel表格：</p><p><img src="1.jpg" alt="微信聊天记录表格"></p><p>这个表格有很多列。<br><code>msgId</code>列表示消息的序号。<br><code>type</code>列表示消息的类型，我们这里只需要用到类型1。<br><code>isSend</code>列表示是发送（1）还是接收（0）的消息。<br><code>createTime</code>列表示消息的时间，不过这里用的是相对时间，单位是毫秒，所以计算的时候要特别注意。<br><code>talker</code>列表示聊天的对象，如果有后缀<code>@chatroom</code>就表示是群聊，如果有前缀<code>gh_</code>就表示是公众号消息，其他的全部都是私聊。<br><code>content</code>列表示消息内容。</p><p><strong>首先将<code>type</code>列只勾选1，因为其他信息都是我们不需要的。</strong></p><h1 id="这一年聊天出现最多的词是什么？"><a href="#这一年聊天出现最多的词是什么？" class="headerlink" title="这一年聊天出现最多的词是什么？"></a>这一年聊天出现最多的词是什么？</h1><p>这个部分我们细分为四个类型，分别是私聊发送的消息，私聊接收的消息，群聊发送的消息和群聊接收的消息。</p><p><strong>私聊发送的消息：</strong><br>第一行<code>isSend</code>列勾选1，<code>talker</code>列去掉所有后缀<code>@chatroom</code>和前缀<code>gh_</code>的勾。<br>然后得到如下的表格：</p><p><img src="2.jpg" alt="私聊发送消息汇总"></p><p>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_send_person_2019.txt</code>，并粘贴进去。<br><img src="3.jpg" alt="选中第I列"></p><p><strong>私聊接收的消息：</strong><br>第一行<code>isSend</code>列勾选0，<code>talker</code>列去掉所有后缀<code>@chatroom</code>和前缀<code>gh_</code>的勾。<br>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_receive_person_2019.txt</code>，并粘贴进去。</p><p><strong>群聊发送的消息：</strong><br>第一行<code>isSend</code>列勾选1，<code>talker</code>列勾选所有后缀<code>@chatroom</code>。<br>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_send_group_2019.txt</code>，并粘贴进去。</p><p><strong>群聊接收的消息：</strong><br>第一行<code>isSend</code>列勾选0，<code>talker</code>列勾选所有后缀<code>@chatroom</code>。<br>然后选中第I列，按<code>ctrl+c</code>复制，新建一个<code>wechat_receive_group_2019.txt</code>，并粘贴进去。</p><p>然后这四个txt文件就可以分别生成词云了。<br>生成词云的方法请看我之前的教程：<a href="https://godweiyang.com/2019/07/27/wordcloud/">https://godweiyang.com/2019/07/27/wordcloud/</a>。</p><p>最终的效果图如下所示：<br><img src="4.jpg" alt="私聊发送消息词云"><br><img src="5.jpg" alt="私聊接收消息词云"><br><img src="6.jpg" alt="群聊发送消息词云"><br><img src="7.jpg" alt="群聊接收消息词云"></p><h1 id="你最喜欢在哪一个时间段发消息？"><a href="#你最喜欢在哪一个时间段发消息？" class="headerlink" title="你最喜欢在哪一个时间段发消息？"></a>你最喜欢在哪一个时间段发消息？</h1><p>首先<code>talker</code>列去掉前缀<code>gh_</code>的勾，其他全部勾选上。<br>然后注意到<code>createTime</code>列默认用的是科学计数法，所以修改一下。<br>选中G列，右键点<code>单元格格式-自定义</code>，<code>类型</code>一栏填写0，确认。<br>然后就会变成下面这样：<br><img src="10.jpg" alt="去除科学计数法"></p><p>然后选中G列，复制粘贴到新建的<code>wechat_send_all_time_2019.txt</code>。<br>注意要把第一行的列名去掉。</p><p>然后就是数据处理与画图部分了。</p><p>直接运行命令：<br><code>python3 process_time.py wechat_send_all_time_2019.txt</code></p><p>出来的效果图如下：<br><img src="8.jpg" alt="各个时间段发送消息数"></p><h1 id="这一年你和谁互动最多？"><a href="#这一年你和谁互动最多？" class="headerlink" title="这一年你和谁互动最多？"></a>这一年你和谁互动最多？</h1><p>首先<code>talker</code>列去掉后缀<code>@chatroom</code>和前缀<code>gh_</code>的勾，其他全部勾选上。<br>然后<code>isSend</code>列0和1都勾上。<br>然后选中H和I列，粘贴到新建的<code>people.txt</code>。</p><p>直接运行命令：<br><code>python3 process_people.py people.txt</code></p><p>出来的效果图如下：<br><img src="9.jpg" alt="和你互动最多的前10个人"></p><p>注意这里用户名并不会显示出来，只会显示微信的id，所以你需要去excel表格里一个个搜索看聊天内容，自己手动看是谁。</p><p>最后安利一下我的公众号，大家可以关注一下，不定期分享NLP专业知识和计算机知识：<br><img src="11.jpg" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[ACL18]一个句子向量表示究竟可以塞进多少语言性质？</title>
      <link href="/2019/12/25/acl18-probe/"/>
      <url>/2019/12/25/acl18-probe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/P18-1198/" target="_blank" rel="noopener">What you can cram into a single $&amp;!#* vector: Probing sentence embeddings for linguistic properties</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文主要探究了不同encoder在不同任务上训练得到的句子向量表示，是否蕴含了各种语言性质。</p><p><img src="1.png" alt></p><p>本文主要有三个贡献点：</p><ul><li>分析了三种类型的encoder，并在7个任务上预训练句向量。</li><li>提出了10种探测任务。</li><li>每个探测任务探究一种语言性质。</li></ul><h1 id="探测任务"><a href="#探测任务" class="headerlink" title="探测任务"></a>探测任务</h1><p>为了探测这些性质，作者提出了10种探测任务，并分成了三个类别，分别用来探测句子的表面信息、句法信息和语义信息。</p><p>这10种探测任务有一些共同点：</p><ul><li>数据集都是作者手工设计的，用来做分类任务。</li><li>数据集基于Toronto Book Corpus，句子长度只挑选了5到28的。</li><li>训练集大小100k，验证集和测试集都是10k。</li><li>数据集里的偏差都被人工去除了（例如对某个类别预测影响很大的单词）。</li></ul><p>探测任务全部采用MLP进行分类。</p><h2 id="表面信息"><a href="#表面信息" class="headerlink" title="表面信息"></a>表面信息</h2><p>第1个任务是预测句子长度（<strong>SentLen</strong>）。<br>这个任务将句子长度划分成了6个区间，预测长度落在哪个区间里，所以最后是一个6分类任务。<br>这个任务用来探索句向量能否保留句子长度的信息。</p><p>第2个任务是预测一个句子里含有哪个关键词（<strong>WC</strong>）。<br>这个任务挑选出了1000个频率比较高的单词，预测一个句子中含有哪个单词。<br>数据保证一个句子中不会同时出现两个关键词。<br>这个任务用来探索句向量能否保留单词的信息。</p><h2 id="句法信息"><a href="#句法信息" class="headerlink" title="句法信息"></a>句法信息</h2><p>第3个任务是预测句子对应句法树第二层的label（<strong>TopConst</strong>）。<br>这个任务将句法树第二层（也就是根节点S的子结点）所有label拼接成一个label（比如ADVP_NP_VP），<br>然后挑选出频率最高的19种label，其他的都归为第20个label。<br>这个任务用来探索句向量能否抽取出句子的句法结构信息。</p><p>第4个任务是预测句子词序是否正确（<strong>BShift</strong>）。<br>这个任务随机调换句子中任意两个相邻单词，然后做2分类，预测是否调换过顺序。<br>这个任务用来探索句向量对词序是否敏感。</p><p>第5个任务是预测句子对应句法树的深度（<strong>TreeDepth</strong>）。<br>在实际数据集中，句法树深度都在5到12之间，所以这是一个8分类任务。</p><h2 id="语义信息"><a href="#语义信息" class="headerlink" title="语义信息"></a>语义信息</h2><p>第6个任务是预测句子的时态（<strong>Tense</strong>）。</p><p>第7个任务是预测句子主语单复数（<strong>SubjNum</strong>）。</p><p>第8个任务是预测句子宾语单复数（<strong>ObjNum</strong>）。</p><p>第9个任务是预测句子中名词或动词是否被替换过（<strong>SOMO</strong>）。<br>这个任务随机将句子中名词或者动词替换为其他名词或动词，然后2分类预测是否做过替换。<br>替换保证换过之后单词前后的bigram出现频次还是相似的。</p><p>第10个任务是预测一个带有从句的句子前后关系是否正确（<strong>CoordInv</strong>）。<br>比如“今天下雨了，因为我没出门。”这句话前后转折关系就反过来了。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>10种探测任务上的表现如下：</p><p><img src="2.jpg" alt></p><p>vote结果是随机的。<br>然后是人类分析结果，句法和语义信息也不能保证是100%正确。<br>Length是只用长度作为输入，可以看出只有SentLen预测正确了，其他都等于随机猜。<br>朴素贝叶斯方法对词信息比较敏感，WC任务效果很好。<br>BoV方法因为不包含词序信息，所以BShift任务很差，等于随机猜。</p><p>再看几种不同的编码器。<br>首先是用LSTM最后一个时刻隐层输出作为句向量。然后是每个维度用不同时刻的最大值作为句向量。最后是门卷积网络编码器。<br>采用的预训练任务有随机初始化，自编码器，机器翻译（三种语言），Seq2Tree，SkipThought（预测下一个句子）和NLI。<br>可以看出Seq2Tree训练出来的句向量在对句法敏感的几种性质上都取得了最好的结果。<br>比较两个LSTM编码器，可以发现采用max的向量表示效果更好。</p><p><img src="3.png" alt><br>上面这个图显示了不同的下游任务和10种语言性质之间的相关度，蓝色表示相关度高，红色表示低。<br>可以发现几乎所有的任务对于句子长度信息都不是很敏感，或者句子长度并不能有效地提升任务的性能。<br>再如SST2任务，情感分类任务的话对于单复数和句法结构信息可能也不是很敏感。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这篇论文主要就是提出了10种探测任务，用来探索模型的10种性质。<br>但是这篇论文里的方法其实还是有点问题的，就如上一篇control task所讲的那样，probe task的准确率并不一定能反应语言性质学习的好坏。<br>但是无妨，这些探测任务还是可以用在我们编码器或者预训练语言模型的分析中的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 可解释性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析[EMNLP19]Designing and Interpreting Probes with Control Tasks</title>
      <link href="/2019/12/19/emnlp19-probe/"/>
      <url>/2019/12/19/emnlp19-probe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/D19-1275.pdf" target="_blank" rel="noopener">Designing and Interpreting Probes with Control Tasks</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>NLP任务都存在着一个常见的问题：<strong>我的神经网络有没有学到某个性质$Y$？</strong><br>所以我们需要构造出一种方法，来告诉我们模型是否真的学到了某些性质。</p><p>例如对于ELMo，我们想知道它是否学到了POS tag信息，所以我们需要设计一种探测任务（probe task）。</p><p><img src="1.jpg" alt></p><p>如上图所示，我们将句子输入到ELMo中，得到每个单词的上下文表示。<br>然后用probe函数（一般是MLP或者linear）进行分类，得到每个单词的POS tag。</p><p>注意到这里的ELMo是不进行fine-tune的，也就是固定住不变的，模型参数只有probe参数。</p><p>但是我们能否说，POS tag效果好，那么ELMo学的就好呢？<br>其实是不行的，因为有三点因素可能影响到最终的tag准确率：</p><ul><li>ELMo真的学到了POS tag信息。</li><li>probe函数设计的比较复杂，可以很好的拟合出POS tag分布。</li><li>POS tag任务的监督信息加的比较多。</li></ul><p>所以本文主要研究了如下三个问题：</p><ul><li>高的探测准确率是否意味着表示真的学到了某种性质？</li><li>探测方法对结果有着什么样的影响？</li><li>上面提到的三点影响因素对探测结论是否有影响？</li></ul><p>下面我们一一关注这三个问题。</p><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>首先答案是否定的，探测任务上准确率越高，并不能代表着表示学到了你想要的性质。</p><p><img src="2.jpg" alt></p><p>还是用ELMo和POS tag举例子，上面这个模型用1000隐层维度的MLP作为probe函数，最终取得了97.3的高准确率。<br>但是我们不能说EMLo能够很好的学到了POS tag信息，因为可能是MLP很好的拟合出了POS tag分布。</p><p>所以我们提出了<strong>控制任务（control task）</strong>的概念，也就是用同样的模型去预测一个随机任务。<br>例如对于POS tag任务，PTB数据集里一共有45个tag，我们给每个单词重新随机分配一个tag，然后用探测模型预测句子的随机tag。<br>这样其实有个小问题，就是消除了单词的一词多义问题，一个单词在所有语境下tag都是一样的了。</p><p><img src="3.jpg" alt></p><p>测试下来结果如上图所示。<br>可以看到MLP和linear对POS tag结果基本没有影响，都非常的高。<br>但是对control任务也就是随机tag影响很大，MLP并没有降低很多（92.8），但是linear降低了很多（71.2）。<br>于是我们将这个差值叫做<strong>selectivity</strong>。如果selectivity越大，说明probe函数影响越小，可能不是probe函数拟合出来的结果。<br>如果selectivity越小，说明不管是gold的label还是随机的label，准确率都很高，这就可能是probe函数拟合出来的结果了，而不是表示学出来的。</p><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>显然linear的学习能力明显不如MLP，那么不同的参数设置对最终结果是否有影响呢？</p><p><img src="4.jpg" alt></p><p>上图举了两个例子，分别是dropout和隐层维度对结果的影响。<br>可以看出简单的正则化对selectivity影响不是很大，但是隐层维度影响特别大。</p><p><img src="5.jpg" alt></p><p>具体的参数影响如上图所示，最终选取了使得准确率比较高，selectivity相对大的参数配置。</p><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><p>答案也是肯定的。</p><p><img src="6.jpg" alt></p><p>比如上面这个例子，一般认为ELMo第1层POS tag效果是要好于第2层的，probe测试下来也是这样。<br>但是可以发现，第2层的selectivity更大，说明其实第2层才更好的学到了POS tag信息。<br>那为什么第1层效果更好呢？可能是因为它更靠近单词层，所以保留了更多单词的信息。<br>这也说明了selectivity方法可能也不是完美的，可能通过聚类预测POS tag，第2层效果会更好。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>具体的实验细节和分析就不说了，大体就是这么个思想。<br>这篇主要就是说明了，光靠准确率并不能说明一个encoder的表示学到了某种性质，而可能是模型拟合的结果。<br>所以他们提出了control task，同时预测一个随机输出，如果准确率差距较大，则验证了表示学到了性质。<br>当然这个方法还有一些问题，比如probe函数的挑选，还有文中依存句法分析的control task的设计是有瑕疵的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 可解释性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一九年终总结</title>
      <link href="/2019/12/13/2019-conclusion/"/>
      <url>/2019/12/13/2019-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>2019年还有十几天就要过去了。<br>这一年依然是，忙忙碌碌，碌碌无为。<br>人老了，话也少了，今年不想写太多，学着敷衍一下吧。</p></blockquote><p>觉得《葡萄成熟时》歌词写的挺好的：</p><blockquote><p>但见旁人谈情何引诱<br>问到何时葡萄先熟透<br>你要静候再静候<br>就算失收始终要守</p></blockquote><h1 id="学术经历"><a href="#学术经历" class="headerlink" title="学术经历"></a>学术经历</h1><h2 id="论文投稿"><a href="#论文投稿" class="headerlink" title="论文投稿"></a>论文投稿</h2><p>都已经研二过去一半了，论文还是没发出来，还是在为毕业担忧。</p><p>研一一直搞得东西没啥新意，不大靠谱，自己都觉得很辣鸡。<br>果不其然，ACL 2019和CoNLL 2019都被拒了。<br>事实证明了，有监督的成分句法分析没有什么空间给你搞了，还是无监督的香。</p><p>最近的话又投了一下ACL 2020，换了一个完全不同的方法。<br>感觉上比上一篇靠谱很多，具体结果怎么样听天命吧。<br>顺便吐槽一下审稿的时间太长了吧，4月份才出结果。</p><p><img src="acl2020.png" alt="ACL 2020"></p><p>今年有幸和实验室大家一起去了杭州和香港参加了两次会议。</p><h2 id="AIS-2019"><a href="#AIS-2019" class="headerlink" title="AIS 2019"></a>AIS 2019</h2><p><img src="ais2019.jpg" alt="AIS 2019"><br>第一次是5月份去杭州参加的AIS 2019论文分享会。<br>虽然自己论文没中，但是能见到这么多的大佬还是很开心的。</p><p><img src="ais2019-gnn.jpg" alt="师兄纪焘会上做报告"><br>上面这张是牌面带师兄焘博对他的ACL 2019论文做报告。<br>什么时候站在台上的人能是我呀~~</p><p><img src="hangzhou1.jpg" alt="西湖"><br><img src="hangzhou2.jpg" alt="西湖"><br>上面两张是第一天过去时去西湖游玩的时候拍的。<br>小米8的自动修图是真的🐂🍺，拍出来就是这么美。</p><p><img src="hangzhou3.jpg" alt="音乐酒吧"><br>这是最后一天去酒吧喝酒玩剧本杀时候拍的，小哥唱歌不错。<br>以后能过上这样的生活多好呀，有酒，有歌，有个爱自己的她。</p><h2 id="EMNLP-2019"><a href="#EMNLP-2019" class="headerlink" title="EMNLP 2019"></a>EMNLP 2019</h2><p>第二次是去香港参加的EMNLP 2019国际会议，主要是沾了ypdu论文的光。</p><p><img src="emnlp1.jpg" alt="Manning"><br>有幸见到了好几位大佬，比如manning、eisner等等。<br>还看了很多的poster，和大牛们用蹩脚的英文交流了一下。</p><p><img src="emnlp2.jpg" alt="太平山顶"><br>这是在太平山顶俯瞰香港市中心。<br>亲眼看到了港片里才能看到的风景，虽然最近很乱，但还是很繁华啊。</p><p><img src="ypdu.jpg" alt="ypdu"><br>怎么能少了我们的主角呢？还是oral哦。<br>我也不求oral了，能不能让我做一回主角？</p><h2 id="IALP-2019"><a href="#IALP-2019" class="headerlink" title="IALP 2019"></a>IALP 2019</h2><p>我们学校今年还组织了一次学术会议，IALP 2019。<br>我负责网站的维护，当然也去现场听了两天的报告。</p><p><img src="ialp.jpg" alt="IALP 2019"><br>虽然没学到啥东西，不过还是面基了一下之前认识的妹子哈哈哈。<br>虽然妹子都不是单身的QAQ，但还是聊的很开心哈哈（强颜欢笑）。</p><h1 id="校园故事"><a href="#校园故事" class="headerlink" title="校园故事"></a>校园故事</h1><h2 id="勇哥毕业"><a href="#勇哥毕业" class="headerlink" title="勇哥毕业"></a>勇哥毕业</h2><p><img src="yongge.jpg" alt="晋西北铁三角"><br>勇哥毕业回他的老家去了，以后吃饭洗澡又少了一个人陪了。<br>但是召唤师峡谷还是常常能遇见，不知道多少年后还能再聚一回。</p><h2 id="带师兄毕业"><a href="#带师兄毕业" class="headerlink" title="带师兄毕业"></a>带师兄毕业</h2><p><img src="czsun.jpg" alt="czsun"><br>AntNLP最🐂🍺的带师兄czsun也毕业了，这儿的第一位博士。<br>和他相识也算是很早了，大一就加上好友了，就是没聊过。<br>虽然他也很憨憨，虽然王者农药是王者还菜的一笔，但不妨碍他的学术🐂🍺。</p><h2 id="猫君也走了"><a href="#猫君也走了" class="headerlink" title="猫君也走了"></a>猫君也走了</h2><p><img src="hcc.png" alt="CC"><br>czsun曾经的室友，大学第一个认识的研究生，和我一样也是水群达人。<br>我们有着共同的特点，我们都很强。<br>现在去了广州，一线城市里幸福感最高的城市，想想毕业后我要是能去也不错。<br>要是我中了论文，还得请他一顿烧烤，但愿能够兑现。</p><h2 id="温柔的男人像火苗"><a href="#温柔的男人像火苗" class="headerlink" title="温柔的男人像火苗"></a>温柔的男人像火苗</h2><p><img src="zgp.jpg" alt="🔥🔥🔥🔥🔥"><br>就让我来守护上面这个笑容⑧。<br>他有很多一起放鞭炮的炮友，还有一堆一起跑步的跑友。<br>他喜欢游走于各个实验室之间，虽然他亚索从来不游走，对线炸穿。<br>对了，有喜欢的妹子可以找我要他的vx，他很寂寞。</p><h2 id="兄弟团聚"><a href="#兄弟团聚" class="headerlink" title="兄弟团聚"></a>兄弟团聚</h2><p><img src="xiongdi.jpg" alt="撸串儿"><br>曾经一起打游戏的兄弟们也都去工作了，都在996为了生活卖命。<br>虽然在一个城市，也很少有机会团聚了。<br>依然记得上次去找钺哥小杰请我吃的饭，等工作了再约一波。</p><h2 id="14届入学5周年"><a href="#14届入学5周年" class="headerlink" title="14届入学5周年"></a>14届入学5周年</h2><p><img src="5years.jpg" alt="礼堂"><br>不知道入学五周年有什么好纪念的哈哈，莫名的喜感。</p><p><img src="5years-1.jpg" alt="聚餐"><br>虽然很多人都不是特别的熟悉，但还是回到了几年前的感觉。<br>不过还是缺了几位曾经洗澡的兄弟（昶臻），爷孙没能团聚还是遗憾。</p><h2 id="回闵行"><a href="#回闵行" class="headerlink" title="回闵行"></a>回闵行</h2><p><img src="minhang.jpg" alt="闵行图书馆"><br>因为办在读证明又回了一次闵行，又是一年半没回去过了，还是熟悉的回忆。<br>闵行还是那么的幽静，周围更加的繁华了，只是当时的人已经不在了。</p><h1 id="游戏人生"><a href="#游戏人生" class="headerlink" title="游戏人生"></a>游戏人生</h1><h2 id="小改改"><a href="#小改改" class="headerlink" title="小改改"></a>小改改</h2><p><img src="lol.jpg" alt="亚索手办"><br>因为搭建博客相识，因为爱打英雄联盟有了共同语言。<br>上面是小改改送的手办，非常的感动，甚至有点慌，有机会一定要见一见哈哈。<br>小改改技术还是非常棒的，就是太贪玩了啊。<br>希望你工作顺利，考研顺利，能找到一个爱自己的npy嘿嘿。<br>安利一下小改改的博客<a href="https://milyyy.github.io/" target="_blank" rel="noopener">https://milyyy.github.io/</a>，她是做前端的，很厉害哟。</p><h2 id="菜的离谱"><a href="#菜的离谱" class="headerlink" title="菜的离谱"></a>菜的离谱</h2><p><img src="zhanji.jpg" alt="艾欧尼亚战绩"><br>这一年技术也没有突飞猛进，顺手的时候战绩就像上面这样，逆风的时候，菜的就像czsun一样。<br>因为写论文也好久没玩了，列表里很多人也不上线了，有的工作了，有的弃坑了，大家都忙了。</p><h1 id="情感八卦"><a href="#情感八卦" class="headerlink" title="情感八卦"></a>情感八卦</h1><p>这一年，无心妹子，所以我没有八卦，让大家失望了。<br>在发出论文前，应该不会再找了，当然如果有合适的，还是会顺其自然的。</p><p>不过作为一个八卦收割机，我还是知道别人的很多八卦的。<br>不知道为什么，自己置身于感情之中，我就是一个失败者。<br>但是作为旁观者，我却能捕捉到许多别人观察不到的细节，道理更是一堆一堆的。</p><p>杭州AIS那会儿，我就观察到了一些细节，回来后再几件事情结合验证，果然成了。<br>香港EMNLP那会儿，还没发现什么，回来后通过各类细节大胆猜想，最后也得到了验证。<br>刚开始说给酸菜鱼我的猜想时，他说我在说胡话，不可能的事，是我真的猜错了吗？<br>后来的一件件事说明了我是对的，大家更是搬出了一件件证据印证我的猜想。<br>这也说明了一个科学实验的方法：大胆猜想，小心求证。</p><p><img src="film.jpg" alt="让我留在你身边"></p><p>希望有一天，我能够不再旁观别人的故事，创造自己的故事。<br>希望到时候，我不会因为置身事中而做出变形的操作。<br>《摆渡人》里面说过，时间一直走，没有尽头，只有路口。<br>希望下一个她，能陪我走到时间的尽头，能让我为之拼命。</p><blockquote><p>日后尽量别教今天的泪白流<br>留低击伤你的石头<br>从错误里吸收<br>也许丰收月份尚未到你也得接受<br>或者要到你将爱酿成醇酒<br>时机先至熟透</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成分句法分析综述（第二版）</title>
      <link href="/2019/08/15/con-parsing-summary-v2/"/>
      <url>/2019/08/15/con-parsing-summary-v2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>本文对成分句法分析近年来的进展做了一个比较完善的总结。分析了多种不同类型的成分句法分析模型（基于转移，动态规划和序列到序列等），比较了它们之间的优缺点，并总结了一些提升它们性能的技巧。最后，本文对成分句法分析的未来发展趋势表明了自己的一些看法。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>成分句法分析近年来取得了飞速的发展，特别是深度学习兴起之后，神经句法分析器的效果得到了巨大的提升。一般来说，句法分析器都可以分为编码模型和解码模型两个部分。编码模型用来获取句子中每个单词的上下文表示，随着表示学习的快速发展，编码模型也由最初的LSTM逐渐进化为了表示能力更强的Transformer （<a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">VaswaniSPUJGKP17</a>）。而解码模型方面，也诞生了许多不同类型的解码算法，比如基于<strong>转移系统</strong>（transition-based）的解码算法（<a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">WatanabeS15</a>, <a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">CrossH16</a>, <a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">LiuZ17a</a>），基于<strong>动态规划</strong>（chart-based）的解码算法（<a href="https://doi.org/10.18653/v1/P17-1076" target="_blank" rel="noopener">SternAK17</a>, <a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">KleinK18</a>）和基于<strong>序列到序列</strong>（sequence-to-sequence）的解码算法（<a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">BengioSCJLS18</a>, <a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">Gomez-Rodriguez18</a>）等等。</p><p>基于转移系统的句法分析模型主要通过预测生成句法树的动作序列来还原出一棵句法树。按照遍历树的顺序，具体还可以分为自底向上（bottom-up）的转移统（<a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">CrossH16</a>），自顶向下（top-down）的转移系统（<a href="http://aclweb.org/anthology/P/P15/P15-1113.pdf" target="_blank" rel="noopener">WatanabeS15</a>）和基于中序遍历（in-order）（<a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">LiuZ17a</a>）的转移系统。基于转移系统的句法分析模型优点是速度快，因为它解码的时间复杂度是线性的。而缺点就是在解码的时候无法考虑短语的边界信息，这会导致解码的精度上相比于基于动态规划的模型稍微差一点。</p><p>基于动态规划的句法分析模型主要通过递归地预测每个短语得分最高的子短语，最后回溯还原出最优句法树。优点就是可以枚举出搜索空间中的所有句法树，解码效果比较好。但是动态规划算法时间消耗较大，复杂度是句子长度的平方级别的。所以针对这个缺点，又提出了近似的自顶向下的贪心解码算法（<a href="https://doi.org/10.18653/v1/P17-1076" target="_blank" rel="noopener">SternAK17</a>），按照句法树的前序遍历顺序进行搜索，在不损失太多性能的前提下，能大大加快解码的速度。</p><p>基于序列到序列的句法分析模型主要思想就是将句法树映射为一个唯一对应的序列表示，然后通过序列标注（<a href="https://aclanthology.info/papers/D18-1162/d18-1162" target="_blank" rel="noopener">Gomez-Rodriguez18</a>）或者序列生成（<a href="http://papers.nips.cc/paper/5635-grammar-as-a-foreign-language" target="_blank" rel="noopener">VinyalsKKPSH15</a>）的方式来预测出这个序列。根据句法树序列化的不同定义方式，模型也有许多不同的变体。这一类模型的优点就是速度极快，因为时间复杂度也是线性的，并且模型参数量比基于转移系统的模型少了很多。缺点也是显而易见的，由于预测出的序列需要有很强的约束，不然不能保证可以还原出一棵完整的句法树，所以最终的效果也没有前面两种模型理想。</p><p>此外还有许多其他类型的解码算法，比如直接利用神经网络来预测语法产生式的概率，模拟上下文无关文法，最后再利用传统的CKY算法来进行解码（<a href="https://aclanthology.info/papers/C18-1011/c18-1011" target="_blank" rel="noopener">TengZ18</a>）。该模型最终也取得了非常不错的效果，在单模型上的结果超过了之前的几种模型。</p><p>成分句法分析可以应用到许多下游任务中去，比如情感分析任务中，可以采用树状LSTM（Tree-LSTM）来对句子的句法树进行建模，从而分析出句子的情感（<a href="http://arxiv.org/abs/1503.04881" target="_blank" rel="noopener">ZhuSG15</a>）。也可以应用到其他基础任务中去，比如可以将训练好的成分句法树根据规则转化为依存句法树，从而提升依存句法分析的准确率（<a href="http://www.aclweb.org/anthology/W04-3228" target="_blank" rel="noopener">Gildea04</a>）。</p><h2 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h2><p>成分句法分析是自然语言处理中的一个基础任务，它的任务是给定一个长度为$n$的句子$(w_0, w_1, \ldots, w_{n-1})$，分析出句子的短语结构句法树$T$。例如给定句子“The little boy likes red tomatoes .”，它的成分句法树如图1所示。</p><p><img src="syntactic_tree.png" alt="图1：句子“The little boy likes red tomatoes .”对应的句法树。"></p><p>对于句法树$T$，有多种方式来对它进行表示。目前比较常用的是基于跨度（span）的表示（<a href="http://aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">CrossH16</a>），也就是将句法树表示成组成它的所有短语的集合。而对于每个短语，可以用三元组$(i, j, \ell)$来表示它，其中$i$和$j$表示这个短语的范围是从单词$w_i$到$w_j$，而$\ell$表示这个短语的非终结符标签。这样句法树$T$就可以表示为三元组$(i, j, \ell)$的集合：<br>$$<br>    T = \{(i, j, \ell) | (i, j, \ell) \in T\}.<br>$$<br>这样预测句法树的任务就可以转化为预测三元组$(i, j, \ell)$集合了。</p><p>当然一般还存在两个小问题，一是如果存在一元产生式怎么办？一种解决方法就是将一元产生式上面的所有非终结符全部拼接成一个新的非终结符，这样整个一元产生式就可以看成一个非终结符了。另一个问题是句法树不一定是二叉树，那么解码的时候就会增加许多搜索的复杂度。解决方法就是新增一个空的非终结符$\varnothing$，将非二叉产生式全部转化为多个二叉产生式，其中新增加的临时结点的非终结符全部定义为这个空的非终结符$\varnothing$，在还原句法树的时候直接忽略它就行了。</p><h2 id="编码模型"><a href="#编码模型" class="headerlink" title="编码模型"></a>编码模型</h2><p>给定句子$(w_0, w_1, \ldots, w_{n-1})$，编码模型的目的就是获得每个单词的上下文表示，并进一步计算出每个短语的向量表示。在实际实现中，一般将单词$x_i$的输入向量分为三部分。首先是它对应的随机初始化的嵌入向量$e_i$。然后是这个单词的词性对应的随机初始化的嵌入向量$p_i$，一般它的词性可以通过外部词性标注器来得到。最后是这个单词的字符级别表示$c_i$，这个一般可以通过字符级别的CNN或者LSTM来得到。最后将三部分向量拼接得到最终的输入向量$x_i$：<br>$$<br>    x_i = [e_i; p_i; c_i].<br>$$</p><p>然后将输入向量送入编码器，得到每个单词的上下文表示。而根据采用的编码器的不同，又可以将编码模型分为以下几种主要类型。</p><h3 id="LSTM编码"><a href="#LSTM编码" class="headerlink" title="LSTM编码"></a>LSTM编码</h3><p>这是最为常用的一种编码方式了，首先将所有$x_i$输入到双向LSTM中，得到每个位置的前向隐层表示$\mathord{\buildrel{\hbox{$\scriptscriptstyle\rightarrow$}}\over{h}}_i$和后向隐层表示$\mathord{\buildrel{\hbox{$\scriptscriptstyle\leftarrow$}}\over{h}}_i$。然后对于短语$(i, j)$，它可以表示为：<br>$$<br>    s_{ij} = [\mathord{\buildrel{\hbox{$\scriptscriptstyle\rightarrow$}}\over{h}}_j - \mathord{\buildrel{\hbox{$\scriptscriptstyle\rightarrow$}}\over{h}}_i; \mathord{\buildrel{\hbox{$\scriptscriptstyle\leftarrow$}}\over{h}}_i - \mathord{\buildrel{\hbox{$\scriptscriptstyle\leftarrow$}}\over{h}}_j].<br>$$<br>这样就得到了短语$(i, j)$的向量表示$s_{ij}$，接着就可以计算出它的得分，然后利用解码模型解码出最优的句法树。</p><h3 id="Transformer编码"><a href="#Transformer编码" class="headerlink" title="Transformer编码"></a>Transformer编码</h3><p>虽然LSTM编码用的最多，但是要问最近这段时间最火的模型是什么，那当然是<strong>Transformer</strong>了（<a href="http://papers.nips.cc/paper/7181-attention-is-all-you-need" target="_blank" rel="noopener">VaswaniSPUJGKP17</a>）。它可以充分利用GPU的并行计算优势，加快计算速度。还可以利用注意力机制，增强对句子的表示能力。</p><p><img src="multi_headed_attention.jpg" alt="图2：Transformer结构。"></p><p>Transformer的输入有三个，查询（query）向量矩阵$Q$，键（key）向量矩阵$K$和值（value）向量矩阵$V$。<br>输出就是查询向量对每个键向量的注意力，然后对值向量加权求和的结果。用矩阵形式表示就是：<br>$$<br>    {\rm Attention}(Q, K, V) = {\rm softmax}(\frac{QK^{\top}}{\sqrt{d_k}})V.<br>$$<br>当然还可以加入多头（multi-head）注意力机制，增强表示能力，具体这里不再赘述，可以参看原论文。最后将输出乘以参数矩阵${\bf W}_O$映射回需要的输出维度，得到最终的输出矩阵$H$，具体结构如图2所示。</p><p>在本文中，$Q$，$K$和$V$三个矩阵都是通过对句子的输入向量拼接而成的矩阵$X$，分别乘以参数矩阵${\bf W}_Q$，${\bf W}_K$和${\bf W}_V$得到的。但是要注意的一点是，在此前的输入向量$x_i$的基础之上，还得再拼接上每个单词的位置向量$p_i$，不然矩阵运算会丢失单词的位置信息。</p><p>得到输出矩阵之后，接下来计算短语的表示方法和LSTM编码是类似的。</p><h3 id="递归神经网络编码"><a href="#递归神经网络编码" class="headerlink" title="递归神经网络编码"></a>递归神经网络编码</h3><p>递归神经网络在自然语言处理中的应用最早是在（<a href="http://aclweb.org/anthology/P/P13/P13-1045.pdf" target="_blank" rel="noopener">SocherBMN13</a>）中提出的。虽然当时取得了不错的效果，但是近些年来递归神经网络已经很少有人使用了，主要因为它存在梯度消失，需要句法树等问题，并且它的初衷（编码树结构信息）由循环神经网络LSTM基本也可以学到，所以没有必要用这种不能并行的网络结构。</p><p>对于短语$(i, j)$，如果它的两个儿子结点是$(i, k)$和$(k, j)$，那么$s_{ij}$就可以由$s_{ik}$和$s_{kj}$计算得到：<br>$$<br>    s_{ij} = f({\bf W}[s_{ik};s_{kj}]+{\bf b}),<br>$$<br>其中，$f$是激活函数，一般可以取${\rm tanh}$。</p><p>当然这种结构现在已经很少使用了，现在用的较多的递归结构是树状LSTM，网络结构和递归神经网络基本相同，唯一的区别就是将计算单元$f$替换成LSTM中的隐层单元，这样可以有效地解决梯度消失和长距离依赖的问题。</p><h3 id="得分计算"><a href="#得分计算" class="headerlink" title="得分计算"></a>得分计算</h3><p>采用以上几种编码模型得到了每个短语的向量表示之后，接下来可以用两层前馈神经网络计算出它的得分：<br>$$<br>    \begin{aligned}<br>        s_{\rm{label}}(i, j, \ell) &amp; = {\bf v}_{\ell}^{\top}f({\bf W}_{\ell}^2f({\bf W}_{\ell}^1s_{ij} + {\bf b}_{\ell}^1) + {\bf b}_{\ell}^2), \\<br>        s_{\rm{span}}(i, j)        &amp; = {\bf v}_s^{\top}f({\bf W}_{s}^2f({\bf W}_{s}^1s_{ij} + {\bf b}_{s}^1) + {\bf b}_{s}^2),<br>    \end{aligned}<br>    \tag{1}<br>$$<br>其中$f$是激活函数，这里通常取${\rm ReLU}$。这里我们将短语$(i, j)$的得分分成了两部分，一部分是它的非终结符$\ell$的得分$s_{\rm{label}}(i, j, \ell)$，一部分是跨度的得分$s_{\rm{span}}(i, j)$。</p><p>最后，定义一棵句法树的总得分为它包含的所有短语的标签得分与跨度得分之和：<br>$$<br>    s_{\rm tree}(T) = \sum\limits_{(i, j, \ell) \in T}{s_{\rm{label}}(i, j, \ell) + s_{\rm{span}}(i, j)}.<br>$$<br>而接下来要介绍的解码模型的任务，就是去寻找一棵句法树，使得它的得分最高。</p><h2 id="基于转移系统的解码算法"><a href="#基于转移系统的解码算法" class="headerlink" title="基于转移系统的解码算法"></a>基于转移系统的解码算法</h2><p>基于转移系统的解码模型主要分为三种。第一种是自底向上的转移系统，第二种是自顶向下的转移系统，最后一种是基于中序遍历的转移系统。这些转移系统的共同点是都包含两个组成成分，一个是栈（stack），用来存放已分析的句法结构，另一个是缓存（buffer），用来存放待分析的句子。而预测句法树结构就转化为了预测转移系统每一个时刻应该采取的动作（action）序列。下面我们分别介绍几种不同的转移系统，我们用三元组$[S, B, T]$来表示转移系统每一个时刻的状态，分别代表栈顶元素、缓存的第一个单词和句法分析结束标志。</p><h3 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h3><p>自底向上的转移系统是根据句法树的后序遍历（post-order）顺序进行句法分析的，首先将缓存中的单词移进栈里，然后将栈顶的若干个单词归约为它们的父结点，直至最后缓存为空并且栈里只有一个根节点。</p><p><img src="bottom_up.png" alt="图3：自底向上的转移系统动作定义。"></p><p>自底向上转移系统的动作形式化定义如图3所示，其中移进（SHIFT）动作就是将缓存里面的第一个单词移进栈里。归约（REDUCE-L/R-X）动作就是将栈顶的两个元素出栈，并且归约为它们的父结点X，然后再将父结点入栈，而L和R就是用来区分左儿子和右儿子谁是头结点。一元（Unary-X）动作就是将栈顶元素出栈，并且归约为父结点X，这个动作是用来预测一元产生式的。最后完成（FINISH）动作用来判断句法分析是否结束。</p><p>注意到这里有一个问题，自底向上转移系统一般要提前对句法树进行二叉化。主要原因是因为自底向上系统有个弊端，就是在不停地移进之后，你不仅要预测哪一步开始归约，还得预测归约的话要归约栈顶的多少个元素，这样预测的状态数就大大增加，导致训练时间也增加了许多。而二叉化后每次预测就只需要预测哪一步归约就行了，每次归约只归约栈顶的两个元素。</p><p><img src="bottom_up_example.png" alt="图4：自底向上的转移系统的一个例子。"></p><p>对于图1中的句法树，用自底向上转移系统分析的过程如图4所示。</p><p>自底向上转移系统的优点就是可以充分利用已经生成的子树信息，来帮助父结点的非终结符预测。但是缺点也很显然，因为无法知道父结点以及再上层的父结点信息，所以丢失了许多有用的全局信息。另一个缺点就是需要提前进行二叉化，虽然二叉化加入了头结点（head）信息，事实证明是很有用的，但是头结点的标注需要许多语义学知识，非常的耗时耗力。一个较为简洁的做法就是，用空结点$\varnothing$来作为句法分析中临时结合两个子结点而产生出的，但是在正确句法树中不存在的结点。在还原树结构的时候忽略这种空结点，这样就可以隐式地进行二叉化操作了。</p><h3 id="自顶向下的转移系统"><a href="#自顶向下的转移系统" class="headerlink" title="自顶向下的转移系统"></a>自顶向下的转移系统</h3><p>自顶向下的转移系统利用的是句法树的前序遍历（pre-order）序列，首先将父结点入栈，然后不断操作直到它的子结点全部入栈，这时将父结点连同所有子结点全部归约为一个结点，也就是这个父结点自身。</p><p><img src="top_down.png" alt="图5：自顶向下的转移系统动作定义。"></p><p>自顶向下转移系统的动作形式化定义如图5所示，其中移进动作和之前一样，都是将缓存的第一个单词入栈。而非终结符（NT-X）动作就是将非终结符X入栈，也就是接下来的子树的父结点就是X。归约动作就是将栈顶若干个元素，一直到之前移进的那个父结点为止都出栈，然后归约为一个结点，再次入栈。注意到这里不同于自底向上转移系统的地方是没有完成动作，因为自底向上系统存在一元动作，所以最后根节点可能会无限归约下去，因此需要通过完成动作来提前终止分析。当然其实转移系统的动作定义并没有严格的要求，不同论文定义的也都不一样，但是都大同小异，也就是都存在移进和归约这两个动作，所以这些转移系统又可以叫做移进-归约系统。</p><p>对于图1中的句法树，用自顶向下系统分析的过程如图6所示。</p><p><img src="top_down_example.png" alt="图6：自顶向下的转移系统的一个例子。"></p><p>自顶向下转移系统的优缺点和自底向上转移系统恰好互补。优点就是可以充分利用全局信息，例如父结点的信息，并且不需要提前进行二叉化，因为归约的时候只要找到栈里第一个非终结符就行了。而缺点就是无法利用局部信息，也就是已经分析好的子树信息，同样非终结符动作也可能会出现无限多次执行的情况，所以要加上一些限制条件。</p><h3 id="基于中序遍历的转移系统"><a href="#基于中序遍历的转移系统" class="headerlink" title="基于中序遍历的转移系统"></a>基于中序遍历的转移系统</h3><p>基于中序遍历的转移系统利用的是句法树的中序遍历（in-order）序列，首先将最左边的子结点移进栈里，然后将父结点入栈，再不断操作直到该父结点的剩余子结点全部入栈，然后对它们进行归约。</p><p><img src="in_order.png" alt="图7：基于中序遍历的转移系统动作定义。"></p><p>基于中序遍历的转移系统的动作形式化定义如图7所示，其中移进动作和之前一样，都是将缓存的第一个单词入栈。映射非终结符（PJ-X）动作是预测出当前栈顶的元素的父结点X。归约动作就是将栈顶的若干个元素归约为最里面倒数第二个元素，也就是它们的父结点。</p><p><img src="in_order_example.png" alt="图8：基于中序遍历的转移系统的一个例子。"></p><p>对于图1中的句法树，用基于中序遍历的系统分析的过程如图8所示。</p><p>根据经验，当我们读一个短语时，我们通常会注意到它的第一个单词，然后我们可以根据观察到的词推断出短语的类型。例如，当我们读到“likes”这个词时，我们可以假设紧跟着这个词的是一个动词短语。而后面的单词“red tomotoes”只是这个动词短语的宾语。与自顶向下的转移系统相比，“likes”中的局部信息对于识别这是一个动词短语可能至关重要。此外，动词短语（VP）中的全局信息也有利于之后的预测。</p><p>基于中序遍历的转移系统的优点恰好结合了前面两种转移系统，既可以考虑到局部信息，又可以考虑到全局信息。</p><h3 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h3><p>之前介绍的三种转移系统都属于判别式模型，而基于自顶向下转移系统，又诞生出了一种生成式模型——<strong>循环神经网络文法</strong>（RNNG）。循环神经网络文法本质上就是自顶向下的转移系统，动作定义和章节<strong>自顶向下的转移系统</strong>介绍的基本一致。只是之前介绍的自顶向下的转移系统是判别式模型，每次移进的单词都是缓存中给定正确的单词。而循环神经网络文法每次移进的单词需要通过动作生成（GEN-X）预测得出，最终模型对预测出来的句子分析出句法树。</p><p>正式定义就是，对于句子$x$和对应的句法树$y$，判别式模型是对条件概率$p(y | x)$进行建模，而生成式模型是对联合概率$p(x, y)$进行建模。</p><p>而循环神经网络文法的另一个重要应用是语言模型（language model），也就是建模$p(x)$。因为$p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}$，所以只需要枚举出所有可能的句法树$y$即可，但是这是指数级别的，显然不现实，这时候就需要用到“<strong>重要性采样</strong>（importance sampling）” （<a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=B2EBD814B4E07636745536DCB26F96CA?doi=10.1.1.157.772&rep=rep1&type=pdf" target="_blank" rel="noopener">doucet2009tutorial</a>）。</p><p>令$q(y | x)$为循环神经网络文法作为判别式模型的时候产生句子$y$的条件概率，那么$p(x)$可以改写为<br>$$<br>    \begin{aligned}<br>        p(x) &amp; = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}       \\<br>             &amp; = \sum\nolimits_{y \in \mathcal{Y}(x)} {q(y|x)w(x,y)} \\<br>             &amp; = {\mathbb {E}_{q(y|x)}}w(x,y),<br>    \end{aligned}<br>$$<br>其中$w(x,y)=p(x,y)/q(y|x)$。然后就可以采用蒙特卡罗方法进行采样了，从分布$q(y | x)$中采样$N$个样本：<br>$$<br>    {y^{(i)}} \sim q(y|x),i = 1,2, \ldots ,N.<br>$$<br>那么$p(x)$就可以近似表示为：<br>$$<br>    \begin{aligned}<br>        p(x) &amp; = {\mathbb{E}_{q(y|x)}}w(x,y)                                                                \\<br>             &amp; \mathop \approx \limits^{\rm MC} \frac{1}{N}\sum\limits_{i = 1}^N {w(x,{y^{(i)}})}.<br>    \end{aligned}<br>$$</p><p>在实验效果上，生成模型的效果要明显好于判别模型，因为它不仅对句法树的概率进行了建模，还对整个句子的语言模型概率也进行了建模。当然在实现上也稍微复杂了一些，主要采样这个操作耗时比较多，因此采样数量不能太多，通常个位数就够了，程序运行时间会成倍增加。</p><h2 id="基于动态规划的解码算法及其变体"><a href="#基于动态规划的解码算法及其变体" class="headerlink" title="基于动态规划的解码算法及其变体"></a>基于动态规划的解码算法及其变体</h2><p><img src="chart_based.png" alt="图9：基于动态规划解码算法的句法分析模型图。"></p><p>这一类解码算法是由传统的CKY算法启发而来的（<a href="http://cds.cern.ch/record/102654" target="_blank" rel="noopener">cocke1970programming</a>）。传统的CKY算法是通过枚举每一个结点处的产生式来状态转移到下一个子结点，然后寻找出概率最大的那一个产生式。而这里的基于动态规划的解码算法是采用神经网络，计算出每个短语的得分，然后枚举它的所有子短语，计算出总得分最高的那棵子树。图9是这一类解码算法加上编码模型整体的模型结构。</p><h3 id="动态规划解码"><a href="#动态规划解码" class="headerlink" title="动态规划解码"></a>动态规划解码</h3><p>解码算法的初衷是求出得分最高的那棵子树，但是状态空间太大了，不可能枚举所有的句法树，所以就只能用动态规划算法求解了。</p><p>对于任意一个跨度$(i, j)$，我们利用公式1计算所有它所有非终结符的得分。直接取得分最高的那一个非终结符$\hat \ell_{ij}$作为最优的非终结符。</p><p>而对于子短语，我们只需要预测出$(i, j)$的最优分割点即可。遍历所有的分割点$k$，取两个子结点$(i,k)$，$(k,j)$与结点$(i, j)$得分之和最高的那个分割点即可：<br>$$<br>    \begin{aligned}<br>        s_{\rm split}(i, j, k) &amp; = s_{\rm label}(i, j, \hat \ell_{ij})                                        \\<br>                               &amp; + s_{\rm label}(i, k, \hat \ell_{ik}) + s_{\rm label}(k, j, \hat \ell_{kj}).<br>    \end{aligned}<br>$$<br>注意这里计算得分取了非终结符的得分$s_{\rm label}(i, j, \ell)$，并没有取跨度的得分$s_{\rm span}(i, j)$。因为在实际实现中，发现加不加这部分得分影响不大，所以为了简化运算，去掉了这项得分。</p><p>动态规划解码算法的时间复杂度是$O(n^3)$的，所以对于稍长一点的句子，运行起来还是挺慢的。但是好处是可以搜索到所有的状态空间，所以准确率上比较高。</p><h3 id="自顶向下贪心解码"><a href="#自顶向下贪心解码" class="headerlink" title="自顶向下贪心解码"></a>自顶向下贪心解码</h3><p>因为动态规划解码算法时间复杂度太高了，所以可以用贪心解码来近似求解最优句法树。思路是自顶向下、贪心地去选择每一个跨度$(i,j)$的最优分割点和最优非终结符$\hat \ell_{ij}$，这样时间复杂度将降到$O(n^2)$。</p><p>具体实现如下，首先从根结点也就是$(0, n)$开始，选择一个分割点$\hat k$，使得两个子结点$(0, \hat k)$，$(\hat k, n)$与根结点$(0, n)$的得分之和最高，而非终结符还是像之前那样直接通过短语的向量表示计算得出。具体公式为：<br>$$<br>    \begin{array}{l}<br>        \hat \ell = \mathop {\arg \max }\limits_l [{s_{\rm label}}(i,j,\ell)] \\<br>        \hat k = \mathop {\arg \max }\limits_k [{s_{\rm split}}(i,j,k)].<br>    \end{array}<br>$$</p><p>自顶向下贪心解码时间复杂度低，而且实际运行中并没有损失太多精度，所以可以很好地近似动态规划解码算法。而由转移系统的三种遍历顺序，自然而然还可以想到，这里也能推广到自底向上和中序遍历的贪心解码，但是由于这里预测的时候只利用到了局部的短语特征，所以仅仅更改遍历的顺序是没有效果的，还得充分利用到预测的历史信息才行。</p><h2 id="基于序列到序列的解码算法"><a href="#基于序列到序列的解码算法" class="headerlink" title="基于序列到序列的解码算法"></a>基于序列到序列的解码算法</h2><p>前面几个章节都是将句法树视为若干跨度的集合，并预测这个集合，最后还原出句法树。这个章节将要介绍的方法都是基于序列的，也就是将句法树序列化，通过预测句法树对应的序列，然后还原出句法树。</p><h3 id="基于括号表达式"><a href="#基于括号表达式" class="headerlink" title="基于括号表达式"></a>基于括号表达式</h3><p><img src="linearization.png" alt="图10：句子“John has a dog .”对应的句法树及其括号表达式。"></p><p>括号表达式是句法树最为常见的一种序列化方法，图10展示了句子“John has a dog .”对应的括号表达式。可以证明，括号表达式和句法树是一一对应的，所以只要预测出了括号表达式，就可以唯一映射到一棵句法树。这样句法分析任务就转化为了输入一个句子，输出一个括号表达式序列，这可以用常见的序列到序列模型来解决（<a href="http://papers.nips.cc/paper/5635-grammar-as-a-foreign-language" target="_blank" rel="noopener">VinyalsKKPSH15</a>)。类比到机器翻译任务，可以把输入句子当成源语言，输出的括号表达式当做目标语言，这就转化为了一个翻译任务。</p><p>但是这种序列化方法存在一个较大的问题，就是限制性太强了，必须要满足输出的序列是一个合法的括号表达式，这就大大增加了预测的难度。所以一般这种序列化方法都是用来重排序的，也就是先用现成的句法分析器预测出概率最大的若干棵句法树，然后预测这几棵句法树对应的括号表达式的语言模型概率，挑选出概率最高的一棵作为最终的模型输出。</p><h3 id="基于句法距离"><a href="#基于句法距离" class="headerlink" title="基于句法距离"></a>基于句法距离</h3><p><img src="syntactic_distance_example.jpg" alt="图11：句子“She enjoys playing tennis .”对应的句法树及其句法距离序列。"></p><p><strong>句法距离</strong>（syntactic distance）是由（<a href="https://openreview.net/forum?id=rkgOLb-0W" target="_blank" rel="noopener">ShenLHC18</a>)首次提出的新概念，句子中相邻两个单词的句法距离定义为它们俩的最近公共祖先的高度。图11展示了句子“She enjoys playing tennis .”的句法距离序列，对于长度为$n$的句子，它的句法距离序列长度为$n - 1$，并且满足如下条件：对于任意两个相邻的单词对，它们的最近公共祖先高度越高，那么它们俩的句法距离就越大（<a href="https://openreview.net/forum?id=rkgOLb-0W" target="_blank" rel="noopener">BengioSCJLS18</a>）。</p><p>以图11为例，“She”和“enjoys”的最近公共祖先是“S”，所以高度最高，对应的句法距离也最大。“enjoys”和“playing”的最近公共祖先是“VP”，高度排第三，所以对应的句法距离大小也是排第三。依次类推，剩下的句法距离也满足这个性质。可以证明，这个数字序列和句法树是一一对应的。更进一步可以发现，这个序列其实就是“中序遍历的结点的高度”，原文中将其称为句法距离。</p><p>当然实际实现中，句法距离并不一定要和结点高度完全对应，甚至不需要是整数，只需要反映出彼此之间的大小关系就行了。预测这个序列也很简单，原文中并没有使用传统的双向LSTM序列标注的模型结构，而是首先将句子输入到一个双向LSTM，然后将每相邻两个单词的隐层输出做一次卷积操作（因为要预测相邻两个单词的最近公共祖先的高度），然后再将卷积输出送到一个双向LSTM中去，最后通过一个前馈神经网络得到每相邻两个单词的句法距离。</p><p>解码过程十分简单，对于一个句法距离序列$d_1, d_2, \ldots, d_n$，首先找出序列中最大的元素$d_i$，然后下标小于$i$的句子构成了左子树，大于等于$i$的部分构成了右子树，即句法树的括号表达式为$((x_{&lt;i})(x_{\ge i}))$。而对于左右两棵子树，只需要递归解码下去就行了。</p><p>当然这种解码方式仍然存在一个问题，就是句法距离序列并不一定能唯一映射回句法树。例如对于序列$(1, 1, 1, 1)$，当出现相同句法距离时，最大的句法距离并不唯一，这时候选谁做根节点都有可能，所以这个句法距离序列可以对应到任意一棵二叉树。当然在实际运行中，因为预测结果都是浮点数，所以几乎不会出现这种情况。</p><h2 id="其他解码算法"><a href="#其他解码算法" class="headerlink" title="其他解码算法"></a>其他解码算法</h2><p>除了以上介绍的基于转移系统的、基于动态规划的和基于序列预测的解码算法以外，还有一些其他的解码算法。</p><p>比如（<a href="https://aclanthology.info/papers/C18-1011/c18-1011" target="_blank" rel="noopener">TengZ18</a>）提出了两种局部模型。一种是直接预测每个跨度$(i, j)$属于句法树的概率，然后使用CKY算法来进行解码。另一种是预测产生式$(i, j) \to (i, k) (k, j)$的概率，然后还是使用CKY算法来进行解码。这两种模型都取得了非常高的F1值。</p><p>再比如（<a href="https://aclanthology.info/papers/P18-1109/p18-1109" target="_blank" rel="noopener">TuZZ18</a>）提出了高斯混合隐向量文法（GM-LVeGs），来学习产生式的向量表示，最终的效果也是要好于之前的组合向量文法（CVG）（<a href="http://aclweb.org/anthology/P/P13/P13-1045.pdf" target="_blank" rel="noopener">SocherBMN13</a>）。</p><h2 id="若干改进"><a href="#若干改进" class="headerlink" title="若干改进"></a>若干改进</h2><p>上面介绍的几种经典的句法分析模型或多或少都有一些问题，有些解码速度很慢，有些效果不是很理想，有些实现起来比较麻烦，对于不同模型要做出不同的设计调整，因此许多工作针对这些模型提出了许多优化，下面选取两个典型的优化来详细说明。</p><h3 id="动态指导"><a href="#动态指导" class="headerlink" title="动态指导"></a>动态指导</h3><p>在基于转移系统的模型和动态规划模型的自顶向下近似解码模中，都使用到了贪心的解码算法。这样就会出现一个问题，就是训练的时候因为有标准的句法树，所以不论你解码到哪一步，都可以继续按照正确的结果走下去。但是如果在测试阶段，如果你预测出了一个从来没有在训练阶段出现过的状态，那模型可能就无法知道下一步该往哪走了。这时候就要采用<strong>动态指导</strong>（dynamic oracle），来告诉模型在错误的状态该往哪走。</p><p>这里只简单说明一下动态规划模型的自顶向下近似解码中动态指导的定义，基于转移系统的模型的动态指导类似。</p><p>假设现在模型预测出了一个跨度$(i, j)$，那么下面就要预测它的非终结符和分割点。</p><p>首先对于非终结符，如果$(i, j)$在标准的句法树中，那么它的非终结符就是标准的非终结符，否则的话就定义为空集$\varnothing$。</p><p>然后对于分割点，如果$(i, j)$在标准的句法树中，那么分割点就是标准的分割点。否则的话就在标准的句法树中寻找包含$(i, j)$的最小的跨度$(i’, j’)$，然后找出$(i’, j’)$的所有分割点中，位于$(i, j)$之间的分割点，任意取一个都可以作为动态指导。在实际实现中，取满足条件的最左边一个分割点。不同的分割点对应了不同的二叉化方式，其实无关紧要。在（<a href="http://aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">CrossH16</a>）中有关于动态指导详细的证明过程。</p><h3 id="策略梯度"><a href="#策略梯度" class="headerlink" title="策略梯度"></a>策略梯度</h3><p>除了动态指导解决的问题之外，贪心解码还存在一个问题，就是它只针对当前时刻来进行优化，而不是针对全局优化，所以得到的并非是全局最优解。此外动态指导针对不同的模型要进行单独的设计，这就比较麻烦，所以可以采用强化学习中的<strong>策略梯度</strong>（policy gradient）来替代它（<a href="https://aclanthology.info/papers/P18-2075/p18-2075" target="_blank" rel="noopener">FriedK18</a>）。</p><p>首先用<strong>风险函数</strong>（risk objective）来作为模型的损失函数：<br>$$<br>    \mathcal{R}(\theta ) = \sum\limits_{i = 1}^N {\sum\limits_y {p(y|{x^{(i)}};\theta )\Delta (y,{y^{(i)}})} },<br>$$<br>其中$(x^{(i)}, y^{(i)})$是训练集中的标准数据。可以看出，风险函数其实就是所有可能的句法树和标准树的差异${\Delta (y,{y^{(i)}})}$的期望，训练的目的就是最小化所有句法树和标准树的差异，这样就解决了之前提到的两个问题。</p><p>但是显然不可能枚举所有可能的句法树，这就得用到<strong>重要性采样</strong>（important sampling）方法。但是不能直接对风险函数进行重要性采样，不然采样后的函数$\theta$消失了，就没有办法对其求导了，所以要先对风险函数求导得到：<br>$$<br>    \nabla \mathcal{R}(\theta ) \approx \sum\limits_{i = 1}^N {\sum\limits_{y \in \mathcal{Y}({x^{(i)}})} {\Delta (y,{y^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )} },<br>$$<br>这里的$y$是根据分布$p(y|x^{(i)})$采样得到的结果。具体实现中可以将标准树也加入到采样结果中，可以提升准确率。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>成分句法分析使用最为广泛的英文数据集是华尔街日报的PTB数据集，其中第2~21章节划分为了训练集，22章节为验证集，23章节为测试集。中文数据集为CTB数据集，目前已经有5.0，6.0以及8.0等多个版本，但是使用最为广泛的还是5.0版本。</p><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="results.jpg" alt="表1：不同模型在PTB测试集上的最终结果，其中$^*$代表生成式模型。"></p><p>表1列举了一些句法分析模型的测试结果，分为了单模型和非单模型两部分。其中单模型就是不使用任何外部知识及重排序等操作的模型，而非单模型则使用了外部语料、预训练模型、模型融合和重排序等各种方法。目前单模型最好的结果来自于（<a href="https://aclanthology.info/papers/P18-1249/p18-1249" target="_blank" rel="noopener">KleinK18</a>），他们采用了Transformer作为编码器，使其结果得到了大大提升。由此可见，目前成分句法分析领域编码器的影响要远远大于解码器。而非单模型领域最好结果则来自于相同团队的工作（<a href="http://arxiv.org/abs/1812.11760" target="_blank" rel="noopener">abs-1812-11760</a>），这里他们使用了更为强大的预训练模型BERT，使结果上升到了一个难以逾越的高度。</p><h2 id="总结与未来展望"><a href="#总结与未来展望" class="headerlink" title="总结与未来展望"></a>总结与未来展望</h2><p>本文介绍了成分句法分析领域近些年来的进展，列举了几种不同类型的成分句法分析模型（基于转移系统、基于动态规划、基于序列到序列），并对比分析了它们之间的优缺点，最后提出了几种常见的改进。</p><p>可以预见，未来成分句法分析的研究方向将会是在编码模型方面，因为解码模型对性能的提升已经到了瓶颈期，而编码模型不仅可以大大提升模型效果，还可以运用在无监督成分句法分析上。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>Attention is All you Need</li><li>Transition-based Neural Constituent Parsing</li><li>Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles</li><li>In-Order Transition-based Constituent Parsing</li><li>A Minimal Span-Based Neural Constituency Parser</li><li>Constituency Parsing with a Self-Attentive Encoder</li><li>Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</li><li>Constituent Parsing as Sequence Labeling</li><li>Grammar as a Foreign Language</li><li>Two Local Models for Neural Constituent Parsing</li><li>Long Short-Term Memory Over Tree Structures</li><li>Dependencies vs. Constituents for Tree-Based Alignment</li><li>A tutorial on particle filtering and smoothing: Fifteen years later</li><li>Programming languages and their compilers: Preliminary notes</li><li>Parsing with Compositional Vector Grammars</li><li>Policy Gradient as a Proxy for Dynamic Oracles in Constituency Parsing</li><li>Multilingual Constituency Parsing with Self-Attention and Pre-Training</li><li>Fast and Accurate Shift-Reduce Constituent Parsing</li><li>Shift-Reduce Constituent Parsing with Neural Lookahead Features</li><li>Linear-time Constituency Parsing with RNNs and Dynamic Programming</li><li>Recurrent Neural Network Grammars</li><li>Effective Inference for Generative Neural Parsing</li><li>Parsing as Language Modeling</li><li>Extending a Parser to Distant Domains Using a Few Dozen Partially Annotated Examples</li><li>Improving Neural Parsing by Disentangling Model Combination and Reranking Effects</li><li>Neural Language Modeling by Jointly Learning Syntax and Lexicon</li><li>Gaussian Mixture Latent Vector Grammars</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信聊天记录导出为电脑txt文件教程</title>
      <link href="/2019/08/09/wechat-explore/"/>
      <url>/2019/08/09/wechat-explore/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>本文的最终目的是将手机微信的聊天记录导出到电脑里，变成txt文本文件，然后对其进行分析。</p></blockquote><p>网上有一些工具也可以完成这个功能，但是基本都是付费的。手动操作的话，找了很多的博客，基本没有完全有效的。最终找到一篇很靠谱的教程：<a href="https://github.com/Heyxk/notes/issues/1" target="_blank" rel="noopener">传送门</a>，本文基本参考这篇进行整理。</p><p>首先上我的github把所有需要的文件下载下来：<a href="https://github.com/godweiyang/wechat-explore" target="_blank" rel="noopener">地址</a>，用法稍后说明。</p><h1 id="导出手机微信数据库"><a href="#导出手机微信数据库" class="headerlink" title="导出手机微信数据库"></a>导出手机微信数据库</h1><p>首先要做的第一步就是将手机端的微信数据库<code>.db</code>文件导出到电脑上。</p><h2 id="小米手机"><a href="#小米手机" class="headerlink" title="小米手机"></a>小米手机</h2><p>小米的话做法很简单，不需要进行root。</p><ol><li><p>首先进入手机的<code>设置-更多设置-备份和重置-本地备份</code>，输入密码，点击<code>新建备份</code>，把两个勾去掉，点击软件程序右边的尖括号，选择微信，点击确定，点击开始备份，等待完成就行了。<br><img src="1.png" alt></p></li><li><p>然后将手机连接电脑，打开手机目录下的<code>MIUI/backup/AllBackup/yyyymmdd_xxxxxx/</code>文件夹，将<code>.bak</code>文件拷贝到电脑上，我这里重命名为了<code>com.tencent.mm.bak</code>。<br><img src="2.jpg" alt></p></li><li><p>然后用任意一种压缩包软件（我用的是7zip）打开这个<code>com.tencent.mm.bak</code>文件，并且将<code>apps\com.tencent.mm\r\MicroMsg\systemInfo.cfg</code>、<code>apps\com.tencent.mm\r\MicroMsg\CompatibleInfo.cfg</code>和<code>apps\com.tencent.mm\r\MicroMsg\xxxx\EnMicroMsg.db</code>三个文件解压到电脑上。这里xxxx是一串随机的字母，代表你的微信用户，每个人不一样，一般是最大的那个文件夹，我这里是下图所示文件夹：<br><img src="3.jpg" alt></p></li></ol><h2 id="其他手机通用做法"><a href="#其他手机通用做法" class="headerlink" title="其他手机通用做法"></a>其他手机通用做法</h2><p>其他手机可能没有这么方便，一种办法是root之后去<code>/data/data/com.tencent.mm/MicroMsg</code>下面找这三个文件，但是很多人是不会去root的，所以介绍另一种方法。</p><p>首先电脑上安装一款安卓模拟器，然后里面下载手机微信并登录，最重要的一步就是<strong>将手机端聊天记录备份到电脑端微信，然后将电脑端聊天记录恢复到安卓虚拟器里的微信</strong>，这个功能是微信自带的，应该没有什么难度。</p><p>然后对安卓虚拟器进行root，这个也是设置里就有的，最后就能把三个文件都拷贝到电脑上了。</p><h1 id="破解数据库密码"><a href="#破解数据库密码" class="headerlink" title="破解数据库密码"></a>破解数据库密码</h1><ol start="4"><li><p>将上面的所有文件全部放在一个目录下。<br><img src="4.jpg" alt></p></li><li><p>然后命令行运行如下代码：</p><pre><code>javac IMEI.javajava IMEI systemInfo.cfg CompatibleInfo.cfg</code></pre><p>第三行就是数据库的密码了。<br><img src="5.jpg" alt></p></li></ol><h1 id="导出聊天记录"><a href="#导出聊天记录" class="headerlink" title="导出聊天记录"></a>导出聊天记录</h1><ol start="6"><li><p>然后打开<code>sqlcipher.exe</code>软件，用它打开<code>EnMicroMsg.db</code>数据库，输入第五步得到的密码。<br><img src="6.jpg" alt><br><img src="7.jpg" alt></p></li><li><p>这时候会显示出很多的表格，点击菜单栏的<code>File-Export-Table as CSV file</code>，选择<code>message</code>表，并导出。<br><img src="8.jpg" alt></p></li><li><p>如果直接用excel打开这个表格，可能会显示乱码。所以新建一个excel表格，点击<code>数据-来自文本</code>，然后导入这个<code>.csv</code>文件。<br><img src="9.jpg" alt></p></li><li><p>弹出的框里，第一个下拉框选择<code>GB2312</code>，然后载入，这时候就不乱码了。<br><img src="10.jpg" alt></p></li><li><p>然后在<code>talker</code>一列选择你想要筛选的聊天对象，单击<code>content</code>列并复制到<code>message.txt</code>文本中。<br><img src="11.jpg" alt></p></li><li><p>最后命令行运行下面代码去除无效信息：</p><pre><code>python3 process_wechat.py message.txt</code></pre><p>这时候会产生一个<code>__message.txt</code>，就是处理完的聊天记录了。</p></li></ol><h1 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h1><p>这个上一篇博客已经讲过了，可以去看看：<a href="https://godweiyang.com/2019/07/27/wordcloud/">地址</a></p><p>最后的效果如图所示<br><img src="12.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Do latent tree learning models identify meaningful structure in sentences?</title>
      <link href="/2019/08/05/tacl18-williams/"/>
      <url>/2019/08/05/tacl18-williams/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://aclweb.org/anthology/papers/Q/Q18/Q18-1019/" target="_blank" rel="noopener">Do latent tree learning models identify meaningful structure in sentences?</a></p><p>本文是一篇分析类论文，主要对近年来几种无监督句法分析模型（RL-SPINN和ST-Gumbel）进行了分析，得出了如下三个结论：</p><ul><li>在句子分类任务上，只有一种模型效果好于传统的树结构模型。</li><li>这些模型随机性很大，初始化不同，结果也都差距很大。</li><li>这些模型产生的句法树的平均深度比PTB数据集的平均深度浅。</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>最近有很多工作都是利用Tree-RNN来生成句子的隐式句法树，然后利用下游任务来提供监督，这样就不需要句法树的标注了。利用上隐式句法树的信息之后，下游任务的效果的确能变好，但是几乎没有文章分析过，为什么效果会变好？这个隐式句法树真的学的很不错吗？真的学到了语法吗？如果真的学到了语法，那这对句法和语义学研究者帮助很大。如果没有学到语法，那为什么对下游任务也有帮助呢？这是值得深思的问题。</p><p>理解任何自然语言，首先都要识别出它的句子中，哪些单词组合出的短语是有意义的。而对于下面这种句子：“I saw the man with the telescope”，就会产生两种语义。一种是“with the telescope”修饰“the man”，另一种是修饰“saw”。而直接给出这句话，是基本没有办法判断属于哪种语义的，所以还是得依赖上下文来判断。</p><p>这篇论文分析了四个问题：</p><ul><li>隐式句法树提升下游任务性能的程度。</li><li>隐式句法树模型对于不同的随机初始化，能学到相似句法树的程度。</li><li>模型学到的语法和PTB语法相似的程度。</li><li>模型学到的语法和任何可识别的语法规则相近的程度。</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>这篇论文主要分析了两种模型：SPINN模型及其变体，ST-Gumbel模型。</p><h2 id="SPINN模型及其变体"><a href="#SPINN模型及其变体" class="headerlink" title="SPINN模型及其变体"></a>SPINN模型及其变体</h2><p><img src="1.png" alt="SPINN模型图。"><br><strong>SPINN模型</strong>如图1所示，其实它也是基于转移系统的，没有太大区别。唯一区别就是它提出来不是用来做句法分析的，而是用来对句子编码，来产生句子的向量表示。模型的转移系统的句法监督来自于斯坦福的PCFG Parser，所以不一定完全准确，但是对于下游任务性能提升够用了。</p><p>然后是<strong>RL-SPINN</strong>，和SPINN模型基本完全一样。最大的区别就是转移系统不是用现成的parser来提供监督了，而是用下游任务准确率作为得分来做强化学习进行优化。</p><p>还有<strong>SPINN-NC</strong>（No Connection），取消了tracking模块和composition模块的连接，也就是句法树的表示不依赖buffer里的单词了，这样SPINN模型就退化为了Tree-LSTM了，完全等价。这个变体主要用来和ST-Gumbel模型进行对比，因为ST-Gumbel也是用的Tree-LSTM作为composition模块。</p><p>最后一个变体是<strong>SPINN-PI-NT</strong>（Parsed Input, No Tracking），这个变体模型移除了Tracking模块，同时依赖它的两个模块之间的连接也移除了。这个模型的转移系统就没法预测了，只能根据现成的句法树直接转移。这个变体主要用来对比，用现成的parser和训练出来的parser影响有多大。</p><h2 id="ST-Gumbel模型"><a href="#ST-Gumbel模型" class="headerlink" title="ST-Gumbel模型"></a>ST-Gumbel模型</h2><p><img src="2.png" alt="ST-Gumbel模型图。"><br>这个模型其实就是使用Tree-RNN来计算任意相邻两个结点的得分，然后合并得分最高的两个结点，最后直到只剩一个根节点。如果是有监督学习的话，这样是可行的。但是现在是无监督，所以中间过程的两个结点的得分是没法直接加入到损失函数里的，而中间过程的决策又是离散的，没法计算梯度。所以提出了用ST Gumbel-Softmax来代替传统的softmax，这样就能估计出反向传播的梯度了，而不用强化学习方法了。</p><h2 id="其他对比模型"><a href="#其他对比模型" class="headerlink" title="其他对比模型"></a>其他对比模型</h2><p>第一个是<strong>单向LSTM和RNN</strong>。</p><p>第二个还是<strong>SPINN-PI-NT</strong>，但是转移序列是随机的，不是正确的。</p><p>第三个也是<strong>SPINN-PI-NT</strong>，但是转移序列对应的是最大深度的句法树和平衡二叉树。</p><blockquote><p>这里对几种模型做一个说明。无句法监督的模型只有RL-SPINN和ST-Gumbel两种。单向LSTM和RNN是和句法树没有任何关系的，只用来学习句子的表示。剩下的SPINN，SPINN-NC和SPINN-PI-NT都是需要句法监督的。</p></blockquote><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>采用了三个数据集，PTB，SNLI和MultiNLI，并且提前都做了二叉化。更多的实验细节就不说了，直接去看论文吧。</p><h1 id="隐式句法树对句子理解有帮助吗？"><a href="#隐式句法树对句子理解有帮助吗？" class="headerlink" title="隐式句法树对句子理解有帮助吗？"></a>隐式句法树对句子理解有帮助吗？</h1><p><img src="3.png" alt="表1：测试集对比结果。"><br>表1是各种模型在SNLI数据集和MultiNLI数据集上的对比结果，其中SNLI是只在SNLI上训练，而MultiNLI是在两个数据集上共同训练。</p><p>从表1中可以得出几个结论：</p><ul><li>首先看Prior Work: Baselines，LSTM和BiLSTM是不学习句法树的，Tree-LSTM和SPINN是监督学习句法树的，SPINN-PI-NT是不学习句法树的，直接根据正确句法树转移。可以看出，SPINN-PI-NT的效果略好于LSTM，不如BiLSTM，所以<strong>正确句法树对下游任务的提升是微乎其微的，至少用Tree-LSTM作为composition函数和在NLI数据集上是这样</strong>。</li><li>再看This Work，SPINN-NC是等价于Tree-LSTM的，但是效果比ST-Gumbel差，并且SPINN-NC需要句法监督。这说明了<strong>隐式句法树的学习对句子的理解的确有帮助，不管它学到的句法树有没有实际上的意义</strong>。</li><li>观察This Work: Baselines，可以看出来SPINN-PI-NT的几个结果都是和其他模型差不多的，也就是不管你用正确句法树还是用随机或者平衡句法树给模型转移，效果都不行。这说明了<strong>影响模型性能的瓶颈并不在parsing策略这一块，parsing的好坏对下游句子理解的影响不大</strong>。而RL-SPINN和ST-Gumbel效果略好，但是他们学到的句法树可能是错的。这和第一点结论是一致的，所以今后可以在composition函数上做改进，正确句法树有了，怎么得到它的好的表示是个问题。</li><li>尽管上面所有模型都没有达到SOTA，但是也很接近了，说明隐式句法树学习的确有效果，还是值得我们去分析的。</li></ul><blockquote><p>结论：隐式句法树对句子理解的确有帮助。</p></blockquote><h1 id="这些模型得出的句法树结果一致吗？"><a href="#这些模型得出的句法树结果一致吗？" class="headerlink" title="这些模型得出的句法树结果一致吗？"></a>这些模型得出的句法树结果一致吗？</h1><p><img src="4.png" alt="表2：在MultiNLI验证集上，5轮运行得出的平均准确率和最高准确率。Self F1表示每轮结果和其它4轮结果的一致程度。"><br>表2是两个句法监督模型，两个无监督模型和两种固定的句法树的对比结果。</p><p>从这个结果可以得出两个结论：</p><ul><li>除了不带Leaf GRU的ST-Gumbel准确率方差有异常，其他的方差都差不多。这说明了超参数和随机初始化对模型性能影响不是很大。</li><li>Self F1方面，两个句法监督模型都在70%左右，而ST-Gumbel模型虽然准确率很高，但是一致性只有50%不到。RL-SPINN的一致性就非常高了，有98%左右，这说明了它可能真的学到了某种语法（事实上并不是的，后面章节会讲）。</li></ul><blockquote><p>结论：除了ST-Gumbel模型，其他模型运行多次结果还是基本一致的。</p></blockquote><h1 id="这些模型学到了PTB语法吗？"><a href="#这些模型学到了PTB语法吗？" class="headerlink" title="这些模型学到了PTB语法吗？"></a>这些模型学到了PTB语法吗？</h1><p><img src="5.png" alt="表3：在整个PTB数据集上的测试结果，训练是在SNLI和MultiNLI上的。"></p><p>表3显示了在SNLI和MultiNLI上训练后的模型，在PTB上测试的结果。</p><p>首先可以看出，两个句法监督模型在PTB上的F1也很低，只有四五十左右，但是两个无监督模型更差，甚至不如随机生成的句法树好。这说明了<strong>这些模型根本没有学到PTB语法信息</strong>。而不同类别的准确率也印证了这一点。</p><p><img src="6.png" alt="表4：不同模型在MultiNLI验证集上关于左二叉树、右二叉树、斯坦福句法分析器产生的句法树的F1值，以及产生的句法树的深度对比结果。"></p><p>而从表4中可以看出，两个句法监督模型在MultiNLI数据集上的表现也不错，能有六七十左右的F1值，并且模型偏向于预测出右二叉树。而无监督模型效果就很差了，甚至还不如随机生成的句法树和平衡树，并且RL-SPINN模型输出基本都是左二叉树。而根据语言学知识，右二叉树是更符合语法的。</p><p>最后一列是不同模型产生出的句法树的深度。可以看出RL-SPINN的深度最大，ST-Gumbel深度最小，和随机生成的差不多。而ST-Gumbel对下游任务提升是最大的，所以可以猜测，<strong>深度比较浅，单词的信息可以更好地保留到根节点，句子的编码可能更好</strong>。另一篇论文做过实验验证过这件事，他们用句子的平衡树跑Tree-LSTM得到表示来做SNLI，效果很好。</p><blockquote><p>结论：这些无监督模型基本没有学到PTB语法，但是学到的深度较浅的句法树反而对句子理解任务有帮助。</p></blockquote><h1 id="句法树分析"><a href="#句法树分析" class="headerlink" title="句法树分析"></a>句法树分析</h1><p>前面几个章节分析出了无监督模型产生的句法树不符合语法规则，但是对下游任务的确有帮助。那这个章节就拿出一些特例，来看看它们到底学出了什么语法规则。</p><p>从前面实验可以看出，ST-Gumbel模型学到的语法随机性更大，更值得分析，所以下面只分析这个模型。这个章节分析的篇幅较多，我就直接说结论了：</p><ul><li><strong>更容易结合头两个单词和最后两个单词</strong>。常识上来说，合并最后两个单词没有意义，因为最后一个单词一般是标点符号。但是合并头两个单词还是有意义的，因为一般句子的前两个单词是限定词和名词。</li><li><strong>更容易结合否定词和紧跟后面的一个词</strong>。这个其实有时候符合语法，比如“not”后面紧跟一个形容词，但是比如“not at all”这种就不对了。</li><li><strong>对于功能词和修饰词，模型结果随机性很大</strong>。这一点其实会导致很多短语都分析错了，比如“the”和介词都没有和后面的名词动词合并起来，但神奇的还是对下游任务效果很好。</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这篇文章得出的结论是：<strong>对下游任务有提升的模型，产生出的句法树不一定是最合乎语法的</strong>。</p><p>那么为什么它们还能提升效果呢？这篇文章并没有给出解释，未来的工作还是要设计出新的编码结构，来利用本文提出的几种句法树特征。</p><p>另一种猜想是，PTB语法规则对于NLI任务不一定是最好的，那么问题是NLI任务需要什么样的语法规则呢？这些模型也没有得出好的结论，因为随机性也很大，提升也不是很大。</p><p>最后就是一个工程问题了，如果的确还是PTB语法规则对于提升下游任务性能有帮助，那么怎么提取这种结构呢？现在的几种模型都不能很好的提取出名词短语和介词短语这种结构。</p><blockquote><p>无监督句法分析的前景还是很开阔的，有很多东西值得去探索，ACL 2019的一篇tutorial就是关于自然语言处理中的隐式结构模型的，叫<a href="https://github.com/deep-spin/tutorial" target="_blank" rel="noopener">Latent Structure Models for NLP</a>，如果大家有什么好的想法也欢迎和我交流。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> TACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python生成词云教程（附带QQ聊天记录生成词云实战）</title>
      <link href="/2019/07/27/wordcloud/"/>
      <url>/2019/07/27/wordcloud/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>很多同学对词云很感兴趣，就是给一段文本，然后根据它的词频，生成出好看的词云，就像下面这张图一样：<br><img src="1.png" alt></p><p>生成这个其实很简单，python代码我已经放在github上面了，大家下载下来就能直接用：<a href="https://github.com/godweiyang/wordcloud" target="_blank" rel="noopener">地址</a></p><p>下面我讲讲怎么使用这个代码。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>首先需要python3环境，推荐使用Anaconda安装。</p><p>然后需要<code>jieba</code>和<code>wordcloud</code>库，所以运行下面两条命令安装两个库：<br><code>pip3 install jieba</code><br><code>pip3 install wordcloud</code></p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>这个代码文件夹是如下结构：</p><ul><li>data<ul><li>templates<br>  这个文件夹下放所有你词云想要的样式图片，背景色最好简单一点。</li><li><code>stopwords.txt</code><br>  这是停止词文件，对于你不想在词云中出现的词，你都可以添加到这个文件中过滤掉它。</li></ul></li><li>fonts<br>  这个文件夹下放词云中显示的字体。</li><li><code>create_word_cloud.py</code><br>  这是词云的主代码。</li><li><code>preprocess.py</code><br>  这是用来预处理QQ聊天记录的。</li></ul><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>对于一般的文本文件，直接运行<code>python3 create_word_cloud.py filename.txt</code>就能生成词云了，效果如下：<br><img src="2.jpg" alt></p><h1 id="生成QQ聊天记录词云"><a href="#生成QQ聊天记录词云" class="headerlink" title="生成QQ聊天记录词云"></a>生成QQ聊天记录词云</h1><p>首先打开消息记录，点击下方的消息管理器：<br><img src="3.jpg" alt><br>然后在需要导出的聊天对象上面右键点击导出消息记录：<br><img src="4.jpg" alt><br>然后保存类型选择<code>txt</code>，点保存，并将文件保存在<code>wordcloud</code>根目录下：<br><img src="5.jpg" alt><br>然后打开命令行运行<code>python3 preprocess.py filename.txt</code>，用来去掉聊天记录中的昵称和时间等信息：</p><p>最后运行<code>python3 create_word_cloud.py __filename.txt</code>就能生成词云了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders</title>
      <link href="/2019/07/25/diora/"/>
      <url>/2019/07/25/diora/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="http://arxiv.org/abs/1904.02142" target="_blank" rel="noopener">Unsupervised Latent Tree Induction with Deep Inside-Outside Recursive Autoencoders</a><br><strong>代码地址：</strong><a href="https://github.com/iesl/diora" target="_blank" rel="noopener">github</a></p><blockquote><p>今天要分享的这篇论文来自NAACL2019，主要利用inside-outside算法推理出给定句子的句法树，不需要任何的监督，也不需要下游任务作为目标函数，只需要masked语言模型就行了。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>无监督句法分析是现在比较热门，也有很多东西可做的方向。有监督的已经做得非常好了，感觉做不下去了，所以做一做无监督的试试。</p><p>这篇论文主要用inside-outside算法算出每个span的表示和分数，然后最大化每个叶子结点的分数，类似于bert的masked语言模型。不用像之前的工作那样，需要最后得到句子和短语的表示，然后用来做下游任务。</p><p>本文模型简称叫DIORA，也就是Deep Inside-Outside Recursive Autoencoders。inside步骤其实类似chart parser的前向过程，outside步骤用来重构每个单词。</p><p>DIORA在好几个数据集上都取得了非常大的提升。</p><p>为了理解这篇论文，推荐先去看一下inside-outside算法：<a href="https://godweiyang.com/2018/04/19/inside-outside/">传送门</a>。</p><h1 id="DIORA"><a href="#DIORA" class="headerlink" title="DIORA"></a>DIORA</h1><p>这篇论文的符号定义有点奇怪，以往都是用span的左右边界$(i, j)$来表示的，但是这篇论文只用几个数字$i$来表示，顺序是按照chart表自底向上，从左向右。也就是按照span长度从小到大排序，相同长度的按照左边界从小到大排序，然后依次给上标号。</p><p>首先给定长度为$T$的句子$x_0, x_1, \ldots, x_{T-1}$，每个单词$x_i$都有一个预训练的词向量$v_i$。本文中只讨论二叉树，所以预先将句法树进行了二叉化。</p><p>对于短语$k$，定义它的inside向量为$\bar a(k)$，outside向量为$\bar b(k)$，inside分数为$\bar e(k)$，outside分数为$\bar f(k)$。定义它的儿子结点对的短语集合为$\{k\}$，例如$i, j$两个短语可以结合成短语$k$，那么$i, j \in \{k\}$。</p><h2 id="Inside过程"><a href="#Inside过程" class="headerlink" title="Inside过程"></a>Inside过程</h2><p>首先对于叶子结点，用一个线性变换算出它的向量表示和得分：<br>\[<br>    \begin{align}<br>        \left[ \begin{array}{c} x \\ o \\ u \end{array} \right] &amp;= \left[ \begin{array}{c} \sigma \\ \sigma \\ \tanh \end{array} \right] (U_{\psi}v_k + b) \\<br>        \bar a(k) &amp;= o + \tanh (x \odot u) \\<br>        \bar e(k) &amp;= 0<br>    \end{align}<br>\]<br>其实这就类似于Tree-LSTM的结点函数，因为叶子结点肯定存在的，所以所有叶子结点得分都初始化为0。</p><p>然后对于任意一个高层的结点$k$，它的儿子结点对的集合为$\{k\}$。对于其中的任意一对结点$i, j$，定义它俩组合的分数为：<br>\[<br>    \hat e(i, j) = \phi (\bar a(i), \bar a(j); S_{\alpha})+ \bar e(i) + \bar e(j)<br>\]<br>其中$\phi$函数是一个双线性函数：<br>\[<br>    \phi (u, v; W) = u^T Wv<br>\]<br>然后用<code>softmax</code>函数算出每一对$i, j$的权重：<br>\[<br>    e(i, j) = \frac{\exp(\hat e(i, j))}{\sum_{\hat i, \hat j \in \{k\}} {\exp(\hat e (\hat i, \hat j))}}<br>\]<br>最后加权求和求出短语$k$的inside得分：<br>\[<br>    \bar e(k) = \sum_{i, j \in \{k\}} {e(i, j)\hat e(i, j)}<br>\]</p><p>下面就是计算短语$k$的inside向量了，首先用TreeLSTM或者两层MLP算出结点对$i, j$的向量表示：<br>\[<br>    a(i, j) = {\rm Compose}_{\alpha} (\bar a(i), \bar a(j))<br>\]<br>然后根据刚刚算出的权重进行加权求和得到inside向量表示：<br>\[<br>    \bar a(k) = \sum_{i, j \in \{k\}} {e(i, j) a(i, j)}<br>\]</p><h2 id="Outside过程"><a href="#Outside过程" class="headerlink" title="Outside过程"></a>Outside过程</h2><p>outside其实计算方法和inside很类似，只是不是通过短语$k$的两个儿子来计算了，而是通过它的父亲结点和兄弟结点计算。</p><p>首先看一下下面这张模型图：<br><img src="1.jpg" alt="左边是inside过程，右边是outside过程"><br>左半部分inside过程很好理解，右半部分注意的是$k$表示的是当前要求的结点，$j$表示的是它的父结点，$i$表示的是它的兄弟结点。</p><p>类比inside过程，首先初始化根结点，注意本文中根节点并没有用inside得到的根结点表示，而是随机初始化的。然后对于下层的结点$k$，计算它的某个父结点$j$和兄弟结点$i$的配对得分：<br>\[<br>    \hat f(i, j) = \phi (\bar a(i), \bar b(j); S_{\beta})+ \bar e(i) + \bar f(j)<br>\]<br>然后还是用<code>softmax</code>函数算出每一对$i, j$的权重：<br>\[<br>    f(i, j) = \frac{\exp(\hat f(i, j))}{\sum_{\hat i, \hat j \in \{k\}} {\exp(\hat f (\hat i, \hat j))}}<br>\]<br>注意这里的$\{k\}$其实表示的是短语$k$的父结点和兄弟结点配对的集合了，和inside过程不一样，但是论文里并没有说。</p><p>然后加权求和求出短语$k$的outside得分：<br>\[<br>    \bar f(k) = \sum_{i, j \in \{k\}} {f(i, j)\hat f(i, j)}<br>\]<br>下面和inside过程一样，计算向量表示了：<br>\[<br>    \begin{align}<br>    b(i, j) &amp;= {\rm Compose}_{\beta} (\bar a(i), \bar b(j)) \\<br>    \bar b(k) &amp;= \sum_{i, j \in \{k\}} {f(i, j) b(i, j)}<br>    \end{align}<br>\]</p><p>在本文中这个${\rm Compose}$函数和inside过程中的是用的同一套参数。</p><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>因为是无监督语料，所以最后的监督只能回到每个单词上面来，用语言模型来训练。对于单词$x_i$，用$\bar b(i) \cdot \bar a(i)$来表示包含这个单词的所有可能的句法树的得分总和。这里采用margin-loss来作为损失函数：<br>\[<br>     L_x = \sum_{i=0}^{T-1}\sum_{i^*=0}^{N-1} {\max(0, 1-\bar b(i)\cdot \bar a(i) + \bar b(i)\cdot \bar a(i^*))}<br>\]<br>其中$N$是采样的负样本数量，当然这里符号写的感觉也有一点小问题，首先没有写出$i^* \neq i$，其次$i^*$是随机采样的，并不是从0到$N-1$，范围其实也在0到$T-1$。不过意思懂了就行，采样是根据词频。</p><h2 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h2><p>预测阶段要解码出句法树，这就很简单了，用的是传统的CKY算法，只需要使用到inside得分$e(i, j)$就行了，下面是伪代码：<br><img src="2.jpg" alt="CKY解码算法"></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="无监督成分句法分析"><a href="#无监督成分句法分析" class="headerlink" title="无监督成分句法分析"></a>无监督成分句法分析</h2><p>首先是在<strong>二叉化后的PTB</strong>和<strong>MultiNLI</strong>数据集上的结果：<br><img src="3.jpg" alt="PTB测试集结果"><br><img src="4.jpg" alt="MultiNLI结果"><br>+PP表示做了后处理，也就是预测的时候去掉标点，最后直接把标点连接到根结点，这样效果会好很多。</p><p>从PTB数据集结果可以看出，DIORA+PP的提升是最大的（ON-LSTM由于论文发表时没有出代码，所以没有实现），而其他几个模型提升很小甚至还有下降（PRPN-LM）。</p><p>并且DIORA产生出的句法树的平均深度是最深的，这也是由于这个模型和前两个模型（PRPN、ON-LSTM）的区别导致的，前两个模型并没有显式地对句法结构进行建模，没有办法得到没有短语结构的表示，而DIORA是按照常规的句法分析的框架来做的，可以显式地得到每个短语的表示与得分。</p><p>MultiNLI结果类似，但是有个区别就是，这个数据集的句法树不是标准的，而是通过斯坦福的parser生成的，所以不一定对。所以这个数据集其实考量的是模型对另一个已知模型的拟合能力。</p><p>然后是<strong>WSJ-10</strong>和<strong>WSJ-40</strong>上面的结果，也就是PTB中长度不超过10和40的句子组成的数据集：<br><img src="5.jpg" alt="WSJ-10和WSJ-40结果"><br>这里为了和之前的论文统一，没有进行二叉化，所以预测出来的句法树F1值有个上限，就是上表中的UB值。可以看出WSJ-40效果还是不错的，但是在WSJ-10上面没有一个神经网络方法能超过之前的传统方法（CCM和PRLG），说明句子长度过短，神经网络的学习能力还有待提高。</p><h2 id="无监督短语分割"><a href="#无监督短语分割" class="headerlink" title="无监督短语分割"></a>无监督短语分割</h2><p>这个任务就是看模型识别出了句子中有多少个短语，其实包含在刚刚的句法树结构中了。数据集还是用的PTB，结果如下：<br><img src="6.jpg" alt="PTB短语分割召回率"><br>可以看出除了两个短语类型，其他短语类型识别出的召回率还是很高的。</p><h2 id="短语相似度"><a href="#短语相似度" class="headerlink" title="短语相似度"></a>短语相似度</h2><p>短语相似度任务是这样的，首先用DIORA算出每个短语的表示，然后两两短语之间算cos相似度，对于一个短语，如果与它最相似的K个短语的label和它一样，那么这个短语就预测对了。下表是在CoNLL2000和CoNLL2012数据集上的准确率：<br><img src="7.jpg" alt="短语相似度结果"><br>其中ELMo分为三种设置，CI表示只输入短语的每个单词然后取平均得到短语表示，SI表示输入一整个短语，最后一个就是输入整个句子了。DIORA的话用短语的inside和outside表示拼接得到。</p><p>结果表明，CoNLL2000中DIORA效果最好，但是CoNLL2012的话ELMo效果最好，这也说明了DIORA在细粒度的语料上还有提升空间。还有一点奇怪的就是，在CoNLL2012上，ELMo-CI的效果竟然比ELMo-SI还要好，这也是没法解释的。</p><p>最后就是一些模型设置，比如TreeLSTM和MLP对效果的影响，这些部分就去看论文吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>未来工作主要放在</p><ul><li>提升细粒度语料准确度。</li><li>训练更大语料，增加额外的目标函数</li><li>跨领域、跨语言。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法编程小白机试指南（大佬勿进）</title>
      <link href="/2019/07/12/algorithm-code-tricks/"/>
      <url>/2019/07/12/algorithm-code-tricks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>大佬就不用往下看了，这篇文章没有任何逻辑，没有任何进阶的指导意义，纯粹为了应付各种机试（夏令营机试、保研机试、程序设计实践考试等等），对正经编程竞赛没有任何帮助。我就想到哪写到哪了，不定期想到新的在更新。</p></blockquote><h1 id="暴力打表法"><a href="#暴力打表法" class="headerlink" title="暴力打表法"></a>暴力打表法</h1><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>给定$n$个数字$1, 2, \ldots, n$，求任意取一个排列，任意第$i$个位置上的元素都不等于$i$的概率是多少？</p><p>如果知道结论的话，这就是一道普通的错位排列题，常规做法是求出递推式<br>\[f(n) = (n-1)(f(n-1)+f(n-2))\]<br>然后除以全排列的数量$n!$就行了，这里就不讲怎么求的了，百度有很多。这里讲讲如果不会求怎么办？</p><p>首先想到的暴力方法就是暴力枚举所有排列，然后看看有多少排列满足题目中的错位的条件。C++中的库函数<code>next_permutation</code>正好可以帮助我们枚举全排列，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL a<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> n <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            cnt <span class="token operator">+</span><span class="token operator">=</span> flag<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, "</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以跑出$n \le 12$的结果，但是再大就跑不出来了，因为全排列数量太多了，跑得太慢了。但是不用管，因为题目要求的不是错位排列的数量，而是除以全排列数量之后的概率，巧的是，$n &gt; 12$之后概率保留两位小数的结果是完全相同的，所以直接取$n = 12$的概率就行了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL p<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>LL a<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">265</span><span class="token punctuation">,</span> <span class="token number">1854</span><span class="token punctuation">,</span> <span class="token number">14833</span><span class="token punctuation">,</span> <span class="token number">133496</span><span class="token punctuation">,</span> <span class="token number">1334961</span><span class="token punctuation">,</span> <span class="token number">14684570</span><span class="token punctuation">,</span> <span class="token number">176214841</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>LL<span class="token punctuation">)</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">/</span> p<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100.0</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f%%\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样即使你完全不会计算，也可以100分通过这题啦。</p><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p><a href="https://acm.ecnu.edu.cn/problem/3337/" target="_blank" rel="noopener">原题链接</a></p><p>这题其实就是给你$n$个数组，计算任意两个指定数组相同元素的个数。</p><p>首先想到的最暴力的方法就是，两层循环遍历两个数组咯，看有多少一样的元素就行了。那我们试试：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">40000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3337-1.jpg" alt></p><p>结果已经不错了，过了大多数样例了，这时你实在不想做了，拿了这点分数也可以做下一题了。</p><p>但是你稍微动点脑子，就可以发现，可以把所有数组提前排个序啊，然后遍历的时候就不需要每次都从头找起了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">40000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">++</span>cnt<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3337-2.jpg" alt></p><p>然后你就会发现，结果并没有任何变化。。。不过理论上来说是会快一点的，这里数据可能比较小。</p><p>所以这里应该想不到啥优化的好方法了，不会做的话就下一题吧，分数够了，下面是正确代码，用<code>bitset</code>实现的：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">40000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>bitset<span class="token operator">&lt;</span>MAXN<span class="token operator">></span> G<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>u<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> q<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>G<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">&amp;</span> G<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="猜答案"><a href="#猜答案" class="headerlink" title="猜答案"></a>猜答案</h1><p><a href="https://acm.ecnu.edu.cn/problem/2819/" target="_blank" rel="noopener">原题链接</a><br>看到这题，首先想到的就是算啊，这是一道数学题，结果可能算半天还是没有推出来结果，还浪费时间。</p><p>所以如果形式很简单的话，先猜答案看看。看这三组样例，先猜一个答案等于$\left\lfloor\frac{3n-1}{2}\right\rfloor$，别问我怎么猜到的，因为我已经算出来了。。好开个玩笑，代入发现都是对的，当然这就是正确结果。那这是怎么猜到的呢？可以这么想，一块钱可以买一块糖，得到一张糖纸，而一张糖纸相当于$\frac{1}{3}$块糖，那么如此继续下去，一块钱一共可以买到$1+\frac{1}{3}+\frac{1}{3^2}+\cdots$块糖，算出来就是$\left\lfloor\frac{3n}{2}\right\rfloor$。但是代进数据发现会差个常数1，所以稍稍修改就得到正确结果了。下面是实现代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span> ans<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然要是猜不出来也没事，可以直接用暴力方法求解，我就模拟换糖的过程就行了，刚开始得到了$n$块糖纸，换到了$\left\lfloor\frac{n}{3}\right\rfloor$块糖，现在还剩下$\left\lfloor\frac{n}{3}\right\rfloor + n % 3$块糖纸，依次模拟下去就行了，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>            n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsupervised Recurrent Neural Network Grammars</title>
      <link href="/2019/04/20/naacl19-urnng/"/>
      <url>/2019/04/20/naacl19-urnng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="http://arxiv.org/abs/1904.03746" target="_blank" rel="noopener">Unsupervised Recurrent Neural Network Grammars</a><br><strong>代码地址：</strong><a href="https://github.com/harvardnlp/urnng" target="_blank" rel="noopener">github</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇是新鲜出炉的NAACL19的关于无监督循环神经网络文法（URNNG）的论文，在语言模型和无监督成分句法分析上都取得了非常不错的结果，主要采用了变分推理和RNNG。本文公式量较大，因此我也推了好久，算法也挺多的，首先上一张我推导的公式笔记：<br><img src="1.jpg" alt></p><p>我这篇博客就不按照论文的顺序来讲了，就按照我上面这张笔记讲一讲我的理解吧，很多细节可能会忽略，请参见原文吧。</p><p>首先对于无监督成分句法分析，常规做法就是学习一个生成模型$p_{\theta}(x, z)$，就比如RNNG就是一个生成模型，但是缺少句法树$z$的监督信号怎么办呢？现在给你的输入只有句子$x$，那么只能用语言模型$p_{\theta}(x)$来做监督了。习惯上我们喜欢取对数，也就是：<br>\[<br>\log p_{\theta}(x) = \log \sum_z p_{\theta}(x, z)<br>\]<br>这里就存在几个问题，比如$z$的状态空间太大了，不可能穷举所有的，所以接下来按步骤讲解如何求解。</p><h1 id="URNNG模型"><a href="#URNNG模型" class="headerlink" title="URNNG模型"></a>URNNG模型</h1><hr><p>先上一张模型图，让大家对整体模型有个大概的认知：<br><img src="2.png" alt><br>左边是一个推理网络（Inference Network），用来根据输入$x$推理出隐变量也就是句法树$z$的概率分布$q_{\phi}(z | x)$。右边是一个生成模型（Generative Model），用来计算从推理网络中采样出来的句法树$z$的联合概率$p_{\theta}(x, z)$，最后根据上面语言模型算出句子的概率，最大化这个概率即可。</p><p>接下来分别讲解这两个部分和具体的优化方法。</p><h2 id="Inference-Network-q-phi-z-x"><a href="#Inference-Network-q-phi-z-x" class="headerlink" title="Inference Network $q_{\phi}(z | x)$"></a>Inference Network $q_{\phi}(z | x)$</h2><p>首先将词向量$e_i$和位置向量$p_i$拼接，作为推理网络LSTM的输入：<br>\[<br>f_i, b_i = {\rm BiLSTM}([e_i, p_i])<br>\]<br>然后算出span $(i, j)$的得分，计算方式和以往一样，用BiLSTM前后向输出做差，然后通过一个前馈神经网络得到分数：<br>\[<br>s_{ij} = {\rm MLP}([f_{j+1} - f_i; b_{i-1} - b_j])<br>\]<br>接下来就需要计算句法树的概率分布了，这里不直接计算句法树$z$，而是计算它的邻接矩阵$B$的概率分布，这个邻接矩阵意思就是如果span $(i, j)$存在，那么$B_{ij} = 1$，否则的话$B_{ij} = 0$。然后就可以用CRF计算出邻接矩阵$B$对应的概率：<br>\[<br>q_{\phi}(B | x) = \frac{1}{Z_T(x)}\exp(\sum_{i \le j} B_{ij}s_{ij})<br>\]<br>其中$Z_T(x)$是配分函数，也就是用来将概率归约到0到1之间的：<br>\[<br>Z_T(x) = \sum_{B’ \in \mathcal B_T} \exp(\sum_{i \le j} B’_{ij}s_{ij})<br>\]<br>注意这里的$\mathcal B_T$并不是所有的01矩阵集合，而是必须满足能产生合法句法树的矩阵，而这情况也很多，不能穷举求解，在这里采用经典的inside算法来求解这个配分函数：<br><img src="3.jpg" alt><br>不过我觉得这里是错的！就是这里的两处$s_{ij}$应该改成$\exp(s_{ij})$。不过具体代码实现的时候并没有这么做，初始值一样都是$\beta[i,i]=s_{ii}$，但是递推的时候采用了如下式子：<br>\[<br>\beta[i, j] = \log\sum_{k=i}^{j-1}\exp(s_{ij}+\beta[i,k]+\beta[k+1,j])<br>\]<br>其实就是用$e^{\beta}$来取代$\beta$了，化简后就是代码实现这个式子，应该是为了防止数值溢出。</p><p>然后就是采样了，推理网络目的就是计算出句法树的概率分布，然后根据这个分布采样出若干个句法树，那么现在给定一棵句法树可以根据上面的算法计算出它的概率了，那怎么采样呢？其实还是可以通过刚刚计算得出的$\beta$数组来采样，采样算法如下:<br><img src="4.jpg" alt><br>其实就是自顶向下的根据概率分布来采样每个span的split，用一个队列来保存所有还没有采样出split的span，然后把所有采样出的span在邻接矩阵中的对应值标为1。</p><p>最后推理网络采样出了若干个句法树$z$，然后根据CRF计算出每个句法树的概率$q_{\phi}(z | x)$，后面的事情就交给生成网络了。</p><h2 id="Generative-Model-p-theta-x-z"><a href="#Generative-Model-p-theta-x-z" class="headerlink" title="Generative Model $p_{\theta}(x, z)$"></a>Generative Model $p_{\theta}(x, z)$</h2><p>上面的推理网络采样出了若干个句法树$z$，生成网络的目的就是计算它的联合概率$p_{\theta}(x, z)$。这个其实不难，在之前的RNNG论文笔记中，我已经大致讲过了，可以去复习一下：<a href="https://godweiyang.com/2018/09/02/RNNG/">Recurrent Neural Network Grammars</a>，这里稍稍做了一些改进。</p><p>首先需要定义一个栈用来存放转移的历史状态，这里定义栈里放的元素为二元组$(h, g)$，一个是stack-LSTM编码的输出，一个是子树的结构表示。首先需要预测下一步的action是什么，所以取出栈顶的元素$(h_{prev}, g_{prev})$，预测action的时候只要用到隐含层输出：<br>\[<br>p_t = \sigma(w^T h_{prev} + b)<br>\]<br>然后根据这个概率预测action是SHIFT还是REDUCE，下面分两种情况讨论。</p><p>如果是SHIFT，那么因为是生成模型，所以需要预测下一个移进的单词是什么：<br>\[<br>x  \sim  softmax(Wh_{prev} + b)<br>\]<br>然后将单词$x$的词向量输入到stack-LSTM中得到下一个时刻的隐含层输出：<br>\[<br>h_{next} = {\rm LSTM}(e_x, h_{prev})<br>\]<br>最后将$(h_{next}, e_x)$推进栈里。</p><p>如果是REDUCE，那么首先需要取出栈顶的两个元素$(h_r, g_r)$和$(h_l, g_l)$，然后用TreeLSTM计算出两个子结点合并后的子树的表示：<br>\[<br>g_{new} = {\rm TreeLSTM}(g_l, g_r)<br>\]<br>接着还是计算stack-LSTM下一个时刻的隐含层输出：<br>\[<br>h_{new} = {\rm LSTM}(g_{new}, h_{prev})<br>\]<br>最后将$(h_{new}, g_{new})$推进栈里。</p><p>为了防止数值溢出，常规上我们计算联合概率的对数：<br>\[<br>\log p_{\theta}(x, z) = \sum_{t=1}^T \log p_{\theta}(x_t | x_{&lt; t}, z_{&lt; n(t)}) + \sum_{j=1}^{2T-1} \log p_{\theta}(z_j | x_{&lt; m(j)}, z_{&lt; j})<br>\]<br>从这个式子可以看出，联合概率定义为所有给定某段单词和action预测下一个单词和给定某段单词和action预测下一个action的概率之积。</p><p>如果是监督任务比如RNNG，那么只需要最大化这个联合概率就足够了，但是现在要做无监督，没有$z$，注意别搞混了，推理网络采样出的$z$可不能用来监督哦，因为那本来就不是正确的，所以接下来要采用语言模型来作为最终的目标函数。</p><h2 id="Variational-Inference"><a href="#Variational-Inference" class="headerlink" title="Variational Inference"></a>Variational Inference</h2><p>句子$x$的对数概率定义为：<br>\[<br>\log p_{\theta}(x) = \log \sum_{z \in {\mathcal Z}_T} {p_{\theta}(x, z)}<br>\]<br>其中${\mathcal Z}_T$是所有合法句法树的集合，但是这里不可能穷举所有的句法树，所以就要用到变分推理，具体的理论知识不仔细介绍了，可以去查阅变分推理相关知识，下面直接推导。<br>\[<br>\begin{array}{l}\log {p_\theta }(x) = \log \sum\limits_{z \in {\mathcal{Z}_T}} { {p_\theta }(x,z)} \\ = \log\sum\limits_{z \in {\mathcal{Z}_T}} { {q_\phi }(z|x)\frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \\ = \log { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \right]\\ \ge { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \right]\end{array}<br>\]<br>其中最后一行叫做先验$\log p_{\theta}(x)$的证据下界（ELBO），要想最大化先验，可以最大化这个ELBO，如果我们对这个ELBO变化一下形式可以得到：<br>\[<br>\begin{array}{l}{\rm ELBO} = { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {p_\theta }(x,z)}}{ { {q_\phi }(z|x)}}} \right]\\ = { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {p_\theta }(z|x){p_\theta }(x)}}{ { {q_\phi }(z|x)}}} \right]\\ = { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x)} \right] - { {\mathbb E}_{ {q_\phi }(z|x)}}\left[ {\log \frac{ { {q_\phi }(z|x)}}{ { {p_\theta }(z|x)}}} \right]\\ = \log {p_\theta }(x) - {\rm KL}({q_\phi }(z|x)\parallel {p_\theta }(z|x))\end{array}<br>\]<br>所以这个ELBO和先验就相差了一个KL散度，最大化ELBO的话等价于最小化KL散度，也就是使推理网络产生句法树的概率分布和生成模型尽量接近。</p><p>但是这个ELBO还是不好算，尽管它把$\log$移到了求和符号也就是期望里面，所以转换一下形式：<br>\[<br>{\rm ELBO} = {\mathbb E}_{q_{\phi}(z|x)}\left[ \log p_{\theta}(x,z) \right] - {\mathbb H} \left[ q_{\phi}(z|x) \right]<br>\]<br>因为模型一共有两组参数，一个是推理网络的参数$\phi$，一个是生成网络的参数$\theta$，所以下面分别对两个参数求导。</p><p>首先对$\theta$求偏导，因为只有第一项有这个参数，所以偏导为：<br>\[<br>\nabla_{\theta}{\rm ELBO} = {\mathbb E}_{q_{\phi}(z|x)}\left[ \nabla_{\theta} \log p_{\theta}(x,z) \right]<br>\]<br>这个偏导可以按照概率$q_{\phi}(z|x)$采样得到：<br>\[<br>\nabla_{\theta}{\rm ELBO} \approx \frac{1}{K}\sum_{k=1}^{K} {\nabla_{\theta} \log p_{\theta}(x,z_k)}<br>\]</p><p>然后对$\phi$求偏导，因为有两项含有这个参数，分别求偏导。第二项是熵，它的值其实可以用之前的$\beta$数组算出来，算法如下：<br><img src="5.jpg" alt><br>然后偏导可以交给深度学习库的自动微分，就不用你自己求啦。</p><p>至于第一项的偏导可以用类似于策略梯度的方法解决：<br>\[<br>\begin{array}{l}{\nabla _\phi }{\mathbb{E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x,z)} \right]\\ = {\nabla _\phi }\sum\limits_z { {q_\phi }(z|x)\log {p_\theta }(x,z)} \\ = \sum\limits_z {\log {p_\theta }(x,z){\nabla _\phi }{q_\phi }(z|x)} \\ = \sum\limits_z { {q_\phi }(z|x)\log {p_\theta }(x,z){\nabla _\phi }\log {q_\phi }(z|x)} \\ = {\mathbb{E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x,z){\nabla _\phi }\log {q_\phi }(z|x)} \right]\\ \approx \frac{1}{K}\sum\limits_{k = 1}^K {\log {p_\theta }(x,{z_k}){\nabla _\phi }\log {q_\phi }({z_k}|x)} \end{array}<br>\]<br>这里最后也是转化为了采样，和策略梯度做法类似，这里加入baseline来提升性能：<br>\[<br>\begin{array}{l}{\nabla _\phi }{\mathbb{E}_{ {q_\phi }(z|x)}}\left[ {\log {p_\theta }(x,z)} \right]\\ \approx \frac{1}{K}\sum\limits_{k = 1}^K {\log {p_\theta }(x,{z_k}){\nabla _\phi }\log {q_\phi }({z_k}|x)} \\ \approx \frac{1}{K}\sum\limits_{k = 1}^K {(\log {p_\theta }(x,{z_k}) - {r_k}){\nabla _\phi }\log {q_\phi }({z_k}|x)} \end{array}<br>\]<br>其中$r_k$定义为所有其他的对数联合概率的均值：<br>\[<br>r_k = \frac{1}{K-1} \sum_{j \ne k} \log p_{\theta}(x, z_j)<br>\]</p><p>至此所有偏导都已求出来了，两个通过采样得到，一个通过inside算法结果自动微分得到，所以去掉导数符号并相加就得到了最终的损失函数：<br>\[<br>{\mathcal L}(\phi, \theta) \approx \frac{1}{K} \sum_{k=1}^K {\left[ \log p_{\theta}(x, z_k) + (\log p_{\theta}(x, z_k) - r_k)\log q_{\phi}(z_k|x) \right]} - {\mathbb H}\left[ q_{\phi}(z|x) \right]<br>\]<br>一定要注意，这里的$\log p_{\theta}(x, z_k) - r_k$在代码实现的时候不能传入梯度，不然的话对$\theta$的偏导就会多出这一项的偏导了！</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验结果这里就不多说了，细节具体看论文吧，就贴两个结果，一个是语言模型：<br><img src="6.jpg" alt><br>可以看出在标准的PTB数据集上，URNNG效果只比监督学习的RNNG和用URNNG损失函数微调后的RNNG效果略差一点，但是在大数据集上，URNNG的优势就体现出来了。</p><p>另一个是无监督成分句法分析，这里是用的全部长度的测试集：<br><img src="7.jpg" alt><br>这个任务上URNNG效果是最好的。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><hr><p>和之前两篇语言模型做无监督成分句法分析类似，这篇论文用推理网络学习句法树的概率分布并采样句法树，再用生成网络计算这些句法树和句子的联合概率，最后用变分推理最大化句子的概率，也就是学习出一个好的语言模型。</p><p>这篇论文的工作还是挺令人惊叹的，融合了inside算法、RNNG、变分推理等等知识。本来我变分推理听老师讲了好几次了都云里雾里的，看了这篇论文后总算弄懂了一点了，不过所了解的还是很少，EM算法、VAE之类的高级境界根本不会。。。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Language Modeling by Jointly Learning Syntax and Lexicon</title>
      <link href="/2019/03/31/iclr18-prpn/"/>
      <url>/2019/03/31/iclr18-prpn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/abs/1711.02013" target="_blank" rel="noopener">Neural Language Modeling by Jointly Learning Syntax and Lexicon</a><br><strong>代码地址：</strong><a href="https://github.com/yikangshen/PRPN" target="_blank" rel="noopener">github</a></p><blockquote><p>最近开始转向去看看一些无监督的成分句法分析论文，看看能否有一些启发QAQ。这篇博客摸鱼划水写了整整四天才写完，好累啊啊啊。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>一般来说，自然语言是由词汇和句法组成的，但是标准的语言模型一般都只用RNN对词汇进行建模，句法信息都是隐式的学习到的，没有办法显式地拿出来使用。所以本文提出的语言模型的变体可以结合结构上的attention，在中间过程中学习到结构信息，然后这层结构信息可以拿来生成句法树，用来做无监督的句法分析。</p><p>那么为什么要做无监督的句法分析呢？主要原因还是一些小语种标注语料太少了甚至没有，不能用监督句法分析来做。而且无监督句法分析学到的信息还可以用来增强语言模型或者更为下游的任务的性能，使它们能更好的融合句法结构信息。</p><p>本文提出的模型（PRPN）主要有如下三个组成部分：</p><ul><li><strong>可微分的Parsing Network</strong>。主要用来学习句子的句法距离（syntactic distance，这个在之前的博客中有讲到，是同一个组做的工作，链接：<a href="https://godweiyang.com/2018/07/19/ConParsing-Syntactic-Distance/">Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</a>），然后产生出门函数（gate function），也就是句子中每个词的权重，这样跑RNN的时候就没有必要考虑之前的所有信息了，只需要考虑句法距离最近的，也就是同一个短语中的信息。这里可微分后面会详细讲到，也就是不能直接预测离散的序列，不然梯度没办法反向传播，所以预测的是一个分布。</li><li><strong>Reading Network</strong>。这个部分就和普通的RNN差不多，区别就是利用了上面的attention，然后每个时刻的输入不仅仅是上一个时刻的隐含层状态，还包括了历史所有相关的隐含层状态。</li><li><strong>Predict Network</strong>。最后预测下一个词也不是直接采用当前时刻的隐含层输出，而是采用所有attention后的历史隐含层信息。</li></ul><p>最后模型训练好之后，用Parsing Network学习到的句法距离就可以产生出无监督的句法树，当然这里只能产生unlabeled的句法树，也就是说，无监督的成分句法分析都是只评测unlabeled F1值，因为nonterminal信息实在是无法无监督的预测出来，除非结合外部标注器或者人工制定规则？</p><p><strong>由于我觉得这篇论文写作有点粗糙，很多地方写的很乱，甚至还有公式变量和图片不对应，所以下面的公式我有些自行修改过了，如果觉得有疑问的，可以参考原文，并且告诉我。</strong></p><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><hr><p>下图是一个输入句子及其对应的句法树示例：<br><img src="1.png" alt><br>其中实线表示成分句法树的结构，而虚线表示同一棵子树的若干个子结点之间的联系。我们用$(x_0, x_1, \ldots, x_n)$表示输入句子，用$y_i$表示句法树中的某一个结点，用$r$表示根结点。定义$y_i$所表示的短语范围是$(l(y_i), r(y_i))$，例如在上图中$y_1$表示的范围是$(2, 6)$，所以有$l(y_1) = 2$和$r(y_1) = 6$。</p><p>下图是模型的Reading Network和Predict Network大致框架：<br><img src="2.png" alt><br>其中实线表示Reading Network中RNN每个时刻的输入依赖于之前的哪些时刻，虚线表示Predict Network中预测下一个词时需要考虑哪些时刻的隐含层输出(<strong>这里有个小错误，图中最上面一行函数参数从$m_3$开始，但实际上虚线表明应该从$m_2$开始</strong>)。</p><p>首先是Parsing Network。这种和之前状态的连接在这里被叫做“跨越连接”（skip connection），而具体和哪些状态连接，就要用到门$g_i^t$，表示当前处在$t$时刻，和之前的第$i$时刻有没有关联，有就是1，没有就是0。在这里先定义变量$l_t$为$x_t$和之前最远到哪个位置的单词有关联，分成两种情况：</p><ul><li>如果$x_t$不是某个子树最左边的叶子结点，那么$l_t$就定义为它的父结点的最左边那个叶子结点，也就是$x_t$最左边那个兄弟结点。比如上图中的$x_4$，因为它在子树中位于中间，所以$l_4 = 3$，也就是说它最远和$x_3$有一定关联，而再往前的单词由于不在同一个短语里，关联就不大了。</li><li>如果$x_t$是某一个子树$y_i$最左边的子结点，那么$l_t$就定义为$y_i$最左边那个兄弟结点的最左边的叶子结点。比如上图中$l_3 = 2$，因为$x_3$是$y_3$的最左边的子结点，而$y_2$是$y_3$最左边的兄弟结点，$x_2$又是$y_2$最左边的叶子结点，也就是说$x_3$最远和之前的$x_2$有关联，它们共同组成了更大的短语$y_1$。（<strong>这里定义又不是很严谨，例如对于上面那个例子，$x_2$既是$y_1$又是$y_2$的最左子结点，这种情况下不能按照$y_2$来计算，因为它没有最左的兄弟结点！所以按照$y_1$来算的话得到$l_2 = 0$。</strong>）</li></ul><p>根据这个$l_t$就可以将$g_i^t$定义为：<br>\[<br>g_i^t = \left\{ {\begin{array}{}{1,{l_t} \le i &lt; t}\\{0,0 &lt; i &lt; {l_t}}\end{array}} \right.<br>\]<br>但是因为这是离散的决策，没法传递梯度，所以之后会介绍用概率来替代这里的0和1。</p><p>然后是Reading Network。得到了gates之后，就可以修改RNN，用下面公式计算$t$时刻的隐含层状态：<br>\[<br>m_t = h(x_t, m_0, \ldots, m_{t-1}, g_0^t, \ldots, g_{t-1}^t)<br>\]<br>具体是怎么使用这个gates的，后面再具体介绍，反正只要知道多考虑了很多个历史状态就行了，每个状态都有一个权重，表示考虑了多少。</p><p>最后就是Predict Network，用来预测下一个单词$x_{t+1}$，用到的是历史多个隐含层状态信息：<br>\[<br>p(x_{t+1} | x_0, \ldots, x_t) \approx p(x_{t+1} ; f(m_0, \ldots, m_t, g_0^{t+1}, \ldots, g_t^{t+1}))<br>\]<br>这里后面也会具体讲到。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p><strong>这里我不按照论文上的顺序讲，论文是倒序，变量定义都得看完整篇论文才出来，实在是看的太杂乱了。。。</strong></p><h2 id="Parsing-Network"><a href="#Parsing-Network" class="headerlink" title="Parsing Network"></a>Parsing Network</h2><p><strong>第1步：</strong><br>首先第一步要预测出相邻两个单词的句法距离，用宽度为$L+1$的卷积核来对单词进行卷积。例如要预测$x_i$和$x_{i-1}$的句法距离，那么就对$x_{i-L}, x_{i-L+1}, \ldots, x_i$进行卷积（其实就是两层前馈神经网络），得到如下输出（<strong>注意原文中这一段里的词向量$e$应该都是$x$，有误</strong>）：<br>\[<br>\begin{array}{}{h_i = {\rm ReLU}(W_c \left[ {\begin{array}{*{20}{c}}e_{i-L}\\e_{i-L+1}\\ \cdots\\ e_i \end{array}} \right] + b_c)} \\ {d_i = {\rm ReLU}(W_dh_i+b_d)}\end{array}<br>\]<br>当然了，第二行也可以看做是窗口大小为1的卷积核，第一个单词之前要补上$L-1$个0。</p><p>最后得到的句法距离反映出了相邻两个词之间的语义相关程度，如果距离比较大，说明两个词可能位于两个不同的短语中，否则就位于同一个短语。一个形象化的句法距离就是相邻两个单词的最近公共祖先的高度。</p><p>下面这个图就是一个例子，卷积核窗口宽度为2：<br><img src="3.png" alt></p><p><strong>第2步：</strong><br>然后就可以根据句法距离，求出$x_t$最远到哪个位置有联系。用$\alpha_j^t$来衡量$x_t$与$x_j$的分别与前一个单词的句法距离的差距：<br>\[<br>\alpha_j^t = \frac{ {\rm hardtanh}((d_t - d_j) \cdot \tau) + 1}{2}<br>\]<br>这里的${\rm hardtanh}$就是当输入大于1或者小于-1时，截取掉，给它限制在-1到1这个范围内，所以最后$\alpha$的范围就是0到1。可以看出，如果$\alpha_j^t$很大，那么$d_t$就大于$d_j$，否则的话$d_t$就小于$d_j$。这也很合乎直观上的认知，如果$d_t$大于$d_j$，那么说明$x_j$和$x_{j-1}$的最近公共祖先的高度比较低，那么说明$x_j$和$x_t$在同一棵子树中，差值自然大，反之的话$x_j$是当前子树的最左边的子结点，差值就很小。</p><p>所以模型只需要一步步往左寻找第一个$\alpha_j^t$最接近0的点，也就是之前提到过的$l_t$。为了实现这个目标，可以定义$l_t = i$的概率为：<br>\[<br>p(l_t = i | x_0, \ldots, x_t) = (1 - \alpha_i^t) \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>为什么这么设计呢？其实还是很有道理的。概率越大的话，说明$\alpha_i^t$越小，而其他的$\alpha_j^t$越大，这就印证了上面提出的观点。而如果取$l_t &gt; i$的话，$1 - \alpha_i^t$一定很小，会拉低概率；反之取$l_t &lt; i$的话，会乘上一个很小的项$\alpha_i^t$，也会拉低概率。所以取$l_t = i$就是最优的。</p><p><strong>第3步：</strong><br>我们的最终目的是求出门$g_i^t$，也就是$x_t$与$x_i$的相关度。在之前的动机中，直接将$l_t$之后的设为1，之前的设为0，但是这样是离散序列，无法传播梯度，所以这里采用另一种方法来求。注意到只有$p(l_t = i | x_0, \ldots, x_t)$接近于1，而其他的概率都接近于0，所以只需要用概率密度函数来作为$g_i^t$就行了：<br>\[<br>g_i^t = P(l_t \le i) = \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>注意到这个概率密度函数在$i &lt; l_t$时值基本很小接近于0，而大于等于它时很大，越来越接近于1。这和设计的初衷已经很像了，所以可以近似用来作为$g_i^t$。</p><p><strong>这里要提几点证明，可看可不看。</strong></p><p><strong>证明开始</strong></p><hr><p>首先这个概率$p(l_t = i | x_0, \ldots, x_t)$的形式其实是一个狄利克雷过程，有两个特殊值要定义一下，一个是$l_t = t-1$时，概率为：<br>\[<br>p(l_t = t - 1 | x_0, \ldots, x_t) = (1 - \alpha_{t - 1}^t)<br>\]<br>还有就是当$l_t = 0$时，因为$d_0$实际不存在，所以定义为句法距离无穷大，那么$\alpha_0^t$定义为0，所以概率为：<br>\[<br>p(l_t = 0 | x_0, \ldots, x_t) = \prod_{j=1}^{t-1} {\alpha_j^t}<br>\]<br>然后可以求出$g_i^t$的期望（<strong>这里论文中又写的一塌糊涂，符号定义都不统一。。。</strong>）：<br>\[<br>\mathbb E(g_i^t) = \prod_{j=1}^{t-1} {\alpha_j^t} + (1 - \alpha_1^t)\prod_{j=2}^{t-1} {\alpha_j^t} + \ldots + (1 - \alpha_i^t)\prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>进一步可以写为：<br>\[<br>\mathbb E(g_i^t) = \sum_{j=0}^i {p(l_t = j | x_0, \dots, x_t)} = P(l_t \le i)<br>\]<br>上面的求和裂项相消可以得到：<br>\[<br>P(l_t \le i) = \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]<br>这里也可以验证出$P(l_t &lt; t) = 1$，所以最终得到下面的门是正确的：<br>\[<br>g_i^t = \prod_{j=i+1}^{t-1} {\alpha_j^t}<br>\]</p><p>然后要证明的就是根据这个策略求出的两个单词的关联区间没有交叉（但是可以完全覆盖）。首先放宽一下条件，证明当$\alpha_j^t$只取0或者1时，性质成立，也就是定义（<strong>这里原文又打错了。。。</strong>）：<br>\[<br>\alpha_j^t = \frac{ {\rm sign}(d_t - d_j) + 1}{2}<br>\]<br>也就是在原来的定义中令$\tau$为正无穷。这样的话如果$d_t &gt; d_j$，那么$\alpha_j^t$就是1，否则就是0。放宽了条件之后，$g_i^t$取值就只有1和0了，所以求出的$l_t$一定是满足句法距离$d_i &gt; d_t$所有位置中最右边的一个。而对于所有的$l_t &lt; i &lt; t$，都满足$d_i &lt; d_t$。证明也很简单，假设存在两个单词$x_v$和$x_n$，其中$v &lt; n$，它俩的关联区间交叉了，那么假设$x_v$的$l_t$为$u$，而$x_n$的$l_t$为$m$，所以$u &lt; m &lt; v &lt; n$。那么根据定义，有：<br>\[<br>\begin{array}{} {d_u &gt; d_v &gt; d_m \\ d_m &gt; d_n &gt; d_v} \end{array}<br>\]<br>这两个式子显然矛盾，所以证明了在宽松的条件下，这个不交叉的性质是成立的。</p><p>另一个极端是令$\tau = 0$，这种情况下$\alpha_j^t = \frac{1}{2}$，最终算下来$g_i^t$是一个首项为$\frac{1}{2^{t-1}}$公比为2的等比数列。这里的话论文里说最终会形成一棵所有叶子结点都直接连接在根结点上面的句法树，但是我是没看出来为什么，首先这种情况下句法距离$d$对最终的损失函数没有影响了，所以梯度无法传播回来，句法距离$d$应该只受到词向量影响了，最终就是一个普通的语言模型，句法距离最终会是什么样子谁也不知道。</p><p>在具体实现时，将$\tau$设为一个中间值，但是这样会产生交叉的关联区间，所以测试的时候再将其设为正无穷。</p><p><strong>证明结束</strong></p><hr><h2 id="Reading-Network"><a href="#Reading-Network" class="headerlink" title="Reading Network"></a>Reading Network</h2><p>上面的Parsing Network求了半天就是为了得到这个gates $g_j^t$，然后怎么使用呢？既然是语言模型，下面当然要用LSTM来对句子进行编码了。众所周知，在LSTM中有两个隐含层状态$h$和$c$，所以在这里不直接使用上一个时刻传过来的状态，而是用历史所有时刻的状态信息，再与gates加权后输入到下一时刻。在论文中并没有直接使用gates作为权重，而是计算了一个新的权重，这里称作结构化attention：<br>\[<br>\begin{array}{} {k_t = W_h h_{t-1} + W_x x_t \\ \tilde s_i^t = {\rm softmax}(\frac{h_i k_t^{T}}{\sqrt {\delta_k}})} \end{array}<br>\]<br>当然这还不是最终的权重，再通过加入gates，定义一个新的结构化intra-attention：<br>\[<br>s_i^t = \frac{g_i^t \tilde s_i^t}{\sum_i g_i^t}<br>\]<br>上面两个式子我也不是很清楚怎么解释，反正最后就用这个权重来对历史状态进行编码：<br>\[<br>\left[ \begin{array}{*{c}}{\tilde h_t \\ \tilde c_t}\end{array} \right] = \sum_{i=1}^{t-1} {s_i^t \cdot m_i} = \sum_{i=1}^{t-1} {s_i^t \cdot \left[ \begin{array}{*{c}}{h_i \\ c_i}\end{array} \right]}<br>\]<br>最后将加权求和后的隐含层状态作为下一个时刻的隐含层输入，得到新的隐含层表示。</p><h2 id="Predict-Network"><a href="#Predict-Network" class="headerlink" title="Predict Network"></a>Predict Network</h2><p>最后就是预测下一个单词是什么了，这里并没有直接用下一时刻$t + 1$的隐含层输出来预测，还是采用了attention，但是存在一个问题，$g_j^{t+1}$的值依赖于$d_{t+1}$，也就是依赖于$x_{t+1}$，但是这是我们需要预测的，那怎么办呢？论文中就直接用另一套参数直接预测出一个临时的$d_{t+1}’$：<br>\[<br>d_{t+1}’ = {\rm ReLU}(W_d’h_t + b_d’)<br>\]<br>最后对历史状态加权求和，然后用一个前馈神经网络预测下一个单词：<br>\[<br>f(m_0, \ldots, m_t, g_0^{t+1}, \ldots, g_t^{t+1}) = \hat f([h_{l:t-1}, h_t])<br>\]</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>具体实验设置啥的去看论文吧，这里就贴几个结果图解释一下。</p><p><img src="4.jpg" alt><br>上面这个是字符级别的语言模型的结果，PRPN取得了SOTA的结果。</p><p><img src="5.jpg" alt><br>上面这个是词级别的语言模型的结果，除了那个用了4层LSTM和跨越连接的模型（参数多）外，PRPN效果是最好的。</p><p>当然我最关心的还是无监督成分句法分析上面的结果：<br><img src="6.jpg" alt><br>目前为止，无监督成分句法分析的标准做法还是用WSJ10数据集（也就是长度小于等于10的句子），然后用unlabeled F1评测。可以看到，PRPN效果只能说一般般，不是很好。</p><p>其实我也很疑惑，这里的无监督句法分析全靠Parsing Network产生的句法距离来产生，但是一个关键问题是句法距离并没有监督，唯一的监督信号来自于最后Predict Network的语言模型，那么这个句法距离真的能够学习到真实的句法距离吗？我比较怀疑，不过效果证明，这个对语言模型还是有帮助的，对无监督成分句法分析的话不好说。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文几个review都给出了还算不错的评价，思想是不错的，但是和其中一个review观点一样，我觉得文章写得太烂了，一堆的笔误，逻辑很混乱，即使这已经是review后修改过的版本了，还是有一堆错误。</p><p>过两天再看一篇ICLR2019的还是这个组的PRPN的改进版本，看看到底有何改进。不过真要搞无监督句法分析的话，还是老老实实去做聚类吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> ICLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Better, Faster, Stronger Sequence Tagging Constituent Parsers</title>
      <link href="/2019/03/11/naacl19-conparsing/"/>
      <url>/2019/03/11/naacl19-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>为了看懂论文里的策略梯度，又去把强化学习看了一遍。。。</p></blockquote><p><strong>论文地址：</strong><a href="https://arxiv.org/abs/1902.10985" target="_blank" rel="noopener">Better, Faster, Stronger Sequence Tagging Constituent Parsers</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇论文主要是在之前的那篇论文<a href="https://godweiyang.com/2019/03/11/ConParSeqLab/">Constituent Parsing as Sequence Labeling</a>基础上解决了如下三个问题：</p><ul><li>太长的短语预测错误率高。</li><li>输出空间太大导致label稀疏性。</li><li>贪心解码导致的错误传播。</li></ul><p>本文提出的解决方法分别是：</p><ul><li>采用融合了相对编码和绝对编码的动态编码。</li><li>将预测任务分解为多个子任务。</li><li>采用辅助任务和策略梯度。</li></ul><h1 id="三大问题以及解决方法"><a href="#三大问题以及解决方法" class="headerlink" title="三大问题以及解决方法"></a>三大问题以及解决方法</h1><hr><h2 id="过长短语预测的高错误率"><a href="#过长短语预测的高错误率" class="headerlink" title="过长短语预测的高错误率"></a>过长短语预测的高错误率</h2><p>由下面这张图可以看出，当$n_i$太小时，准确率就会大幅下降。这个问题主要体现在过长短语的闭合上，右括号的预测尤其困难。其实这也跟数据稀疏性有很大关系，训练集中过长短语毕竟占少数。<br><img src="1.jpg" alt></p><p>解决方法就是采用动态编码，如下图所示：<br><img src="2.jpg" alt><br>第一行是相对值编码，第二行是绝对值编码，之前文章都已经解释过了。第三行是结合了上面两种编码的动态编码，具体取值情况是大多数时候都还采用相对值编码，因为毕竟相对值编码空间比较小，可以适当缓解数据稀疏性。但是当满足如下两种情况的时候，就采用绝对值编码：</p><ul><li>绝对值$n_t’ \leq 3$，也就是说CA的个数不能超过3个，这样也是为了降低数据的稀疏性。</li><li>相对值$n_t \leq -2$，也就是说将上图中准确率比较低的那些负数值全部用绝对值替代了，在句法树中表现为$w_{t+1}$所在的子树比$w_t$低两层以上。</li></ul><h2 id="输出空间太大导致label稀疏性"><a href="#输出空间太大导致label稀疏性" class="headerlink" title="输出空间太大导致label稀疏性"></a>输出空间太大导致label稀疏性</h2><p>这个问题主要是由于三元组$(n_t, c_t, u_t)$太稀疏了导致的。假设$n_t \in N, c_t \in C, u_t \in U$，那么这个三元组的状态空间是$\left| N \right| \times \left| C \right| \times \left| U \right|$，可以通过将三元组分解为三个不同的子任务将复杂度降低为$\left| N \right| + \left| C \right| + \left| U \right|$。最后的损失函数定义为三个子任务的损失之和：<br>\[<br>\mathcal{L} = \mathcal{L}_n + \mathcal{L}_c + \mathcal{L}_u<br>\]<br>具体实现上，可以将任务$U$的输出给任务$N$和$C$作为输入。</p><h2 id="贪心解码导致的错误传播"><a href="#贪心解码导致的错误传播" class="headerlink" title="贪心解码导致的错误传播"></a>贪心解码导致的错误传播</h2><p>这个问题在基于贪心的方法中基本都存在，也就是所谓的一步错步步错，这里主要提出了两种解决方法。</p><p><strong>辅助任务</strong> 辅助任务主要就是用来帮助主任务学习到一些不太容易学到的信息。这里才用了两个辅助任务，一个是在预测$n_t$的同时再预测一个$n_{t+1}$，这样就能往后多预测一步，适当的减少了贪心的影响。另一个方法就是将之前博客写到的句法距离（syntactic distances）加入到模型中一起预测：<br><img src="3.jpg" alt><br>对于不同的辅助任务，最后将他们的损失求和加到最终的损失函数中去：<br>\[<br>\mathcal{L} = \mathcal{L}_n + \mathcal{L}_c + \mathcal{L}_u + \beta \sum_a \mathcal{L}_a<br>\]</p><p><strong>策略梯度</strong> 这个方法可以从全局的角度来对模型进行优化。假设模型在$t$时刻的状态为$s_t$，输出标签为$l_t = (n_t, c_t, u_t)$，那么模型选择$l_t$的概率定义为策略$\pi$，模型最终可以获得的奖励为$\mathcal R_{tree}$，定义为句法树的F1值。</p><p>定义句法树的概率为每一步决策的概率之积：<br>\[<br>p(tree) = \prod\limits_{t = 1}^T {\pi ({l_t}|{s_t};\theta )}<br>\]<br>所以模型最终就是要最大化如下的奖励：<br>\[<br>\mathcal R = \sum\limits_{tree} { {\mathcal R_{tree}}p(tree)}<br>\]<br>按照梯度上升的方向更新参数$\theta$，求梯度可得：<br>\[<br>\begin{array}{l}\Delta \mathcal R = \sum\limits_{tree} { {\mathcal R_{tree}}\Delta p(tree)} \\ = \sum\limits_{tree} {p(tree){\mathcal R_{tree}}\frac{ {\Delta p(tree)}}{ {p(tree)}}} \\ = \sum\limits_{tree} {p(tree){\mathcal R_{tree}}\Delta \log p(tree)} \\ = {\mathbb{E}_{tree \sim p}}({\mathcal R_{tree}}\Delta \log p(tree))\end{array}<br>\]<br>将$p(tree)$代入可得：<br>\[<br>\begin{array}{l}\Delta \mathcal R = {\mathbb{E}_{tree \sim p}}({\mathcal R_{tree}}\Delta \log p(tree))\\ = {\mathbb{E}_{tree \sim p}}({\mathcal R_{tree}}\Delta \log \prod\limits_{t = 1}^T {\pi ({l_t}|{s_t};\theta )} )\\ = {\mathbb{E}_{tree \sim p}}(\sum\limits_{t = 1}^T { {\mathcal R_{tree}}\Delta \log \pi ({l_t}|{s_t};\theta )} )\\ \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\mathcal R_{i}\Delta \log \pi ({l_t}|{s_t};\theta )} } \end{array}<br>\]<br>其中$\mathcal R_{i}$是根据分布$p$采样出来的$N$棵句法树的奖励。</p><p>具体实现的时候有好几个小Tips。</p><p>第一个就是要将奖励减去一个baseline，这里定义为模型直接根据贪心求得的句法树的F1值：<br>\[<br>\Delta \mathcal R \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\Delta \log \pi ({l_t}|{s_t};\theta )({\mathcal R_i} - {B_i})} }<br>\]<br>这么做的目的就是为了让奖励有正有负，不然全部都是正数的话，因为采样不可能全部采样到，可能会导致高概率的样本概率越来越高，而没有采样到的低概率样本可能奖励非常高，却因此概率越来越低。</p><p>第二个Tip就是加入熵作为正则项：<br>\[<br>\Delta \mathcal R \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\Delta \log \pi ({l_t}|{s_t};\theta )({\mathcal R_i} - {B_i}) + \beta \Delta H(\pi ({l_t}|{s_t};\theta ))} }<br>\]<br>目的就是使概率尽量不要太小，不然的话采样数不够的话就有可能造成采样不到小概率的样本。</p><p>还有就是给策略加入噪声：<br>\[<br>\Delta \mathcal R \approx \frac{1}{N}\sum\limits_{i = 1}^N {\sum\limits_{t = 1}^T {\Delta (\log \pi ({l_t}|{s_t};\theta ) + N)({\mathcal R_i} - {B_i}) + \beta \Delta H(\pi ({l_t}|{s_t};\theta ) + N)} }<br>\]<br>目的同样是加大概率，防止概率太接近于0，当然这个可加可不加。。。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>首先测试了不同设置的影响：<br><img src="4.jpg" alt><br>可以看出上面提到的几种方法对性能都有提升，其中采用动态编码、多任务（也就是减少输出空间）、辅助任务（主要是预测前一个$n_{t-1}$）还有策略梯度可以获得最好的结果。</p><p>最终模型在测试集上取得了90.6的F1值，虽然不是很高，但比之前的序列标注模型提升还是不少。<br><img src="5.jpg" alt></p><p>最后再来看一下模型在负数预测上的准确率，可以看出有了非常大的提升：<br><img src="6.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文提出了不少的小Tips来提升序列模型的准确率，但是效果却还是远远低于syntactic distances那篇论文（F1值91.8），具体原因我也不得而知，我猜测跟树到序列映射编码关系可能不是特别大，可能还是跟序列建模有关，那篇论文的序列采用了两次LSTM，中间还夹杂了一次CNN卷积操作。所以编码器的好坏还是直接决定了最后性能的好坏，怪不得Elmo和Bert的效果那么的突出。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Constituent Parsing as Sequence Labeling</title>
      <link href="/2019/03/11/conparseqlab/"/>
      <url>/2019/03/11/conparseqlab/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>貌似已经有好几个月没怎么看过论文了，之前一直在写论文，一直没空更新博客，最近闲下来把最后几篇没看完的论文看了。</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/D18-1162" target="_blank" rel="noopener">Constituent Parsing as Sequence Labeling</a></p><p><strong>代码地址：</strong><a href="https://github.com/aghie/tree2labels" target="_blank" rel="noopener">Code</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>本文定义了一种新的树的序列化方法，将树结构预测问题转化为了序列预测问题。该序列用相邻两个结点的<strong>公共祖先（CA）数量</strong>和<strong>最近公共祖先（LCA）的label</strong>来表示一棵树，并且证明了这个树到序列的映射是单射但不是满射的，但是提出了一系列方法来解决这个问题。</p><p>相比于之前的序列方法，比如<a href="http://www.aclweb.org/anthology/D16-1257" target="_blank" rel="noopener">Parsing as Language Modeling</a>，本文的序列化有所不同，主要体现在之前的方法都是seq2seq的，也就是输入句子，直接输出树的括号表达式序列。但是这种方法输出不是定长的，所以结果可能会比较差。本文的方法将输出长度固定在了句子长度减1上（只针对不存在一元产生式的句法树，这种情况之后讨论），所以可以将每个预测分配到每个单词上，然后用序列标注的方法来解决。</p><h1 id="树的序列化"><a href="#树的序列化" class="headerlink" title="树的序列化"></a>树的序列化</h1><hr><h2 id="记号和基础知识"><a href="#记号和基础知识" class="headerlink" title="记号和基础知识"></a>记号和基础知识</h2><p>记输入句子为$\textbf{w} = [w_1, w_2, \ldots, w_N]$，其中$w_i \in V$。$T_N$为拥有$N$个叶子结点的不含有一元产生式的句法树集合。句法分析的任务就是将输入句子$\textbf{w}$映射到句法树$T_N$。</p><p>为了将句法分析转化为序列标注任务，需要定义一个树的序列化方法：$\Phi_N : T_N \to L^{N - 1}$，也就是将一棵有$N$个叶子结点的句法树转化为长度为$N - 1$的序列。并且该映射函数还得满足一定的条件，首先它一定得是一个<strong>函数</strong>（<em>也就是对于所有的句法树，都得找到一个对应的序列</em>），然后这个函数还得有<strong>单射性</strong>（<em>也就是句法树和序列要一一对应，不能存在两个句法树对应同一个序列，否则的话预测出来一个序列可能解码出两棵句法树，那就尴尬了</em>），当然要是还满足<strong>满射性</strong>就最好了（<em>也就是对于每一个序列，最好都能找到一棵句法树与之对应，不然预测出一个序列无法找到对应的句法树也很尴尬</em>），当然找不到也没事，后文有解决方法。</p><p>然后需要定义一个函数，将句子映射为序列：$F_{N, \theta} : V^N \to L^{N - 1}$。这个映射就通过序列标注的LSTM来实现了，$\theta$就是LSTM的参数。</p><p>最后通过函数$F_{N, \theta} \circ \Phi_N^{-1}$将输入句子转化为对应的句法树。那么$F_{N, \theta}$没什么好说的，就是一个序列标注模型，下面重点就是介绍如何设计函数$\Phi_N$。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>之前说到了将一棵有$N$个叶子结点的句法树转化为长度为$N - 1$的序列，这个序列是这样生成的：对于单词$w_i$，分配给它一个二元label $l_i = (n_i, c_i)$，其中$n_i$为单词$w_i$和$w_{i + 1}$的CA数量，$c_i$为它俩的LCA的label。</p><p><img src="1.jpg" alt></p><p>如上图所示，这个序列的$n_i$有两种表示方法。一种就表示成CA的绝对数量，如图中第一行所示。还有一种表示成后一个数与前一个数的差值，这样能减少元组的数量，但是会出现负数。当然在这个例子中貌似并不能看出数量减少了。。。</p><p><strong>$k$叉树编码：</strong>如果句法树所有产生式全部是$k$叉的，那么还可以将编码进一步简化，具体做法就是将所有的负数$n_i$统一为一个负数就行。为什么这里就不需要对负数进行区分了呢？这还得从句法树的解码说起，我们看一看是怎么从序列解码成句法树的。</p><p>当遇到一个负数$n_i$的时候，说明${\rm LCA}(w_{i}, w_{i+1})$到根结点路径的长度比${\rm LCA}(w_{i-1}, w_i)$到根结点路径长度少$-n_i$个结点。大致结构如下图所示（图画的丑，不要介意）：</p><p><img src="2.jpg" alt></p><p>可以看出，$w_{i+1}$这棵子树接在了从$w_i$到根结点路径上的第$-n_i + 2$个结点上。但是$w_{i+1}$具体在哪还无法确定，只能确定它的子树根结点位置。另外需要解释的是，为什么这里是常数2？因为$w_i$到$w_{i-1}$与$w_i$的LCA的距离一定是2，如果不是的话，中间就一定会有其他结点，那么就一定存在结点位于$w_{i-1}$与$w_i$之间，这显然不可能。最后可以注意到，这种情况下，</p><p>如果$n_i$是正数的话，说明${\rm LCA}(w_{i}, w_{i+1})$到根结点路径的长度比${\rm LCA}(w_{i-1}, w_i)$到根结点路径长度多$n_i$个结点。大致结构如下图所示：</p><p><img src="3.jpg" alt></p><p>这种情况下，$w_{i+1}$这棵子树接在了从${\rm LCA}(w_{i-1}, w_i)$到$w_i$路径上的第$n_i + 1$个结点处。同样也无法确定它的准确位置，但是它所在的子树确定了从这分叉出去的。</p><p>回到正题，之前说到了对于$k$叉树，所有负数都可以统一起来，为什么呢？继续看上面$n_i$负数那张图，对于$w_{i+1}$所在子树，需要在从$w_i$到根结点这条路径上寻找一个分叉点，也就是它俩的LCA。如果这是一个$k$叉树，那么这个分叉点就一定是第一个孩子数不满$k$个的结点。因为如果再往下的话，孩子数都满了，再加子树孩子数一定大于$k$。再往上的话，就会导致这第一个结点孩子数小于$k$，因为从左到右遍历的，子树之间不会交叉，以后都不会有子树插入到这个结点处了。</p><p>下图就是简化序列化后的二叉树例子，第三行将所有的负数都用一个负号替代了：</p><p><img src="4.jpg" alt></p><p>我尝试过了按照这个序列构建出一棵树的过程，画了个草图给大家看看，可能有点乱（参照的是上面那个非二叉树的图）：<br><img src="5.jpg" alt></p><p>还有一个小trick就是对于有些直接连到根结点的叶子，用$({\rm ROOT}, c_i)$作为它们的label。</p><h2 id="理论证明"><a href="#理论证明" class="headerlink" title="理论证明"></a>理论证明</h2><p>主要证明两个性质，一个就是充分性（即每个句法树都能映射为一个序列），另一个就是单射性（即每个序列只能唯一对应一个句法树）。</p><p><strong>充分性：</strong><br>这个显而易见，对于每个句法树，相邻两个单词一定存在唯一的LCA，且它的label也是唯一的，所以充分性肯定能保证的。</p><p><strong>单射性：</strong><br>为了简便，首先证明不包含非终结符的树结构映射的单射性，再证明加上非终结符也是单射的。</p><p>如果用$(\bullet_i)$表示第$i$个叶子结点，那么句法树可以表示成如下的括号表达式：<br>\[<br>\alpha_0 (\bullet_1) \alpha_1 (\bullet_2) \ldots \alpha_{\left| w \right| - 1} (\bullet_{\left| w \right|}) \alpha_{\left| w \right|}<br>\]<br>更进一步，每个$\alpha_i$形式肯定是$[)]^*[(X]^*$，因为如果存在一个闭合的括号对，那么中间肯定还存在着一个叶子结点，这显然不可能。所以我们可以用$\alpha_{i)}$来替代$[)]^*$，用$\alpha_{i(}$来替代$[(X]^*$，将$\alpha_i$改写为$\alpha_{i)} \alpha_{i(}$，括号表达式可以重写为：<br>\[<br>\alpha_{0)} \alpha_{0(} (\bullet_1) \alpha_{1)} \alpha_{1(} (\bullet_2) \ldots (\bullet_{\left| w \right|}) \alpha_{\left| w \right|)} \alpha_{\left| w \right|(}<br>\]<br>注意到首尾两个元素一定是空的，接下来用$\beta_i$替换$\alpha_{i-1(}(\bullet_i)\alpha_{i)}$，得到序列：<br>\[<br>\beta_1 \beta_2 \ldots \beta_{\left| w \right|}<br>\]<br>更进一步，可以证明$\beta_i$一定只含有$[(X]^*(\bullet_i)$和$(\bullet_i)[)]^*$中的一个。因为如果两个都含有的话，说明存在$(X(\bullet_i))$这种一元产生式，但是因为一元产生式都提前处理过了，所以不可能存在。</p><p>接下来可以给每个$\beta_i$分配一个值$\delta(\beta_i)$，如果$\beta_i$左右两边都没有括号，那这个值就是0，如果左边有$k$个括号，那值就是$+k$，如果右边有$k$个括号，那值就是$-k$。如果将这些值写成序列：<br>\[<br>\delta(\beta_1)\delta(\beta_2)\ldots\delta(\beta_{\left|w\right| - 1})<br>\]<br>这个序列正好对应了之前的第二种编码，也就是编码成LCA的个数之差。这是为什么呢？可以看出，一直到$\beta_i$结束，没有闭合的括号数量正好就是$w_i$和$w_{i+1}$的LCA数量。所以$\delta(\beta_i)$就是$w_i$和$w_{i+1}$的LCA数量与$w_{i-1}$和$w_{i}$的LCA数量的差值。</p><p>最后这就验证了括号序列和之前的编码是一一对应的，单射性得证。解码的时候只需要将数字直接转化成对应的括号序列就行了。</p><p>而加上了非终结符之后，单射性不会受到影响。因为虽然两棵相同结构但是拥有不同非终结符的句法树，转化成括号序列后是相同的。但是因为之前的定义中，还有一个变量$c_i$来表示这个非终结符了，所以还是能够唯一对应过去的。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>上面定义的序列化函数有两个缺点：一是非满射，二是不能处理一元产生式，下面介绍一下解决方法。</p><p><strong>对于一元产生式：</strong><br>有两种一元产生式，一种是中间结点，还有一种是叶子结点的label。</p><p>对于中间结点，直接将一条链上的label合并成一个新的label就行了，方法和之前文章介绍的一样。</p><p>而对于叶子结点的label，一个方法是在解码之前先用一个函数预测一下每个叶子结点的label，如果为空，说明没有label，否则就加上这个label，然后再进行正常的解码。另一个方法是将之前的序列化的二元组扩展为三元组$(n_i, c_i, u_i)$，其中第三个元素就是每个叶子结点的label。</p><p><strong>非满射：</strong><br>非满射会导致的问题就是产生出来的序列可能无法映射到某一棵句法树。根据文中所说，一共有两种无法映射的情况。</p><p>一种情况是对于多叉树，相邻两对叶子结点的LCA的label预测不同。比如在最上面一张图中，“the red toy”如果预测为两个不同的label，那么就会产生矛盾。这种情况很好解决，只要在解码的时候只取第一个label，忽略后一个就行了。</p><p>另一种情况是序列可能会产生一元产生式，如下图所示：</p><p><img src="6.jpg" alt></p><p>根据图中序列，会产生下面那棵句法树，一元结点X并没有预测到。但其实因为一元结点已经提前合并了，所以如果预测到了一元结点，直接删掉不要就行了。</p><h1 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h1><hr><p>这里就不细讲了，用的就是基本的BiLSTM + CRF序列标注模型，具体可以看这篇论文：<a href="https://arxiv.org/abs/1603.01354" target="_blank" rel="noopener">End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF</a>。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>这篇论文最大的卖点不是效果，而是速度快，下面是和其他模型的速度对比，可以看出，速度的确快了不少，达到了大几百句每秒。但是还是存在序列标注模型的老毛病，效果并不好，虽然比之前的高了，但是还是只有90%的F1。</p><p><img src="7.jpg" alt></p><h1 id="结论与展望"><a href="#结论与展望" class="headerlink" title="结论与展望"></a>结论与展望</h1><hr><p>这篇论文定义了一种新的句法树序列化方法，将句法树序列化为长度减1的序列，其中每个值就是相邻两个单词的CA个数和LCA的label。</p><p>看完这篇，我仔细想了想，其实之前的chart-based方法也都可以转化成序列，只不过都得特别处理一下一元产生式和多叉树，比较麻烦。以后可以考虑在这方面有所突破，速度快还是很nice的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> EMNLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex撰写论文常用技巧总结</title>
      <link href="/2019/01/13/latex-pdf/"/>
      <url>/2019/01/13/latex-pdf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这篇博文专门用来记录Latex写论文过程中遇到的一些技巧与心得。</p><h1 id="插入矢量图片"><a href="#插入矢量图片" class="headerlink" title="插入矢量图片"></a>插入矢量图片</h1><hr><p>首先在Office PowerPoint中画好模型图，然后有两种方法在Latex中插入矢量图。<br><img src="1.jpg" alt><br><strong>方法一：</strong><br>直接另存为pdf，例如存为<code>figure.pdf</code>。<br><img src="2.jpg" alt><br>注意到pdf打开来左右两个侧边栏有较大的空余空间，所以最好在ppt中绘制模型图的时候就调整好。<br>然后在Latex中使用如下代码插入pdf图片即可：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span> Model. <span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">fig::model</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中参数<code>width=\textwidth</code>是用来调整图片宽度，使得图片占满整个论文，效果如下：<br><img src="3.jpg" alt><br>注意到这里左右两个侧边栏间距的确有点大了，没有占满整个页面。<br>如果想要图片只显示在一半的页面上，那么只需要用如下代码即可：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\linewidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span> Model. <span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">fig::model</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下：<br><img src="4.jpg" alt></p><p><strong>2019.1.14更新：</strong><br>关于生成出来的模型图pdf侧边距过大的问题，可以下载“迅捷pdf编辑器”，使用它强大的页面裁剪功能。当然非会员会留下水印，只需要修改水印透明度为0即可。</p><p><strong>方法二：</strong><br>ppt绘制好的模型图右键另存为<code>emf</code>格式，这是一种Windows的矢量图格式，然后下载一款软件叫<code>Metafile to EPS Converter</code><a href="http://wiki.lyx.org/uploads/Windows/metafile2eps/metafile2eps.exe" target="_blank" rel="noopener">地址</a>，将图片转为Latex支持的<code>eps</code>格式，例如命名为<code>figure.eps</code>。</p><p>最后在Latex使用相同的代码插入图片即可，效果如下：<br><img src="5.jpg" alt><br>可以看出两侧间距比原来小了很多。</p><p><strong>2019.3.6更新：</strong></p><h1 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h1><hr><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">CJK</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">CJK*</span><span class="token punctuation">}</span><span class="token punctuation">{</span>GBK<span class="token punctuation">}</span><span class="token punctuation">{</span>song<span class="token punctuation">}</span><span class="token comment" spellcheck="true">% 正文</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">CJK*</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><hr><p><strong>单幅图片：</strong></p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\linewidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span>xxxxx.<span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:xxxxx</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跨双栏的话把<code>figure</code>改成<code>figure*</code>，<code>htbp</code>控制位置，自己看着调。</p><p>难点是跨双栏图片置顶，一般情况下会自动跑到下一页去，找了半天才找到解决方法：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\twocolumn</span><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token function selector">\renewcommand</span><span class="token function selector">\twocolumn</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>#1<span class="token punctuation">}</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span>        <span class="token function selector">\centering</span>        <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure.pdf<span class="token punctuation">}</span>        <span class="token function selector">\captionof</span><span class="token punctuation">{</span>xxxxx.<span class="token punctuation">}</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缺点是无法添加<code>label</code>，正文只能手动加引用了。</p><p><strong>两幅图片同一行显示：</strong></p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span class="token punctuation">[</span>htbp<span class="token punctuation">]</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\subfigure</span><span class="token punctuation">[</span>fig1.<span class="token punctuation">]</span><span class="token punctuation">{</span>        <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">{</span>0.58<span class="token function selector">\textwidth</span><span class="token punctuation">}</span>        <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure1.pdf<span class="token punctuation">}</span>        <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span>        <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:fig1a</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function selector">\subfigure</span><span class="token punctuation">[</span>fig2.<span class="token punctuation">]</span><span class="token punctuation">{</span>        <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">{</span>0.34<span class="token function selector">\textwidth</span><span class="token punctuation">}</span>        <span class="token function selector">\includegraphics</span><span class="token punctuation">[</span>width=<span class="token function selector">\textwidth</span><span class="token punctuation">]</span><span class="token punctuation">{</span>figure2.pdf<span class="token punctuation">}</span>        <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">minipage</span><span class="token punctuation">}</span>        <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:fig1b</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span>xxxxx.<span class="token punctuation">}</span>    <span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Fig:fig1</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">figure*</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意的是，两个图片宽度之和<code>0.58 + 0.34 = 0.92</code>要尽量小于1，不然会显示出问题。</p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><hr><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\renewcommand</span><span class="token punctuation">{</span><span class="token function selector">\algorithmicrequire</span><span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token function selector">\textbf</span><span class="token punctuation">{</span>Input:<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function selector">\renewcommand</span><span class="token punctuation">{</span><span class="token function selector">\algorithmicensure</span><span class="token punctuation">}</span><span class="token punctuation">{</span> <span class="token function selector">\textbf</span><span class="token punctuation">{</span>Output:<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">algorithm</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span>    <span class="token function selector">\caption</span><span class="token punctuation">{</span> alg1. <span class="token punctuation">}</span><span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Alg:Alg1</span><span class="token punctuation">}</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">algorithmic</span><span class="token punctuation">}</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>        <span class="token function selector">\Require</span>            <span class="token comment" spellcheck="true">% 输入</span>        <span class="token function selector">\Ensure</span>            <span class="token comment" spellcheck="true">% 输出</span>        <span class="token comment" spellcheck="true">% 过程</span>        <span class="token function selector">\Function</span> <span class="token punctuation">{</span>xxxxxx<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token equation string">$i, j$</span><span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">% 函数体</span>        <span class="token function selector">\EndFunction</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">algorithmic</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">algorithm</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><hr><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\newcommand</span><span class="token punctuation">{</span><span class="token function selector">\tabincell</span><span class="token punctuation">}</span><span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>@<span class="token punctuation">{</span><span class="token punctuation">}</span>#1@<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>#2<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token function selector">\normalsize</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>l|l|ccc<span class="token punctuation">}</span><span class="token function selector">\hline</span><span class="token function selector">\multicolumn</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span><span class="token punctuation">{</span>c|<span class="token punctuation">}</span><span class="token punctuation">{</span>Model<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> LR <span class="token punctuation">&amp;</span> LP <span class="token punctuation">&amp;</span> F1<span class="token function selector">\\</span><span class="token function selector">\hline</span><span class="token function selector">\hline</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">center</span><span class="token punctuation">}</span><span class="token function selector">\caption</span><span class="token punctuation">{</span> xxxxx.<span class="token punctuation">}</span><span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Tab:CompDiffConfig</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个难点，一个是合并同一行的单元格，用<code>\multicolumn{cols}{pos}{text}</code>。</p><p>一个是合并同一列的单元格，用：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span>    <span class="token function selector">\centering</span>    <span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token punctuation">{</span>|c|c|c|c|<span class="token punctuation">}</span>        <span class="token function selector">\hline</span>        <span class="token function selector">\multirow</span><span class="token punctuation">{</span>2<span class="token punctuation">}</span>*<span class="token punctuation">{</span>合并两行一列<span class="token punctuation">}</span> <span class="token punctuation">&amp;</span> 二 <span class="token punctuation">&amp;</span> 三 <span class="token punctuation">&amp;</span> 四 <span class="token function selector">\\</span>        ~ <span class="token punctuation">&amp;</span> 2 <span class="token punctuation">&amp;</span> 3 <span class="token punctuation">&amp;</span> 4 <span class="token function selector">\\</span>        <span class="token function selector">\hline</span>    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">tabular</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">table</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意第二行第一列要用<code>~</code>补上空位。用<code>\cline{start-end}</code>来代替<code>\hline</code>划线。</p><p><strong>暂时就想到这些了，等想到了再更吧，祝我paper顺利。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一八年终总结</title>
      <link href="/2018/12/31/2018-conclusion/"/>
      <url>/2018/12/31/2018-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>某天，你无端想起了一个人，她曾让你对明天有所期许，但是却完全没有出现在你的明天里。</p></blockquote><p>2017年好像还历历在目，2018年却要过去了，貌似这一年并没有发生什么特别值得纪念的事情吧，平平淡淡，淡的就像一杯白开水。</p><p>细数这一年发生的事，前半年写毕业论文，送走了一个又一个熟悉的面孔，略有感伤；后半年荒废，偶尔看看论文偶尔写两行代码，仍然时常因为一些无关紧要的事情而感伤。</p><ul><li>毕业</li><li>炼丹</li><li>想开</li></ul><h1 id="毕业季"><a href="#毕业季" class="headerlink" title="毕业季"></a>毕业季</h1><hr><p>整个上半年差不多都在忙着读论文、改代码、写毕设吧。虽然当时的眼光有限，看的论文还都是几年前的传统方法，例如CKY算法，模型也基本都是基于Grammar的，在现在看来效率实在是低下，效果也不尽人意。幸好论文写得马马虎虎，也算是萌混过关吧QAQ，最后也混了个并没有什么卵用的优秀毕业论文。</p><p>毕业论文封面：<br><img src="1.jpg" alt></p><p>忙完了毕业论文，接下来就是毕业典礼了吧，也是个忧伤的时期吧。还记得毕业典礼那天大家一起去了闵行，自从两年前搬来中北后，就再也没有回去过了吧。闵行的校园，闭着眼睛也能知道走到哪了吧，毕竟曾经都一起走过，到处都留下了回忆。那天天气非常的好，又把校园都走了一遍吧，只是没有去曾经的三舍看看，略有遗憾，当年去四舍帮忙搬家的情景又浮现在了眼前。也许是回忆过多，没有久留，一伙曾经玩的最好的朋友们一起在宝龙广场吃了饭唱了歌，就当做是散伙饭了吧。</p><p>之后就是暑假了吧，有人升学到了其他学校，有人开始了工作生涯，也有人继续和我一样留在了本校，继续做了室友。特别值得一提的是永日至秦吧，那个打游戏打的我心态爆炸的选手。暑假每天一起半夜出来跑了最后的步，还一起骑着单车骑到了外滩，再上一次去那看夜景还是不知几年前和她去的了吧，换了个人去，别有一番滋味。现在永日至秦也一个人去了北京，不知何时再能见到，希望下次见到李院士的时候你不是一个人（此处貌似有歧义）。</p><p>最后附上孙子临走前的美照一张，有意向勾搭的找我要联系方式：<br><img src="2.jpg" alt></p><h1 id="炼丹生涯开始"><a href="#炼丹生涯开始" class="headerlink" title="炼丹生涯开始"></a>炼丹生涯开始</h1><hr><p>送走了所有人之后，暑假搬了宿舍，就正式开始了研究僧的炼丹生涯（划水混毕业）了吧。一整个暑假都在看论文，补基础，也差不多看完了成分句法分析近几年来的所有深度学习方法了吧，基本对此有了一个初步的认识。还开通了<a href="https://zhuanlan.zhihu.com/godweiyang" target="_blank" rel="noopener">知乎专栏：自然语言处理与深度学习</a>，经营到现在也才900不到的粉丝吧，希望有一天能像大佬们那样几万的粉丝，在这个领域做出自己的贡献吧。通过看论文，写博客，也认识了许多志同道合的人吧，还和大佬们有所交流。</p><p><img src="4.jpg" alt></p><p>其实写博客也是很累的，从刚开始计划的paper daily到后来的paper weekly，再到现在的paper randomly。有时候一篇论文真的要精读好久才能读懂，有时候实在读不懂了，就直接开写，在写的过程中，逐渐的就把自己说服懂了。其实这也和讲presentation一样，我也是比较喜欢做presentation的，一个原因是我确实喜欢和别人分享各种好的paper，好的思想，另一个原因是在讲的过程中，有些我一直不懂的问题可能讲着讲着我就懂了，也可以和台下的老师同学们自由讨论，理解得更加透彻。</p><p>可能会有人问我，你写了没人看，哪里有成就感？确实，刚开始时只有寥寥无几的老同学们来捧个场子，而且他们也都看不懂，只是点个赞。但是如果只是为了出名，那就不要写博客了吧，写博客是主要是为了提升自己，记录自己的点点滴滴，然后是和别人分享，同时自己也能获得进步。至于成就感的话，慢慢就有了，最起码每次写完一篇博客，看着整理的满满当当的博文，自己就会有一种成就感，不需要别人来证明。现在每天看着知乎多了新粉丝，偶尔会有新评论和私信，询问学术方面的问题，还是会有小小的欣慰的。</p><p>现在论文看的不如以前多了，看来还是得去补补基础，或者去看看其他方面的论文，涉猎广一点，有些东西是通用的，可以拿来为之所用。代码的话之前写的也不多，一直都是面向过程，写的代码都不堪入目。直到开学才拿了伯克利的优质代码，重构了一下，整合了比较流行的几种模型，在上面进行了修改，最近也一直在跑。虽然现在没有对象，但是面向对象的思想还是要有的，不然以后代码维护起来都很困难的。</p><p>开学了课虽然不多，但是事情还是挺繁杂的吧。周二要给大三的操作系统实践做助教，每周都要改作业，还是挺麻烦的，混学分不容易。周四一天满课，知识分析课每周都要抄作业度日，其他几门课也都没怎么听，现在担忧期末考试怎么办，本科认真学习的劲头不知道都去哪里了，可能现在只要不挂科就行了吧，心态变了。而且现在想找个能一起学习的朋友都很难了。</p><h1 id="庸人自扰"><a href="#庸人自扰" class="headerlink" title="庸人自扰"></a>庸人自扰</h1><hr><p>并没有遇到什么在意的人吧，就说说我一直以来的心路历程吧。</p><p>一个人好过歹过也已经有一年半多了，在旁人看来这么久了，也早该忘得一干二净了，但是毕竟这是初恋吧，被义务教育压榨了这么多年后的第一次解脱，很难忘记。而且我也不是一个很随便的人，没那么容易忘。直到一个多月前吧，她终于遇到了对她真正好的人了，我想我也该彻底释怀了，知道消息时也没多大的情绪波动，一切都在意料之中，早晚会来临的。</p><p>可能会有人觉得我喜欢撩妹吧，学妹加了挺多。的确，是加了不少，都是每年开学水新生群加的吧，但绝大多数都安静地躺尸在了好友列表里。偶尔会有一些“慕名前来”问问题的人，以前我还能认真回答回答，毕竟我一直喜欢帮助别人，分享自己的经验。但是现在我改变了这些想法，二十三年了，第一次在这方面感到累了，也许自闭才是最好的解决方法吧，帮助别人到最后什么都得不到吧，还是照顾好自己。既然喜欢的人不可得，那就安心学习吧，对自己好才是最重要的。如果对任何人都这么有求必应，可能真的变成了小太阳了吧。</p><p>以前的我也跟小标题一样，时常庸人自扰，无病呻吟吧，可能是我想太多了吧，总是被一些无关痛痒的事影响，每天都是唉声叹气的。现在我想开了，真的没必要为这些琐事担忧烦心，放任它去吧。每当再遇到了困扰的事，出去散散心倒是最好的解决方式，虽然找不到最合适的人一起散心，但是能呼吸一下外面透心凉的空气，心里的结也能一下子解开了。见的多了自然而然就不会为一些事而感到郁郁寡欢了，从前每次遇到不顺心的事总会连着影响几天，饭也吃不好觉也睡不着，学习也没有任何的动力。现在想开了，努力练就一颗强大的内心吧，虽然铁石心肠不好，但是还是要坚强呀。你已经是个大人了，要学着自己控制情绪了，不要再做一个幼稚的小孩了，成熟点吧。<br><img src="3.jpg" alt></p><h1 id="2019畅想"><a href="#2019畅想" class="headerlink" title="2019畅想"></a>2019畅想</h1><hr><p>关于下一年，首先把课混过去，然后好好看论文敲代码做实验吧，但愿能有个不错的想法和实验效果，让我能在明年就安然毕业。至于发A什么的，就先想想吧，朝着这方面努力，希望我的微信名可以早日改掉。</p><p>情感方面，就准备单着三年吧，除非天上掉馅饼了，好好做学术才是正道。</p><p>多出去走走吧，本科四年都呆在学校了，三点一线式的类高中生活，谈的也是高中式恋爱吧，累了累了。</p><p>其他没啥好想的了，鄙人不善幻想，只喜欢晚上做梦，最后送上泰戈尔的一句名言吧，与君共勉：</p><blockquote><p>有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；<br>有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Oracles for Top-Down and In-Order Shift-Reduce Constituent Parsing</title>
      <link href="/2018/11/07/emnlp18-dynamic-oracle/"/>
      <url>/2018/11/07/emnlp18-dynamic-oracle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>有一句话，宾语是你。“吉下两点一口，又有欠字相依。”</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/D18-1161" target="_blank" rel="noopener">Dynamic Oracles for Top-Down and In-Order Shift-Reduce Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/danifg/Dynamic-InOrderParser" target="_blank" rel="noopener">github</a></p><p>本文是发表在EMNLP18上的一篇关于Dynamic Oracle的论文，主要介绍了针对自顶向下和中序两种移进归约成分句法分析模型的Dynamic Oracles。在PTB数据集上，取得了单模型最高的F1值92.0（截至论文发稿时是最高的，张岳TACL18的论文已经取得了92.4的最高F1值）。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>Dynamic Oracle是用在转移系统中，防止错误传播的一种手段。而转移系统主要有分为三种：bottom-up、top-down和in-order的转移系统。</p><p>其中bottom-up转移系统的Dynamic Oracle在<a href="http://aclweb.org/anthology/D16-1001" target="_blank" rel="noopener">Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles</a>中有很详细的证明，也可以参看我之前的博客<a href="https://godweiyang.com/2018/08/03/dynamic-oracles/">Deep Understanding of Dynamic Oracle in Constituent Parsing</a>。</p><p>而本文就提出了另外两种转移系统的Dynamic Oracle，其中top-down转移系统主要基于<a href="http://aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a>，in-order转移系统主要基于<a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a>。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><hr><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>bottom-up的转移系统这里就不讨论了，这里主要讨论另外两种转移系统。转移系统的状态用五元组$c = \left\langle {\sum ,i,f,\gamma ,\alpha } \right\rangle $表示，五元组内元素分别表示stack、buffer第一个单词的下标、in-order转移系统中结束标记、已经生成的短语成分集合、stack中非终结符集合。</p><p>每个短语成分用三元组$(X, l, r)$表示，其中X是非终结符，l和r是短语的边界下标。而非终结符用二元组$(X, j)$表示，其中j表示X入栈后下一个入栈的单词的下标。</p><p><img src="1.jpg" alt></p><p>例如对于上图中的句法树，它的gold短语成分集合是<br>\[(S,0,6),(NP,0,2),(VP,2,5),(ADVP,3,4),(ADJP,4,5)\]如果采用top-down的转移系统，非终结符入栈的顺序为<br>\[(S, 0), (NP, 0), (VP, 2), (ADVP, 3), (ADJP, 4)\]如果采用in-order的转移系统，非终结符入栈的顺序为<br>\[(NP, 1), (S, 2), (VP, 3), (ADVP, 4), (ADJP, 5)\]<br>正如之前所说，top-down中非终结符的下标就是短语的第一个单词的下标，但是in-order不是的，因为短语的第一个子结点已经在非终结符入栈之前形成了，所以它的下标是第二个子结点表示的短语的第一个单词的下标。</p><p>之前的top-down和in-order转移系统中并没有用到预测的短语集合$\gamma$和stack里的非终结符集合$\alpha$，但是在本文的转移系统中需要用到，因为本文要用它来改进loss函数，以此来实现Dynamic Oracle。</p><h2 id="top-down转移系统"><a href="#top-down转移系统" class="headerlink" title="top-down转移系统"></a>top-down转移系统</h2><p><img src="2.jpg" alt><br><img src="3.jpg" alt></p><p>上面两张图分别是top-down转移系统的转移过程和具体的转移示例。注意到REDUCE动作会将新的短语加入到$\gamma$集合中，并且从非终结符集合$\alpha$中删去该非终结符。而NT-X动作会将新的非终结符X加入到非终结符集合$\alpha$中。</p><h2 id="in-order转移系统"><a href="#in-order转移系统" class="headerlink" title="in-order转移系统"></a>in-order转移系统</h2><p><img src="4.jpg" alt><br><img src="5.jpg" alt></p><p>上面两张图分别是in-order转移系统的转移过程和具体的转移示例，大致细节和top-down转移系统类似。</p><h2 id="Dynamic-Oracles简介"><a href="#Dynamic-Oracles简介" class="headerlink" title="Dynamic Oracles简介"></a>Dynamic Oracles简介</h2><p>最后再解释一下Dynamic Oracle是干嘛用的，传统的Static Oracle就是在转移的每一步按照标准转移序列中的action进行转移，但是这样会有一个问题，如果预测的时候某一步预测错了，遇到了一个训练阶段没有出现过的状态，那么该怎么进行转移呢？这时候就要用到Dynamic Oracle，用来针对不同的错误情况进行动态的指导，引导它转移到正确的状态中去。另外在训练时可以手动加入一些错误状态，来训练模型，不然的话遇到的错误状态还是太少了，不足以训练好模型。</p><h1 id="Dynamic-Oracles"><a href="#Dynamic-Oracles" class="headerlink" title="Dynamic Oracles"></a>Dynamic Oracles</h1><hr><p>Goldberg (2012)证明了Dynamic Oracle可以通过定义一个损失函数来直接实现，而这个损失函数可以用来衡量当前状态可以产生的最优句法树和标准句法树的距离。最小化这个距离就会使得错误状态也会转移到最终错误最少的状态。而这个损失函数就要和当前状态c挂钩了，这样才能达到和传统的Dynamic Oracle类似的效果。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>传统的损失函数定义为预测短语成分集合和标准短语成分集合不相交的元素数量，即：<br>\[\mathcal{l}(c) = \min_{\gamma | c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| { {\gamma _G}\backslash \gamma } \right| + \left| {\gamma \backslash {\gamma _G}} \right|\]</p><p>根据<a href="https://godweiyang.com/2018/11/06/arxiv-18-SR-CP-bottom-up/">上一篇博文</a>的推导，该损失函数可以计算为<br>\[\mathcal{l}(c) = \min_{\gamma | c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| \mathcal{U}(c, \gamma_G) \right| + \left| {\gamma_c \backslash {\gamma _G}} \right|\]</p><p>上面的损失函数是上一篇论文中介绍的bottom-up的转移系统的Dynamic Oracle，但是本文主要讨论top-down和in-order的转移系统，因为转移系统多了non-terminal，所以需要新加入两项损失，用来衡量当前状态可以产生的最优句法树与标准句法树之间的汉明损失。</p><p>这两项新加的损失分别是：</p><ul><li>当前栈中已经生成的non-terminal集合$\alpha_c$中不包含在标准non-terminal集合$\alpha_G$中的non-terminal数量，即$\left| \alpha_c \backslash \alpha_G \right|$。</li><li>当前栈中违反了标准树中non-terminal顺序的non-terminal数量。</li></ul><p>所以最终的损失函数为：<br>\[\mathcal{l}(c) = \min_{\gamma | c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| \mathcal{U}(c, \gamma_G) \right| + \left| {\gamma_c \backslash {\gamma _G}} \right| + \left| \alpha_c \backslash \alpha_G \right| + out \_ of \_ order(\alpha_c, \alpha_G)\]</p><p>前面三项都很容易求得，至于最后一项，可以通过计算栈里的gold non-terminal序列的最长上升子序列来得到，而序列中每个non-terminal的标号就是它在标准树转移序列的non-terminal顺序标号。</p><h2 id="短语的可达性"><a href="#短语的可达性" class="headerlink" title="短语的可达性"></a>短语的可达性</h2><p>在这里用短语集合${(X, l, r)}$来表示一棵句法树，我们假设状态c的短语集合为$\sum = [(Y_p, i_p, i_{p-1}) \cdots (Y_2, i_2, i_1)|(Y_1, i_1, j)]$，那么我们说，标准句法树中的一个短语$(X, l, r) \in \gamma_G$当且仅当满足如下三个条件之一时，称它是“各自可达短语”：</p><p>对于top-down转移系统：</p><ul><li>$(X, l, r) \in \gamma_c$（因为短语已经包含在了状态c已生成的短语集合里，那么它当然是可达的）。</li><li>$j \le l &lt; r \wedge (X, l) \notin \alpha_c$（因为短语还在buffer中，并且短语的non-terminal还没有入栈，所以可以通过入栈$(X, l)$，再不断SHIFT然后REDUCE得到）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r \wedge (X, l) \in \alpha_c$（这种情况表明了短语的左端点恰好位于栈里某个短语的边界处，而右端点又还在buffer里，所以还可以通过不断SHUFT然后REDUCE得到短语。但是如果左端点不是栈里短语的边界，那说明产生了交叉，自然不会可达了。而如果右端点已经在栈里了，那之后也不会得到了，因为转移系统每次都是REDUCE栈顶的短语，不可能从栈里面开始REDUCE的，当然这些前提条件当然是non-terminal$(X, l)$已经在栈里了）。</li></ul><p>对于in-order转移系统：</p><ul><li>$(X, l, r) \in \gamma_c$（因为短语已经包含在了状态c已生成的短语集合里，那么它当然是可达的）。</li><li>$j \le l &lt; r$（因为短语还在buffer中，所以可以通过入栈第一个左儿子，再入栈$(X, m)$，再不断SHIFT然后REDUCE得到）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r \wedge (X, m) \notin \alpha_c$（这种情况表明了第一个左儿子已经生成了一部分或者完全生成了，并且根结点non-terminal还没有入栈，所以依然可以生成）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r \wedge (X, m) \in \alpha_c \wedge \exists (Y,l,m) \in \sum $（这种情况表明了第一个左儿子已经完全生成了，并且根结点non-terminal在栈里，所以依然可以生成）。</li></ul><p>枚举标准树中的所有短语，根据以上规则可以得到可达短语集合$\mathcal{R}(c, \gamma_G)$，然后从标准短语集合中排除掉这部分短语，剩下的就是不可达短语集合$\mathcal{U}(c, \gamma_G) = \gamma_G \backslash \mathcal{R}(c, \gamma_G)$。这部分短语就是不论采取何种动作序列，最后都不可能生成的短语集合。</p><p>关于这两个Dynamic Oracles的正确性，这里就不再证明了，证明过程和上一篇bottom-up的差不多。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>本文和基础的几个转移系统做了对比，代码也是在他们基础上进行修改的，结果如下：<br><img src="5.jpg" alt><br>可以发现，加了Dynamic Oracles之后，结果还是有略微提高的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> EMNLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faster Shift-Reduce Constituent Parsing with a Non-Binary, Bottom-Up Strategy</title>
      <link href="/2018/11/06/arxiv-18-sr-cp-bottom-up/"/>
      <url>/2018/11/06/arxiv-18-sr-cp-bottom-up/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文地址：<a href="http://arxiv.org/abs/1804.07961" target="_blank" rel="noopener">Faster Shift-Reduce Constituent Parsing with a Non-Binary, Bottom-Up Strategy</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇论文提出了一种非二叉化、自底向上的转移系统，并且针对它提出了一种Dynamic Oracle，用损失函数的形式来实现它。</p><p>之前的模型针对多叉树的处理都是采用head规则进行二叉化，或者采用空结点作为临时结点来进行隐式二叉化。但是本文将REDUCE动作扩展为REDUCE-k动作，从而可以对k叉树进行预测，这样减少了很多二叉树预测的中间过程，降低了模型的训练时间。并且为了提升准确率，还提出了一种用损失函数实现的Dynamic Oracle。</p><p>自底向上的转移系统就不详细介绍了，之前都已经介绍过了，这里只说明一下之后要用到的记号。</p><p>转移系统由一个stack和buffer组成，每个时刻的状态通常表示为$c = \left\langle {\sum ,i,f,\gamma} \right\rangle $，四个元素分别表示stack、buffer第一个单词的单词下标、分析结束标记、已经生成的短语成分的集合。</p><h1 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h1><hr><p>传统的转移系统REDUCE操作都只是将栈顶的两个元素归约为一个结点，而本文提出的转移系统将REDUCE扩展为REDUCE-X#k动作，归约栈顶概率最大的k个结点为结点X。举个例子，对于产生式$VP \to is \ ADVP \ ADJP$，使用的动作为REDUCE-VP#3，表示归约栈顶的三个结点。</p><p><img src="1.jpg" alt><br><img src="2.jpg" alt><br>具体的转移系统和例子如上图所示，为了区分具有不同数量儿子的结点X，将结点的label细化为X#k，表示具有k个儿子。例如对于VP结点，如果有两个儿子，那么它的label就是VP#2，如果有三个儿子就是VP#3。</p><h1 id="Dynamic-Oracle"><a href="#Dynamic-Oracle" class="headerlink" title="Dynamic Oracle"></a>Dynamic Oracle</h1><hr><p>本文采用的Dynamic Oracle是用损失函数来实现的，损失函数衡量的是状态c可以产生的最优句法树和标准句法树之间的距离，这样就可以计算出采取每一个动作之后下一个状态的损失函数值，选择损失函数值最小的动作。</p><p>对于状态c，损失函数$l(c)$定义为状态c可以产生的最终的句法树t和标准句法树$t_G$之间的最小汉明距离，即：<br>\[l(c) = \min_{t|c \to t} \mathcal{L}(t, t_G)\]<br>一个训练正确的Dynamic Oracle应当使得预测的下一个状态$\tau(c)$不会增加损失函数值，即<br>\[l(\tau(c)) - l(c) = 0\]<br>这个最小汉明损失可以定义为$\left| { {t_G}\backslash t} \right| + \left| {t\backslash {t_G}} \right|$，下面就将讨论这两部分怎么计算，主要用到短语的可达性和可分解性。</p><h2 id="短语的可达性"><a href="#短语的可达性" class="headerlink" title="短语的可达性"></a>短语的可达性</h2><p>在这里用短语集合${(X, l, r)}$来表示一棵句法树，我们假设状态c的短语集合为$\sum = [(Y_p, i_p, i_{p-1}) \cdots (Y_2, i_2, i_1)|(Y_1, i_1, j)]$，那么我们说，标准句法树中的一个短语$(X, l, r) \in \gamma_G$当且仅当满足如下三个条件之一时，称它是“各自可达短语”：</p><ul><li>$(X, l, r) \in \gamma_c$（因为短语已经包含在了状态c已生成的短语集合里，那么它当然是可达的）。</li><li>$j \le l &lt; r$（因为短语还在buffer中，所以可以通过不断SHIFT然后REDUCE得到）。</li><li>$l \in \{i_k | 1 \le k \le p\} \wedge j \le r$（这种情况表明了短语的左端点恰好位于栈里某个短语的边界处，而右端点又还在buffer里，所以还可以通过不断SHUFT然后REDUCE得到短语。但是如果左端点不是栈里短语的边界，那说明产生了交叉，自然不会可达了。而如果右端点已经在栈里了，那之后也不会得到了，因为转移系统每次都是REDUCE栈顶的短语，不可能从栈里面开始REDUCE的）。</li></ul><p>枚举标准树中的所有短语，根据以上规则可以得到可达短语集合$\mathcal{R}(c, \gamma_G)$，然后从标准短语集合中排除掉这部分短语，剩下的就是不可达短语集合$\mathcal{U}(c, \gamma_G) = \gamma_G \backslash \mathcal{R}(c, \gamma_G)$。这部分短语就是不论采取何种动作序列，最后都不可能生成的短语集合。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>对于每一个状态c，可以定义它的损失函数为<br>\[l(c) = \min_{\gamma |c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| { \mathcal{U}(c, \gamma_G)} \right| + \left| {\gamma_c \backslash {\gamma_G}} \right|\]<br>其中第一个因子惩罚的是False Negative短语，也就是漏报的短语，即正确的但是不可能被生成的短语。第二个因子惩罚的是False Positive短语，也就是误报的短语，即已经生成的但是是错的短语。</p><h2 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h2><p>那么我们如何证明，按照这个最小的损失函数值走下去，一定能得到最优的句法树呢？也就是要证明，这个状态c的损失函数，的确就是从状态c能得到的最优句法树和标准树的汉明损失。<br>\[\min_{\gamma |c \to \gamma} \mathcal{L}(\gamma, \gamma_G) = \left| { \mathcal{U}(c, \gamma_G)} \right| + \left| {\gamma_c \backslash {\gamma_G}} \right|\]<br>首先证明这个损失函数是<strong>短语可分解</strong>的，也就是证明，对于一个标准树中的短语集合，如果其中的每一个短语都是各自可达的，那么整个集合中的短语可以同时生成。</p><p>证明这个性质要用到数学归纳法。首先$m = 1$时显然成立，然后假设集合元素个数为$m, (m &gt; 1)$时性质成立，下面证明集合T元素个数为$m + 1$时性质也成立。</p><p>令$(X, l, r)$表示集合T中偏序最小的短语，即l是最小的，如果l有相等的，就再取r最小的。根据假设，$(X, l, r)$是从状态c可到达的gold短语。令$T’ = T \backslash (X, l, r)$，所以集合T’有m个元素，根据递归定义，整个集合都是从状态c可达的。</p><p>如果短语的可达性条件中第一种情况满足，那么$(X, l, r)$已经存在于状态c已生成短语集合中了，那么整个T集合当然是可达的。</p><p>如果第二种情况满足，即$j \le l &lt; r$，那么可以通过不断SHIFT再一个REDUCE来得到短语$(X, l, r)$。那么T’集合又如何能全部生成呢？可以发现T’集合中的短语，要么是左边界等于l并且右边界大于r的（根据定义），这种可以继续SHUFT再REDUCE得到（满足条件3）。要么是左边界大于等于r的（因为都是标准树中的短语，所以不会有边界交叉），这种满足条件2，也可达。<strong>论文中就说了这两种情况，是否还存在一种左边界大于等于l，右边界小于等于r的情况呢？当然这种情况满足条件1，因为在生成$(X, l, r)$的时候就已经生成了。</strong>所以最终T集合还是全部可达的。</p><p>如果第三种情况满足，即l是栈里某个短语的边界，而r大于等于j，那么这种情况依然可以通过不断SHIFT再REDUCE得到，而T集合仍然可以全部可达，原因和上一种情况类似。</p><p>所以可以证得，从状态c开始，存在某个转移序列，使得所有可达短语全部生成，那么只有不可达的短语会被错过，即：<br>\[\min_{\gamma |c \to \gamma} \left| {\gamma_G \backslash {\gamma}} \right| = \left| { \mathcal{U}(c, \gamma_G)} \right|\]</p><p>最后一步就是证明另一项$\left| {\gamma \backslash {\gamma_G}} \right|$等于$\left| {\gamma_c \backslash {\gamma_G}} \right|$。首先因为前者肯定包含了后者，因为随着转移的进行，预测错误的短语只会增加，不会减少。然后证明最优句法树不会再增加新的错误短语，即从状态c开始的最优句法树一定是$\mathcal{R}(c, \gamma_G) \cup \left| {\gamma_c \backslash {\gamma_G}} \right|$。这里不是很好想，可以想象从包含当前栈顶短语的最小的标准短语开始，一步步的进行转移，按照<a href="https://www.aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">James and Huang</a>中的Dynamic Oracle。</p><p>至此已经证明了，这个损失函数可以保证每一步都按照最优的策略来进行转移。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验采用的转移模型都是基于<a href="http://aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Dyer et al.</a>，并且也采用了<a href="https://www.aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">James and Huang</a>中的exploration策略来增加错误状态，提高Dynamic Oracle的准确率。</p><p>在PTB上的实验结果如下：<br><img src="3.jpg" alt></p><p>结果其实也不是很高，现在来看算低的了，本文只和其他的转移系统结果进行了比较，可以说在转移系统上还算比较高的吧，虽然今年转移系统也做到了92.0了。在运行速度上，本文的模型也比其他转移系统略有提升，我感觉虽然不需要二叉化了，但是REDUCE#k动作的增加同样会增加复杂度，这是自底向上转移系统的一个固有的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文提出了一个非二叉化的自底向上的转移系统，主要有如下几个贡献点吧：</p><ul><li>非二叉化预测，采用REDUCE#k动作。</li><li>采用损失函数来实现Dynamic Oracle。</li><li>准确率上超过了除了in-order的大多数转移系统。</li><li>训练速度上是所有转移系统中最快的。</li></ul><p>看完这篇，我准备在chart-based的top-down模型上面也搞一个这种Dynamic Oracle试试，需要改变的就是每个状态的损失函数，现在的F1还只有91.87，希望能有所突破吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meta Multi-Task Learning for Sequence Modeling</title>
      <link href="/2018/10/25/metamtl/"/>
      <url>/2018/10/25/metamtl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>这篇文章是知识分析课准备讲的论文，随便拿来看一看了，简单介绍一下吧，论文是复旦邱锡鹏老师组写的。</p></blockquote><p><strong>论文地址：</strong><a href="https://arxiv.org/pdf/1802.08969.pdf" target="_blank" rel="noopener">Meta Multi-Task Learning for Sequence Modeling</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>多任务学习一般的模型是共享特征表示层，也就是最底层的特征表示层是共享的，上层的神经网络都是随具体任务而不同的。但是这有个问题，比如用LSTM对句子进行建模的时候，不同的短语的组合函数是一样的，比如动词+名词、形容词+名词。但是组合函数应该定义成不同的比较好，于是这篇文章提出了针对不同的任务，不同的时刻产生不同的参数矩阵的动态参数生成方法。</p><p>本文主要有如下三个贡献点：</p><ul><li>不同于以往的特征层的共享，本文模型提出了函数层的共享，也就是针对不同任务动态的生成不同的组合函数。</li><li>不仅对于多任务，Meta-LSTM对于单任务也有提升，因为是动态生成参数，所以每个时刻的参数都不一样，可以更好地表示不同的短语语义。</li><li>模型还可以被用作迁移学习，Meta-LSTM在训练完成后可以直接被用于新任务上面作为先验知识，而任务特定的LSTM就作为后验知识。</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>本文主要在序列标注和文本分类两个任务上面做实验，而且是多任务的，序列标注包括NER和POS tagging，文本分类包括多个不同领域的文本分类。</p><h2 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h2><p>传统的多任务模型共享一个私有LSTM特征表示层，用这个私有LSTM学习出句子的表示，然后和词向量拼接共同输入到任务特定的公有LSTM去。具体结构如下图所示：<br><img src="1.jpg" alt><br>输出层每个任务都是不共享的，和一般的模型一样，这里就不介绍了。最终的损失函数为所有任务的损失函数加权之和。</p><p>多任务模型的训练策略如下所示：</p><ul><li>首先随机选择一个任务。</li><li>然后从这个任务的数据集中随机选择一个mini-batch。</li><li>然后用这个任务的mini-batch数据去训练并更新参数。</li><li>不断重复以上三个过程。</li></ul><p>这样就可以训练出一个适用于所有任务的多任务模型。</p><h2 id="元多任务学习"><a href="#元多任务学习" class="headerlink" title="元多任务学习"></a>元多任务学习</h2><p>传统模型只共享了特征表示层，也就是共享了私有LSTM。本文的模型创新就是通过Meta-LSTM动态生成针对每个任务、每个时刻不同的参数，然后用每个任务特定的Basic-LSTM进行编码。具体结构如下图所示：<br><img src="2.jpg" alt><br>其中Basic-LSTM的结构和普通的LSTM基本一样，唯一区别就是每个时刻的参数W和b是通过Meta-LSTM动态生成的，形式化定义如下：<br><img src="3.jpg" alt><br>因为W维度过大，计算复杂度太高，并且也容易导致过拟合，所以这里采用了SVD分解：<br><img src="4.jpg" alt><br>而这里的$z_t$就是通过Meta-LSTM动态生成的，形式化定义如下：<br><img src="5.jpg" alt><br>如果精简的表示出这个LSTM之间的关系，可以写成如下形式：<br><img src="6.jpg" alt><br>概括起来就是：<strong>Basic-LSTM上一个时刻的输出$h_{t - 1}$、Meta-LSTM上一个时刻的输出$\hat h_{t - 1}$和当前时刻的单词表示$x_t$作为Meta-LSTM当前时刻的输入，产生的输出$z_t$用来产生Basic-LSTM当前时刻的参数矩阵。</strong></p><p>Meta-LSTM主要有如下两个优点：</p><ul><li>一个就是每个时刻的参数动态生成。</li><li>另一个就是比普通的LSTM参数数量更少，因为有SVD分解。</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><h2 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h2><p>文本分类任务是在16个购物网站评论数据集上做的，数据集大小如下所示：<br><img src="7.jpg" alt><br>最后在大多数数据集上，Meta-LSTM都能做到最好结果，具体结果如下：<br><img src="8.jpg" alt></p><h2 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h2><hr><p>序列标注任务是在三个数据集上面做的，两个是NER数据集，一个是POS tagging数据集，具体结果如下：<br><img src="9.jpg" alt><br>只能说比最基础的LSTM+CRF模型高了那么一丢丢吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文提出了一种function-level的多任务共享机制，即使用Meta-LSTM来动态产生Basic-LSTM每个时刻的参数矩阵。</p><blockquote><p>看完后我在想，这个动态参数生成的机制能不能用在成分句法分析上面，例如对于top-down的chart-based模型，可以自顶向下通过Tree-LSTM动态产生每一个树结点的参数矩阵，然后用这个参数矩阵来预测结点的label和split。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 迁移学习 </tag>
            
            <tag> AAAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Local Models for Neural Constituent Parsing</title>
      <link href="/2018/10/18/coling18-2localmodels/"/>
      <url>/2018/10/18/coling18-2localmodels/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>我们究竟是活了365天，还是活了1天，重复了364遍。</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/C18-1011" target="_blank" rel="noopener">Two Local Models for Neural Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/zeeeyang/two-local-neural-conparsers" target="_blank" rel="noopener">github</a></p><p>今天要介绍的论文来自COLING 2018，本文主要探讨了局部特征对成分句法分析到底有多大的影响，并同时提出了两种局部特征模型，在PTB上面取得了92.4的F1值。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>对于传统句法分析模型，需要使用大量的全局特征来指导每一步的决策。同时全局的损失函数也是必不可少的，可以用来避免预测偏差的问题，也就是loss mismatch问题。但是随着神经网络的加入，越来越多的模型使用了局部的特征来进行句法分析，主要原因是可以采用双向LSTM预先对句子进行编码，从而捕获全部特征。</p><p>因此本文主要探讨局部特征对句法分析的影响，顺带提出了两个句法分析模型。模型是chart-based的，但是将结构预测和标签预测分成了两个模型，首先通过双仿射模型来产生一棵无标签的句法树，然后再上面跑一遍Tree-LSTM来产生每一个结点的label。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>模型分为两部分，第一部分是无标签模型，用来预测不带label的句法树，第二部分是标签模型，用来在无标签模型预测出来的句法树上预测出每一个结点的label。</p><p>对于无标签模型，有两种方法来生成句法树，第一种叫做span模型，预测任意span是否属于标准树，也就是二分类。第二种叫做rule模型，也就是普通的chart-based方法，类似于CKY算法，预测每个span的得分最高的split。</p><p>对于标签模型，在生成的句法树上跑一遍Tree-LSTM，计算出每个结点的向量表示，这是Encoder部分。然后对于每个结点，运行一遍Decoder，也就是一个LSTM，解码出该结点处的label，如果label只有一个，那么就解码出“X - &lt;\L&gt;”，其中&lt;\L&gt;是结束符，而如果label不止一个，也就是一元产生式，那么就会解码出一系列非终结符。</p><p>下面我们一个个介绍编码和解码模型，我尽量不使用太多的公式来解释模型，一是因为本质上模型也都是很老的了，二是因为公式太多了我也懒得打嘻嘻。</p><h2 id="Span模型"><a href="#Span模型" class="headerlink" title="Span模型"></a>Span模型</h2><p>主要思想就是对于句子的每一个可能的span，预测它是否属于标准树，属于标签就是1，不属于就是0。因为一共有$n(n + 1) / 2$个span，所以时间复杂度为$O(n^2)$。在代码实现中，因为长度为1和长度为n的span一定属于标准树，所以不考虑这两种span。</p><p>模型通过一个双向LSTM来对短语进行编码，这个之前的文章已经说过很多次了，可以用来捕获全局信息。span$(i, j)$的向量表示和之前略有不同，这里不是用两端的差值，而是改用直接拼接得到：<br>\[v[i, j] = [f_{i + 1}; r_i; f_{j + 1}; r_j]\]<br>然后将每个span的表示输入到一个两层的前馈神经网络中，最后通过一个softmax进行二分类：<br>\[\begin{array}{l}o[i,j] = \tanh ({W_o}v[i,j] + {b_o})\\\\u[i,j] = {W_u}o[i,j] + {b_u}\\\\P({Y_{[i,j]}}|S,\Theta ) = softmax(u[i,j])\end{array}\]<br>其中$Y_{[i, j]}$可以取值1或者0，最终要使得正确span标签为1的概率与错误span标签为0的概率之和最高。</p><p>训练完毕之后，在预测阶段，使用CKY算法求解最优的句法树。注意这里不能直接采用$Y_{[i, j]} = 1$概率比较大的那些span组成句法树，因为可能根本就是一棵不合法的句法树。对于span$(i, j)$，它的split为k的概率为：<br>\[P(r|S, \Theta) = P(Y_{[i, k]} = 1|S, \Theta)P(Y_{[k + 1, j]} = 1|S, \Theta)\]</p><p>模型还有个扩展版本，就是在softmax层改二分类为预测每个label的概率。然后损失函数也稍做修改，对于每个标准树中的span，对所有label求和（求和主要针对的是一元产生式的多个label），使概率之和最大。在预测阶段解码时，依然使用CKY算法，只不过span的概率要修改为：$Y_{[i, j]} = 1$的概率为label不为终结符的概率之和，$Y_{[i, j]} = 0$的概率为label是终结符的概率。</p><h2 id="Rule模型"><a href="#Rule模型" class="headerlink" title="Rule模型"></a>Rule模型</h2><p>span模型是训练出每个span属于标准树的概率，然后预测时计算出产生式的概率。而rule模型就直接训练每个产生式的概率，对于span$(i, j)$，假设它的split为k的分数为$ps_k$，那么产生式的概率就为：<br>\[P([i, j] \to [i, k][k + 1, j] | S, \Theta) = \frac{\exp (ps_k)}{\sum\nolimits_{k’ = i}^{j - 1} {\exp (p{s_{k’}})} }\]<br>最终的损失函数就是标准树中所有产生式概率的负对数之和。解码依然使用CKY算法，只是这里产生式概率直接得到了，所以直接计算即可。</p><p>这种方法本质上其实就是用神经网络来拟合PCFG，得到和它类似的效果，最后再用CKY算法解码出句法树。</p><p>而上面的$ps_k$是怎么得到的呢？这里首先还是用双向LSTM的边界差值作为span的表示（我也不知道这里为什么又突然用这个表示了）：<br>\[s[i, j] = [f_{j + 1} - f_i; r_i - r_{j + 1}]\]<br>然后将span之前和span和span之后三部分的表示拼接起来：<br>\[sr[i, j] = [s[0, i - 1]; s[i, j]; s[j + 1, n - 1]]\]<br>然后将它输入到一个单层前馈神经网络：<br>\[r[i, j] = \phi (W_r^M sr[i, j] + b_r^M)\]<br>注意到这里的W和b是分为三种：父结点、左儿子、右儿子。</p><p>然后就是最后一步了，终于可以得到最终的span表示了。。。这里又有两种方法，一种是线性模型，直接对左右儿子的r向量加权求和。另一种是双仿射模型，这个方法也可以解决span长度不一导致的类别数可变的多分类问题，双仿射模型得分首先在父结点和左儿子向量上进行操作：<br>\[lps_k = {[r[i,j];1]^T}{W_{pl}}[r[i,k];1]\]<br>然后在父结点和右儿子向量上进行类似操作得到$rps_k$，最后相加得到最终的split得分：<br>\[ps_k = lps_k + rps_k\]</p><h2 id="标签生成模型"><a href="#标签生成模型" class="headerlink" title="标签生成模型"></a>标签生成模型</h2><p>首先用Tree-LSTM得到每个span的向量表示，然后再通过一个LSTM依次得到span的一个或者若干个label，这个就不详细解释了。</p><h2 id="联合训练"><a href="#联合训练" class="headerlink" title="联合训练"></a>联合训练</h2><p>整个模型总的损失函数是无标签模型损失加上标签生成模型的损失，其中无标签模型分为三种：二分类、多分类、rule模型。</p><p>整个模型的流程如下图所示：<br><img src="1.jpg" alt><br>span模型和rule模型的span得分计算如下图所示：<br><img src="2.jpg" alt></p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>几种模型在PTB上的F1值如下：<br><img src="3.jpg" alt><br>可以看出对于二分类span模型，用$v[i, j]$作为span表示效果最好，而对于rule模型，采用的是双仿射，那么用$sr[i, j]$，也就是拼接上span左右的span效果更好。总体来说，多分类的span模型F1值是最高的。</p><p>而和其他模型的比较如下表所示：<br><img src="4.jpg" alt><br>左侧是多模型融合的结果，右侧是单模型，本文的几个模型结果都是最高的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文模型和变体有点多，其实仔细分析下来可以发现本质上也还是那么些东西，在这里简单总结一下几种模型：<br>首先是结构预测：</p><ul><li>二分类span模型：预测每个span属于标准树的概率，测试阶段使用CKY算法解码，通过span正确的概率计算得到产生式概率。</li><li>多分类span模型：在二分类的基础上，预测每个span是每个label的概率，最后求和得到它属于标准树的概率，测试过程和二分类相同。</li><li>线性组合rule模型：通过split的得分直接预测每个产生式的概率，采用线性组合计算概率，解码采用CKY算法。</li><li>双仿射rule模型：除了概率计算采用双仿射，其他部分和线性组合rule模型完全相同。</li></ul><p>然后是标签预测：<br>都是采用Tree-LSTM产生每个结点的编码，然后创新地使用LSTM来预测label，而不是用传统的label列表。</p><p>这篇论文可借鉴的地方还挺多的，结构和标签分开预测，span特征继续堆叠，双仿射变换等等。准备之后在以往模型上加上去试试，然后可以想想神经网络训练PCFG这类点子，其实本质上和chart-based的没啥大区别。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> COLING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear-Time Constituency Parsing with RNNs and Dynamic Programming</title>
      <link href="/2018/10/15/acl18-beamspanparser/"/>
      <url>/2018/10/15/acl18-beamspanparser/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>好像已经很久没有看论文了呢，开学了一堆事情，以后还是要抽空阅读论文，保持一定的阅读量，并且不能光看最新的论文，还得去前人传统的方法中去寻找有没有能应用于深度学习的东西，说不定就发ACL了呢（手动滑稽）。</p></blockquote><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/P18-2076" target="_blank" rel="noopener">Linear-Time Constituency Parsing with RNNs and Dynamic Programming</a><br><strong>代码地址：</strong><a href="https://github.com/junekihong/beam-span-parser" target="_blank" rel="noopener">github</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这次要介绍的论文是huang liang发表在ACL18的一篇短文，提出了一个基于转移系统的线性时间句法分析器。本文的主要贡献点主要有如下几点：</p><ul><li>传统的基于转移的句法分析模型都是贪心解码，不能考虑到所有的状态空间，所以本文的模型采用beam search将状态空间提升到了指数级别。</li><li>首次采用cube pruning将分析的时间复杂度降低到了$O(nb \log b)$。</li><li>采用max-violation损失函数代替原来的求和的损失函数，并且对cross-span的span进行了惩罚。</li><li>在单模型上取得了最高的F1值。</li><li>采用图结构的栈（GSS）代替了原来的stack，这样不需要时刻保存历史信息。</li></ul><h1 id="模型基础"><a href="#模型基础" class="headerlink" title="模型基础"></a>模型基础</h1><hr><h2 id="基于span的转移系统"><a href="#基于span的转移系统" class="headerlink" title="基于span的转移系统"></a>基于span的转移系统</h2><p>这个我已经在之前的文章<a href="https://godweiyang.com/2018/09/26/constituent-parsing-summary/#系统改进">成分句法分析综述</a>中详细阐述过了。核心思想就是stack里面保存的不再是短语结构树，而是span的左右边界下标$(i, j)$，初始时stack里面是$(0, 0)$，终止状态栈里是$(0, n)$，SHIFT之后栈顶变为$(j, j + 1)$，REDUCE之后栈顶变为$(k, j)$（假设之前栈顶两个元素是$(k, i)$和$(i, j)$）。</p><h2 id="Bi-LSTM特征"><a href="#Bi-LSTM特征" class="headerlink" title="Bi-LSTM特征"></a>Bi-LSTM特征</h2><p>状态转移时用双向LSTM两端的差值计算每个span的表示，然后计算出得分，用来预测action。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr><h2 id="句法树得分"><a href="#句法树得分" class="headerlink" title="句法树得分"></a>句法树得分</h2><p>还是和之前chart-based模型一样，用每个span的label得分之和作为句法树的总得分。</p><h2 id="图结构栈（Graph-Struct-Stack-GSS）"><a href="#图结构栈（Graph-Struct-Stack-GSS）" class="headerlink" title="图结构栈（Graph-Struct Stack, GSS）"></a>图结构栈（Graph-Struct Stack, GSS）</h2><p>因为要采用动态规划来枚举每个时刻所有的状态，不是用普通的stack，使用GSS来保存每个时刻的状态。GSS每个时刻只需要保存栈顶的span就行了，假设为$(i, j)$。如果action是SHIFT，那么下一步就变成了$(j, j + 1)$，如果action是REDUCE，那么还需要知道栈顶第二个元素是什么。因为考虑到了所有的状态空间，所以所有的$(k, i)$都是有可能的。</p><p>GSS的具体结构如下图所示：<br><img src="1.jpg" alt><br>每个时刻的状态仅用一个span表示，在具体实现的时候，每个span还保存了一个span指针数组，指向它前面所有可能的span，还保存了当前span以及之前所有span的分数之和$c$和当前span子树的分数之和$v$。每个状态还保存了一个时刻标记$l$，易知一共有$2n - 1$个时刻。</p><p>当采取SHIFT动作时，状态变为了$(j, j + 1)$，并且新的span$(j, j + 1)$的指针数组中新增加一个span也就是$(i, j)$。prefix分数变为$c + \xi$，其中$\xi$是span$(j, j + 1)$的最高label得分，而inside分数就是span$(j, j + 1)$的分数$\xi$。</p><p>当采取REDUCE动作时，枚举span$(i, j)$指针数组中所有的前一个span$(k, i)$，然后合并成一个span$(k, j)$，prefix分数变为$c’ + v + \sigma$，其中$\sigma$就是span$(k, j)$的最高label得分，inside分数变为了$v’ + v + \sigma$。实际代码实现中，REDUCE完了后，span$(k, j)$的指针数组要更新为span$(k, i)$的指针数组。</p><h2 id="Beam-Search和Cube-Pruning"><a href="#Beam-Search和Cube-Pruning" class="headerlink" title="Beam Search和Cube Pruning"></a>Beam Search和Cube Pruning</h2><p>在每个时刻，只保存prefix得分最高的前b个span状态，这样时间复杂度可以降为$nb^2$，但是$b^2$相对于句子长度来说还是太大了，所以采用cube pruning继续降到$nb \log b$。</p><p>cube pruning原理是这样的：普通的beam search每个时刻枚举至多b个span，每个span和之前的至多b个span结合，所以一共最多产生$b^2$个span。</p><p>而cube pruning在每个时刻都建立一个堆，首先用上一个时刻的beam里的b个span，来产生b个SHIFT的span，送入堆里。理论上来说还应该产生至多$b^2$个REDUCE的span，但是在这里对于每个span，只取它的指针数组里得分最高的那个span，来和它结合产生新的span，送入堆里。然后在产生好的堆里，每次取出得分最高的span，出堆，如果它是REDUCE得到的span，那么就继续按照它的指针数组得分从高到低顺序产生一个span，REDUCE完之后送入堆里。依次下去，直到出栈了b个span为止。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><hr><p>还是使用max-margin loss来训练，但是有几点小小的改进。</p><h2 id="cross-span损失"><a href="#cross-span损失" class="headerlink" title="cross-span损失"></a>cross-span损失</h2><p>以往的损失函数里有个$\Delta (t,t’)$，衡量的是预测树和标准树不同的span的数量。但是这有个问题，因为用了隐式二叉化，所以在预测树里存在label为空的情况。如果这个span在标准树中label也是空，那么原来的损失就不惩罚这一项了，但是要考虑到如果这个span在标准树中与某个标准的span产生了交叉，那么它根本就不可能是对的，也得进行惩罚。</p><h2 id="max-violation-updates"><a href="#max-violation-updates" class="headerlink" title="max violation updates"></a>max violation updates</h2><p>这是huang liang在2012提出来的，其实就是计算出每个时刻预测得分和标准得分的差距，然后取差距最大的那个时刻的得分差距作为最终的损失函数，之前都是用每个时刻得分差距之和来作为损失函数的。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>下图是不同的beam大小对不同长度句子分析速度的影响：<br><img src="2.jpg" alt><br>最终综合考虑速度和准确率，选择beam大小为20。</p><p>最后是beam-span模型在PTB测试集上的准确率，在单模型上取得了最好的结果：<br><img src="3.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这篇论文是短论文，所以相比之下创新没有那么的大吧，主要还是速度上比chart-based有了提升，准确率上比普通的转移系统有了提升，另外还提出了几点小的改进吧，例如cross-span问题、max-violation损失之类的，转移系统也改成了适合用来进行beam search的GSS，为了进一步加快速度，还用了cube剪枝。</p><p>这么多改进其实个人感觉也是影响不大的，不是很通用，cross-span和max-violation损失可以考虑拿来用一下。下一步的工作还是考虑如何增加特征表示、加入头结点之类的吧。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给python新手的一些建议</title>
      <link href="/2018/10/11/python-advice/"/>
      <url>/2018/10/11/python-advice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>首先很荣幸被邀请给大一新入学的学弟学妹们谈谈编程入门经验，尤其是他们正在学的python语言。我就随便谈谈我大一时是如何编程入门的，以及怎么才能学好python编程，其他语言类似，都是相通的。最后再回答一下大家问的比较多的一些问题。</p></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><hr><p>大多数人应该和我刚上大学时一样，完全没有接触过编程，所以在上python课的时候可能是一脸懵逼，完全不知道代码的原理是什么，为什么写出来就能运行，也不知道如何熟练地写出一段完整的代码。这都很正常，我大学之前也是对计算机一窍不通的，但是高中毕业的那个暑假，刚刚接触电脑、用上互联网的我，用了一个月自学了谭浩强的《C语言程序设计》，从此打开了新世界的大门。因此我下面结合我自身的经历给大家一些编程学习的经验，当然很多都要结合你自身的喜好和习惯，不用完全按我的来。</p><h1 id="一个称手的代码编辑器"><a href="#一个称手的代码编辑器" class="headerlink" title="一个称手的代码编辑器"></a>一个称手的代码编辑器</h1><hr><p>要想代码写的舒服，首先得用一个称手的代码编辑器，最常用的python IDE是pycharm，如果你刚入门很依赖调试的话，可以使用这款IDE。当然不能过于依赖IDE的调试功能，要练就肉眼调试的本领，这样能极大的提高你的代码能力。所以我熟练了之后换上了sublime代码编辑器，这是一款十分漂亮的编辑器，个人觉得比pycharm好看到不知哪里去了。而具体的安装与python环境配置，去看看我的教程就行了：<a href="https://godweiyang.com/2017/10/02/sublime/">Sublime Text安装与配置教程</a>。</p><h1 id="多练-gt-多看"><a href="#多练-gt-多看" class="headerlink" title="多练&gt;多看"></a>多练&gt;多看</h1><hr><p>很多人还以为和高中一样，上课听听就完事了，课后也就不花时间去写代码了。其实不然，要想学好python，光课上听是没什么用的，还需要课后不停的找题目练习，只有试了才知道自己可能会踩到什么坑，才能不断总结出许多代码编写的经验。我刚开始也是一个劲看书，觉得语法都看的差不多了，以为自己都懂了，但是真正自己写起来才发现有很多的问题。</p><p>课本首先得看熟了，上面的例子都要自己敲过去，还有布置的编程作业都得认真做完。推荐大家一个在线编程网站：<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">Python 基础教程 | 菜鸟教程</a>，上面可以边学边练习，可以一定程度上提高你的学习积极性。</p><h1 id="善于使用EOJ"><a href="#善于使用EOJ" class="headerlink" title="善于使用EOJ"></a>善于使用EOJ</h1><hr><p>有很多同学学到最后都不知道有EOJ这个东西，这是我们学校的在线刷题网站，现在已经做得十分精美了。如果让你干巴巴的去写书上的代码，可能没多久你也没什么兴趣写了，但是如果让你用python做出来一道道的编程题，那么依旧会获得难以描述的快感，这能极大的提升你的积极性和代码能力。</p><p>首先去<a href="http://acm.ecnu.edu.cn/" target="_blank" rel="noopener">EOJ</a>注册一个账号，然后去做过的人多的简单题，很多题首先考察的不是代码能力，而是你的算法，下面我还会讲到算法的重要性。做题需要注意输入输出格式，注意题目中的各种坑点，代码不是自然语言，和数学题一样容不得半点差错。</p><h1 id="程序-算法-数据结构"><a href="#程序-算法-数据结构" class="headerlink" title="程序=算法+数据结构"></a>程序=算法+数据结构</h1><hr><p>光会写几行代码没用，还要学会使用基本的数据结构和算法，这样才能写出高效率高质量的代码。比如python中的列表<code>list</code>、元组<code>tuple</code>、字典<code>dict</code>等等，熟练使用它们将会大大减轻你的工作量。算法也是非常重要的，比如要对若干个数进行排序，如果暴力的话速度会很慢很慢，这时候你就要学会用快速排序算法，就能立即得到结果啦。</p><h1 id="学会查阅资料"><a href="#学会查阅资料" class="headerlink" title="学会查阅资料"></a>学会查阅资料</h1><hr><p>很多人遇到什么函数不会用了，使用报错了都不知道怎么办，到处问人，其实可以直接去<a href="https://docs.python.org/3/" target="_blank" rel="noopener">python官网</a>查看文档，里面都有各个函数的用法说明。遇到错误也可以百度错误内容，会有很多人写博客说明解决方法的，实在找不到推荐一个网站：<a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>，这是国外的一个问答网站，上面有超多编程相关问题，只要你提问了基本都有人替你解答。</p><h1 id="良好的编码风格"><a href="#良好的编码风格" class="headerlink" title="良好的编码风格"></a>良好的编码风格</h1><hr><p>很多同学刚开始写的代码风格都很丑，我自己也是，要尽快形成自己的代码风格，python相比c语言好很多，强制了缩进，不然编译都不给你通过，但是还是有很多地方需要你自己注意，比如表达式运算符两边要加空格、变量命名要可以直接看出用途等等。推荐大家去读一读google的<a href="https://www.runoob.com/w3cnote/google-python-styleguide.html" target="_blank" rel="noopener">python编程规范</a>，写出美观的代码，以后也便于维护。</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><hr><ul><li><p><strong>Q: python相对于其他语言有哪些优势和区别？</strong></p></li><li><p><em>A:*</em> 首先python语言最大的优势就是简单，非常适合没有编程基础的人入门，它去除了c语言繁琐的指针类型，而且代码也很容易读懂，与人类语言有点类似。python也支持面向对象，并且不像c++和java那样繁琐，保持了它的简洁性。因为它是开源的，所以有很多很多的第三方库可以调用，很多功能根本不需要你自己动手写，别人都帮你写好封装好了，你直接调用一个函数就解决了。但是python也有缺点，一大缺点就是相比于c++和java这种较为底层的语言，python的运行速度非常慢，当然可以选择使用cython来加速python。并且python的格式要求非常严格，强制代码缩进，两条语句不能写在同一行等等。</p></li><li><p><strong>Q: 老师上课提到“面向对象”和“面向过程”，是什么意思？</strong></p></li><li><p><em>A:*</em> 简单来说，面向过程就是按照解决问题的顺序，一步步的编写代码、调用函数。而面向对象就是将你要处理的事物分解为一个个对象（也就是类），每个对象有很多属性，编写代码时只要生成这些类，并且调用它们的类方法就好了。面向对象的一大好处就是可维护性好，比如如果你要对两个相同的对象进行操作，如果用面向过程，那你就要写两段相同的代码，如果改了一段，还得同时修改另一段；而面向对象就很简单了，因为你的两个对象都封装在了一个类里，所以只要改一下类就好啦。</p></li><li><p><strong>Q: 拿到一个问题应该如何思考？如何解决？步骤是什么？</strong></p></li><li><p><em>A:*</em> 拿到一个问题（比如编程题），不要直接下手写代码，先想想该用什么方法解决？方法的时间复杂度和空间复杂度能否承受？要用到哪些函数？总体框架应该写成什么样子？然后再一个个模块编写，不要写一步想一步。</p></li><li><p><strong>Q: 什么是递归思维？有什么好处？</strong></p></li><li><p><em>A:*</em> 递归思想也就是递归算法是经常用到的一种算法，可以将规模很大的问题化解为一个个的小问题，便于求解也增加了可读性。举个例子吧，求解阶乘，常规方法是从$f(1)$开始逐项计算，而用递归思想就是要计算$f(n)$，就先计算出$f(n - 1)$然后乘以$n$，而$f(n - 1)$继续递归算下去就行了。</p></li><li><p><strong>Q: 对于萌新，基础薄弱，学长有什么好的方法？推荐一下有用的参考资料</strong></p></li><li><p><em>A:*</em> 基础薄弱那就先把书上的语法看懂了，边看边敲了自己试一试怎么用，不要光看不写。资料的话看再多不如自己敲来的记忆深刻，推荐《python简明教程》吧，最方便的还是不会的用法直接百度或者谷歌，看博客讲解。</p></li><li><p><strong>Q: 如何避免语法符号规范的错误？</strong></p></li><li><p><em>A:*</em> 语法错误很正常，我也经常遇到，特别是没怎么用过的函数，这个只能靠查文档，然后用多了自然就记得怎么用了。规范之类的上面说过了，去看google的python编码规范，养成一个好的编码习惯，既是为了别人能看懂你的代码，也是为了你自己今后还能看懂你自己的代码。</p></li><li><p><strong>Q: 如何判断什么时候该用什么函数？</strong></p></li><li><p><em>A:*</em> 这个就根据你要实现的功能啊，比如你要切分一个句子变成若干个单词，那么自然而然想到要用<code>string.split()</code>函数。当然刚开始你可能根本就不知道有哪些函数可以给你用，那么你就需要百度“python切分一个句子变成若干个单词”，然后就会告诉你要用什么方法了，多查多记以后就会用了。</p></li><li><p><strong>Q: OJ系统是什么？我们如何利用它？</strong></p></li><li><p><em>A:*</em> OJ全称是Online Judge，是一个在线评测系统，上面有很多很多编程题，你可以写代码实现它，然后提交给OJ运行，它会告诉你你的代码是否正确。大家可以利用我们学校自己的EOJ来进行编程训练，先从简单的题开始做起，记住，不要一遇到不会做的题就去百度找题解，一定要自己思考，自己想出了方法收获才是最大的，切记。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成分句法分析综述</title>
      <link href="/2018/09/26/constituent-parsing-summary/"/>
      <url>/2018/09/26/constituent-parsing-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>本文不再更新，请移步最新第二版综述。</strong><br><a href="https://godweiyang.com/2018/09/26/con-parsing-summary-v2/">成分句法分析综述（第二版）</a></p><blockquote><p>一直以来想对保研到现在一年多看过的论文进行一个总结，正好赶上下周二要讲组会，所以将自己看过的成分句法分析相关的论文梳理一下，写一个粗略的综述。可能有很多细节还不是很懂，理解有误，还请大家指正。</p></blockquote><p><strong>PPT地址：</strong><a href="https://github.com/godweiyang/files-backup/tree/master/lecture/ppt1" target="_blank" rel="noopener">A Summary of Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/godweiyang/ConstituentParsing" target="_blank" rel="noopener">Constituent Parsing</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>成分句法分析（constituent parsing）是自然语言处理中的一个基础任务，它的任务是给定一个句子，分析出句子的短语结构句法树。例如给定句子“The little boy likes red tomatoes .”，它的成分句法树如下图所示：<br><img src="syntactic_tree.png" alt><br>成分句法分析可以利用到许多下游任务中去，比如情感分析可以利用句子的成分句法树来进行递归神经网络建模，从而分析出句子的情感。也可以利用在其他基础任务中去，比如可以将训练好的成分句法树直接转为依存句法树，从而提升依存句法分析的准确率。</p><p>传统的成分句法分析方法主要是规则（grammar）和统计的，比如结合两者的概率上下文无关文法（PCFG），在此基础上产生了应用广泛的CKY解码算法。CKY算法本质上是一种动态规划算法，本文之后要讲到的chart-based模型的解码算法也是基于动态规划算法的，和CKY算法十分地相似。</p><p>Socher在2013年又提出了组合向量文法（CVG），将递归神经网络应用到了成分句法分析中，给每个短语结构赋予了向量表示。但是这种方法还是需要用到规则，采用CKY算法解码，时间效率比较低。还有一种基于CRF的神经网络句法分析方法，将离散的特征转化为了连续的特征表示。</p><p>不过，上面这些方法统统都不在本文的讨论范围之内。本文讨论近两年来研究最热门的几种模型，主要包括基于转移系统（transition-based）的模型、基于动态规划（chart-based）解码的模型、基于自顶向下贪心（greedy top-down）解码的模型和一些将预测树结构转化为预测序列（sequence to sequence）的模型。</p><h1 id="基于转移系统的模型"><a href="#基于转移系统的模型" class="headerlink" title="基于转移系统的模型"></a>基于转移系统的模型</h1><hr><p>基于转移系统的模型主要分为三大类。第一种是自底向上（bottom-up）的系统，代表性论文有Transition-based Neural Constituent Parsing等。第二种是自顶向下（top-down）的系统，代表性论文有Recurrent Neural Network Grammars和Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles等。最后一种是2017年提出的基于中序遍历（in-order）的系统，代表性论文有In-Order Transition-based Constituent Parsing等。</p><p>在这三类系统的基础之上，许多人又做了非常多的改进。例如提出了动态指导（dynamic oracle）技术，来解决序列预测中的exposure bias问题（具体含义之后会讲到）。还有使用强化学习中的policy gradient来代替dynamic oracle，解决了针对不同转移系统需要设计不同的dynamic oracle的问题。</p><p>基于转移的句法分析系统主要包含两个组成成分，一个是栈（stack），用来存放已分析的句法结构，另一个是缓存（buffer），用来存放待分析的句子。而预测句法树结构就转化为了预测转移系统每一个时刻应该采取的动作（action）序列。下面我们分别介绍几种不同的转移系统，我们用三元组$[S, B, T]$来表示转移系统每一个时刻的状态，分别代表栈、buffer的第一个单词下标、句法分析结束标志。</p><h2 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h2><p>自底向上的转移系统是根据句法树的后序遍历（post-order）顺序进行句法分析的，首先将buffer中的单词移进栈里，然后将栈顶的若干个单词归约为它们的父结点，直至最后buffer为空并且栈里只有一个根节点。</p><p>在句法分析之前，首先要对句法树进行二叉化，这一点在传统的CKY算法中也会用到。例如对于之前的那棵句法树，二叉化后就变成了下图所示：<br><img src="binarized_syntactic_tree.png" alt></p><p>自底向上转移系统的action形式化定义如下：<br><img src="bottom_up.jpg" alt><br>其中SHIFT动作就是将buffer里面的第一个单词移进栈里。REDUCE-L/R-X动作就是将栈顶的两个元素出栈，并且归约为它们的父结点X，然后再将父结点入栈，而L和R就是用来区分左儿子和右儿子谁是头结点（head branch）。Unary-X动作就是将栈顶元素出栈，并且归约为父结点X，这个动作是用来预测一元产生式的。最后FINISH动作用来判断句法分析是否结束。</p><p>注意到这里有一个问题：为什么这里一定要提前对句法树进行二叉化？主要原因是因为自底向上系统有个弊端，就是在不停地SHIFT之后，你不仅要预测哪一步开始REDUCE，还得预测REDUCE的话要REDUCE栈顶的多少个元素，这样预测的状态数就大大增加，导致训练时间也增加了许多。而二叉化后每次预测就只需要预测哪一步REDUCE就行了，每次REDUCE只REDUCE栈顶的两个元素。</p><p>对于上面的句法树，用自底向上系统分析的过程如下图所示：<br><img src="bottom_up_example.jpg" alt><br>自底向上转移系统的优点就是可以充分利用已经生成的子树信息，来辅助后面的子树预测。</p><p>但是缺点也很显然，因为无法知道父结点以及再上层的父结点信息，所以丢失了许多有用的全局信息，这也有点类似于CKY算法的弊端了，同样只能根据局部的子树信息预测当前子树。</p><p>另一个缺点就是需要提前进行二叉化，虽然二叉化加入了head结点信息，事实证明是很有用的，但是head结点的标注需要许多语义学知识，也可以用神经网络来自己学习到head结点，但是二叉化总归是比较麻烦的。一个较为简洁的做法就是，用空结点$\emptyset$来作为本不应该归约的两个结点的临时结点，在还原树结构的时候忽略这种空结点，这样就可以隐式地进行二叉化操作了。</p><h2 id="自顶向下的转移系统"><a href="#自顶向下的转移系统" class="headerlink" title="自顶向下的转移系统"></a>自顶向下的转移系统</h2><p>自顶向下的转移系统利用的是句法树的前序遍历（pre-order）序列，首先将父结点入栈，然后不断操作直到它的子结点全部入栈，这时将父结点连同所有子结点全部归约为上一层的父结点。</p><p>自顶向下转移系统的action形式化定义如下：<br><img src="top_down.jpg" alt><br>其中SHIFT动作和之前一样，都是将buffer的第一个单词入栈。而NT-X动作就是将父结点X入栈。REDUCE动作就是将栈顶若干个元素直到它们的第一个父结点为止都出栈，然后归约为一个结点，再次入栈。注意到这里不同于自底向上系统的地方是没有FINISH动作，笔者也没有找到相关解释，猜测可能是因为自底向上系统存在一元动作Unary-X，所以最后根节点可能会无限归约下去，需要通过FINISH来提前终止分析。当然其实转移系统的动作定义并没有严格的要求，不同论文定义的也都不一样，但是都大同小异，也就是都存在SHIFT-REDUCE动作。</p><p>对于上面的句法树，用自顶向下系统分析的过程如下图所示：<br><img src="top_down_example.jpg" alt></p><p>自顶向下系统的优缺点和自底向上系统恰好互补。优点就是可以充分利用全局信息，例如父结点的信息，并且不需要进行二叉化，因为REDUCE的时候只要往栈里找到第一个父结点就行了。而缺点就是无法利用局部信息，也就是子树信息，同样NT-X动作也可能会出现无限多次执行的情况，所以要加上一些限制条件。</p><h2 id="In-order转移系统"><a href="#In-order转移系统" class="headerlink" title="In-order转移系统"></a>In-order转移系统</h2><p>Zhang和Liu两人在2017年提出了in-order转移系统，它利用的是句法树的中序遍历（in-order）序列，首先将一个子结点SHIFT入栈，然后将父结点入栈，再不断操作直到该父结点的剩余子结点全部入栈，然后对它们进行归约。</p><p>in-order转移系统的action形式化定义如下：<br><img src="in_order.jpg" alt><br>其中SHIFT动作和之前一样，都是将buffer的第一个单词入栈。PJ-X动作是预测出当前栈顶的元素的父结点X。REDUCE动作就是将栈顶的若干个元素归约为最里面倒数第二个元素，也就是它们的父结点。</p><p>对于上面的句法树，用in-order系统分析的过程如下图所示：<br><img src="in_order_example.jpg" alt></p><p>in-order转移系统提出的动机也很符合人类的直觉，在你读一个句子的时候，如果你第一个看到的单词是“The”，那么你脑海中可能会想到后面紧跟着的可能是个名词短语NP，然后你继续往后看，果然验证了你的猜想，后面的单词序列是“red tomatoes”。</p><p>in-order转移系统的优点恰好结合了前面两种转移系统，既可以考虑到局部信息，又可以考虑到全局信息。</p><p><strong>模型变体：</strong>in-order系统就是在自顶向下系统的基础上，在父结点入栈之前先入栈了1个子结点。那么如果稍加修改，还可以提前入栈两个、三个等等。假设在父结点入栈之前先入栈了$k$个子结点，那么称这种转移系统为k-in-order系统。特别地，如果$k = 0$，那么这就是自顶向下转移系统；如果$k = 1$，那么这就是in-order转移系统；$k = \infty$，那么这就是自底向上转移系统。</p><h2 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h2><p>上面说到的三种基于转移的句法分析系统，都可以概括为预测每一个时刻的action，那么每一个时刻的状态如何表示就是最重要的问题。在每一个时刻，最重要的组成部分有三个，分别是当前栈的状态、当前buffer的状态、当前已生成的action序列的状态。</p><p>当前状态的表示通过下图所示的三个LSTM得到：<br><img src="transition_framework.png" alt><br>其中栈和buffer的编码使用的是stack-LSTM，而action的编码使用的是普通的LSTM。最后将三种LSTM输出拼接到一起，用softmax预测出正确的action。</p><p>另一个问题就是如何编码栈里的短语。在以前都是通过递归神经网络或者树状LSTM来编码树状结构短语的，而在这里的话直接将父结点和子结点合为一个序列，送入到双向LSTM中就行了，具体形式如下图所示：<br><img src="composition.png" alt></p><h2 id="系统改进"><a href="#系统改进" class="headerlink" title="系统改进"></a>系统改进</h2><p><strong>基于span的自底向上的转移系统</strong><br>黄亮在2016年论文里提出了转移系统的栈里用span的左右边界数值来代替分析出来的子树，并且将REDUCE动作和预测label分开来进行，他们的转移系统action形式化定义如下：<br><img src="span_based_bottom_up.png" alt><br>可以看出，在第偶数个时刻，只预测结构化动作sh和comb(对应于之前转移系统的SHIFT和REDUCE)，sh动作从buffer中移进栈里一个单词$w_{j+1}$，栈顶的span就变为了$span(j, j+1)$。而comb动作就是将栈顶的两个span归约为一个span。在第奇数个时刻，只预测栈顶span的label，如果这个span的确能构成一个短语，那么就预测它的label，否则的话说明只是个临时结点，就预测为空结点，这一点在之前就已经提到过了。</p><p>论文里给出了一个具体的例子：<br><img src="span_based_bottom_up_tree.png" alt><br><img src="span_based_bottom_up_example.png" alt></p><p>文章开头提供的代码也是基于这个转移系统的，一个好处是用span来表示的话比较方便，代码也好写。另一个好处就是每一个时刻的状态可以不再用三个LSTM动态地算出来了，而是可以提前用双向LSTM对句子进行编码，然后用两个单词输出的差值作为单词之间span的表示，最后用它来计算转移状态的向量表示。</p><p>例如在某个时刻，栈首元素为$(i, k, j)$，那么结构化预测就采用四个span特征：$span(0, i), span(i, k), span(k, j), span(j, n)$，为什么要用这四个呢？因为comb动作涉及到栈首的两个span，而之前已经生成的$span(0, i)$也可以作为局部信息指导预测，buffer中的$span(j, n)$也要考虑到，因为可能预测为sh动作，同时也可以作为全局信息参考。</p><p>而label预测就只要用到三个span特征：$span(0, k), span(k, j), span(j, n)$，因为label动作只需要对栈首的span进行预测，所以三个特征就足够了。</p><p><strong>生成模型RNNG</strong><br>RNNG是2016年提出的一种文法，全称叫做“Recurrent Neural Network Grammar”，是一种生成式模型。RNNG本质上就是自顶向下的转移系统，动作定义和之前介绍的基本一致。只是之前介绍的自顶向下的转移系统是判别式模型，每次SHIFT的单词都是buffer中给定的。而RNNG每次SHIFT的单词需要通过动作GEN(x)预测得出，最终模型对预测出来的句子分析出句法树。</p><p>正式一点就是，对于句子$x$和对应的句法树$y$，判别式模型是对条件概率$p(y | x)$进行建模，而生成式模型是对联合概率$p(x, y)$进行建模。</p><p>而RNNG的另一个重要应用是语言模型（language model），也就是建模$p(x)$。因为$p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}$，所以只需要枚举出所有可能的句法树$y$即可，但是这是指数级别的，显然不现实，这时候就需要用到“重要性采样（importance sampling）”。</p><p>令$q(y | x)$为RNNG作为判别式模型的时候产生句子$y$的条件概率，那么$p(x)$可以改写为<br>\[p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}  = \sum\nolimits_{y \in \mathcal{Y}(x)} {q(y|x)w(x,y)}  = {E_{q(y|x)}}w(x,y)\]<br>然后就可以采用蒙特卡罗方法进行采样了，从分布$q(y | x)$中采样$N$个样本：<br>\[{y^{(i)}} \sim q(y|x),i = 1,2, \ldots ,N\]<br>那么$p(x)$就可以近似表示为：<br>\[p(x) = {E_{q(y|x)}}w(x,y)\mathop  \approx \limits^{MC} \frac{1}{N}\sum\limits_{i = 1}^N {w(x,{y^{(i)}})} \]</p><p><strong>Dynamic Oracle</strong><br>文章开头提到了一个转移系统会遇到的问题：“exposure bias问题”，这个问题意思就是训练的时候转移系统的每个时刻都是按照标准的action来进行训练的，但是如果测试的时候遇到了一个训练时从来没有遇见过的状态，这时候该怎么预测？如果预测错了，那么之后的时刻可能错的越来越离谱，偏差越来越大。</p><p>解决的方法就是采用Dynamic Oracle技术，在预测错误的时候，按照标准树的结构指导转移系统向着错误尽可能小的状态进行转移。但是比较麻烦的是，对于每一个转移系统，可能大家定义的状态都不尽相同，所以Dynamic Oracle要针对特定的转移系统单独设计，一个解决方法就是之后要提到的Policy Gradient方法。</p><p>这里举一个针对上面的“基于span的自底向上的转移系统”的Dynamic Oracle例子。</p><p>首先是结构化oracle，如果当前的栈首span是$span(i, j)$，那么就在标准树中寻找所有包含$span(i, j)$并且最小的span，记为$span(p, q)$，那么下一步可以采取的动作定义如下：<br><img src="structural_oracle.png" alt><br>也就是说，如果$span(p, q)$比$span(i, j)$右边界多出一部分，那么为了向着标准span靠近，就只能sh单词入栈；否则如果左边界多出一部分，那么就必须先comb之前的两个span，扩大span左边的边界；否则的话左右两边都有空出，那就随机预测一个动作就行了。</p><p>然后是label oracle，这个就很简单了，如果当前的栈首span是$span(i, j)$，只需要在标准树中寻找是否存在$span(i, j)$，如果存在，那么就给他正常预测label就行了；如果不存在，那么直接预测为空结点。oracle定义如下:<br><img src="label_oracle.png" alt><br>而关于这个Dynamic Oracle的证明和更加深入的理解，参见我之前写过的一篇博客：<a href="https://godweiyang.com/2018/08/03/dynamic-oracles/">深入理解成分句法分析中的Dynamic Oracle</a>。</p><p>但是如果直接按照这个Dynamic Oracle来实现代码的话，效果不会有什么提升，原因就是训练的时候遇到的错误情形还是太少了，不足以应付所有的测试阶段遇到的未知情形。所以要在训练阶段加上exploration操作，也就是转移的每一个时刻，不要总是预测概率最大的action，而是以一定的概率随机选择一个action，诱导系统进入一个错误的状态，这样系统就能学到更多错误状态下的回正技巧了。</p><p><strong>Policy Gradient</strong><br>序列预测存在着两个问题：一个就是之前提到的exposure bias问题，另一个就是loss mismatch问题，意思就是在每一个状态的loss累和得到最终整个序列的loss，但是因为是贪心解码，并没有考虑到之后的结果，所以某一个状态的loss其实并不能代表整个序列的loss。</p><p>Dynamic Oracle可以解决第一个问题，如果修改一下也可以解决第二个问题，但是Dynamic Oracle需要针对特定的转移系统单独设计，不能通用，所以这里引入了强化学习中的Policy Gradient来解决这个问题。</p><p>首先用风险函数（risk objective）代替原来的损失函数：<br>\[\mathcal{R}(\theta ) = \sum\limits_{i = 1}^N {\sum\limits_y {p(y|{x^{(i)}};\theta )\Delta (y,{y^{(i)}})} } \]<br>其中$(x^{(i)}, y^{(i)})$是训练集中的标准数据。可以看出，风险函数其实就是所有可能的句法树和标准树的差异${\Delta (y,{y^{(i)}})}$的期望，训练的目的就是最小化所有句法树和标准树的差异，这样就消除了之前提到的两个问题。</p><p>但是可以发现，显然不可能枚举所有可能的句法树，这时候想到了之前用到的重要性采样方法。</p><p>但是不能直接对风险函数进行重要性采样，不然就会发现采样后的函数$\theta$消失了！那就没办法求导了。所以先对风险函数求导：<br>\[\begin{array}{l}\nabla \mathcal{R}(\theta ) = \sum\limits_{i = 1}^N {\sum\limits_y {p(y|{x^{(i)}})\Delta (y,{y^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )} } \\ \approx \sum\limits_{i = 1}^N {\sum\limits_{y \in \mathcal{Y}({x^{(i)}})} {\Delta (y,{y^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )} } \end{array}\]<br>这里的$y$是根据分布${p(y|{x^{(i)}})}$采样得到的结果。实验中可以将标准树也加入到采样结果中，可以提升准确率。<br>至于$\log$项是怎么来的，可以如下推导得来：<br>\[\nabla p(y|{x^{(i)}};\theta ) = p(y|{x^{(i)}})\frac{ {\nabla p(y|{x^{(i)}};\theta )}}{ {p(y|{x^{(i)}};\theta )}} = p(y|{x^{(i)}})\nabla \log p(y|{x^{(i)}};\theta )\]</p><h1 id="编码解码模型"><a href="#编码解码模型" class="headerlink" title="编码解码模型"></a>编码解码模型</h1><hr><p>上面介绍完了基于转移的句法分析系统，下面开始介绍编码解码（Encoder-Decoder）模型。</p><p>模型的大致框架如下图所示：<br><img src="chart_based.png" alt><br>首先通过编码器将句子编码成向量，然后用解码器对向量操作，解码出句法树。</p><h2 id="编码器（Encoder）"><a href="#编码器（Encoder）" class="headerlink" title="编码器（Encoder）"></a>编码器（Encoder）</h2><p>编码器的主要目的是将每个短语编码成语义向量，用来给解码器预测splits和labels。</p><p>编码器主要有两种，一种是简单的双向LSTM编码，下图是一个用双向LSTM对句子进行编码的示例：<br><img src="bi_lstm.jpg" alt><br>例如要编码“played soccer in”这个短语，那么就用“in”处的前向LSTM输出减去“She”处的前向LSTM输出，得到了短语的前向LSTM表示。类似的，用“played”处的反向LSTM输出减去“the”处的反向LSTM输出，得到了短语的反向LSTM表示。</p><p>另一种是multi-headed self-attention编码。Attention是谷歌在“Attention is all you need”中提出的一种方法，严格来说它并不能算作一种模型，只能说是一种机制。具体原理在这里就不细讲了，可以直接去看一下原文。</p><p>大体框架就是，每个单词的词向量经过三个不同的$W$矩阵变换之后得到了三个不同的向量表示$q, k, v$，分别拼接起来组成了矩阵$Q, K, V$，其中$Q, K$相乘就得到了任意两个单词之间的相似度矩阵，然后对矩阵每一行进行softmax就得到了每一个单词对于其他所有单词的权重。再乘上矩阵$V$就得到了它对其他所有单词的加权求和，以此来作为它的向量表示。</p><p>下图就是self-attention的框架图：<br><img src="single_attention.jpg" alt><br>形式化定义就是：<br>\[S(X) = \left[ { {\rm{softmax}}\left( {\frac{ {Q{K^{\rm{T}}}}}{ {\sqrt { {d_k}} }}} \right)V} \right]{W_O}\]<br>其中$Q = XW_Q, K = XW_K, V = XW_V$，$d_k$是向量$q, k$的维度，用它作为分母是为了防止数值太大溢出。最后的矩阵$W_O$是为了将输出映射到与输入相同的维度。</p><p>而multi-headed self-attention就是将刚刚的attention计算8次，并且相加：<br>\[M(X) = \sum\limits_{i = 1}^8 {S(X)} \]<br>注意这8个attention的参数矩阵是不共享的，也可以不相加，改为直接拼接。</p><p>最终的编码器模型如下图所示：<br><img src="multi_headed_attention.jpg" alt><br>也就是说，将刚刚的multi-headed self-attention经过一层layernorm之后再经过一层前馈神经网络，最后再经过一层layernorm得到输出。将上述模型复制8份，首尾拼接，即前面的输出作为后面的输入，即可得到编码器最终的输出，也就是每个单词最终的向量表示。</p><p>至于每个短语的表示，和双向LSTM编码一样，用短语边界两个单词向量的差值作为短语的表示。只是这里没有前向后向的概念，所以要将每个单词向量一分为二，前一半作为前向向量，后一半作为后向向量。当然在实际实现中，将单数维度提取出来作为前向表示，双数维度提取出来作为后向表示。</p><h2 id="解码器（Decoder）"><a href="#解码器（Decoder）" class="headerlink" title="解码器（Decoder）"></a>解码器（Decoder）</h2><p>得到了每个短语的向量表示之后，就需要对它们进行解码，得到最终的句法树，解码的方法主要有两种。<br><strong>基于动态规划解码的模型</strong><br>这种方法在论文中被叫做“chart-based model”，正如其名，就是利用一个数组来进行动态规划，求出每个span的最优split和最优label。</p><p>定义一棵句法树的分数为所有子结点的label分数之和，即：<br>\[{s_{tree}}(T) = \sum\limits_{(l,(i,j)) \in T} { {s_{label}}(i,j,l)} \]<br>其实原本论文中的定义还多了一项span的分数，但是由于具体实现中去掉这一项并没有什么影响，所以为了简便我就只算label分数了。</p><p>要使得句法树分数最大，不可能枚举所有的句法树，那就只能用动态规划算法求解了。对于任意一个$span(i, j)$，我们将它通过编码器产生的表示$s_{ij}$输入到前馈神经网络中，直接取得分最高的那一维作为最优label，即：<br>\[s_{label}(i, j, l) = [Vg(Ws_{ij}+b)]_l\]<br>而对于split，遍历所有的split，取两个子结点与自己结点得分之和最高的那个split即可：<br>\[s_{split}(i, j, k) = s_{label}(i, j, l_{ij}) + s_{label}(i, k, l_{ik}) + s_{label}(k, j, l_{kj})\]</p><p>最后的训练过程和以往一样，采用max-margin训练方法，即使得标准树的得分比预测树的得分至少高一个margin，在这里margin大小定义为两棵树不同短语的数量，最终的损失函数定义为：<br>\[\mathcal{L}(\theta ) = \max \left( {0,\Delta (\hat T,T) - {s_{tree}}(T) + {s_{tree}}(\hat T)} \right)\]</p><p><strong>基于自顶向下贪心解码的模型</strong><br>基于动态规划的解码算法时间复杂度为$O(n^3)$，对于长度大一点的句子来说还是有点不可接受的。但是如果采用自顶向下、贪心地去选择每一个span的最优split和最优label，那么时间复杂度将降到$O(n^2)$。具体操作过程如下，首先从根节点也就是$span(0, n)$开始，选择一个split，使得两个子结点与自己结点得分之和最高，而label还是向之前那样直接通过短语的向量计算得出。具体公式为：<br>\[\begin{array}{l}\hat l = \mathop {\arg \max }\limits_l [{s_{label}}(i,j,l)]\\\hat k = \mathop {\arg \max }\limits_k [{s_{split}}(i,k,l)]\end{array}\]<br>而由于贪心解码和转移系统action预测一样，在预测阶段可能会遇到训练阶段没有碰到过的状态，所以也需要用到Dynamic Oracle。同样也需要用到exploration，来增加训练阶段遇到的错误状态数。</p><h1 id="Sequence-to-Sequence模型"><a href="#Sequence-to-Sequence模型" class="headerlink" title="Sequence to Sequence模型"></a>Sequence to Sequence模型</h1><hr><p>上面最主流的两大模型：转移系统和编码解码模型都已经介绍完了，下面介绍几种比较新颖的方法。</p><p>大家都知道句法树和某些序列存在一一对应关系，句法树可以唯一转换成序列，序列也可以唯一转换成句法树，所以预测句法树的问题就转变为了预测序列问题，下面几种方法都是将句法树转换为了某种序列来进行预测。</p><h2 id="树结构转化为括号序列"><a href="#树结构转化为括号序列" class="headerlink" title="树结构转化为括号序列"></a>树结构转化为括号序列</h2><p>这种方法思路特别简单，因为训练集里原始数据的表示形式就是括号序列嘛，所以就采用语言模型直接预测出括号序列的概率。</p><p>但是不可能枚举出所有的句法树括号序列，所以最终还是只对其他句法分析器预测出来的最好的若干棵树进行预测概率，然后重排序选出概率最高的一棵树。</p><h2 id="句法距离（Syntactic-Distance）"><a href="#句法距离（Syntactic-Distance）" class="headerlink" title="句法距离（Syntactic Distance）"></a>句法距离（Syntactic Distance）</h2><p>这个方法就很新颖了，本质上也是将树结构转换成了唯一对应的序列。<br><img src="syntactic_distance_example.jpg" alt><br>首先看上面一张图，对于长度为$n$的句子，存在一个长度为$n - 1$的数字序列，满足如下条件：$n$个单词存在$n - 1$个两两相邻的单词对，而两个相邻的单词的最近公共祖先（LCA）在句法树中有一个高度，所以这$n - 1$个数的大小关系恰好对应了从左向右任意两个相邻单词对的LCA的高度的大小关系。</p><p>拿上面那张图为例，“She”和“enjoys”的最近公共祖先是“S”，所以高度最高，对应的数字也最大。“enjoys”和“playing”的最近公共祖先是“VP”，高度排第三，所以对应的数字大小也是排第三。依次类推，剩下的数也满足这个性质。可以证明，这个数字序列和句法树是一一对应的。更进一步可以发现，这个序列其实就是“中序遍历的结点的高度”，文中将其称为句法距离。</p><p>预测这个序列也很简单，通过一个双向LSTM，然后将每相邻两个单词的输出做一次卷积操作（因为要预测相邻两个单词的LCA高度嘛），然后再将输出送到一个双向LSTM中去，最后通过一个前馈神经网络得到每相邻两个单词的数字。</p><p>而从树到序列和从序列到树的算法都很简单，这里就不详述了，可以直接去看论文。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>下面列出了成分句法分析领域目前为止最好的一些结果：<br><img src="results.jpg" alt><br>最好的是采用self-attention编码器+外部预训练词向量ELMo的模型，第二是模型融合+重排序之后的结果，之后的模型也基本都是本文介绍过的，最厉害的就是最后一个2006年的模型，十几年了依然如此强悍。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>虽然看起来貌似已经看了不少的成分句法分析相关的工作了，但是其实还有很多细节性的工作还没有去了解。前两年ACL等顶会成分句法分析的论文都很少，但是18年又好像多了起来，但终究还是伯克利Dan Klein、斯坦福Socher、黄亮等一批大佬在做这个，想在巨人的肩膀上面做出点东西还是很有挑战性的。</p><p>目前能想到的工作只有在编码器上面做文章，学习出语义更加丰富的短语表示。或者可以采用失传多年的递归神经网络，解码时对句法树进行建模，但是随便试了一下，速度很慢而且存在梯度消失的问题，效果也不是很好。转移系统的话暂时也想不出什么好的点子，序列预测的话如果能再想出个新颖的一一对应的序列就好了。</p><p>前路还很长，说长也不长了，只有三年不到的时间了，做不出东西就要延毕了。但愿能在有限的三年时间里做出点成果，提高自己的代码能力，对这个领域也有更加深入的理解！</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr><p>[ACL15] Transition-based Neural Constituent Parsing<br>[NAACL16] Recurrent Neural Network Grammars<br>[EMNLP16] Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles<br>[TACL17] In-Order Transition-based Constituent Parsing<br>[EMNLP17] Effective Inference for Generative Neural Parsing<br>[ACL18] Policy Gradient as a Proxy for Dynamic Oracles in Constituency Parsing<br>[ACL17] A Minimal Span-Based Neural Constituency Parser<br>[ACL18] Constituency Parsing with a Self-Attentive Encoder<br>[EMNLP16] Parsing as Language Modeling<br>[ACL18] Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recurrent Neural Network Grammars</title>
      <link href="/2018/09/02/rnng/"/>
      <url>/2018/09/02/rnng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/N/N16/N16-1024.pdf" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a><br><strong>代码地址：</strong><a href="https://github.com/clab/rnng" target="_blank" rel="noopener">github</a></p><p>今天要介绍的这篇论文是来自NAACL16的Recurrent Neural Network Grammars，主要贡献点就是提出了一种新的文法RNNG，不同于传统的PCFG之类的文法，RNNG使用RNN来对句子和它的句法树的联合概率进行建模，因此它是一个生成模型。但是稍稍修改就可以改为判别模型，也就是大家熟悉的基于转移的成分句法分析系统，并且转移系统是采用top-down方法的，也就是利用了句法树的前序遍历。</p><p>RNNG在语言模型任务上取得了当时的state-of-the-art结果，成分句法分析任务上，生成模型取得了媲美最好结果的F1值，而判别模型就差了点。本文最大的贡献点就是提出了生成式模型RNNG，说明了在数据量不是很大的时候，利用生成式模型可以提高成分句法分析的准确率。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>RNN在语言模型和其他许多NLP任务上面都已经取得了非常不错的效果，但是RNN只能捕捉到句子的序列特征，例如句子的句法结构等递归嵌套的结构信息无法用RNN捕捉到。</p><p>因此本文提出了一种利用RNN建模出来的全新文法RNNG，建立在句子的句法结构之上，消除了PCFG的上下文无关假设。并提出了两种变体，一种是生成模型，可以用来句法分析和训练语言模型，另一种是判别模型，可以用来句法分析。</p><p>RNNG建立在top-down转移系统之上，top-down转移系统相比于bottom-up转移系统有一个好处，就是不需要二叉化，因为如果bottom-up转移系统不二叉化的话，REDUCE的状态就会有很多种可能，不知道到底归约栈里的几个结点。而top-down转移系统就不存在这个问题，直接归约到第一个父结点为止就行了。本文应该也是第一个提出用RNN来实现top-down转移系统的，之前的方法都是用top-down的文法，或者是bottom-up的，例如Sochar2013的CVG，也是用二叉化后的RNN学习结点的语义表示。</p><h1 id="RNN文法"><a href="#RNN文法" class="headerlink" title="RNN文法"></a>RNN文法</h1><hr><p>RNNG定义为三元组$(N, \Sigma, \Theta)$，其中$N$是非终结符集合，$\Sigma$是终结符集合，并且$N \cap \Sigma = \emptyset$，$\Theta$就是神经网络的参数集合。RNNG和传统的PCFG的一个明显区别就是它没有显式地指出语法规则是什么，而是蕴含在了神经网络中，在句法转移的时候动态的生成。</p><h1 id="Top-down句法分析和生成"><a href="#Top-down句法分析和生成" class="headerlink" title="Top-down句法分析和生成"></a>Top-down句法分析和生成</h1><p>这部分主要介绍RNNG的两个变体，一个是top-down的句法分析系统，还有一个是稍稍修改后的生成系统。</p><h2 id="判别式系统"><a href="#判别式系统" class="headerlink" title="判别式系统"></a>判别式系统</h2><p>这个判别式模型之前也已经介绍过很多次了，和普通的基于转移的句法分析系统一样，输入是一个句子$x$，输出是它的句法分析树$y$。主要组成部分有句法树栈、句子单词buffer、动作集合，每一步的动作有三种：</p><ul><li>NT(X)： 将一个父结点X移进栈里。</li><li>SHIFT： 从buffer中移一个单词到栈里。</li><li>REDUCE： 将栈顶的若干个结点归约为它们的父结点，并且出栈。</li></ul><p>图1就是每个动作的状态变化过程，图2是判别式模型进行句法分析的示例：<br><img src="1.jpg" alt></p><p>当然得给动作添加一些限制，首先记当前状态为三元组$(B, S, n)$，分别表示buffer、栈、当前栈里未归约的父结点数量，这个之前的博客没有提及过：</p><ul><li>NT(X)动作只有当buffer不为空并且$n &lt; 100$的时候才能进行。因为buffer空了的话就没有单词了，此时不可能移进新的非终结符了，并且要限制$n &lt; 100$防止一元产生式无限生成下去。</li><li>SHIFT动作只有当buffer不为空并且$n \ge 1$时才能进行。前者不用解释了，后者的话因为是top-down的，所以栈里至少要有一个父结点才能移进新的单词。</li><li>REDUCE只有当栈顶不是没有归约的父结点才能进行。</li><li>REDUCE只有当$n \ge 2$或者buffer为空时才能进行。<strong>这里要解释一下为什么$n \ge 2$，因为如果buffer不为空同时$n = 1$，那么这时候如果REDUCE的话，栈里就只剩一个非终结符了，只可能是根节点S，而buffer里还有单词，所以这是不可能的。</strong></li></ul><p>记当前状态的可能动作集合为$\mathcal{A}_D(B, S, n)$。</p><h2 id="生成式系统"><a href="#生成式系统" class="headerlink" title="生成式系统"></a>生成式系统</h2><p>将上面的top-down转移系统稍稍修改即可得到生成式系统。区别有两点：</p><ul><li>首先没有了输入的buffer，取而代之的是输出的buffer $T$。</li><li>其次因为没有输入单词了，所以在需要输入单词的时候采用GEN(x)动作来产生一个新的单词$x$，然后移进栈里，取代SHIFT动作。</li></ul><p>图3就是每个动作的状态变化过程，图4是生成式模型进行句法分析的示例：<br><img src="2.jpg" alt></p><p>同样也要对其采取一些限制：</p><ul><li>GEN(x)动作只有当$n \ge 1$时才能进行，上面SHIFT限制已经解释过了。</li><li>REDUCE只有当$n \ge 1$或者buffer为空时才能进行。<strong>这里再次解释一下，上面判别式模型限制条件是$n \ge 2$，为什么这里就变成了$n \ge 1$？因为生成模型没有输入buffer，所以即使$n = 1$时REDUCE了，以后不要再GEN(x)即可，直接结束分析</strong></li></ul><p>记当前状态的可能动作集合为$\mathcal{A}_G(T, S, n)$。</p><h2 id="转移序列"><a href="#转移序列" class="headerlink" title="转移序列"></a>转移序列</h2><p>因为一棵句法树的前序遍历是唯一的，所以不管用判别式模型还是生成式模型，得到的动作序列也都是唯一的。对于句子$x$和句法树$y$，记生成式模型动作序列为$a(x, y)$，判别式模型动作序列为$b(x, y)$。</p><h1 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h1><hr><p>本文最重要的就是上面提到的生成式模型，因为GEN(x)动作的存在，所以模型同时对句子$x$和句法树$y$的联合分布进行了建模。记当前状态的向量表示为$u_t$，那么联合分布可以表示为：<br>\[p(x,y) = \prod\limits_{t = 1}^{\left| {a(x,y)} \right|} {p({a_t}|{a_{ &lt; t}})}  = \prod\limits_{t = 1}^{\left| {a(x,y)} \right|} {\frac{ {\exp r_{ {a_t}}^T{u_t} + {b_{ {a_t}}}}}{ {\sum\nolimits_{a’ \in {\mathcal{A}_G}({T_t},{S_t},{n_t})} {\exp r_{a’}^T{u_t} + {b_{a’}}} }}} \]<br>其中$r_a$表示动作$a$的向量表示，$b$表示偏移向量，都包含在了RNNG参数集合$\Theta$里面，通过训练得到。</p><p>而当前状态的向量表示$u_t$由三部分得到，输出buffer的LSTM输出$o_t$、栈的LSTM输出$s_t$、历史动作序列的LSTM输出$h_t$，然后经过一个前馈神经网络得到：<br>\[u_t = \tanh (W[o_t; s_t; h_t] + c)\]<br>$W$和$c$同样也包含在了RNNG参数集合$\Theta$里面，下图是三个LSTM的示例图：<br><img src="3.jpg" alt></p><h2 id="句法成分组合"><a href="#句法成分组合" class="headerlink" title="句法成分组合"></a>句法成分组合</h2><p>在REDUCE操作时，需要将若干个子结点归约为一个父结点，为了得到父结点的向量表示，再次利用一个LSTM对子结点序列进行编码，同时在首尾加上父结点，结构图如下所示：<br><img src="4.jpg" alt></p><h2 id="单词生成"><a href="#单词生成" class="headerlink" title="单词生成"></a>单词生成</h2><p>单词生成采用softmax寻找概率最大的单词，但是单词数量可能十分巨大，所以采用分层softmax的思想，首先预测当前动作是不是GEN，如果是GEN，记单词总数为${\left| { \sum  } \right|}$，再将单词平均分成${\sqrt {\left| \sum  \right|} }$个类别，用softmax预测属于哪个类别，然后在那个类别里再用softmax预测输出哪个单词。这样时间复杂度就从$O\left( {\left| \sum  \right|} \right)$降到了$O\left( {\sqrt {\left| \sum  \right|} } \right)$。</p><h2 id="参数训练和判别式模型"><a href="#参数训练和判别式模型" class="headerlink" title="参数训练和判别式模型"></a>参数训练和判别式模型</h2><p>模型最终训练目的就是使得联合概率最大。</p><p>而只需要将输出buffer改为输入buffer，GEN动作改为SHIFT动作，然后重新训练，就可以将模型变为判别式模型了，输出给定输入句子下概率最大的句法树。</p><h1 id="通过重要性采样进行推理"><a href="#通过重要性采样进行推理" class="headerlink" title="通过重要性采样进行推理"></a>通过重要性采样进行推理</h1><hr><p>本文的生成式模型另一大作用是训练语言模型$p(x)$，根据边际分布公式<br>\[p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)} \]<br>可以直接得到$p(x)$，但是一句话的句法树可能性是指数级别的，不可能一一枚举，这时候就要用到重要性采样算法。</p><p>首先定义一个比较容易得到的条件分布$q(y | x)$，它满足如下性质：</p><ul><li>$p(y | x) &gt; 0$可以推出$q(y | x) &gt; 0$。</li><li>服从分布的样本很容易得到。</li><li>$q(y | x)$可以直接计算得到。</li></ul><p>可以发现，上面的判别式模型得到的条件分布符合上面的性质，所以这里直接用判别式模型来进行采样。</p><p>这样$p(x)$就变为了：<br>\[p(x) = \sum\nolimits_{y \in \mathcal{Y}(x)} {p(x,y)}  = \sum\nolimits_{y \in \mathcal{Y}(x)} {q(y|x)w(x,y)}  = {E_{q(y|x)}}w(x,y)\]<br>其中重要性权重$w(x,y) = p(x,y)/q(y|x)$。</p><p>最后如果根据分布$q(y | x)$采样得到了$N$个句法树样本，那么用蒙特卡罗方法就可以估计出$p(x)$了：<br>\[{E_{q(y|x)}}w(x,y) \approx \frac{1}{N}\sum\limits_{i = 1}^N {w(x,{y_i})} \]</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验部分主要说一下PTB上的句法分析和语言模型吧，下面两张图分别是句法分析和语言模型的结果：<br><img src="5.jpg" alt><br><img src="6.jpg" alt><br>句法分析方面可以看出，生成模型效果要远远好于判别模型，生成模型效果也接近了当时的最好结果。一个合理的解释是在小数据集上面，生成模型效果要更好，而在大数据集上，判别模型效果可以赶上生成模型。</p><p><strong>这里要提到的一点是，判别式模型就是每一个状态直接贪心argmax找到概率最大的动作，然后生成句法树。而生成式模型是利用判别式模型采样出100个概率比较高的句法树，然后用生成式模型计算它们的联合概率，重排序选择概率最高的句法树。</strong></p><p>语言模型方面，结果要比最好结果高了一点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>RNNG这个文法是个生成式模型，建模了句子和句法树的联合分布，稍稍修改即可应用到句法分析和语言模型中，效果也非常的好。</p><p>最后，我再简要梳理一遍RNNG的主要训练过程，因为这篇论文也看了整整两天，还是看的头大，一些细节可能还是没完全搞清。</p><p>首先利用生成式模型对每句话进行训练，在每个状态计算正确的动作的概率，然后训练使得概率之积最大。</p><p>然后应用到句法分析中，只需要修改为判别式模型即可。</p><p>最后应用到语言模型中，由于需要用到重要性采样，所以直接利用判别式模型生成若干样本，然后根据算得的条件概率计算语言模型句子的概率。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>In-Order Transition-based Constituent Parsing</title>
      <link href="/2018/08/28/tacl17-conparsing/"/>
      <url>/2018/08/28/tacl17-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://www.aclweb.org/anthology/Q/Q17/Q17-1029.pdf" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a><br><strong>代码地址：</strong><a href="https://github.com/LeonCrashCode/InOrderParser" target="_blank" rel="noopener">github</a></p><p>今天要介绍的这篇论文是成分句法分析领域目前的第三名，结果最高的几篇paper可以参见ruder在github整理的列表：<a href="https://github.com/sebastianruder/NLP-progress/blob/master/constituency_parsing.md" target="_blank" rel="noopener">github</a>。<br>下面就是成分句法分析目前排名：</p><table><thead><tr><th>Model</th><th align="center">F1 score</th><th>Paper / Source</th></tr></thead><tbody><tr><td>Self-attentive encoder + ELMo (Kitaev and Klein, 2018)</td><td align="center">95.13</td><td><a href="https://arxiv.org/abs/1805.01052" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a></td></tr><tr><td>Model combination (Fried et al., 2017)</td><td align="center">94.66</td><td><a href="https://arxiv.org/abs/1707.03058" target="_blank" rel="noopener">Improving Neural Parsing by Disentangling Model Combination and Reranking Effects</a></td></tr><tr><td>In-order (Liu and Zhang, 2017)</td><td align="center">94.2</td><td><a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a></td></tr><tr><td>Semi-supervised LSTM-LM (Choe and Charniak, 2016)</td><td align="center">93.8</td><td><a href="http://www.aclweb.org/anthology/D16-1257" target="_blank" rel="noopener">Parsing as Language Modeling</a></td></tr><tr><td>Stack-only RNNG (Kuncoro et al., 2017)</td><td align="center">93.6</td><td><a href="https://arxiv.org/abs/1611.05774" target="_blank" rel="noopener">What Do Recurrent Neural Network Grammars Learn About Syntax?</a></td></tr><tr><td>RNN Grammar (Dyer et al., 2016)</td><td align="center">93.3</td><td><a href="https://www.aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a></td></tr><tr><td>Transformer (Vaswani et al., 2017)</td><td align="center">92.7</td><td><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a></td></tr><tr><td>Semi-supervised LSTM (Vinyals et al., 2015)</td><td align="center">92.1</td><td><a href="https://papers.nips.cc/paper/5635-grammar-as-a-foreign-language.pdf" target="_blank" rel="noopener">Grammar as a Foreign Language</a></td></tr><tr><td>Self-trained parser (McClosky et al., 2006)</td><td align="center">92.1</td><td><a href="https://pdfs.semanticscholar.org/6f0f/64f0dab74295e5eb139c160ed79ff262558a.pdf" target="_blank" rel="noopener">Effective Self-Training for Parsing</a></td></tr></tbody></table><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>基于转移的成分句法分析主要分为两种：</p><ul><li>一种是自顶向下（top-down）的方法，按照前序遍历（pre-order）的顺序生成句法树。这种方法可以更好地利用全局信息，但是需要一个强大的编码器来对每个短语成分进行编码。</li><li>一种是自底向上（bottom-up）的方法，按照后序遍历（post-order）的顺序生成句法树。这种方法可以充分利用子树的特征来进行分析，但是却无法利用全局信息。</li></ul><p>本文的模型就对这两种方法进行了改进，采用中序遍历（in-order）的顺序来生成句法树。单模型最终取得了91.8的F1值（貌似也不是特别高？），采用监督重排序之后F1值提升到了93.6，采用半监督重排序之后F1值提升到了94.2。所以看起来还是重排序起了很大的作用。</p><h1 id="基于转移的成分句法分析"><a href="#基于转移的成分句法分析" class="headerlink" title="基于转移的成分句法分析"></a>基于转移的成分句法分析</h1><hr><p>首先简要介绍一下这三种基于转移的句法分析方法。</p><h2 id="自底向上的转移系统"><a href="#自底向上的转移系统" class="headerlink" title="自底向上的转移系统"></a>自底向上的转移系统</h2><p>自底向上的转移系统是基于后序遍历的，例如对于下图这棵句法树，算法产生结点的顺序为3、4、5、2、7、9、10、8、6、11、1。<br><img src="1.jpg" alt><br>a图是未经二叉化的句法树，b图是二叉化之后的句法树，二叉化之后的结点要用l和r来区分头结点。其实不二叉化也是可以的，伯克利一帮人的做法就是用$\emptyset $来作为临时结点，构造树的时候去掉就行了。</p><p>句法分析系统如下：<br><img src="2.jpg" alt><br>每个时刻的状态用三元组$[\sigma ,i,f]$来表示，分别表示栈中元素、buffer的第一个元素在句子中的下标、句法分析结束标记。系统一共有四个操作：</p><ul><li>SHIFT： 从buffer中移进一个单词到栈里。</li><li>REDUCE-L/R-X：将栈顶两个结点归约为一个父结点X。</li><li>UNARY-X：将栈顶元素归约为一元结点X。</li><li>FINISH：句法分析结束。</li></ul><p>上面那个句法树按照该模型分析的话过程如下：<br><img src="3.jpg" alt><br>优缺点很显然，可以充分利用已生成的子树来对父结点的预测进行分析，但是不能利用全局信息（也就是其他子树、父结点等信息），并且需要提前进行二叉化（这点可以用临时结点标记来规避）。</p><h2 id="自顶向下的转移系统"><a href="#自顶向下的转移系统" class="headerlink" title="自顶向下的转移系统"></a>自顶向下的转移系统</h2><p>自顶向下的转移系统是基于前序遍历的，例如对于之前那棵句法树，算法产生结点的顺序为1、2、3、4、5、6、7、8、9、10、11。</p><p>句法分析系统如下：<br><img src="4.jpg" alt><br>系统一共有三个操作：</p><ul><li>SHIFT： 从buffer中移进一个单词到栈里。</li><li>NT-X：对一个父结点生成出它的一个子结点X。</li><li>REDUCE：将栈顶的若干个结点归约为一个结点，并且全部出栈，注意它们的父结点这时已经在栈顶了。</li></ul><p>上面那个句法树按照该模型分析的话过程如下：<br><img src="5.jpg" alt><br>优缺点也很显然，可以充分利用全局信息，但是因为预测子树的时候，子树还没有生成，所以无法利用子树的特征来进行分析，所以需要提前对句子的每个短语进行编码。</p><h2 id="采用中序遍历的转移系统"><a href="#采用中序遍历的转移系统" class="headerlink" title="采用中序遍历的转移系统"></a>采用中序遍历的转移系统</h2><p>为了协调上面的两种问题，本文提出了一种基于中序遍历的转移系统。</p><p>其实采用中序遍历也符合人们的直觉判断，比如你读到一个单词“like”，脑子里首先就会想到，这个可能和下面短语共同组成了动词短语VP，然后接着往下看，果然印证了你的猜想。</p><p>中序遍历就是采用这种思想的，例如对于之前那棵句法树，算法产生结点的顺序为3、2、4、5、1、7、6、9、8、10。</p><p>句法分析系统如下：<br><img src="6.jpg" alt><br>系统一共有四个操作：</p><ul><li>SHIFT： 从buffer中移进一个单词到栈里。</li><li>PJ-X：向栈里移进父结点X，来作为栈顶结点的父结点。</li><li>REDUCE：将栈顶的若干个结点归约为一个结点，并且全部出栈，注意它们的父结点在出栈元素的倒数第二个。然后再将父结点入栈。</li><li>FINISH：句法分析结束。</li></ul><p>上面那个句法树按照该模型分析的话过程如下：<br><img src="7.jpg" alt></p><p>该转移系统还有很多变体。对于短语(S, a, b, c, d)，可以令它在栈中S结点之前的子结点个数为$k$，例如对于上面的中序转移系统，栈里存放顺序是“a S b c d”，那么$k = 1$，如果栈里存放顺序是“a b S c d”，那么$k = 2$。而对于自底向上的转移系统，$k$就是正无穷，对于自顶向下的转移系统，$k$就是0。</p><h1 id="句法分析模型"><a href="#句法分析模型" class="headerlink" title="句法分析模型"></a>句法分析模型</h1><hr><p>对于每一个状态，模型采用三个LSTM来预测当前步动作，结构如下图所示：<br><img src="8.jpg" alt><br>一个LSTM用来对栈顶元素进行编码，一个LSTM用来对buffer中所有元素进行编码，一个LSTM用来对之前预测完毕的所有动作进行编码。</p><h2 id="单词表示"><a href="#单词表示" class="headerlink" title="单词表示"></a>单词表示</h2><p>对于每个单词，用预训练词向量、随机初始化词向量、POS向量拼接起来，然后经过一个前馈神经网络来作为最终的单词表示：<br>\[{x_i} = f({W_{input}}[{e_{ {p_i}}};{\bar e_{ {w_i}}};{e_{ {w_i}}}] + {b_{input}})\]<br>其中${e_{ {p_i}}}$表示POS为$p_i$的向量，${\bar e_{ {w_i}}}$表示单词$w_i$的预训练词向量，${e_{ {w_i}}}$表示单词$w_i$的随机初始化词向量。$f$函数通常取ReLU。</p><h2 id="栈里的短语表示"><a href="#栈里的短语表示" class="headerlink" title="栈里的短语表示"></a>栈里的短语表示</h2><p>对于自顶向下和in-order的转移系统，由于不需要二叉化，所以采用如下图所示的LSTM来对栈里的短语进行编码：<br><img src="9.jpg" alt><br>具体的短语表示为：<br>\[{s_{comp}} = (LST{M_f}[{e_{nt}},{s_0}, \ldots ,{s_m}];LST{M_b}[{e_{nt}},{s_m}, \ldots ,{s_0}])\]<br>其中${e_{nt}}$是父结点的向量表示，其他都是子结点的短语表示。</p><p>而作为对比实验，自底向上的转移系统因为是二叉树，所以LSTM略有不同，结构图如下所示：<br><img src="12.jpg" alt><br>唯一的区别就是不管你短语的单词顺序如何，都要把中心词也就是头结点放在前面。</p><h2 id="贪心动作预测"><a href="#贪心动作预测" class="headerlink" title="贪心动作预测"></a>贪心动作预测</h2><p>上面的两个小节将buffer和栈里的元素都进行了编码，最后就要对当前状态进行动作预测了。</p><p>假设第$k$个状态为$[{s_j}, \ldots ,{s_0},i,false]$，那么当前状态每个动作的概率为：<br>\[p = SOFTMAX(W[{h_{stk}};{h_{buf}};{h_{ah}}] + b)\]<br>其中${h_{stk}}$是栈里的LSTM编码结果：<br>\[{h_{stk}} = LSTM[{s_0}, \ldots ,{s_j}]\]<br>${h_{buf}}$是buffer里的LSTM编码结果：<br>\[{h_{buf}} = LSTM[{x_i}, \ldots ,{x_n}]\]<br>${h_{ah}}$是之前动作序列的LSTM编码结果：<br>\[{h_{ah}} = LSTM[{e_{ac{t_k}}}, \ldots ,{e_{ac{t_0}}}]\]</p><p>最终的损失函数采用交叉熵：<br>\[L(\theta ) =  - \sum\limits_i {\sum\limits_j {\log {p_{ {a_{ij}}}}} }  + \frac{\lambda }{2}{\Vert \theta  \Vert ^2}\]</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>实验的超参数设置如下：<br><img src="10.jpg" alt><br>经过对比实验可以发现，结果比自底向上和自顶向下的转移系统都要略高一点，就算加上了重排序，还是略高一点。单模型的话，和2017年之前的结果相比的确是最高的，但是91.8的F1值现在看来不是特别高了，毕竟伯克利基于CKY算法的chart-parser都已经到了92多甚至93了。</p><p>详细结果如下表：<br><img src="11.jpg" alt><br>模型在依存句法分析和CTB上的表现也都很不错。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文提出了一种基于中序遍历转移系统的成分句法分析模型，主要的动机还是基于人类阅读时的直觉，该模型协调了自底向上和自顶向下转移系统的优缺点，在采用重排序之后，结果达到了非常高的水准。</p><p>当然我个人认为模型也存在一些改进的地方：</p><ul><li>单词的表示可以加上Char-LSTM。</li><li>预测阶段可以采用之前文章提到的Dynamic Oracle技术，来减少预测错误的发生。详见之前的文章：<a href="https://godweiyang.com/2018/08/03/dynamic-oracles/">地址</a>。不过这里的Dynamic Oracle要重新设计了，设计好了说不定又可以发一篇论文了？（手动滑稽）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> TACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-bandit Algorithm</title>
      <link href="/2018/08/05/k-bandit/"/>
      <url>/2018/08/05/k-bandit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><hr><p>有$K$个赌博机，每个赌博机有一定概率$P$吐出硬币，但是我们不知道这个概率是多少，每个赌博机吐出的硬币价值$V$也是不一样的，现在有$T$次机会选择赌博机，怎么选才能使得到的硬币总价值最大？</p><p>在下面的不同算法实现中，统一设定<br>\[\begin{array}{l}K = 5 \\ P = [0.1,0.9,0.3,0.2,0.7] \\ V = [5,3,1,7,4] \\ T = 1000000\end{array}\]<br>可以计算出，这种情况下：</p><ol><li>如果每次都选期望价值最高的4号赌博机，可以获得的最高总价值为2800000。</li><li>如果每次都选期望价值最低的2号赌博机，可以获得的最低总价值为300000。</li><li>如果随机选取赌博机，可以获得的期望总价值为1540000。</li></ol><h1 id="探索与利用算法"><a href="#探索与利用算法" class="headerlink" title="探索与利用算法"></a>探索与利用算法</h1><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>“仅探索”（exploration-only）算法就是将机会平均分配给每一个赌博机，随机挑选赌博机。<br>“仅利用”（exploitation-only）算法就是选取当前平均价值最高的那台赌博机。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">R</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> V<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">exploration_bandit</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> K <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        v <span class="token operator">=</span> R<span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span>        r <span class="token operator">+=</span> v    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> <span class="token number">5</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    V <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    T <span class="token operator">=</span> <span class="token number">1000000</span>    <span class="token keyword">print</span> exploration_bandit<span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行结果为：获得总价值1538893。</p><h1 id="varepsilon-贪心算法"><a href="#varepsilon-贪心算法" class="headerlink" title="$\varepsilon $贪心算法"></a>$\varepsilon $贪心算法</h1><hr><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">R</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> V<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">eplison_bandit</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token number">0</span>    Q <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    count <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        eplison <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> eplison<span class="token punctuation">:</span>            k <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> K <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            k <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>Q<span class="token punctuation">)</span>        v <span class="token operator">=</span> R<span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span>        r <span class="token operator">+=</span> v        Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>v <span class="token operator">-</span> Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> <span class="token number">5</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    V <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    T <span class="token operator">=</span> <span class="token number">1000000</span>    <span class="token keyword">print</span> eplison_bandit<span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行结果为：获得总价值2795546。</p><h1 id="Softmax算法"><a href="#Softmax算法" class="headerlink" title="Softmax算法"></a>Softmax算法</h1><hr><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">R</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> V<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">eplison_bandit</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">,</span> tau<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> <span class="token number">0</span>    Q <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    count <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>K<span class="token punctuation">)</span>    <span class="token keyword">for</span> t <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> softmax<span class="token punctuation">(</span>Q <span class="token operator">/</span> tau<span class="token punctuation">)</span>        rand <span class="token operator">=</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>        total <span class="token operator">=</span> <span class="token number">0.0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>            total <span class="token operator">+=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> total <span class="token operator">>=</span> rand<span class="token punctuation">:</span>                k <span class="token operator">=</span> i                <span class="token keyword">break</span>        v <span class="token operator">=</span> R<span class="token punctuation">(</span>k<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">)</span>        r <span class="token operator">+=</span> v        Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>v <span class="token operator">-</span> Q<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        count<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> r<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    K <span class="token operator">=</span> <span class="token number">5</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    V <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    T <span class="token operator">=</span> <span class="token number">1000000</span>    tau <span class="token operator">=</span> <span class="token number">0.1</span>    <span class="token keyword">print</span> eplison_bandit<span class="token punctuation">(</span>K<span class="token punctuation">,</span> P<span class="token punctuation">,</span> V<span class="token punctuation">,</span> R<span class="token punctuation">,</span> T<span class="token punctuation">,</span> tau<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行结果为：$tau=0.01$时，获得总价值1397795。$tau=0.1$时，获得总价值2798372。当然随机性很大，每次运行结果都会不同</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Understanding of Dynamic Oracle in Constituent Parsing</title>
      <link href="/2018/08/03/dynamic-oracles/"/>
      <url>/2018/08/03/dynamic-oracles/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>本文将从定义到证明，一步步理清成分句法分析中用到的Dynamic Oracle函数。参考了James Cross在2016年发表在EMNLP上面的论文：<a href="https://www.aclweb.org/anthology/D/D16/D16-1001.pdf" target="_blank" rel="noopener">论文地址</a>，该论文还是当年的best paper。</p><h1 id="成分句法分析系统"><a href="#成分句法分析系统" class="headerlink" title="成分句法分析系统"></a>成分句法分析系统</h1><hr><p>首先本文用到的成分句法分析系统是基于span-based的转移系统，在这里只做简略介绍，详见<a href="http://ir.library.oregonstate.edu/downloads/0g354j52q" target="_blank" rel="noopener">Parsing with Recurrent Neural Networks</a>。<br><img src="1.png" alt><br>上图展示了该转移系统的转移过程，其中结构化预测只用到了shift(sh)和combine(comb)两种动作，因为stack中存放的是span的左右边界下标，所以comb动作不需要区分左右，这与另一种转移系统的reduce动作不同。而对于label的预测，如果栈首的span不构成短语结点，那么就预测为nolabel，否则就预测为$_i{X_j}$。</p><p>每个时刻的状态用三元组$\left\langle {z,\sigma ,t} \right\rangle $表示，分别表示第几个动作、栈（span的split序列）、当前已生成的结点$_i{X_j}$集合。注意到对于长度为$n$的句子，只需要用$4n-2$个动作就可以分析出句法树了，并且第偶数个动作做结构预测（sh和comb），第奇数个动作做label预测。<br><img src="2.png" alt><br>上图是一个转移的具体例子，下面将全部以这个句子为例进行介绍。注意到多叉树隐式的转化为了二叉树，临时结点预测为nolabel。</p><h1 id="Dynamic-Oracle"><a href="#Dynamic-Oracle" class="headerlink" title="Dynamic Oracle"></a>Dynamic Oracle</h1><hr><p>Dynamic Oracle是Goldberg和Nivre在2013年总结出来的，发表在TACL上面：<a href="https://www.aclweb.org/anthology/Q/Q13/Q13-1033.pdf" target="_blank" rel="noopener">Training Deterministic Parsers with Non-Deterministic Oracles</a>。</p><p>提出的动机就是为了解决测试阶段贪心预测错误导致误差越来越大的问题。在训练的时候，原来的静态Oracle方法就是每一步都严格按照标准树的动作来进行预测，最终拟合得和标准树动作序列相同，但是测试的时候没有标准树了，如果某一步预测错误，可能会到达一个训练中没有出现过的状态，那就会导致之后的预测越来越错。所以就提出了Dynamic Oracle的技巧，在训练过程中的每一步预测，不再局限于标准树中的一个动作，而扩展为一个动作集合，只要采取集合中的动作，那么最终得到的动作序列一定也是最优的。</p><p>这种方法主要用于贪心的预测方法，例如本文的转移系统就是在每一步贪心的预测当前动作，再如之前介绍过的成分句法分析top-down模型<a href="https://www.aclweb.org/anthology/P/P17/P17-1076.pdf" target="_blank" rel="noopener">A Minimal Span-Based Neural Constituency Parser</a>中，自顶向下贪心的选择每一个span的最佳split，也要用到Dynamic Oracle来防止错误扩大。之前的博客有过专门介绍，可以去翻看一下：<a href="https://godweiyang.com/2018/06/28/ACL17-ConParsing/#top-down解码模型">Dynamic Oracle</a></p><p>下面就将从定义、证明等方面来详细阐述Dynamic Oracle。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><hr><p><strong>定义1：</strong> 定义$c{ \vdash _\tau }c’$为状态$c$经过动作$\tau $之后转移到状态${c’}$，写成函数的形式就是$c’ = \tau ({c})$。另外定义$ \vdash $为所有动作$\tau $的并集，也就是状态$c$经过任意动作之后转移到状态${c’}$。定义${ \vdash ^*}$为$ \vdash $的自反和传递闭包。</p><p><strong>定义2（派生树/可到达树）：</strong> 定义$D({c})$为从状态$c$出发，最终可以产生的句法树的集合，即<br>\[D({c}) = \left\{ {t|c{ \vdash ^*}\left\langle {z,\sigma ,t} \right\rangle } \right\}\]<br>也可以称作“派生树”或者“可到达树”。</p><p><strong>定义3（$F_1$值）：</strong> 定义预测树$t$关于标准树$t_G$的$F_1$值为<br>\[{F_1}(t) = \frac{ {rp}}{ {r + p}}\]<br>其中$r = \frac{ {\left| {t \cap {t_G}} \right|}}{ {\left| { {t_G}} \right|}},p = \frac{ {\left| {t \cap {t_G}} \right|}}{ {\left| t \right|}}$。</p><p><strong>定义4：</strong> 将$F_1$扩展为状态$c$的函数，定义${F_1}({c})$为从状态$c$出发可以产生的$F_1$值最高的句法树的$F_1$值，即<br>\[{F_1}(c) = {\max _{t \in D(c)}}{F_1}(t)\]</p><p><strong>定义5（oracle）：</strong> 定义状态$c$的oracle为使状态$c$转移过后最优$F_1$值不变的动作集合，即<br>\[oracle(c) = \left\{ {\tau |{F_1}(\tau (c)) = {F_1}(c)} \right\}\]<br>至于这个集合该怎么求解，下面将会讲到。</p><p><strong>定义6（span包含）：</strong> span$(i,j)$被span$(p,q)$包含，当且仅当$p \le i &lt; j \le q$，记为<br>\[(i,j) \preceq (p,q)\]</p><p><strong>定义7（严格包含）：</strong> span$(i,j)$被span$(p,q)$严格包含，当且仅当$(i,j) \preceq (p,q)$，并且$(i,j) \ne (p,q)$，记为<br>\[(i,j) \prec (p,q)\]<br>同样可以将偏序关系从span扩展到类别，即$_i{X_j}{ \prec _p}{Y_q}$，当且仅当$(i,j) \prec (p,q)$。</p><p><strong>定义8（可到达类别）：</strong> 对于任意状态$c = \left\langle {z,\sigma |i|j,t} \right\rangle $，定义它的可到达类别集合为<br>\[reach(c) = left(c) \cup right(c)\]<br>其中左右可到达类别集合又分别定义为<br>\[\begin{array}{l}left(c) = \left\{ {_p{X_q} \in {t_G}|(i,j) \prec (p,q),p \in \sigma |i} \right\}\\right(c) = \left\{ {_p{X_q} \in {t_G}|p \ge j} \right\}\end{array}\]<br>光看定义可能有点生涩，通俗理解就是，$left(c)$为标准树中包含span$(i,j)$的类别集合，并且类别的左端点与栈中的span没有交叉，也就是说类别的左端点就是栈中除了$j$以外的其余split中的某一个。而$right(c)$为标准树中还处于队列中没有进栈的类别集合。<br><img src="3.png" alt><br>如上图所示，还以之前的句法树为例，现在的状态为$\left\langle {10,[0,1,2,4],\left\{ {_0N{P_1}} \right\}} \right\rangle $，此时的栈顶span$(i,j)=(2,4)$，也就是红色梯形部分，那么$left(c)$就是深蓝色类别，$right(c)$就是天蓝色类别。而灰色类别因为与红色类别交叉了，所以属于不可到达类别，而标准树中还有一个类别$_0N{P_1}$由于已经被识别出来了，所以也属于不可到达类别。</p><p>上面定义是基于动作序号为偶数的情况，而对于动作序号为奇数的情况，也就是预测label的动作，只需要将偏序$\prec$修改为$\preceq$即可，因为转移过后span依然是本身，所以不是严格包含关系。</p><p>特殊情况（初始值）：<br>\[reach(\left\langle {0,[0],\emptyset } \right\rangle ) = {t_G}\]<br>很显然，初始时$t_G$中所有类别都属于$right(c)$。</p><p>最后需要注意的一点是，根据以上定义有<br>\[reach(c) \cap t = \emptyset ,reach(c) \subseteq {t_G} - t\]<br>这一点也是很显然的，$left(c)$都是严格包含span$(i,j)$的，所以与$t$不存在交集，而$right(c)$在队列里，更不可能存在交集，观察上面的例子会更加好理解。</p><p><strong>定义9（next类别）：</strong> 对于任意状态$c = \left\langle {z,\sigma |i|j,t} \right\rangle $，上面已经定义了它的可到达类别集合，最后再定义它的下一个可到达类别为严格包含span$(i,j)$的可到达类别集合（即$left(c)$）中偏序关系最小的类别<br>\[next(c) = {\min _ \prec }left(c)\]</p><h1 id="结构化和label-Oracles"><a href="#结构化和label-Oracles" class="headerlink" title="结构化和label Oracles"></a>结构化和label Oracles</h1><hr><p>对于任意动作序号为偶数的状态$c = \left\langle {z,\sigma |i|j,t} \right\rangle $，记$next(c){ = _p}{X_q}$，那么定义它的结构化Dynamic Oracle为<br><img src="4.png" alt><br>也就是使当前状态向着标准树中最接近它的状态$next(c)$转移，如果$p = i,q &gt; j$，那么应该在移进栈里一些单词；如果$p &lt; i,q = j$，那么不能再移进了，而应该在栈里combine两个span；如果$p &lt; i,q &gt; j$，那么移进或者归约都可以，反正总能达到前两种状态。</p><p>特殊情况（初始值）：<br>\[dyna(\left\langle {0,[0],\emptyset } \right\rangle ) = \{ sh\} \]<br>即使当前预测的span是错的，也可以经过Dynamic Oracle指导，几步之后预测到正确的$next(c)$。而如果没有Dynamic Oracle，可能就一直错下去了。<br><img src="5.png" alt><br>上图是几种任意状态的Dynamic Oracle示例，除了第一种之外，其余三个都是预测错误的，如果没有Dynamic Oracle，甚至都不知道下一步转移的动作是什么。</p><p><strong>引理1：</strong> 对于任意状态$c$，任意动作$\tau  \in dyna(c)$，有<br>\[reach(\tau (c)) = reach(c)\]<br>而对于任意动作$\tau  \notin dyna(c)$，有<br>\[reach(\tau (c)) \not\subset reach(c)\]</p><p>最后是label Dynamic Oracle，这个就很简单了，如果span$(i,j)$出现在了标准树中，那么预测类别就行了，否则的话预测为nolabel：<br><img src="6.png" alt></p><h1 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h1><hr><p>主要证明两点内容：</p><ul><li>首先定义一个特殊的树$t^*{(c)}$，下面会证明它是从状态$c$开始可以得到的得分最高的树。</li><li>然后证明从状态$c$开始按照Dynamic Oracle策略，确实可以得到最优树$t^*{(c)}$。</li></ul><p><strong>定义10（$t^*{(c)}$）：</strong> 对于任意状态$c = \left\langle {z,\sigma,t} \right\rangle $，定义最优树$t^*{(c)}$为$c$中的子树$t$并上当前状态可到达的类别集合，也就是<br>\[{t^*}(c) = t \cup reach(c)\]<br>下面我们会证明，$t^*{(c)}$的确是当前状态可以得到的得分最高的树。<br><img src="7.png" alt><br>上图形象的说明了几种树之间的关系。当前子树$t$与标准树$t_G$不一定完全重合，可能有预测错误的，所以是交叉的。那么接下来的预测如果全部预测为标准树中的$reach(c)$，那么得分一定是最高的。而剩余的白色部分就是与$t$的span产生交叉的类别，属于不可到达的。</p><p><strong>引理2：</strong> 对于任意状态$c$，最优树$t^*{(c)}$一定是$c$的派生树，也就是<br>\[{t^*}(c) \in D(c)\]</p><p><strong>定理1：</strong> 对于任意状态$c$，有<br>\[{F_1}({t^*}(c)) = {F_1}(c)\]</p><p>也就是说最优树$t^*{(c)}$的得分一定是当前状态可以得到的最高分数。</p><p>证明也很简单，根据召回率和准确率公式，最优树$t^*{(c)}$是在$t$的基础上加入了所有的标准树中的可到达类别$reach(c)$，所以召回率分子不会降下来，召回率不可能更高了；同时并没有加入任何不在标准树中的类别，所以准确率的分母也不可能减小，准确率也不会更高了。因此$t^*{(c)}$就是当前状态可以得到的最优树。</p><p><strong>推论1：</strong> 对于任意状态$c = \left\langle {z,\sigma,t} \right\rangle $，对任意$t’ \in D(c),t’ \ne {t^*}(c)$，都有<br>\[{F_1}(t’) &lt; {F_1}(c)\]<br>上面已经证明了$t^*{(c)}$是最优树，所以自然其余的树得分都比它低了。</p><p>最后需要证明的一点就是，按照Dynamic Oracle策略进行转移，一定能到达这个最优树吗？</p><p><strong>引理3：</strong> 对于任意状态$c = \left\langle {z,\sigma,t} \right\rangle $，对任意动作$\tau  \in dyna(c)$，都有<br>\[{t^*}(\tau (c)) = {t^*}(c)\]<br>反之如果$\tau  \notin dyna(c)$，那么有<br>\[{t^*}(\tau (c)) \ne {t^*}(c)\]<br>原文并没有给出证明，粗略理解的话，按照Dynamic Oracle策略，下面应该向着$next(c)$这个类别靠近，而在这个过程中，包含在$next(c)$内的$right(c)$都会被sh动作识别，而其余不在标准树中的类别都会被识别为nolabel，$next(c)$又是第一个$left(c)$，所以所有的$reach(c)$都可以被识别，所以这是符合$t^*{(c)}$定义的。</p><p>反之如果不按照Dynamic Oracle策略来转移，下一步产生的span一定会与$next(c)$产生交叉，因此$next(c)$再也无法被包括进最终的句法树中，所以第二点也成立。</p><p>最终综合引理3、定理1和推论1，得到了本文中最关键的结论：</p><p><strong>定理2：</strong> $dyna()$函数符合定义5中的oracle定义，即对于任意状态$c$，有<br>\[dyna(c) = oracle(c)\]</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>至此关于Dynamic Oracle已经全部介绍完了，在黄亮老师的个人主页上面，还有这篇论文的会议视频和ppt，还有github源码，大家可以去深入学习：<a href="http://web.engr.oregonstate.edu/~huanlian/" target="_blank" rel="noopener">Liang Huang</a>。</p><p>当然，在具体实现中，由于在训练集上过早的拟合，单纯使用Dynamic Oracle并没有得到任何效果提升，所以要加入exploration机制，也就是人为的干预动作分类，使模型故意预测错误的动作，这样就能学习到更多的情况了，事实证明这样的确得到了略微提升。PTB上的结果如下：<br><img src="8.png" alt></p><p>最后提一个小疑问，关于引理1，原文说之后定理的证明会用到它，但我没看出来哪里用到了。而且我对它的正确性也有所怀疑，按照Dynamic Oracle转移之后，$reach(c)$不可能一直不变啊，按理说会先不变，再变少，交替变化，最后生成句法树后变为空集。并且原文中引理1符号也出现了一个小错误，我在这里修改正确了。</p><p>关于这一点疑问，我已经发邮件请教了原作者James Cross，他也已经回复我了，更深入的解答不久应该就会告诉我了，到时候我再更新一下。如果大家有想法的话，也可以提出来。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Straight to the Tree： Constituency Parsing with Neural Syntactic Distance</title>
      <link href="/2018/07/19/conparsing-syntactic-distance/"/>
      <url>/2018/07/19/conparsing-syntactic-distance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="http://aclweb.org/anthology/P18-1108" target="_blank" rel="noopener">Straight to the Tree: Constituency Parsing with Neural Syntactic Distance</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>今天要讲的这篇论文发表在ACL18上面，一句话概括，本文就是<strong>将句法树序列化，通过预测序列进行句法分析。</strong></p><p>主要思想是通过预测一个实值向量来构造出成分句法树，该实值向量表示的就是成分句法树的所有split，并且按照中序遍历给出，具体细节之后会讲到。这个方法之前没有见过，很有新意，效果也很不错，虽然比不上之前讲的基于span的方法，但是该模型最大的优点就是可以并行，时间复杂度低。</p><p>近些年来，成分句法分析模型大多是通过学习出词和短语的表示，然后用基于转移的或者基于chart的方法进行句法分析，亦或者是上一篇笔记中提到的top-down方法。但是这一类方法都有一些不可避免的缺点，比如基于转移的方法，通过预测转移序列来生成句法分析树，但是一棵句法分析树可能对应着多棵不同的转移序列，所以训练的时候可能产生错误，可以通过动态Oracle技术解决。基于chart的模型缺点就是速度太慢。</p><p>本文提出了一种新的概念叫做“syntactic distance”，以下称作句法距离，这个概念首次提出是2017年一篇语言模型的论文中的，本文将其用在了句法分析中。主要思想是这样的：对于一棵二叉树，它的中序遍历的split序列和二叉树是唯一对应的，所以只需要预测这个split序列就行了，而每个split就是用句法距离来表示。下图就是一棵句法树对应的句法距离：<br><img src="1.png" alt><br>这棵树有两个split，第一个split的高度更高，所以对应的句法距离数值更大。</p><p>最后通过top-down顺序进行解码，解码时间复杂度为$O(n\log n)$。最后模型在PTB上取得了91.8的F1值，CTB上取得了86.5的F1值。</p><h1 id="Syntactic-Distances"><a href="#Syntactic-Distances" class="headerlink" title="Syntactic Distances"></a>Syntactic Distances</h1><hr><p>一棵句法树的句法距离如下定义：<br>对于句法分析树$T$，它的叶子结点也就是句子为$({w_0}, \ldots ,{w_n})$，记叶子结点$w_i,w_j$的最近公共祖先LCA为$\tilde d_j^i$，那么句法树$T$的句法距离定义为任意向量$d = ({d_1}, \ldots ,{d_n})$，并且满足<br>\[sign({d_i} - {d_j}) = sign(\tilde d_i^{i - 1} - \tilde d_j^{j - 1})\]<br>这个定义可能看起来比较难理解，通俗一点讲就是，$({d_1}, \ldots ,{d_n})$中任意一对元素的大小关系和$(\tilde d_1^0, \ldots ,\tilde d_n^{n - 1})$中下标相同的一对元素的大小关系是完全一样的，也就是说，句法距离大小反映的是一个句子两两相邻元素的LCA的高度大小。</p><p>还用上面那张图举个例子，$\tilde d_1^0 = 2,\tilde d_2^1 = 1$，那么它的句法距离$d=(d_1,d_2)$就是满足$d_1&gt;d_2$的任意向量。</p><p>这样就可以将一棵句法树唯一对应到一个句法距离的序列，只要预测这个序列就可以得到句法树了，这比预测span集合更加直接。</p><p>那么训练的时候如何将句法树转化为句法距离呢？这里只考虑二叉树，下面的算法1给出了伪代码，将句法树转化为三元组$(d,c,t)$。其中$d$是两两相邻的叶子结点的LCA的高度向量，可以证明，这和中序遍历得到的结点顺序完全相同。$c$是与之顺序相同的结点的label向量。$t$是叶子结点从左向右的tag标签向量。<br><img src="2.png" alt><br>从算法中可以看出，采用自顶向下递归的形式，叶子结点高度为0，不存在句法距离和label。而内结点的高度等于左右儿子高度较大的一个加1，句法距离为左儿子句法距离拼接上自身句法距离再拼接上右儿子句法距离，label也是如此。</p><p>那么如果得到了一棵句法树的三元组$(d,c,t)$，如何还原出这棵句法树呢？算法2给出了构造方法，其实类似于之前那篇论文的top-down方法。<br><img src="3.png" alt><br>原理很简单，只要在每一步寻找$d$中最大的元素，也就是寻找高度最大的内结点，该内结点对应的下标就是句法树的split，然后对左右子树递归解析就行了。时间复杂度只要$O(n\log n)$，而之前的top-down模型时间复杂度为$O(n^2)$。<br><img src="4.png" alt><br>上图是构造句法树的一个例子，和之前一样，通过$\emptyset$的label隐式的将句法树二叉化了，一元还是处理成新的label。图中的矩形高度就代表了句法距离的大小，可以看出，除了$d_0,d_5$这两个句子开始结束标记的句法距离以外，$d_1$最大，所以句法树的split就是$w_0$和$w_1$，然后对右子树递归分析。</p><p>在子树递归过程中，可以并行计算，理论上时间复杂度可以降到$O(\log n)$，但是句子长度过短的话，是否与cpu通讯时间都要大于这个数量级了呢？这个并行的意义还有待商榷。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><hr><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>下面的问题就是给出一个句子，如何学习出它的三元组$(d,c,t)$呢？</p><p>首先将每个单词的词向量和tag向量拼接作为输入，然后送入一个Bi-LSTM，得到隐含层输出为<br>\[h_0^w, \ldots ,h_n^w = {\rm{BiLST}}{ {\rm{M}}_w}([e_0^w,e_0^t], \ldots ,[e_n^w,e_n^t])\]</p><p>对于每个单词，可能存在一元结点，也可能不存在，不存在的话就标记为$\emptyset$，用一个前馈神经网络和softmax预测每个单词的一元结点：<br>\[p(c_i^w|w) = {\rm{softmax(FF}}_c^w(h_i^w))\]</p><p>为了得到每个split的表示，对两两相邻单词进行卷积：<br>\[g_1^s, \ldots ,g_n^s = {\rm{CONV(}}h_0^w, \ldots ,h_n^w)\]<br>注意输出比输入少一个，因为split数量比单词少一个。</p><p>然后再将输出通过一层Bi-LSTM，得到最终的split表示：<br>\[h_1^s, \ldots ,h_n^s = {\rm{BiLST}}{ {\rm{M}}_s}(g_1^s, \ldots ,g_n^s)\]<br>当然这里也可以选择采用self-attention，详见我的上一篇博客。</p><p>最后将输出通过一个两层前馈神经网络，得到每个split的句法距离值：<br>\[{ {\hat d}_i} = {\rm{F}}{ {\rm{F}}_d}(h_i^s)\]</p><p>每个内结点的label同样用一个前馈神经网络和softmax预测：<br>\[p(c_i^s|w) = {\rm{softmax(FF}}_c^s(h_i^s))\]</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>对于训练样例$\left\{ {\left\langle { {d_k},{c_k},{t_k},{w_k}} \right\rangle } \right\}_{k = 1}^K$，它的损失函数就是$d$和$c$的损失函数之和。</p><p>对于$c$，因为用的是softmax预测的，所以直接用交叉熵即可得到损失${L_{ {\rm{label}}}}$。</p><p>对于$d$，可以用均方误差：<br>\[L_{dist}^{mse} = \sum\limits_i { { {({d_i} - { {\hat d}_i})}^2}} \]<br>然而我们并不在意句法距离的绝对值大小，我们只要它的相对大小是正确的即可，所以均方误差在这里不是很合适，可以换成如下损失函数：<br>\[L_{dist}^{rank} = \sum\limits_{i,j &gt; i} {\max (0,1 - sign({d_i} - {d_j})({ {\hat d}_i} - { {\hat d}_j}))} \]</p><p>最后总的损失函数为：<br>\[L = {L_{ {\rm{label}}}} + L_{dist}^{rank}\]</p><p>下面这张图形象的说明了模型的结构，由下往上，第一层圆圈是单词之间的LSTM，然后每个单词上面的五边形是前馈神经网络用来预测一元label，两个相邻单词之间的三角形是卷积，卷积得到的结果再通过一个LSTM得到split表示，最后每个split上面有两个五边形，一个是前馈神经网络用来预测label，另一个是前馈神经网络用来预测句法距离。<br><img src="5.png" alt></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>在PTB数据集上的实验结果如下：<br><img src="6.png" alt><br>可以看出，结果还是很有竞争力的，虽然有很多比本文高的模型，但本文解释了，那是因为他们用了Char-LSTM，用了外部数据，用了半监督方法或者重排序方法。。。目前单模型最高的方法依然是上一篇博客讲的span-based模型。</p><p>最后值得一提的是模型的运行速度，之前理论分析时间复杂度非常低，而实际上运行速度的确快了许多，结果如下：<br><img src="7.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>本文最大的创新点就是应用句法距离进行句法分析，并且时间复杂度很低。至于文章题目为什么叫“Straight to the Tree”，文章最后说因为只通过一个最普通的LSTM和卷积就预测出了句法树，所以是很直接的。。。</p><p>本文的模型还比较粗糙，我觉得仍然有许多改进之处：</p><ul><li>可以将LSTM替换为self-attention，因为之前博客讲到了，伯克利的self-attention编码器比LSTM编码器准确率高了1个多的百分点。</li><li>可以尝试最近新出的词向量模型ELMo，也许会有特别大的提升。</li><li>加入词级别的Char-LSTM，可能会有一定提升。</li><li>我觉得split的表示可以更加复杂化一点，而不仅仅是一层卷积+一层LSTM这么简单。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Constituency Parsing with a Self-Attentive Encoder</title>
      <link href="/2018/07/04/acl18-attconparsing/"/>
      <url>/2018/07/04/acl18-attconparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/pdf/1805.01052.pdf" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a><br><strong>代码地址：</strong><a href="https://github.com/nikitakit/self-attentive-parser" target="_blank" rel="noopener">github</a></p><p>今天要介绍的这篇论文是成分句法分析领域目前的state-of-the-art，结果最高的几篇paper可以参见ruder在github整理的列表：<a href="https://github.com/sebastianruder/NLP-progress/blob/master/constituency_parsing.md" target="_blank" rel="noopener">github</a>。<br>下面就是成分句法分析目前排名：</p><table><thead><tr><th>Model</th><th align="center">F1 score</th><th>Paper / Source</th></tr></thead><tbody><tr><td>Self-attentive encoder + ELMo (Kitaev and Klein, 2018)</td><td align="center">95.13</td><td><a href="https://arxiv.org/abs/1805.01052" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a></td></tr><tr><td>Model combination (Fried et al., 2017)</td><td align="center">94.66</td><td><a href="https://arxiv.org/abs/1707.03058" target="_blank" rel="noopener">Improving Neural Parsing by Disentangling Model Combination and Reranking Effects</a></td></tr><tr><td>In-order (Liu and Zhang, 2017)</td><td align="center">94.2</td><td><a href="http://aclweb.org/anthology/Q17-1029" target="_blank" rel="noopener">In-Order Transition-based Constituent Parsing</a></td></tr><tr><td>Semi-supervised LSTM-LM (Choe and Charniak, 2016)</td><td align="center">93.8</td><td><a href="http://www.aclweb.org/anthology/D16-1257" target="_blank" rel="noopener">Parsing as Language Modeling</a></td></tr><tr><td>Stack-only RNNG (Kuncoro et al., 2017)</td><td align="center">93.6</td><td><a href="https://arxiv.org/abs/1611.05774" target="_blank" rel="noopener">What Do Recurrent Neural Network Grammars Learn About Syntax?</a></td></tr><tr><td>RNN Grammar (Dyer et al., 2016)</td><td align="center">93.3</td><td><a href="https://www.aclweb.org/anthology/N16-1024" target="_blank" rel="noopener">Recurrent Neural Network Grammars</a></td></tr><tr><td>Transformer (Vaswani et al., 2017)</td><td align="center">92.7</td><td><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a></td></tr><tr><td>Semi-supervised LSTM (Vinyals et al., 2015)</td><td align="center">92.1</td><td><a href="https://papers.nips.cc/paper/5635-grammar-as-a-foreign-language.pdf" target="_blank" rel="noopener">Grammar as a Foreign Language</a></td></tr><tr><td>Self-trained parser (McClosky et al., 2006)</td><td align="center">92.1</td><td><a href="https://pdfs.semanticscholar.org/6f0f/64f0dab74295e5eb139c160ed79ff262558a.pdf" target="_blank" rel="noopener">Effective Self-Training for Parsing</a></td></tr></tbody></table><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>本篇论文将之前<a href="http://godweiyang.com/2018/06/28/ACL17-ConParsing/">A Minimal Span-Based Neural Constituency Parser</a>这篇论文中模型的编码器部分由LSTM替换为了Self-Attentive，来捕捉句子单词内容(content)与位置(position)之间的联系。实验结果可以达到93.55%的F1值，如果再加上预训练的词向量ELMo，那么F1值可以提升到95.13%。这是目前效果最好的一个模型了。</p><p>Attention的主要想法借鉴了谷歌的神作：<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>，这篇论文网上也有很多讲解了，我挑选了一篇讲解比较好的，大家可以先看看：<a href="https://yq.aliyun.com/articles/342508?utm_content=m_39938" target="_blank" rel="noopener">Attention Is All You Need</a>。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>这部分详见我之前写的一篇笔记：<a href="http://godweiyang.com/2018/06/28/ACL17-ConParsing/">A Minimal Span-Based Neural Constituency Parser</a>，解码器部分和之前模型基本一致。本文主要探讨的是编码器的构造，也就是如何求出每个span的向量表示，从而得到span的得分$s(i,j,l)$，然后应用解码器进行解码，生成成分句法分析树。</p><h2 id="词向量表示"><a href="#词向量表示" class="headerlink" title="词向量表示"></a>词向量表示</h2><p>第$t$个单词的词向量由三个部分组成：</p><ul><li>word embdding：$w_t$，这部分可以用随机初始化的向量，也可以用CharLSTM，也可以用预训练的词向量。</li><li>tag embdding：$m_t$</li><li>位置向量：$p_t$</li></ul><p>最终词向量为三部分的加和：<br>\[z_t = w_t + m_t + p_t\]</p><h2 id="Self-Attentive"><a href="#Self-Attentive" class="headerlink" title="Self-Attentive"></a>Self-Attentive</h2><p>模型结构如下图所示：<br><img src="1.png" alt><br>这一部分是不同位置单词互相联系的唯一方式，采用谷歌<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>中的Self-Attentive模型。</p><p>模型一共由8个SingleHead组成，每个SingleHead结构如下图：<br><img src="2.png" alt><br>计算方式如下：<br>\[{\rm{SingleHead}}(X) = \left[ { {\rm{Softmax}}\left( {\frac{ {Q{K^{\rm{T}}}}}{ {\sqrt { {d_k}} }}} \right)V} \right]{W_o}\]<br>其中$Q = X{W_Q};K = X{W_K};V = X{W_V}$，而$W_O$用来将输出映射到与输入相同的维度。</p><p>详细分析一下计算过程，首先输入矩阵$X = [{z_1},{z_2}, \ldots ,{z_T}]$是由一个句子中所有词向量组成的矩阵，拼接在一起是为了并行，加快计算速度，$X \in {\mathbb{R}^{T \times {d_{ {model}}}}}$。</p><p>然后将$X$映射为三个矩阵，query矩阵$Q$，key矩阵$K$，value矩阵$V$，其中$Q,K \in {\mathbb{R}^{ {d_{ {model}}} \times {d_k}}}$。</p><p>我们想要计算单词$i$和单词$j$之间的Attention大小，可以用两者query向量和key向量元素乘得到：<br>\[p(i \to j) \propto \exp \left( {\frac{ { {q_i} \cdot {k_j}}}{ {\sqrt { {d_k}} }}} \right)\]<br>所有单词的value向量乘以单词$i$对它的Attention值，加权求和之后得到的结果就是单词$i$最后的向量表示：<br>\[{ {\bar v}_i} = \sum\nolimits_j {p(i \to j){v_j}} \]<br>最后乘以$W_O$映射到与输入$X$相同的维度。</p><p>整个过程如果写成矩阵形式就是最开始的那个矩阵式子。注意到式子中$Q{K^{\rm{T}}} \in {\mathbb{R}^{ {\rm{T \times T}}}}$，矩阵中的每个元素恰好就是Attention值$p(i \to j)$。$\sqrt { {d_k}}$是归一化因子。</p><p>最后将8个SingleHead的结果求和得到MultiHead结果，注意这8个SingleHead参数不共享：<br>\[{\rm{MultiHead(}}X) = \sum\limits_{i = 1}^8 { {\rm{SingleHea}}{ {\rm{d}}^{(i)}}(X)} \]</p><p>注意到Attention模型有一个很严重的问题，就是无论单词的顺序是怎么样的，都不影响最终的结果。所以在输入中要添加位置向量$p_t$，否则之后会有实验表明，不加的话效果大大下降。</p><p>图一中还有一个前馈神经网络的部分，使用的是一个双层前馈神经网络：<br>\[{\rm{FeedForward}}(x) = {W_2}{\rm{relu}}({W_1}x + {b_1}) + {b_2}\]</p><h2 id="Span得分"><a href="#Span得分" class="headerlink" title="Span得分"></a>Span得分</h2><p>最终的span得分计算方式如下：<br>\[s(i,j, \cdot ) = {M_2}{\rm{relu}}({\rm{LayerNorm}}({M_1}v + {c_1})) + {c_2}\]<br>其中$v$就是短语的向量表示，由之前的每个单词的向量输出得到：<br>\[v = [{ {\vec y}_j} - { {\vec y}_i},{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over y} }_{j + 1}} - { {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over y} }_{i + 1}}]\]<br>在之前的LSTM模型中前向后向表示很容易得到，在这里只能通过将输出向量一分为二，一半作为前向表示，一半作为后向表示，实际实现中，偶数维度作为前向表示，奇数维度作为后向表示。</p><h1 id="模型分析"><a href="#模型分析" class="headerlink" title="模型分析"></a>模型分析</h1><hr><h2 id="Content-vs-Position-Attention"><a href="#Content-vs-Position-Attention" class="headerlink" title="Content vs Position Attention"></a>Content vs Position Attention</h2><p>之前的模型中，我们采用元素加将三个输入向量求和作为输入，期待模型自己训练出它们之间的权重，将它们很好地分开，但是实际上效果并不好。</p><p>下面论文做了许多实验来探讨content和position的重要性。</p><p>首先修改模型输入，令$Q=PW_Q,K=PW_K$，也就是丢弃了content信息，但是最后结果只下降了0.27个百分点，说明了content信息对模型影响不是很大。</p><p>然后为了验证是不是元素加导致content和position信息混合在一起模型无法分开，实验将输入向量显示分开，输入改为<br>\[z_t=[w_t+m_t;p_t]\]<br>但是实验结果只下降了0.07个百分点，说明不是这个因素导致的。事实上元素加和拼接操作在高维度上面是相似的，特别是之后立即乘上了一个矩阵，这就会混合里面的信息。</p><p>所以最好的解决办法就是将content和position向量分开计算attention，最后求和。这样attention矩阵就可以表示为：<br>\[QK^{\rm{T}} = {Q_c}K_c^{\rm{T}} + {Q_p}K_p^{\rm{T}}\]<br>这时的权重矩阵$W$就可以写为<br>\[W = \left[ {\begin{array}{*{20}{c}}{ {W_c}}&amp;0\\0&amp;{ {W_p}}\end{array}} \right]\]</p><p>通过将content和position信息分开，模型的效果从92.67%提升到了93.15%，模型示意图如下：<br><img src="3.png" alt></p><p>最后的实验在测试阶段的8层模型中，每一层手动选择采不采用content或者position attention，实验结果如下：<br><img src="4.png" alt><br>可以发现，不用position信息的话结果大大下降，接近传统的CKY算法，这也说明了普通的CKY算法是无法捕捉到全局的信息的。还有就是content信息主要作用在最后几层，这也说明了前面几层有点类似于扩张卷积网络。</p><h2 id="窗口Attention"><a href="#窗口Attention" class="headerlink" title="窗口Attention"></a>窗口Attention</h2><p>这一部分也不是什么新鲜玩意了，谷歌的论文中也有提到，主要思想就是限制attention的范围，每个单词只与周围窗口大小内的单词进行计算。在本文中还提出一个relaxed变体，就是除了窗口大小范围外，再加入首尾各两个单词进行attention操作。</p><p>如果只在测试阶段进行窗口attention的话，实验结果如下：<br><img src="5.png" alt><br>可以看出，首尾的4个单词对模型效果有很大的影响，如果加上的话，即使窗口很小，效果下降也不会很多。</p><p>然后如果训练和测试阶段都采用窗口attention，结果如下：<br><img src="6.png" alt><br>这时结果下降反而不是很明显了，其实模型的8层就类似于卷积操作，假设窗口大小为10，那么经过8层计算之后，窗口其实可以覆盖到长度为80的句子，这已经足够了，所以性能没有下降太多不足为奇。</p><h1 id="模型的一些改进"><a href="#模型的一些改进" class="headerlink" title="模型的一些改进"></a>模型的一些改进</h1><hr><h2 id="Subword-Features"><a href="#Subword-Features" class="headerlink" title="Subword Features"></a>Subword Features</h2><p>可以尝试加入CharLSTM来代替随机初始化的tag embdding，并且可以直接删除随机初始化的word embdding，只保留tag embdding和位置向量，效果反而能有提升。</p><p>受到其他工作的启发，还可以将每个单词的前后各8个字符向量拼接起来作为输入，但是实验结果不如CharLSTM。</p><p>上面的实验结果如下图所示：<br><img src="7.png" alt><br>可以看出，采用CharLSTM输出作为tag embdding，并且不采用word embdding的效果最好。</p><h2 id="外部词向量"><a href="#外部词向量" class="headerlink" title="外部词向量"></a>外部词向量</h2><hr><p>如果采用另一项关于词向量的工作成果ELMo，将其预训练的结果作为word embdding，实验结果可以更高。因为该词向量已经很好的学习到了全局的信息，所以模型可以减少到4层，效果比8层更好，结果如下：<br><img src="8.png" alt><br>F1值大大提高，达到了惊人的95.21%。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>在PTB数据集上，无论是单模型还是多模型或者加入外部词向量，本文的模型结果都是近来最好的，单模型93.55%，多模型95.13%，对比结果如下：<br><img src="9.png" alt><br>本文开头已经提到了最高的几个排名，大家可以去看看其他的方法学习学习。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>之前的工作大多数围绕解码器的算法优化，但是本文对编码器进行了改进，使其能更好的捕捉全局信息。</p><p>同时提出了几点重要的改进：</p><ul><li>subword的信息（CharLSTM）和预训练的词向量非常重要。</li><li>将content和position信息分开可以提升实验结果。</li></ul><p>同时在阅读<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention Is All You Need</a>的同时，我也发现了谷歌的attention模型其实还是有很多问题的，例如模型本身无法捕捉位置信息，需要加入position embdding来表示位置信息，但这只是临时应付措施，今后工作可以探讨更好的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What&#39;s Going On in Neural Constituency Parsers? An Analysis</title>
      <link href="/2018/07/03/naacl18-conparsing/"/>
      <url>/2018/07/03/naacl18-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>论文地址：</strong><a href="https://arxiv.org/pdf/1804.07853.pdf" target="_blank" rel="noopener">What’s Going On in Neural Constituency Parsers? An Analysis</a><br><strong>代码地址：</strong><a href="https://github.com/dgaddy/parser-analysis" target="_blank" rel="noopener">github</a></p><p><img src="1.jpg" alt></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>最近几年，成分句法分析的方法发生了巨大的变化。传统的有基于PCFG的CKY算法，最近几年随着神经网络的兴起又产生了基于转移的方法、CRF句法分析、重排序方法等等。</p><p>本文是伯克利大学在NAACL18提出的一种基于神经网络的句法分析方法，和传统的方法不同的是，完全不使用语法规则和词汇特征，只需要用神经网络学习出短语的表示即可。通过实验可以发现，神经网络的确也很好的隐式学习出了传统的方法显式用到的语法规则和其他一些特征。在PTB数据集上，该方法达到了92.08%的F1值，这也直接超过了传统的大多数方法。而在下一篇伯克利的ACL18论文中，他们提出的基于Multi-Head Attention的成分句法分析方法更是达到了95.13%的F1值。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>在过去几年，成分句法分析方法发生了巨大的变化。最大的变化就是语法规则和人工的词汇特征变得越来越不那么重要，取而代之的用循环神经网络学习短语的表示，但是还没有什么人对这种神经网络表示的有效性做研究分析。本文提出了一种用RNN学习表示用来句法分析的模型，并对模型的各个方面进行了分析。</p><h1 id="句法分析模型"><a href="#句法分析模型" class="headerlink" title="句法分析模型"></a>句法分析模型</h1><hr><h2 id="模型总览"><a href="#模型总览" class="headerlink" title="模型总览"></a>模型总览</h2><p>和传统的CKY算法一样，该模型还是采用动态规划的算法求解每个短语的最大得分对应的类别以及分割点。只不过这里的短语得分不再是产生式概率之积，而是用RNN训练出来的短语得分。</p><p>用$s(i,j,l)$表示短语$x_{ij}$类别为$l$的得分，句法树$T$的得分表示为所有产生式的得分总和：<br>\[s(T) = \sum\limits_{(i,j,l) \in T} {s(i,j,l)} \]</p><p><strong>值得一提的是，该句法分析模型不需要句法树是二叉树，所以可以直接分析出$n$叉树结构。</strong></p><p>模型的任务依然是寻找得分最高的句法分析树：<br>\[\hat T = \mathop {\arg \max }\limits_T s(T)\]</p><p>短语得分$s(i,j,l)$的计算可以通过三个部分实现：单词表示、短语表示、短语类别得分。</p><h2 id="单词表示"><a href="#单词表示" class="headerlink" title="单词表示"></a>单词表示</h2><p>首先采用Char-BiLSTM训练出每个单词的字符级别的表示，这种表示方法已经很常见了，优点是可以捕捉到单词的前缀后缀等信息，还可以解决未登录词的表示问题。</p><p>最后将字符级别的词表示和预训练的词向量拼接起来作为最终的单词表示。也可以用外部序列标注器预测出单词的词性，并拼接上去作为输入，但是在这里只要Char-BiLSTM训练的足够好，就不需要词性标注了。</p><h2 id="短语表示"><a href="#短语表示" class="headerlink" title="短语表示"></a>短语表示</h2><p>对句子单词序列跑一遍双向LSTM，得到每个单词的前向后向上下文表示${ {\bf{f}}_i}$和${ {\bf{b}}_i}$，然后对于短语$x_{ij}$，用两者的上下文表示的差值拼接起来作为该短语的向量表示：<br>\[{ {\bf{r}}_{ij}} = [{ {\bf{f}}_j} - { {\bf{f}}_i},{ {\bf{b}}_i} - { {\bf{b}}_j}]\]<br>图1是一个具体的例子：<br><img src="2.jpg" alt></p><h2 id="短语类别得分"><a href="#短语类别得分" class="headerlink" title="短语类别得分"></a>短语类别得分</h2><p>最后将短语表示输入到一个单层前馈神经网络中，输出得分向量，其中得分向量每个维度就对应了每个类别的概率。具体计算公式如下：<br>\[s(i,j,l) = {[{ {\bf{W}}_2}ReLU({ {\bf{W}}_1}{ {\bf{r}}_{ij}} + { {\bf{z}}_1}) + { {\bf{z}}_2}]_l}\]</p><h2 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h2><p>虽然现在是$n$叉树，但是依然可以用CKY算法来进行句法分析。这时候就需要定义一个虚拟短语类别$\emptyset$，表示实际上不能构成短语的临时短语。例如对于产生式$A \to BCD$，分析的时候可以将其分析为$A \to \emptyset D,\emptyset  \to BC$。定义虚拟短语类别的得分为0，即$s(i,j,\emptyset ) = 0$。</p><p>定义${s_{best}}(i,j)$为短语$x_{ij}$得分最高的句法分析树的得分。首先对长度为1的短语即单词进行初始化：<br>\[{s_{best}}(i,i + 1) = \mathop {\max }\limits_l s(i,i + 1,l)\]<br>然后对于短语$x_{ij}$，运用动态规划算法计算得分最高的句法分析树：<br>\[{s_{best}}(i,j) = \mathop {\max }\limits_l s(i,j,l) + \mathop {\max }\limits_k [{s_{best}}(i,k) + {s_{best}}(k,j)]\]<br>注意到这里对类别的预测和分割点的预测是分开的，短语的最高分数就是最优子树的每个结点的类别得分之和。</p><p>自底向上进行计算，最终整个句子的最高得分就是${s_{best}}(0,n)$。然后自顶向下回溯得到整个句子的句法分析树，注意如果回溯遇到了虚拟短语类别$\emptyset$，就直接忽略它，继续往下回溯。</p><p>整个算法的时间复杂度为$O({n^3} + L{n^2})$，因为没有用到语法规则，所以$n^3$的常数系数$\left| G \right|$就没有了，复杂度大大降低！</p><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>损失函数依然使用的是max-margin，即<br>\[\mathcal L = \max \left( {0,\mathop {\max }\limits_T [s(T) + \Delta (T,{T^*})] - s({T^*})} \right)\]<br>这里提到了一点加快计算的方法，${\Delta (T,{T^*})}$可以融入到动态规划算法中一起计算，即将短语类别得分$s(i,j,l)$替换为$s(i,j,l) + 1[l \ne l_{ij}^*]$，其中$l_{ij}^*$是标准树中短语$x_{ij}$的类别。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经过10轮训练之后，模型在验证集上的F1值达到了92.22%，在测试集上的F1值为92.08%。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Minimal Span-Based Neural Constituency Parser</title>
      <link href="/2018/06/28/acl17-conparsing/"/>
      <url>/2018/06/28/acl17-conparsing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文地址：<a href="https://www.aclweb.org/anthology/P/P17/P17-1076.pdf" target="_blank" rel="noopener">ACL17</a><br>代码地址：<a href="https://github.com/mitchellstern/minimal-span-parser" target="_blank" rel="noopener">github</a></p><p>今天要分享的是伯克利2017年发表在ACL的一篇成分句法分析论文，论文和代码地址都已经放在上面了，代码里还给出了处理过的PTB数据集，使用起来非常方便。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>本文提出了一种不同于传统方法的成分句法分析方法。</p><p>传统的句法分析器需要预处理出语法规则集合，然后利用语法规则来进行各种句法分析，这类方法的弊端有很多，我列举了主要的三点：</p><ul><li>语法规则集合构造的好坏直接影响到分析效果的好坏。</li><li>不仅如此，利用语法规则的方法时间复杂度高，因为每次都要遍历一遍语法规则集合来决定每个短语采用哪一条语法规则。</li><li>还有一种弊端就是利用语法规则的方法无法产生新的产生式，也就是说如果测试集中的语法规则没有在训练集中出现过，那么是无法预测出来的。</li></ul><p>而本文提出的模型不需要预先构造出语法规则集合，只需要预测出每个短语的label和split就行了，这样就能构造出一棵完整的句法树。</p><p>该模型分为编码与解码两部分，其中编码部分就是利用双向LSTM将每个词和短语表示成向量，解码部分提出了两种模型，一种是chart模型，类似于CKY算法，另一种是top-down模型，就是自顶向下的贪心算法，具体模型之后介绍。</p><h1 id="编码模型"><a href="#编码模型" class="headerlink" title="编码模型"></a>编码模型</h1><hr><p>一棵句法分析树可以看做是$(label, span)$的集合，也就是句法树中的每一个结点的类别是label，该结点对应的短语在句子中的下标范围就是span。所以模型的任务就是要预测这个集合，给每一个label和span一个得分，找出使得一个句子得分最高的$(label, span)$集合即可。</p><p>那么我们的编码模型任务就是要得出每一个短语的表示，并将其转换为短语的label得分和span得分。这里用到的就是最简单的双向LSTM，对于句子的第$i$个位置，得到它的双向表示$f_i$和$b_i$，那么$span(i,j)$就可以表示为$[f_j-f_i,b_i-b_j]$。</p><p>然后将短语表示输入到两个单独的单层前馈神经网络中，就能分别得到label得分和span得分了。假设用$s_{ij}$表示$span(i,j)$的短语表示，那么label得分和span得分可以分别表示为：<br>\[\begin{array}{*{20}{l}}{ {s_{labels}}(i,j) = {V_l}g({W_l}{s_{ij}} + {b_l})}\\\ { {s_{span}}(i,j) = {v_s}^{\rm{T}}g({W_s}{s_{ij}} + {b_s})}\end{array}\]<br>注意到这里计算出来的label得分是一个向量，维数为label的类别数，而span得分计算出来就是一个标量了。而对于某一个特定的类别，它的得分就可以直接从label得分向量中取出对应的那一维就行了：</p><p>\[{s_{label}}(i,j,l) = {[{s_{labels}}(i,j)]_l}\]</p><p>还有个重要的问题就是一元和$n$元的产生式怎么处理，对于一元产生式，可以将所有的类别合并为一个新的类别，然后加入类别集合中共同预测就行了，在实现代码中，将一元的产生式链上面的类别合并成了一个元组作为这棵子树的label。对于$n$元的产生式，可以添加一个临时类别$\emptyset $，相当于进行了二叉化，所有的新增节点全部预测为$\emptyset $。</p><h1 id="chart解码模型"><a href="#chart解码模型" class="headerlink" title="chart解码模型"></a>chart解码模型</h1><hr><p>chart模型本质上就是一个动态规划算法，类似于CKY算法。</p><p>首先一棵句法树的总得分可以表示为组成它的$(label, span)$集合的label得分与span得分之和：<br>\[{s_{tree}}(T) = \sum\limits_{(l,(i,j)) \in T} {[{s_{label}}(i,j,l) + {s_{span}}(i,j)]} \]<br>我们目的就是寻找使得该式最大的集合$T$，利用动态规划可以将时间复杂度降到$O(n^3)$。</p><p>对于叶子结点的情况，因为没有split，所以我们只需要预测最大得分的label就行了：<br>\[{s_{best}}(i,i + 1) = \mathop {\max }\limits_l [{s_{label}}(i,i + 1,l)]\]<br>而对于一般的$span(i,j)$，我们不仅要预测label，还得预测split。对于split$k$，我们可以将split得分表示为：<br>\[{s_{split}}(i,k,j) = {s_{span}}(i,k) + {s_{span}}(k,j)\]<br>那么最大得分可以表示为：<br>\[{s_{best}}(i,j) = \mathop {\max }\limits_l [{s_{label}}(i,j,l)] + \mathop {\max }\limits_k [{s_{split}}(i,k,j) + {s_{best}}(i,k) + {s_{best}}(k,j)]\]<br>这样就可以对label和split单独预测，在实际代码实现中，去掉了${s_{split}}(i,k,j)$这一部分，也就是只预测label得分之和最高的split。这样做的一个好处就是防止了二叉化过程中，从左边开始合并和从右边开始合并得到的分数不一样，从而导致偏差，另外加上这部分效果提升也不大，所以为了简便就删掉了。</p><p>训练的话采用的还是Max-Margin：<br>\[max\left( {0,\Delta (\hat T,{T^*}) - {s_{tree}}({T^*}) + {s_{tree}}(\hat T)} \right)\]<br>至于句法树差异${\Delta (\hat T,{T^*})}$，可以方便的将${s_{label}}(i,j,l)$替换为${s_{label}}(i,j,l) + {\bf{1}}(l \ne l_{ij}^*)$，其中$l_{ij}^*$就是$span(i,j)$在标准树中的label。</p><h1 id="top-down解码模型"><a href="#top-down解码模型" class="headerlink" title="top-down解码模型"></a>top-down解码模型</h1><hr><p>top-down模型其实就是自顶向下贪心的选择每一个短语的最大label和split。</p><p>其中叶子结点处依然还是直接找得分最高的那一维：<br>\[\hat l = \mathop {arg\max }\limits_l [{s_{label}}(i,i + 1,l)]\]<br>对于一般的$span(i,j)$，直接贪心的寻找得分最高的label和split就行了：<br>\[\begin{array}{l}\hat l = \mathop {\arg \max }\limits_l [{s_{label}}(i,j,l)]\\\hat k = \mathop {\arg \max }\limits_k [{s_{split}}(i,k,j)]\end{array}\]<br>虽然这种贪心的方法看上去并不十分科学，但是实际效果却比动态规划算法还要好一点，并且它的时间复杂度只有$O(n^2)$。</p><p>下面是top-down模型进行解析的一个例子：<br><img src="1.png" alt><br>其中$\emptyset $在构造句法树的时候就直接忽略，最后可以还原成$n$元的产生式。并且一元产生式$S \to VP$被直接替换为了新的类别$S-VP$。</p><p>训练过程类似，对标准树中的每一个$span(i,j)$，分别计算label和split的loss就行了：<br>\[\begin{array}{l}\max \left( {0,1 - {s_{label}}(i,j,{l^*}) + {s_{label}}(i,j,\hat l)} \right)\\\max \left( {0,1 - {s_{split}}(i,{k^*},j) + {s_{split}}(i,\hat k,j)} \right)\end{array}\]<br>最后累加求出总的loss即可。</p><p><strong>动态Oracle</strong><br>top-down模型在每一个$span(i,j)$处都计算出得分最高的label和split，然后与标准树对应的$span(i,j)$作比较，计算出loss。但是这样存在一个很严重的问题，就是如果这个预测出来的$span(i,j)$没有出现在标准树中，那么他在标准树中的label和split是什么呢？这时候就要用到这里提到的动态Oracle技术了。</p><p>对于label而言，如果$span(i,j)$出现在标准树中，那么label就是标准树中的label，否则的话就是$\emptyset $。</p><p>对于split而言，定义$b(i,j)$为$span(i,j)$的split集合，因为可能是$n$元的，所以split可能不止一个。如果$span(i,j)$在标准树中，那么$b(i,j)$显然就是标准树中$span(i,j)$的split集合。如果$span(i,j)$不在标准树中，那么就寻找一个标准树中包含$span(i,j)$的最小span，该span的split集合中位于$i,j$之间的split就构成了$b(i,j)$。</p><p>形式化定义为，寻找：<br>\[({i^*},{j^*}) = \min \left\{ {(i’,j’) \in T:i’ \le i &lt; j \le j’} \right\}\]<br>其中这里的最小是定义在区间长度上的偏序关系。所以$b(i,j)$就可以定义为：<br>\[b(i,j) = \left\{ {k \in b({i^*},{j^*}):i &lt; k &lt; j} \right\}\]</p><p>这样对于任意的$span(i,j)$，都能在标准树中找到对应的split集合，然后计算出loss。这样也能解决因为$n$叉树不同的二叉化导致的不同的split产生的问题。在实际的代码中，直接采用了$b(i,j)$集合中最左边的split作为标准树中的split，当然也可以选择得分最高的一个split，不过提升不大没有必要。</p><p>采用动态Oracle有两个好处：</p><ul><li>一个就是上面说到的，训练的时候不需要每次都预测的和标准树一样了，就算不一样也能给出评判标准。</li><li>另一个就是在预测不准的时候，可以给出在该span里的标准树中的split，这样可以将贪心预测从错误中逐渐“拉回正轨”。</li></ul><h1 id="其他的得分计算方法"><a href="#其他的得分计算方法" class="headerlink" title="其他的得分计算方法"></a>其他的得分计算方法</h1><hr><p><strong>Top-Middle-Bottom label得分</strong><br>其实就是将每个span的label拆分为三元组$(top,middle,bottom)$，主要用来应对一元产生式的：</p><ul><li>如果不是一元产生式，那么父结点label就可以写为$(X,\emptyset,\emptyset)$。</li><li>如果产生式为$X \to Y$，那么label可以合并写为$(X,\emptyset,Y)$。</li><li>如果产生式为$X \to {Z_1} \to  \cdots  \to {Z_k} \to Y$，那么label可以合并写为$(X,{Z_1} -  \cdots  - {Z_k},Y)$。</li></ul><p>label的得分也由三部分求和得到：<br>\[{s_{label}}(i,j,({l_t},{l_m},{l_b})) = {s_{top}}(i,j,{l_t}) + {s_{middle}}(i,j,{l_m}) + {s_{bottom}}(i,j,{l_b})\]<br>求最大得分的时候也可以三部分分开求。</p><p><strong>左右span得分</strong><br>其实就是在计算split得分时，将左右span的得分区别为left和right两部分：<br>\[{s_{split}}(i,k,j) = {s_{left}}(i,k) + {s_{right}}(k,j)\]</p><p><strong>span连接得分</strong><br>之前计算split得分都是将左右span得分直接相加，当然也可以将他们拼接起来，输入到单层前馈神经网络里，输出作为得分：<br>\[{s_{split}}(i,k,j) = {v^{\rm{T}}}g({W_s}[{s_{ik}};{s_{kj}}] + {b_s})\]</p><p><strong>深度双仿射span得分</strong><br>首先令${h_{ik}} = {f_{left}}({s_{ik}}),{h_{kj}} = {f_{right}}({s_{kj}})$，然后split得分可以计算为：<br>\[{s_{split}}(i,k,j) = h_{ik}^{\rm{T}}{W_s}{h_{kj}} + v_{left}^{\rm{T}}{h_{ik}} + v_{right}^{\rm{T}}{h_{kj}}\]</p><p><strong>结构化label损失</strong><br>对于两个label集合，定义它们之间的结构化Hamming损失为：<br>\[\left| { {l_1}\backslash {l_2}} \right| + \left| { {l_2}\backslash {l_1}} \right|\]<br>这个loss可以被用在之前的训练过程中。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>具体代码细节以及超参数设置请参看代码。</p><p>首先实验对不同的得分计算方式以及loss计算方式进行了对比，发现效果最好的chart模型用的是原始label，0-1标签损失，split得分用的是拼接得分，而top-down模型效果最好的是原始label，结构化label损失，split得分用的是左右span得分。</p><p>当然提升都不是很大，实验为了简便，用了最简单原始的设置：原始label，0-1标签损失，split得分用的是直接求和。</p><p>实验对比结果如下图所示：<br><img src="2.png" alt></p><p>在PTB数据集上，实验结果都要好于之前的所有parser，结果如下：<br><img src="3.png" alt></p><p>不仅结果更好，处理速度也有很大提升，chart模型一秒钟能处理20.3句话，top-down模型一秒钟能处理75.5句话。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>近些年来，效果最好的成分句法分析器基本都是基于转移系统的，还有诸如基于CRF之类的句法分析器。本文提出的基于span表示与得分，从而进行chart解析或者top-down解析的模型是当时结果最好的模型。而且该模型非常的简单，不再需要复杂的语法规则。模型仍然有很多改进之处，体现在span表示的计算方式，各种得分的计算方式。在下一篇博客中，我将为大家介绍一篇伯克利最新的成分句法分析论文，使用的是自注意力机制的编码器，F1值达到了惊人的95.15%。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ3006. 计算多项式的系数II</title>
      <link href="/2018/06/05/eoj3006/"/>
      <url>/2018/06/05/eoj3006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>题目链接：<a href="https://acm.ecnu.edu.cn/problem/3006/" target="_blank" rel="noopener">EOJ3006</a></strong></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><hr><p>给定一个多项式${(ax + by)^k}$，计算多项式展开后${x^n}{y^m}$项的系数，结果对1000000007取模。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr><p>由二项式定理可以得知，${x^n}{y^m}$项的系数就是<br>\[{a^n}{b^m}C_k^n\]<br>然后再对1000000007取模，其中${a^n}{b^m}$取模很方便，用快速幂就行了，剩下的问题就是如何求解<br>\[C_k^n\bmod p\]<br>这里由于$n,k$都不是很大，所以直接采用组合数计算公式求出答案，再进行取模就行了。</p><p>拓展一下，如果$n,k$都是小于$10^9$的，那么就不能直接计算了。</p><p>这时候要用到一个大组合数取模的定理，叫做lucas定理：</p><blockquote><p><strong>定理：</strong><br>对于组合数取模<br>\[C_n^m\bmod p\]<br>其中$p$是质数。<br>如果令$n=sp+q,m=tp+r. (q,r&lt;p)$<br>那么有<br>\[C_{sp + q}^{tp + r} \equiv C_s^tC_q^r\bmod p\]<br><strong>证明:</strong><br>\[\begin{array}{l}{(1 + x)^n} \equiv {(1 + x)^{sp + q}} \equiv {(1 + x)^{sp}}{(1 + x)^q}\\ \equiv {({(1 + x)^p})^s}{(1 + x)^q} \equiv {(1 + {x^p})^s}{(1 + x)^q}\\ \equiv \sum\limits_{i = 0}^s {C_s^i{x^{ip}}} \sum\limits_{j = 0}^q {C_q^j{x^j}} \bmod p\end{array}\]<br>其中$(1 + x)^n$中$x^{tp+r}$项的系数为$C_{sp + q}^{tp + r}$，而在同余号右边$x^{tp+r}$项的系数只能为$C_s^tC_q^r$。<br>因为假设<br>\[tp + r = ip + j\]<br>所以<br>\[(t - i)p = j - r\]<br>而<br>\[ - p &lt;  - r \le j - r \le q - r &lt; p - r \le p\]<br>所以只能是<br>\[t - i = 0,j - r = 0\]<br>所以<br>\[C_{sp + q}^{tp + r} \equiv C_s^tC_q^r\bmod p\]</p></blockquote><p>在代码实现中，应用lucas定理之后，将$C_n^m$替换为$C_s^t$继续调用lucas定理即可。递归终止条件是$t=0$。</p><p>最后计算$C_q^r\bmod p$时直接应用组合数定义即可：<br>\[C_q^r \equiv \frac{ {q!}}{ {r!(q - r)!}} \equiv q!{(r!(q - r)!)^{p - 2}} \equiv q!{(r!(q - r)!\bmod p)^{p - 2}}\bmod p\]<br>这里还用到了逆元：<br>\[{a^{ - 1}} \equiv {a^{p - 2}}\bmod p\]<br>证明详见我的另一篇博客：<a href="http://godweiyang.com/2018/05/14/concrete-math-12/">具体数学-第12课</a>中的费马小定理和欧拉定理。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">1000000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> LL MOD <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>LL f<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>LL <span class="token function">QuickPow</span><span class="token punctuation">(</span>LL a<span class="token punctuation">,</span> LL n<span class="token punctuation">,</span> LL p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> a<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>        n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>LL <span class="token function">C</span><span class="token punctuation">(</span>LL n<span class="token punctuation">,</span> LL m<span class="token punctuation">,</span> LL p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL res <span class="token operator">=</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">QuickPow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">*</span> f<span class="token punctuation">[</span>n<span class="token operator">-</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token operator">%</span> p<span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAXN<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> T<span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld%lld%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>k<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">QuickPow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">QuickPow</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> m<span class="token punctuation">,</span> MOD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">C</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> n<span class="token punctuation">,</span> MOD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"case #%d:\n%lld\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eoj </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ2854. 统计特定字串模式的个数</title>
      <link href="/2018/06/05/eoj2854/"/>
      <url>/2018/06/05/eoj2854/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p><strong>题目链接：<a href="https://acm.ecnu.edu.cn/problem/2854/" target="_blank" rel="noopener">EOJ2854</a></strong></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><hr><p>在0和1组成的长度为$n(1 \le n \le 31)$的字符串中，统计包含$m(1 \le m \le n)$个连续1子串的字符串的个数。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr><p>这题要用到的算法思想是动态规划。</p><p>首先令$f(n, m)$表示长度为$n(1 \le n \le 31)$的字符串中，包含$m(1 \le m \le n)$个连续1子串的字符串的个数。考虑最后一位，也就是第$n$位的取值，可以分为两种情况：</p><ul><li>如果第$n$位为0，那么只能在前面的$n-1$位里取长度为$m$的连续1子串，那么答案就是<br>\[f(n-1,m)\]</li><li>如果第$n$位为1，那么考虑两种情况。<br>一种是最后$m$位全为1，那么前面$n-m$位就可以任意取值，答案为<br>\[2^{n-m}\]<br>另一种情况是最后$m$位不全为1，也就是存在某一位为0，枚举最后一位0出现的位置，可能出现在第$n-1$位、第$n-2$位，一直到第$n-m+1$位，不管最后一个0出现在哪里，都要在之前的字符串中重新出现长度为$m$的连续1子串，所以答案是<br>\[\sum\limits_{n - m \le i \le n - 2} {f(i,m)} \]</li></ul><p>所以最终的答案就是<br>\[f(n,m) = {2^{n - m}} + \sum\limits_{n - m \le i \le n - 1} {f(i,m)} \]<br>进一步化简这个式子，用$n-1$替换$n$可以得到<br>\[f(n - 1,m) = {2^{n - m - 1}} + \sum\limits_{n - m - 1 \le i \le n - 2} {f(i,m)} \]<br>两式相减可以得到<br>\[f(n,m) = {2^{n - m - 1}} + 2f(n - 1,m) - f(n - m - 1,m)\]<br>边界条件为：</p><ul><li>当$n &lt; m$时，$f(n,m)=0$。</li><li>当$n = m$时，$f(n,m)=1$。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> m <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eoj </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第五章作业解答</title>
      <link href="/2018/06/01/concrete-math-hw5/"/>
      <url>/2018/06/01/concrete-math-hw5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><hr><p><strong>题目：</strong><br>通过上指标翻转计算出$\left( {\begin{array}{*{20}{c}}{ - 1}\\k\end{array}} \right)$。<br><strong>解答：</strong><br>如果$k \ge 0$，那么<br>\[<br>\left( {\begin{array}{*{20}{c}}{ - 1}\\k\end{array}} \right) = {( - 1)^k}\left( {\begin{array}{*{20}{c}}{k - ( - 1) - 1}\\k\end{array}} \right) = {( - 1)^k}\left( {\begin{array}{*{20}{c}}k\\k\end{array}} \right) = {( - 1)^k}<br>\]<br>如果$k&lt;0$，那么<br>\[<br>\left( {\begin{array}{*{20}{c}}{ - 1}\\k\end{array}} \right) = 0<br>\]</p><h1 id="46"><a href="#46" class="headerlink" title="46."></a>46.</h1><hr><p><strong>题目：</strong><br>求出下列和式的闭形式解，其中$n$是正整数。<br>\[<br>\sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}{4n - 2k - 1}\\{2n - k}\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {(2k - 1)(4n - 2k - 1)}}}<br>\]<br><strong>解答：</strong><br>由公式$(5.69)$可得<br>\[<br>{\mathcal B_{ - 1}}(z) = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { { {( - z)}^k}}}{ {1 - 2k}}}  = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {2k - 1}}{z^k}}<br>\]<br>\[<br>{\mathcal{B}_{ - 1}}( - z) = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { {z^k}}}{ {1 - 2k}}}  = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { - 1}}{ {2k - 1}}{z^k}}<br>\]<br>两式相乘得到${\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z)$，其中$z^{2n}$项的系数恰好就是<br>\[<br>\begin{array}{l}\sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {2k - 1}} \cdot \left( {\begin{array}{*{20}{c}}{2(2n - k) - 1}\\{2n - k}\end{array}} \right)\frac{ { - 1}}{ {2(2n - k) - 1}}} \\ =  - \sum\limits_k {\left( {\begin{array}{*{20}{c}}{2k - 1}\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}{4n - 2k - 1}\\{2n - k}\end{array}} \right)\frac{ { { {( - 1)}^{k - 1}}}}{ {(2k - 1)(4n - 2k - 1)}}} \end{array}<br>\]<br>所以题目所求的和式的闭形式解就是${\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z)$的$z^{2n}$项的系数的相反数。<br>由公式$(5.69)$还可以得到<br>\[<br>{\mathcal{B}_{ - 1}}(z) = \frac{ {1 + \sqrt {1 + 4z} }}{2}<br>\]<br>\[<br>{\mathcal{B}_{ - 1}}( - z) = \frac{ {1 + \sqrt {1 - 4z} }}{2}<br>\]<br>所以<br>\[<br>(2{\mathcal{B}_{ - 1}}(z) - 1)(2{\mathcal{B}_{ - 1}}( - z) - 1) = \sqrt {1 - 16{z^2}}<br>\]<br>展开化简可以得到<br>\[<br>{\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z) = \frac{1}{4}\sqrt {1 - 16{z^2}}  + \frac{1}{2}{\mathcal{B}_{ - 1}}(z) + \frac{1}{2}{\mathcal{B}_{ - 1}}( - z) - 1<br>\]<br>而<br>\[<br>\begin{array}{l}{(1 - 16{z^2})^{1/2}} = \sum\limits_k {\left( {\begin{array}{*{20}{c}}{1/2}\\k\end{array}} \right){ {( - 16)}^k}{z^{2k}}} \\ = \sum\limits_k {\frac{1}{ {1 - 2k}}\left( {\begin{array}{*{20}{c}}{ - 1/2}\\k\end{array}} \right){ {( - 16)}^k}{z^{2k}}} \\ = \sum\limits_k {\frac{1}{ {1 - 2k}}\frac{ { { {( - 1)}^k}}}{ { {4^k}}}\left( {\begin{array}{*{20}{c}}{2k}\\k\end{array}} \right){ {( - 16)}^k}{z^{2k}}} \\ = \sum\limits_k {\frac{1}{ {1 - 2k}}\left( {\begin{array}{*{20}{c}}{2k}\\k\end{array}} \right){4^k}{z^{2k}}} \end{array}<br>\]<br>所以题目答案即${\mathcal{B}_{ - 1}}(z){\mathcal{B}_{ - 1}}( - z)$的$z^{2n}$项的系数的相反数为<br>\[<br>\left( {\begin{array}{*{20}{c}}{2n}\\n\end{array}} \right)\frac{ { {4^{n - 1}}}}{ {2n - 1}} + \left( {\begin{array}{*{20}{c}}{4n - 1}\\{2n}\end{array}} \right)\frac{1}{ {4n - 1}}<br>\]</p><h1 id="64"><a href="#64" class="headerlink" title="64."></a>64.</h1><hr><p><strong>题目：</strong><br>计算<br>\[<br>\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)/\left\lceil {\frac{ {k + 1}}{2}} \right\rceil }<br>\]<br><strong>解答：</strong><br>\[<br>\begin{array}{l}\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)/\left\lceil {\frac{ {k + 1}}{2}} \right\rceil } \\ = \sum\limits_{k = 0}^n {\left( {\left( {\begin{array}{*{20}{c}}n\\{2k}\end{array}} \right) + \left( {\begin{array}{*{20}{c}}n\\{2k + 1}\end{array}} \right)} \right)\frac{1}{ {k + 1}}} \\ = \sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}{n + 1}\\{2k + 1}\end{array}} \right)\frac{1}{ {k + 1}}} \\ = \frac{2}{ {n + 2}}\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}{n + 2}\\{2k + 2}\end{array}} \right)} \\ = \frac{ { {2^{n + 2}} - 2}}{ {n + 2}}\end{array}<br>\]</p><h1 id="65"><a href="#65" class="headerlink" title="65."></a>65.</h1><hr><p><strong>题目：</strong><br>证明<br>\[<br>\sum\limits_k {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{ - k}}(k + 1)!}  = n<br>\]<br><strong>解答：</strong><br>等号左边可以写为<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{ - k}}(k + 1)!}<br>\]<br>替换$k$为$n-1-k$，得到<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{1 + k - n}}(n - k)!}<br>\]<br>即证<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^{1 + k - n}}(n - k)!}  = n<br>\]<br>等式两边同时乘以$n^{n-1}$，即证<br>\[<br>\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^k}(n - k)!}  = {n^n}<br>\]<br>等式左边等于<br>\[<br>\begin{array}{l}\sum\limits_{0 \le k \le n - 1} {\left( {\begin{array}{*{20}{c}}{n - 1}\\k\end{array}} \right){n^k}(n - k)!} \\ = (n - 1)!\sum\limits_{0 \le k \le n - 1} {\frac{ { {n^k}(n - k)}}{ {k!}}} \\ = (n - 1)!\sum\limits_{0 \le k \le n - 1} {\left( {\frac{ { {n^{k + 1}}}}{ {k!}} - \frac{ { {n^k}}}{ {(k - 1)!}}} \right)} \\ = (n - 1)!\frac{ { {n^n}}}{ {(n - 1)!}}\\ = {n^n}\end{array}<br>\]<br>得证。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第14课（牛顿级数和生成函数）</title>
      <link href="/2018/05/28/concrete-math-14/"/>
      <url>/2018/05/28/concrete-math-14/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="牛顿级数"><a href="#牛顿级数" class="headerlink" title="牛顿级数"></a>牛顿级数</h1><hr><p>多项式函数的一般表示形式为：<br>\[f(x) = {a_d}{x^d} + {a_{d - 1}}{x^{d - 1}} +  \cdots  + {a_1}{x^1} + {a_0}{x^0}\]<br>也可以将其表示为下降阶乘幂的形式：<br>\[f(x) = {b_d}{x^\underline{d}} + {b_{d - 1}}{x^{\underline{d - 1}}} +  \cdots  + {b_1}{x^\underline{1}} + {b_0}{x^\underline{0}}\]<br>这种表示的好处是，求差分更加方便：<br>\[\Delta (f(x)) = {b_d}d{x^{\underline{d - 1}}} + {b_{d - 1}}(d - 1){x^{\underline {d - 2} }} +  \cdots  + {b_1}{x^\underline{0}}\]<br>因为有<br>\[\left( {\begin{array}{*{20}{c}}x\\k\end{array}} \right) = \frac{ { {x^\underline{k}}}}{ {k!}}\]<br>所以多项式又可以表示为组合数的形式，也被叫做牛顿级数：<br>\[f(x) = {c_d}\left( {\begin{array}{*{20}{c}}x\\d\end{array}} \right) + {c_{d - 1}}\left( {\begin{array}{*{20}{c}}x\\{d - 1}\end{array}} \right) +  \cdots  + {c_1}\left( {\begin{array}{*{20}{c}}x\\1\end{array}} \right) + {c_0}\left( {\begin{array}{*{20}{c}}x\\0\end{array}} \right)\]<br>这种形式的差分也特别简单，因为有<br>\[\Delta \left( {\left( {\begin{array}{*{20}{c}}x\\k\end{array}} \right)} \right) = \left( {\begin{array}{*{20}{c}}x\\{k - 1}\end{array}} \right)\]<br>所以$n$阶差分可以写为：<br>\[{\Delta ^n}(f(x)) = {c_d}\left( {\begin{array}{*{20}{c}}x\\{d - n}\end{array}} \right) + {c_{d - 1}}\left( {\begin{array}{*{20}{c}}x\\{d - 1 - n}\end{array}} \right) +  \cdots  + {c_1}\left( {\begin{array}{*{20}{c}}x\\{1 - n}\end{array}} \right) + {c_0}\left( {\begin{array}{*{20}{c}}x\\{ - n}\end{array}} \right)\]<br>所以有：<br>\[{\Delta ^n}(f(0)) = \left\{ {\begin{array}{*{20}{c}}{ {c_n},n \le d}\\{0,n &gt; d}\end{array}} \right.\]<br>所以牛顿级数又可以写为：<br>\[f(x) = {\Delta ^d}(f(0))\left( {\begin{array}{*{20}{c}}x\\d\end{array}} \right) + {\Delta ^{d - 1}}(f(0))\left( {\begin{array}{*{20}{c}}x\\{d - 1}\end{array}} \right) +  \cdots  + \Delta (f(0))\left( {\begin{array}{*{20}{c}}x\\1\end{array}} \right) + f(0){c_0}\left( {\begin{array}{*{20}{c}}x\\0\end{array}} \right)\]<br>这个形式是不是很像泰勒展开？</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><hr><p>对于无限序列$\left\langle { {a_0},{a_1},{a_2}, \ldots } \right\rangle $，定义它的生成函数为：<br>\[A(z) = {a_0} + {a_1}z + {a_2}{z^2} +  \cdots  = \sum\limits_{k \ge 0} { {a_k}{z^k}} \]<br>定义一个函数用来表示$z^n$的系数：<br>\[[{z^n}]A(z) = {a_n}\]<br>两个生成函数相乘的结果为：<br>\[A(z)B(z) = \sum\limits_{k \ge 0} {\sum\limits_{i = 0}^k { {a_i}{b_{k - i}}} {z^k}} \]<br>考虑下面的二项展开：<br>\[{(1 + z)^r} = \sum\limits_{k \ge 0} {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right){z^k}} \]<br>可以发现这就是序列$\left\langle {\left( {\begin{array}{*{20}{c}}r\\0\end{array}} \right),\left( {\begin{array}{*{20}{c}}r\\1\end{array}} \right),\left( {\begin{array}{*{20}{c}}r\\2\end{array}} \right), \ldots } \right\rangle $的生成函数。<br>替换变量可以得到：<br>\[{(1 + z)^s} = \sum\limits_{k \ge 0} {\left( {\begin{array}{*{20}{c}}s\\k\end{array}} \right){z^k}} \]<br>两个式子相乘可以得到：<br>\[{(1 + z)^r}{(1 + z)^s} = {(1 + z)^{r + s}}\]<br>等式两边$z^n$的系数相等，于是：<br>\[\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}s\\{n - k}\end{array}} \right)}  = \left( {\begin{array}{*{20}{c}}{r + s}\\n\end{array}} \right)\]<br>这和上节课讲到的范德蒙德卷积公式类似！这里是用生成函数证出来的。</p><p>同理根据<br>\[{(1 + z)^r}{(1 - z)^r} = {(1 - {z^2})^r}\]<br>可以得到<br>\[\sum\limits_{k = 0}^n {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}r\\{n - k}\end{array}} \right)} {( - 1)^k} = {( - 1)^{n/2}}\left( {\begin{array}{*{20}{c}}r\\{n/2}\end{array}} \right)[n是偶数]\]<br>下面是一个重要的生成函数：<br>\[\frac{1}{ {1 - z}} = 1 + z + {z^2} + {z^3} +  \cdots  = \sum\limits_{k \ge 0} { {z^k}} \]<br>它其实就是序列$\left\langle { {1},{1},{1}, \ldots } \right\rangle $的生成函数。</p><h1 id="生成函数应用"><a href="#生成函数应用" class="headerlink" title="生成函数应用"></a>生成函数应用</h1><hr><p>那么生成函数有什么应用呢？一个很重要的应用就是用来求解递归式。</p><p>例如大家很熟悉的斐波那契数列：<br>\[\begin{array}{l}{g_0} = 0;{g_1} = 1\\{g_n} = {g_{n - 1}} + {g_{n - 2}},n \ge 2\end{array}\]</p><p>首先为了统一表示，将递归式改写为如下形式：<br>\[{g_n} = {g_{n - 1}} + {g_{n - 2}} + [n = 1]\]<br>然后两边同时乘以$z^n$，得到：<br>\[{g_n}{z^n} = {g_{n - 1}}{z^n} + {g_{n - 2}}{z^n} + [n = 1]{z^n}\]<br>两边对指标$n$同时求和，可以得到：<br>\[G(z) = zG(z) + {z^2}G(z) + z\]<br>所以<br>\[G(z) = \frac{z}{ {1 - z - {z^2}}}\]<br>最后只要将$\frac{z}{ {1 - z - {z^2}}}$表示成多项式的形式就行了，$[{z^n}]\frac{z}{ {1 - z - {z^2}}}$就是斐波那契数列的通项公式了。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第13课（组合数各种性质）</title>
      <link href="/2018/05/27/concrete-math-13/"/>
      <url>/2018/05/27/concrete-math-13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>首先庆祝我自己顺利毕业了，忙完了毕业论文答辩一直在浪，所以上周的具体数学没有更新，现在补更一下，大家见谅。</p></blockquote><p>首先这节课讲的基本都是组合数的相关性质，而且特别多，所以我就不在这里详细证明了，如果你们对某一个性质感兴趣，可以自己证明去。</p><h1 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h1><hr><p>首先将组合数推广到负数域，也就是底数为负数的情况：<br>\[\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right) = {( - 1)^k}\left( {\begin{array}{*{20}{c}}{k - r - 1}\\k\end{array}} \right)\]<br>证明可以从下降阶乘幂的定义直接得到。</p><h1 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h1><hr><p>由于<br>\[\left( {\begin{array}{*{20}{c}}{m + n}\\m\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{m + n}\\n\end{array}} \right)\]<br>所以由性质1可得<br>\[{( - 1)^m}\left( {\begin{array}{*{20}{c}}{ - n - 1}\\m\end{array}} \right) = {( - 1)^n}\left( {\begin{array}{*{20}{c}}{ - m - 1}\\n\end{array}} \right)\]</p><h1 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h1><hr><p>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right){ {( - 1)}^k}}  = {( - 1)^m}\left( {\begin{array}{*{20}{c}}{r - 1}\\m\end{array}} \right)\]<br>这就说明了杨辉三角同一行的前面若干项交错和是可以求得的，但是它们的直接和是无法求出的。</p><h1 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h1><hr><p>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r}\\k\end{array}} \right){x^k}{y^{m - k}} = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{ - r}\\k\end{array}} \right){ {( - x)}^k}{ {(x + y)}^{m - k}}} } \]<br>证明可以通过令<br>\[{S_m} = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r}\\k\end{array}} \right){x^k}{y^{m - k}}}  = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r - 1}\\k\end{array}} \right){x^k}{y^{m - k}}}  + \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r - 1}\\{k - 1}\end{array}} \right){x^k}{y^{m - k}}} \]<br>将左边表示成递归式的形式，同理如果右边可以表示成相同的递归式，那么左右就相等了。</p><p>性质4看起来特别复杂，那么它有什么用呢？如果令$x$和$y$等于不同的值，那么就可以得到许多不同的恒等式。</p><h1 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h1><hr><p>令$x =  - 1,y = 1$可以得到<br>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + r}\\k\end{array}} \right){ {( - 1)}^k}}  = \left( {\begin{array}{*{20}{c}}{ - r}\\m\end{array}} \right)\]<br>这其实就是性质3的特例。</p><h1 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h1><hr><p>令$x = y = 1,r = m + 1$可以得到<br>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{2m + 1}\\k\end{array}} \right)}  = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + k}\\k\end{array}} \right){2^{m - k}}} \]<br>左边就是杨辉三角一行中左边一半的和，所以可以得到<br>\[\sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{m + k}\\k\end{array}} \right){2^{ - k}}} {\rm{ = }}{2^m}\]</p><h1 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h1><hr><p>\[\left( {\begin{array}{*{20}{c}}r\\m\end{array}} \right)\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right) = \left( {\begin{array}{*{20}{c}}r\\k\end{array}} \right)\left( {\begin{array}{*{20}{c}}{r - k}\\{m - k}\end{array}} \right)\]<br>这个公式可以形象理解为，从$r$个物品中取$m$个，再从这$m$个中取$k$个的方法数等于从$r$个物品中取$k$个，再从剩下的$r-k$个中取$m-k$个的方法数。证明的话直接用定义可证。</p><h1 id="性质8"><a href="#性质8" class="headerlink" title="性质8"></a>性质8</h1><hr><p>之前介绍了二项式系数，那么可以推广到任意$m$个未知数，它的展开式为<br>\[{({x_1} + {x_2} +  \cdots  + {x_m})^n} = \sum\limits_{\scriptstyle0 \le {a_1},{a_2}, \cdots ,{a_m} \le n\atop\scriptstyle{a_1} + {a_2} +  \cdots  + {a_m} = n} {\left( {\begin{array}{*{20}{c}}{ {a_1} + {a_2} +  \cdots  + {a_m}}\\{ {a_1},{a_2}, \cdots ,{a_m}}\end{array}} \right)} {x_1}^{ {a_1}}{x_2}^{ {a_2}} \cdots {x_m}^{ {a_m}}\]<br>其中<br>\[\left( {\begin{array}{*{20}{c}}{ {a_1} + {a_2} +  \cdots  + {a_m}}\\{ {a_1},{a_2}, \cdots ,{a_m}}\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{ {a_1} + {a_2} +  \cdots  + {a_m}}\\{ {a_2} +  \cdots  + {a_m}}\end{array}} \right) \cdots \left( {\begin{array}{*{20}{c}}{ {a_{m - 1}} + {a_m}}\\{ {a_m}}\end{array}} \right)\]</p><h1 id="性质9"><a href="#性质9" class="headerlink" title="性质9"></a>性质9</h1><hr><p>范德蒙德卷积式：<br>\[\sum\limits_k {\left( {\begin{array}{*{20}{c}}r\\{m + k}\end{array}} \right)} \left( {\begin{array}{*{20}{c}}s\\{n - k}\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{r + s}\\{m + n}\end{array}} \right)\]<br>很多公式都可以通过替换其中的一些变量推导得到：<br>\[\begin{array}{l}\sum\limits_k {\left( {\begin{array}{*{20}{c}}l\\{m + k}\end{array}} \right)} \left( {\begin{array}{*{20}{c}}s\\{n + k}\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{l + s}\\{l - m + n}\end{array}} \right)\\\sum\limits_k {\left( {\begin{array}{*{20}{c}}l\\{m + k}\end{array}} \right)} \left( {\begin{array}{*{20}{c}}{s + k}\\n\end{array}} \right){( - 1)^k} = {( - 1)^{l + m}}\left( {\begin{array}{*{20}{c}}{s - m}\\{n - l}\end{array}} \right)\\\sum\limits_{k \le l} {\left( {\begin{array}{*{20}{c}}{l - k}\\m\end{array}} \right)} \left( {\begin{array}{*{20}{c}}s\\{k - n}\end{array}} \right){( - 1)^k} = {( - 1)^{l + m}}\left( {\begin{array}{*{20}{c}}{s - m - 1}\\{l - m - n}\end{array}} \right)\\\sum\limits_{0 \le k \le l} {\left( {\begin{array}{*{20}{c}}{l - k}\\m\end{array}} \right)} \left( {\begin{array}{*{20}{c}}{q + k}\\n\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{l + q + 1}\\{m + n + 1}\end{array}} \right)\end{array}\]</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>最后详细求解一道组合题，其他的题目就不介绍了，可以去看具体数学英文版第173页。</p><p>求下面式子的闭形式解：<br>\[\sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)} ,n \ge m \ge 0\]</p><p>根据性质7，可以得到<br>\[\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right) = \left( {\begin{array}{*{20}{c}}{n - k}\\{m - k}\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\m\end{array}} \right)\]<br>所以<br>\[\sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)}  = \sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}{n - k}\\{m - k}\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\m\end{array}} \right)} \]<br>而<br>\[\begin{array}{l}\sum\limits_{k \ge 0} {\left( {\begin{array}{*{20}{c}}{n - k}\\{m - k}\end{array}} \right)}  = \sum\limits_{m - k \ge 0} {\left( {\begin{array}{*{20}{c}}{n - (m - k)}\\{m - (m - k)}\end{array}} \right)} \\ = \sum\limits_{k \le m} {\left( {\begin{array}{*{20}{c}}{n - m + k}\\k\end{array}} \right)} \\ = \left( {\begin{array}{*{20}{c}}{(n - m) + m + 1}\\m\end{array}} \right)\\ = \left( {\begin{array}{*{20}{c}}{n + 1}\\m\end{array}} \right)\end{array}\]<br>所以<br>\[\sum\limits_{k = 0}^m {\left( {\begin{array}{*{20}{c}}m\\k\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\k\end{array}} \right)}  = \left( {\begin{array}{*{20}{c}}{n + 1}\\m\end{array}} \right)/\left( {\begin{array}{*{20}{c}}n\\m\end{array}} \right) = \frac{ {n + 1}}{ {n + 1 - m}}\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第12课（数论进阶与组合数入门）</title>
      <link href="/2018/05/14/concrete-math-12/"/>
      <url>/2018/05/14/concrete-math-12/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p>这节课内容太多了，再加上感冒身体不舒服，下面的定理就不一一证明了，大家可以自行练习。以后有空我会补上的！</p></blockquote><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>首先接着上节课同余继续讲，在<a href="http://godweiyang.com/2018/04/23/concrete-math-9/">第三章例题2</a>中，我们遗留了一个问题：对于如下序列<br>\[0\bmod m,n\bmod m,2n\bmod m, \ldots ,(m - 1)n\bmod m\]<br>它的值就是<br>\[0,d,2d, \ldots ,(m/d - 1)d\]<br>的某个排列，并且重复了$d$次。其中$d = gcd(m, n)$</p><p>首先我们有如下同余式：<br>\[jn \equiv kn(\bmod m) \Leftrightarrow j(n/d) \equiv k(n/d)(\bmod m/d)\]<br>这就可以看出该序列的确是重复出现了$d$次，那么剩下的问题就是证明这$m/d$个数恰好就是<br>\[\{ 0,d,2d, \ldots ,m - d\} \]<br>的某个排列。<br>令$m = m’d,n = n’d$，所以有<br>\[kn\bmod m = d(kn’\bmod m’)\]<br>所以我们只考虑$m \bot n$的情形，在此情形下，我们可以得到<br>\[jn \equiv kn(\bmod m) \Leftrightarrow j \equiv k(\bmod m)\]<br>由此可以看出，这$m-1$个数一定就是<br>\[\{ 0,1,2, \ldots ,m - 1\} \]<br>至此得证。</p><p>下面介绍几个著名的数论定理。</p><h1 id="费马最后定理"><a href="#费马最后定理" class="headerlink" title="费马最后定理"></a>费马最后定理</h1><hr><p>对于所有的正整数$a,b,c,n&gt;2$，有<br>\[{a^n} + {b^n} \ne {c^n}\]</p><h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><hr><p>如果$n \bot p$，那么有<br>\[{n^{p - 1}} \equiv 1(\bmod p)\]</p><p>证明也很好证。</p><p>之前证过了，序列<br>\[n\bmod p,2n\bmod p, \ldots ,(p - 1)n\bmod p\]<br>结果就是<br>\[1,2, \ldots ,p-1\]<br>的某个排列，所以有<br>\[n \cdot (2n) \cdot  \ldots  \cdot ((p - 1)n) \equiv (p - 1)!\]<br>所以<br>\[(p - 1)!{n^{p - 1}} \equiv (p - 1)!(\bmod p)\]<br>所以<br>\[{n^{p - 1}} \equiv 1(\bmod p)\]</p><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><hr><p>定义$\varphi (m)$为小于$m$且与其互素的正整数个数。</p><p>所以我们有欧拉定理<br>\[{n^{\varphi (m)}} \equiv 1(\bmod m)\]<br>其中$n \bot m$，可以发现，当$m$是素数时，欧拉定理就是费马小定理，所以欧拉定理是费马小定理的推广形式。</p><p>欧拉定理有很多有趣的性质，这里就不一一介绍了，详情见<a href="https://blog.csdn.net/howe_young/article/details/50282775" target="_blank" rel="noopener">博客地址</a>。</p><h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><hr><p>定义莫比乌斯函数$\mu (m)$为<br>\[\sum\limits_{d|m} {\mu (d)}  = [m = 1]\]</p><p>这个定义看起来很奇怪是不是？其实这是一个递归定义，可以递归地计算得到所有的值。</p><p>这个函数有什么用呢？主要用来进行莫比乌斯反演：<br>\[g(m) = \sum\limits_{d|m} {f(d)}  \Leftrightarrow f(m) = \sum\limits_{d|m} {\mu (d)g(\frac{m}{d})} \]</p><p>详细的性质及应用也不介绍了，给大家推荐一个牛逼的博客<a href="https://blog.csdn.net/acdreamers/article/details/8542292" target="_blank" rel="noopener">博客地址</a>，我当时学ACM的时候这部分都是看着他的学的。</p><h1 id="组合数入门"><a href="#组合数入门" class="headerlink" title="组合数入门"></a>组合数入门</h1><hr><p>定义组合数$\left( {\begin{array}{c}n\\k\end{array}} \right)$为从$n$个物品中取出$k$个物品的方法数，具体计算为<br>\[\left( {\begin{array}{c}n\\k\end{array}} \right) = \frac{ {n(n - 1) \ldots (n - k + 1)}}{ {k(k - 1) \ldots 1}}\]</p><p>推广到实数领域，定义<br>\[\left( {\begin{array}{c}r\\k\end{array}} \right) = \left\{ {\begin{array}{c}{\frac{ {r(r - 1) \ldots (r - k + 1)}}{ {k(k - 1) \ldots 1}} = \frac{ { {r^{\underline{k}}}}}{ {k!}},k \ge 0}\\{0,k &lt; 0}\end{array}} \right.\]</p><p>下面介绍一些组合数性质。</p><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>\[\left( {\begin{array}{c}n\\k\end{array}} \right) = \left( {\begin{array}{c}n\\{n - k}\end{array}} \right),n,k \in \mathbb{Z},n \ge 0\]<br>这里为什么要限定$n \ge 0$呢？举个例子，如果$n = -1$，那么有<br>\[\left( {\begin{array}{c}{ - 1}\\k\end{array}} \right) \ne \left( {\begin{array}{c}{ - 1}\\{ - 1 - k}\end{array}} \right)\]<br>因为左边等于${( - 1)^k}$，而右边等于${( - 1)^{-1-k}}$。</p><h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>\[\left( {\begin{array}{c}r\\k\end{array}} \right) = \frac{r}{k}\left( {\begin{array}{c}{r - 1}\\{k - 1}\end{array}} \right)\]</p><h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>\[(r - k)\left( {\begin{array}{c}r\\k\end{array}} \right) = r\left( {\begin{array}{c}{r - 1}\\k\end{array}} \right)\]</p><h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>\[\left( {\begin{array}{c}r\\k\end{array}} \right) = \left( {\begin{array}{c}{r - 1}\\k\end{array}} \right) + \left( {\begin{array}{c}{r - 1}\\{k - 1}\end{array}} \right)\]<br>这条性质可以通过性质3和性质4两边分别相加得到。</p><h2 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h2><p>\[\sum\limits_{k \le n} {\left( {\begin{array}{c}{r + k}\\k\end{array}} \right)}  = \left( {\begin{array}{c}{r + n + 1}\\n\end{array}} \right)\]</p><h2 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h2><p>\[\sum\limits_{0 \le k \le n} {\left( {\begin{array}{c}k\\m\end{array}} \right)}  = \left( {\begin{array}{c}{n + 1}\\{m + 1}\end{array}} \right)\]</p><h2 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h2><p>微分形式：<br>\[\Delta \left( {\left( {\begin{array}{c}x\\m\end{array}} \right)} \right) = \left( {\begin{array}{c}{x + 1}\\m\end{array}} \right) - \left( {\begin{array}{c}x\\m\end{array}} \right) = \left( {\begin{array}{c}x\\{m - 1}\end{array}} \right)\]<br>\[\sum {\left( {\begin{array}{c}x\\m\end{array}} \right)\delta x = } \left( {\begin{array}{c}x\\{m + 1}\end{array}} \right) + C\]</p><h1 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h1><hr><p>\[{(x + y)^r} = \sum\limits_k {\left( {\begin{array}{c}r\\k\end{array}} \right)} {x^k}{y^{r - k}},r \in \mathbb{Z}\]</p><p>二项式系数也有很多有趣的性质。</p><p>\[{2^n} = \left( {\begin{array}{c}n\\0\end{array}} \right) + \left( {\begin{array}{c}n\\1\end{array}} \right) +  \cdots  + \left( {\begin{array}{c}n\\n\end{array}} \right)\]</p><p>\[{0^n} = \left( {\begin{array}{c}n\\0\end{array}} \right) - \left( {\begin{array}{c}n\\1\end{array}} \right) +  \cdots  + {( - 1)^n}\left( {\begin{array}{c}n\\n\end{array}} \right)\]<br>即奇数项系数和等于偶数项系数和。</p><p>推广到实数域：<br>\[{(1 + z)^r} = \sum\limits_k {\left( {\begin{array}{c}r\\k\end{array}} \right){z^k}} ,\left| z \right| &lt; 1,r \in \mathbb{R}\]<br>可以通过泰勒展开证明。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第11课（Stern-Brocot树和同余关系）</title>
      <link href="/2018/05/07/concrete-math-11/"/>
      <url>/2018/05/07/concrete-math-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="Stern-Brocot树"><a href="#Stern-Brocot树" class="headerlink" title="Stern-Brocot树"></a>Stern-Brocot树</h1><hr><p>我们接着上节课讲到的Stern-Brocot树继续往下讲。</p><h2 id="LR序列表示"><a href="#LR序列表示" class="headerlink" title="LR序列表示"></a>LR序列表示</h2><p>对于任意分数$\frac{a}{b}$，我们从$\frac{1}{1}$开始走到它所在的结点。如果向左走就记为L，向右走记为R，最终可以得到一个L和R的序列。例如$\frac{5}{7}$的表示就是LRRL。</p><p>这种表示产生了两个问题：</p><ol><li>给定满足正整数$m$和$n$互素的分数$\frac{m}{n}$，它所对应的LR序列是什么？</li><li>给定LR序列，它所表示的分数是什么？</li></ol><p>第二个问题看起来更好解决一点，我们先解决第二个问题。<br>我们定义<br>\[f(S) = 与S对应的分数\]<br>例如<br>\[f(LRRL) = \frac{5}{7}\]<br>如果用代码实现的话，对于每个L或者R，如果是L，那么就把右边界设为中间值，如果是R，那么就把左边界设为中间值。</p><p>但是如何用数学式子来表达这一过程呢？</p><p>我们建立一个2阶方阵：<br>\[M(S) = \left( {\begin{array}{*{20}{c}}n&amp;{n’}\\m&amp;{m’}\end{array}} \right)\]<br>表示$f(S)$的两个祖先分数$\frac{m}{n}$和$\frac{m’}{n’}$</p><p>那么初始状态就可以表示为<br>\[M(I) = \left( {\begin{array}{*{20}{c}}1&amp;0\\0&amp;1\end{array}} \right)\]</p><p>如果遇到了向左符号L，那么</p><p>\[M(SL) = \left( {\begin{array}{}n&amp;{n + n’}\\m&amp;{m + m’}\end{array}} \right) = M(S)\left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right)\]</p><p>如果遇到了向右符号R，那么<br>\[M(SL) = \left( {\begin{array}{}{n + n’}&amp;{n’}\\{m + m’}&amp;{m’}\end{array}} \right) = M(S)\left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\]<br>所以我们将L和R定义成2阶方阵就行了：<br>\[L = \left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right),R = \left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\]<br>所以<br>\[\begin{array}{l}M(LRRL) = LRRL\\ = \left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right)\left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\left( {\begin{array}{}1&amp;0\\1&amp;1\end{array}} \right)\left( {\begin{array}{}1&amp;1\\0&amp;1\end{array}} \right)\\ = \left( {\begin{array}{}3&amp;4\\2&amp;3\end{array}} \right)\end{array}\]<br>所以LRRL表示的分数为<br>\[\frac{ {2 + 3}}{ {3 + 4}} = \frac{5}{7}\]<br>那么第一个问题如何解决呢？<br>同样可以用类似二叉搜索的方法来求出LR序列，也可以用矩阵的方法来求解，根据上面的L和R的方阵，可以发现：<br>\[f(RS) = f(S) + 1\]<br>对于L也有类似的性质，所以我们得到了如下的求解算法：</p><ul><li>如果$m &gt; n$，输出R，令$m = m - n$。</li><li>如果$m &lt; n$，输出L，令$n = n - m$。</li></ul><h2 id="无理数近似表示"><a href="#无理数近似表示" class="headerlink" title="无理数近似表示"></a>无理数近似表示</h2><p>虽然说无理数不在Stern-Brocot树中，但是我们可以找到无限逼近它的分数。</p><p>方法仍然使用二叉搜索，不同的是，搜索过程不会终止，除非得到了我们想要的精度或者我们人为终止。</p><p>值得一提的是，无理数$e$的LR表示很有规律性：<br>\[e = R{L^0}RL{R^2}LR{L^4}RL{R^6}LR{L^8}RL{R^{10}}LR{L^{12}} \cdots \]</p><p>最后值得一提的是，欧几里得算法和有理数的Stern-Brocot树表示有密切的关系。给定$\alpha  = \frac{m}{n}$，根据之前的算法，它的LR表达式首先是$\left\lfloor {m/n} \right\rfloor $个R，然后是$\left\lfloor {n/(m\bmod n)} \right\rfloor $个L，依次下去，这些系数恰好就是求最大公因数的时候用到的系数。</p><h1 id="同余关系"><a href="#同余关系" class="headerlink" title="同余关系"></a>同余关系</h1><hr><p>同余定义为：<br>\[a \equiv b(\bmod m) \Leftrightarrow a\bmod m = b\bmod m\]<br>读作“a关于模m与b同余”，我们只讨论都是整数的情况。</p><p>同样可以写作：<br>\[a \equiv b(\bmod m) \Leftrightarrow a - b是m的倍数\]</p><p>同余是等价关系，满足自反律、对称律、传递律，即：<br>\[\begin{array}{l}a \equiv a\\a \equiv b \Rightarrow b \equiv a\\a \equiv b \equiv c \Rightarrow a \equiv c\end{array}\]<br>如果我们对同余两边的元素加减乘，同余仍然满足：<br>\[\begin{array}{l}a \equiv b,c \equiv d \Rightarrow a + c \equiv b + d(\bmod m)\\a \equiv b,c \equiv d \Rightarrow a - c \equiv b - d(\bmod m)\\a \equiv b,c \equiv d \Rightarrow ac \equiv bd(\bmod m)\end{array}\]<br>因此可以得到<br>\[a \equiv b \Rightarrow {a^n} \equiv {b^n}(\bmod m)\]</p><p>然而对于除法同余并不总是成立，一些特殊条件下可能成立。<br>如果<br>\[ad \equiv bd(\bmod m)\]<br>当$d,m$互素的时候，我们可以得到<br>\[a \equiv b(\bmod m)\]<br>同样<br>\[ad \equiv bd(\bmod md) \Leftrightarrow a \equiv b(\bmod m)\]<br>更一般的情况下，我们有<br>\[ad \equiv bd(\bmod m) \Leftrightarrow a \equiv b(\bmod \frac{m}{ {\gcd (d,m)}})\]<br>还有许多性质我就直接列举了，不做证明了，证明很简单：<br>\[\begin{array}{l}a \equiv b(\bmod md) \Rightarrow a \equiv b(\bmod m)\\a \equiv b(\bmod m),a \equiv b(\bmod n) \Leftrightarrow a \equiv b(\bmod lcm(m,n))\\a \equiv b(\bmod mn),m \bot n \Leftrightarrow a \equiv b(\bmod m),a \equiv b(\bmod n)\\a \equiv b(\bmod m) \Leftrightarrow \forall p,a \equiv b(\bmod {p^{ {m_p}}})\end{array}\]<br>其中$m = \prod\nolimits_p { {p^{ {m_p}}}} $是$m$的素因子分解。<br>第三条性质是中国剩余定理的特例，今后我们再做证明。</p><h1 id="独立剩余"><a href="#独立剩余" class="headerlink" title="独立剩余"></a>独立剩余</h1><hr><p>同余的应用之一就是剩余系，将整数$x$表示为一组互素的模的剩余（余数）序列：<br>\[(x\bmod {m_1}, \ldots ,x\bmod {m_r})\]<br>其中模$m$两两互素。</p><p>通过这个剩余序列可以确定出$x$的通解，其实可以看出来，这就是中国剩余定理的另一种表示形式。</p><p>这种表示形式有很多好处，比如可以直接在每个维度上面进行加减乘法。例如对于$m_1 = 3, m_2 = 5$的剩余系，有如下表示：<br>\[13 = (1,3),7 = (1,2)\]<br>那么$13 \cdot 7\,\bmod \,15$就可以这样计算：<br>\[(1 \cdot 1\bmod 3,3 \cdot 2\bmod 5) = (1,1)\]<br>所以<br>\[13 \cdot 7\bmod 15 = 1 \cdot 1\bmod 15 = 1\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第10课（素数和阶乘的有趣性质）</title>
      <link href="/2018/04/28/concrete-math-10/"/>
      <url>/2018/04/28/concrete-math-10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="欧几里得数"><a href="#欧几里得数" class="headerlink" title="欧几里得数"></a>欧几里得数</h1><hr><p>首先我们来证明一下，素数有无穷多个。</p><p>假设素数只有$k$个，分别为$2,3, \ldots ,{P_k}$，那么我们构造下面的数字：<br>\[M = 2 \cdot 3 \cdot  \ldots  \cdot {P_k} + 1\]<br>显然$M$无法被$2,3, \ldots ,{P_k}$中的任意一个整除，那么要么$M$可以被其他的素数整除，要么$M$自己就是一个素数。所以素数有无穷多个。</p><p>下面我们来定义欧几里得数，是用递归形式来定义的：<br>\[{e_n} = {e_0}{e_1}{e_2} \ldots {e_{n - 1}} + 1\]</p><p>那么欧几里得数是否是素数呢？当然不是的，${e_5} = 1807 = 13 \cdot 139$。</p><p>但是欧几里得数还是有很多奇妙的性质。</p><p><strong>性质1</strong><br>\[\gcd ({e_m},{e_n}) = 1,m \ne n\]<br><strong>证明：</strong><br>假设$n &gt; m$，那么有<br>\[\gcd ({e_m},{e_n}) = \gcd ({e_m},{e_0}{e_1} \ldots {e_m}{e_{m + 1}} \ldots {e_{n - 1}} + 1) = \gcd (1,{e_m}) = 1\]<br><strong>性质2</strong><br>如果令$q_j$等于$e_j$的最小素因子，那么${q_1},{q_2}, \ldots $就是一个不重复的素数序列，这也证明了素数有无穷多个。<br><strong>性质3</strong><br>\[{e_n} = {e_0}{e_1}{e_2} \ldots {e_{n - 1}} + 1 = ({e_{n - 1}} - 1){e_{n - 1}} + 1 = e_{n - 1}^2 - {e_{n - 1}} + 1\]<br>在后面的章节可以证明：<br>\[{e_n} = \left\lfloor { {E^{ {2^n}}} + \frac{1}{2}} \right\rfloor \]<br>其中$E \approx 1.264$</p><p>下面我们稍稍探究一下下面这个数的性质：<br>\[{2^p} - 1\]<br>这个数如果是素数，那么就被叫做<strong>梅森素数</strong>，那么它在什么情况下是素数呢？</p><p>首先$p$不能是合数，因为有<br>\[{2^{km}} - 1 = ({2^m} - 1)({2^{m(k - 1)}} + {2^{m(k - 2)}} +  \cdots  + 1)\]<br>但是如果$p$是素数，这个数也不一定是素数，2017年年末美国一个电气工程师发现了人类历史上最大的梅森素数——${2^{77232917}} - 1$。</p><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><p>阶乘定义如下：<br>\[n! = 1 \cdot 2 \cdot  \ldots  \cdot n = \prod\limits_{k = 1}^n k \]<br>所以有<br>\[n{!^2} = (1 \cdot 2 \cdot  \ldots  \cdot n)(n \cdot  \ldots  \cdot 2 \cdot 1) = \prod\limits_{k = 1}^n {k(n + 1 - k)} \]<br>由基本不等式可以得到<br>\[n \le k(n + 1 - k) \le \frac{ { { {(n + 1)}^2}}}{4}\]<br>所以<br>\[\prod\limits_{k = 1}^n n  \le n{!^2} \le \prod\limits_{k = 1}^n {\frac{ { { {(n + 1)}^2}}}{4}} \]<br>所以<br>\[{n^{n/2}} \le n! \le \frac{ { { {(n + 1)}^n}}}{ { {2^n}}}\]<br>这里得到了阶乘的一个粗略范围，在后面章节中，我们会得到阶乘的一个更精确的表达式：<br>\[n! \sim \sqrt {2\pi n} {\left( {\frac{n}{e}} \right)^n}\]<br>这就是斯特林数，搞ACM还是很有用的。</p><p>下面我们来探讨$n!$中含有多少个素因子$p$，个数记为${\varepsilon _p}(n!)$。</p><p>从特殊情况讨论起，当$p = 2$的时候，我们首先看$n!$含有多少个2，然后看有多少个4，再看有多少个8，依次下去，所以答案为：<br>\[{\varepsilon _2}(n!) = \sum\limits_{k \ge 1} {\left\lfloor {\frac{n}{ { {2^k}}}} \right\rfloor } \]<br>可以看出，这个答案不就是$n$的二进制表示不停右移1位，然后相加吗？所以又可以写成：<br>\[{\varepsilon _2}(n!) = n - {\nu _2}(n)\]<br>其中${\nu _2}(n)$表示$n$的二进制表示中1的个数。</p><p>推广到一般情况：<br>\[{\varepsilon _p}(n!) = \sum\limits_{k \ge 1} {\left\lfloor {\frac{n}{ { {p^k}}}} \right\rfloor } \]<br>放缩一下有：<br>\[{\varepsilon _p}(n!) = \sum\limits_{k \ge 1} {\left\lfloor {\frac{n}{ { {p^k}}}} \right\rfloor }  &lt; \sum\limits_{k \ge 1} {\frac{n}{ { {p^k}}} = \frac{n}{ {p - 1}}} \]</p><p>如果我们令$p = 2$和$p = 3$可以发现：<br>\[{\varepsilon _2}(n!) \approx 2{\varepsilon _3}(n!)\]<br>但是这个式子在什么情况下相等呢？这仍然是一个未解之谜。</p><p>所以$p$对$n!$的贡献度满足如下式子：<br>\[{p^{ {\varepsilon _p}(n!)}} &lt; {p^{\frac{n}{ {p - 1}}}}\]<br>又因为$p \le 2^{p - 1}$，所以<br>\[{p^{ {\varepsilon _p}(n!)}} &lt; {p^{\frac{n}{ {p - 1}}}} \le {2^n}\]<br>假设素数只有$k$个，分别为$2,3, \ldots ,{P_k}$，那么有<br>\[n! &lt; {({2^n})^k}\]<br>如果我们令$n = {2^{2k}}$，那么<br>\[n! &lt; {({2^n})^k} = {2^{k{2^{2k}}}} = {2^{2k{2^{2k}}/2}} = {n^{n/2}}\]<br>这与我们之前推过的不等式矛盾！所以一定有无穷个素数。</p><p>设小于等于$n$的素数个数为$\pi (n)$，所以<br>\[n! &lt; {2^{n\pi (n)}}\]<br>根据斯特林数公式，我们可以得到<br>\[\pi (n) &gt; \lg (n/e)\]</p><h1 id="互素"><a href="#互素" class="headerlink" title="互素"></a>互素</h1><hr><p><strong>定义</strong><br>$m$和$n$互素定义为$gcd(m, n) = 1$，记作$m \bot n$。</p><p>互素也有很多性质。</p><p><strong>性质1</strong><br>\[m/\gcd (m,n) \bot n/\gcd (m,n)\]<br><strong>性质2</strong><br>\[m \bot n \Leftrightarrow \min ({m_p},{n_p}) = 0\]<br>其中${m_p},{n_p}$就是两个数的素数指数表示法，详细定义见上一节课。<br>或者可以表示为<br>\[m \bot n \Leftrightarrow {m_p}{n_p} = 0\]<br><strong>性质3</strong><br>\[k \bot m,k \bot n \Leftrightarrow k \bot mn\]</p><h1 id="Stern-Brocot树"><a href="#Stern-Brocot树" class="headerlink" title="Stern-Brocot树"></a>Stern-Brocot树</h1><hr><p><img src="1.png" alt><br>如上图所示，Stern-Brocot树就是0到1之间的分数生成的一棵二叉树。</p><p>初始时只有$\frac{0}{1},\frac{1}{0}$两个数，第一轮将两者分母相加，分子也相加作为新的分数的分母分子。第二轮再对相邻的两个分数做相同的操作，生成新的分数序列。不断生成下去，得到了上图的二叉树。</p><p>Stern-Brocot树有下面四个性质：</p><ol><li>0到1之间的所有有理数都出现在了这棵树中。</li><li>每个分数仅出现了1次。</li><li>每个分数都是不可约分的，即分子分母互素。</li><li>生成的序列是单调递增的。</li></ol><p>下面我们来一个一个证明。</p><p><strong>引理</strong><br>对于相邻的两个分数$\frac{m}{n},\frac{ {m’}}{ {n’}}$，满足：<br>\[m’n - mn’ = 1\]<br><strong>证明</strong><br>用数学归纳法证明。</p><p>性质4就是证明：<br>\[\frac{m}{n} &lt; \frac{ {m + m’}}{ {n + n’}} &lt; \frac{ {m’}}{ {n’}}\]<br>结论是很显然的，这样性质2同时就成立了。</p><p>性质1的话，对于任意有理数$\frac{a}{b}$，假设$\frac{m}{n} &lt; \frac{a}{b} &lt; \frac{ {m’}}{ {n’}}$。<br>我们采用如下策略生成$\frac{a}{b}$。</p><ul><li>如果$\frac{ {m + m’}}{ {n + n’}} = \frac{a}{b}$，那么成功。</li><li>如果$\frac{ {m + m’}}{ {n + n’}} &lt; \frac{a}{b}$，那么令$m = m + m’,n = n + n’$。</li><li>如果$\frac{ {m + m’}}{ {n + n’}} &gt; \frac{a}{b}$，那么令$m’ = m + m’,n’ = n + n’$。</li></ul><p>那么有<br>\[an - bm \ge 1,bm’ - an’ \ge 1\]<br>所以<br>\[(m’ + n’)(an - bm) + (m + n)(bm’ - an’) \ge m’ + n’ + m + n\]<br>而左边式子就等于$a + b$，所以<br>\[a + b \ge m’ + n’ + m + n\]<br>因为$m,n,m’,n’$都在不断增加，所以最多$a + b$轮就能生成$\frac{a}{b}$。</p><p>性质3的话，同样用数学归纳法。通过引理可以得到<br>\[(m + m’)n - m(n + n’) = 1\]<br>由扩展欧几里得定理可以得到$m + m’$与$n + n’$互素。</p><p><strong>Farey序列</strong><br>我们引申出Farey序列的概念，定义如下：<br>\[{F_n} = \{ a/b|\gcd (a,b) = 1,0 \le a,b \le n,0 \le a/b \le 1\} \]<br>关于它的更多性质，留到下一节课继续。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-best Iterative Viterbi Parsing</title>
      <link href="/2018/04/24/ivp-eacl17/"/>
      <url>/2018/04/24/ivp-eacl17/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>本文链接：<a href="https://www.aclweb.org/anthology/E/E17/E17-2049.pdf" target="_blank" rel="noopener">EACL17</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>CKY算法或维特比inside算法是成分句法分析的主要方法之一，但是当产生式数量特别大之后，时间复杂度也线性增大。可行的一种方法是剪枝，但是剪枝会造成准确率的下降。所以本文就提出了一种迭代的维特比句法分析算法，通过剪枝去除掉没用的边。实验表明，时间上加快了一个数量级，但是本文并没有说准确率怎么样。。。</p><p>本文用到的inside和outside算法之前已经介绍过了，详见<a href="http://godweiyang.com/2018/04/19/inside-outside/">PCFG中inside和outside算法详解</a>。</p><h1 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h1><hr><h2 id="分层聚类"><a href="#分层聚类" class="headerlink" title="分层聚类"></a>分层聚类</h2><p>首先提出分层聚类的概念。</p><p><img src="1.jpg" alt><br>如上图所示，原来的类别标记有很多，将他们聚类成几个小类，再将这几个小类聚成更小的类，依次下去，最后类别标记会少很多很多。<br><img src="2.jpg" alt><br>以上图为例，${X_1}{\rm{ = \{ }}A,B{\rm{\} ,}}{X_2}{\rm{ = \{ }}C,D{\rm{\} }}$，聚类之后的分析表为b图，原始的分析表为a图，聚类之后的表（下面叫<strong>粗表</strong>）b唯一对应了聚类之前的表（下面叫<strong>原始表</strong>）a，而反过来原始表a能对应多种不同的粗表b。</p><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>我们将类别分为$m + 1$层，分别表示为${N_0} \ldots {N_m}$，那么第$m$层的类别集合$N_m$就是原始的类别集合，而$0$到$m - 1$层的类别就称之为<strong>收缩符号</strong>。</p><p>对于$0 \le i \le j \le m$，我们定义${\pi _{i \to j}}:{N_i} \mapsto \Im ({N_j})$，其中$\Im ({N_j})$就是$N_j$的一个子集。该式将$N_i$中的一个类别$X_i$映射为了$N_j$中所有聚类为$X_i$的类别集合。</p><p>举个例子吧，在第一张图中，${\pi _{1 \to 2}}(ADJ\_) = \{ JJ,JJR,JJS\} $。如果$i = j$，那么${\pi _{i \to j}}(A) = \{ A\} $。</p><p>那么对于${X_i} \in {N_i},{X_j} \in {N_j},{X_k} \in {N_k}$，我们定义产生式${X_i} \to {X_j}{X_k}$的概率为：<br>\[\log q({X_i} \to {X_j}{X_k}) = \mathop {\max }\limits_{\scriptstyle A \in {\pi _{i \to m}}({X_i})\atop{\scriptstyle B \in {\pi _{j \to m}}({X_j})\atop\scriptstyle C \in {\pi _{k \to m}}({X_k})}} \log q(A \to BC)\]<br>也就是说，粗表中的每一棵句法树都给出了它在原始表中的句法树的分数的上界，通俗说就是，如果把粗表中的收缩符号全部替换成原始表中的符号，那么新的句法树的分数一定会小于等于粗表中的句法树。</p><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><blockquote><p>如果粗表中的最优句法树${\hat d}$不包含任意收缩符号，那么它等价于原始表中的最优句法树。</p></blockquote><p><strong>证明：</strong><br>令$Y$等于原始表中的句法树集合，$Y’ \subset Y$等于没有出现在粗表中，但是出现在原始表中的句法树集合，${Y’’}$等于粗表中的句法树集合。</p><p>那么对于每一个句法树$d \in Y’$，都存在唯一的句法树$d’ \in Y’’$与之对应。所以可以推出：<br>\[\forall d \in Y,\exists d’ \in Y’’,s(d) \le s(d’) &lt; s(\hat d)\]<br>这就意味着$\hat d$也是原始表中的最优句法树。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="3.jpg" alt></p><ul><li><p>$lb$初始化为句法树的最优得分或者负无穷，其中<code>det()</code>用来求解句法树的最优得分，但是没有必要真的求出最优句法树，只需要在每个结点处保留得分最高的边即可。尽管这样得出来的句法树基本不是最高的，但是能够缩小$lb$范围即可。</p></li><li><p><code>init-chart()</code>首先初始化分析表，全部初始化为收缩符号。</p></li><li><p>然后开始迭代过程，首先执行维特比inside算法，也就是CKY算法<code>Viterbi-inside()</code>，得到最优句法树$\hat d$。</p></li><li><p>如果最优句法树不含有任意收缩符号，那么迭代结束，直接返回该句法树。</p></li><li><p>否则的话，更新$lb$为最优句法树的分数<code>best()</code>。</p></li><li><p><code>expand-chart()</code>将所有收缩符号替换为下一层的收缩符号。</p></li><li><p><code>Viterbi-outside()</code>计算outside值。</p></li><li><p><code>prune-chart()</code>进行剪枝，过滤掉无用的边。</p></li></ul><h2 id="剪枝过程"><a href="#剪枝过程" class="headerlink" title="剪枝过程"></a>剪枝过程</h2><p>算法的重要部分就是<code>prune-chart()</code>剪枝过程，这里要详细讲一下。</p><p>对于一条边$e = (A,i,j)$，定义$\alpha \beta (e) = \alpha (e) + \beta (e)$为含有边$e$的句法树的最大分数。那么如果<br>$\alpha \beta (e) &lt; lb$，这条边$e$就没有搜索的必要了，可以从分析表中去掉。</p><p>但是每次迭代都从原始表中计算$\alpha \beta (e)$值太麻烦了，可以在每次迭代的时候计算粗表中的值：<br>\[\alpha \beta (e) \le \hat \alpha (e) + \hat \beta (e) = \hat {\alpha \beta} (e)\]</p><p>所以当$\hat {\alpha \beta} (e) &lt; lb$时，从分析表中删除这条边。虽然搜索空间减少了，但是不影响算法的迭代轮数。</p><p>虽然在<code>expand-chart()</code>这一步要扩展收缩符号为下一层所有符号，但是实际运行起来时间比普通的CKY算法大大减少。</p><h2 id="K-best扩展"><a href="#K-best扩展" class="headerlink" title="K-best扩展"></a>K-best扩展</h2><p><img src="4.jpg" alt></p><p>基本框架和1-best是一样的，主要思路就是首先求出最优句法树，如果包含收缩符号，那么就下面步骤和1-best一样。否则的话求出后面k-1棵最优的句法树，如果都不包含收缩符号，直接返回k-best棵句法树。否则从中选出最好的一棵含有收缩符号的句法树，下面的步骤和1-best一样。</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>数据集用的是PTB中长度小于35的句子。<br><img src="5.jpg" alt></p><p>上面这张表显示出，IVP算法的边的数量远远小于CKY算法，虽然迭代次数大大增加，但是总时间仍然远远小于CKY算法，而且边数减少了之后inside和outside算法的时间可以忽略不计了。最后一行是平均数据。<br><img src="6.jpg" alt><br>上图说明了，当k较小时，IVP算法时间快于普通的k-best算法，但是k大了之后就变慢了，原因如下图所示：<br><img src="7.jpg" alt><br>当k太大了之后，lb不能很好的得到最优得分的下界，所以无法有效地剪枝。而且k越小，算法收敛的也越快。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><hr><p>提出了K-best IVP算法，基本框架还是inside-outside算法。</p><p>但是全文自始自终没有提及算法的准确率，感觉应该不是很高，不知道有没有又高又快的优化方法？</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
            <tag> EACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第9课（取整进阶与数论入门）</title>
      <link href="/2018/04/23/concrete-math-9/"/>
      <url>/2018/04/23/concrete-math-9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天讲完了取整的最后一部分知识，并给第四章数论开了个头。</p><p>首先还是以一道例题开始我们今天的课程。</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>求和：<br>\[\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor } \]</p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>首先令$m = \left\lfloor {\sqrt k } \right\rfloor $<br>那么有<br>\[\begin{array}{l}\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor }  = \sum\limits_{k,m \ge 0} {m\left[ {k &lt; n} \right]\left[ {m = \left\lfloor {\sqrt k } \right\rfloor } \right]} \\ = \sum\limits_{k,m \ge 0} {m\left[ {k &lt; n} \right]\left[ {m \le \sqrt k  &lt; m + 1} \right]} \\ = \sum\limits_{k,m \ge 0} {m\left[ {k &lt; n} \right]\left[ { {m^2} \le k &lt; { {(m + 1)}^2}} \right]} \\ = \sum\limits_{k,m \ge 0} {m\left[ { {m^2} \le k &lt; { {(m + 1)}^2} \le n} \right]} \\ + \sum\limits_{k,m \ge 0} {m\left[ { {m^2} \le k &lt; n &lt; { {(m + 1)}^2}} \right]} \end{array}\]<br>我们先算左半部分，先假设$n = {a^2}$，那么有<br>\[\begin{array}{l}\sum\limits_{k,m \ge 0} {m\left[ { {m^2} \le k &lt; { {(m + 1)}^2} \le {a^2}} \right]} \\ = \sum\limits_{m \ge 0} {m(2m + 1)\left[ {m &lt; a} \right]} \\ = \frac{1}{6}(4a + 1)a(a - 1)\end{array}\]<br>而对于一般的$n$，令$a = \left\lfloor {\sqrt n } \right\rfloor $，我们只需要计算${a^2} \le k &lt; n$的部分，而这部分$\sqrt k  = a$，所以结果为$(n - {a^2})a$。</p><p>所以总的结果为：<br>\[\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor }  = na - \frac{1}{3}{a^3} - \frac{1}{2}{a^2} - \frac{1}{6}a,a = \left\lfloor {\sqrt n } \right\rfloor \]</p><p>这里解释一下为什么没有算右半部分？因为右半部分就是${a^2} \le k &lt; n$的这部分，已经计算过了。</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>因为$\left\lfloor x \right\rfloor  = \sum\nolimits_j {\left[ {1 \le j \le x} \right]} $，所以可以将原式替换掉，还是令$n = {a^2}$，然后如下计算：<br>\[\begin{array}{l}\sum\limits_{0 \le k &lt; n} {\left\lfloor {\sqrt k } \right\rfloor }  = \sum\limits_{j,k} {\left[ {1 \le j \le \sqrt k } \right]\left[ {0 \le k &lt; {a^2}} \right]} \\ = \sum\limits_{1 \le j &lt; a} {\sum\limits_k {\left[ { {j^2} \le k &lt; {a^2}} \right]} } \\ = \sum\limits_{1 \le j &lt; a} {({a^2} - {j^2})}  = {a^3} - \frac{1}{3}a(a + \frac{1}{2})(a + 1)\end{array}\]<br>其中第二行交换了变量计算顺序。</p><h1 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h1><hr><p>这里直接介绍一个定理，就不证明了，过程比较复杂：<br>\[\mathop {\lim }\limits_{n \to \infty } \frac{1}{n}\sum\limits_{0 \le k &lt; n} {f(\{ k\alpha \} )}  = \int_0^1 {f(x)dx} \]<br>其中$\alpha $是一个无理数。</p><p>这个公式说明了，无理数$\alpha $的整数倍的小数部分均匀分布在$(0,1)$之间。</p><p>这就给了我们一个启示，我们可以用它来生成随机数啊！其他用处还有很多，自己想咯。</p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><hr><p>求如下和式：<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor } \]<br>其中整数$m &gt; 0$，$n$也是整数。</p><p>通过枚举$m = 1,2,3, \ldots $，可以发现和式满足如下形式：<br>\[a\left\lfloor {\frac{x}{a}} \right\rfloor  + bn + c\]<br>那么怎么计算出来呢？</p><p>首先做一个变形：<br>\[\left\lfloor {\frac{ {x + kn}}{m}} \right\rfloor  = \left\lfloor {\frac{ {x + kn\bmod m}}{m}} \right\rfloor  + \frac{ {kn}}{m} - \frac{ {kn\bmod m}}{m}\]<br>这就将原来的和式分为了三个部分求和。</p><p><strong>第一个部分为：</strong><br>\[\left\lfloor {\frac{x}{m}} \right\rfloor  + \left\lfloor {\frac{ {x + n\bmod m}}{m}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {x + (m - 1)n\bmod m}}{m}} \right\rfloor \]<br>具体怎么算留到下一章节，这里通过枚举可以发现它的值是有周期的，周期重复次数是$d = \gcd (m,n)$。所以算出来结果为：<br>\[\begin{array}{l}d\left( {\left\lfloor {\frac{x}{m}} \right\rfloor  + \left\lfloor {\frac{ {x + d}}{m}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {x + m - d}}{m}} \right\rfloor } \right)\\ = d\left( {\left\lfloor {\frac{ {x/d}}{ {m/d}}} \right\rfloor  + \left\lfloor {\frac{ {x/d + 1}}{ {m/d}}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {x/d + m/d - 1}}{ {m/d}}} \right\rfloor } \right)\\ = d\left\lfloor {\frac{x}{d}} \right\rfloor \end{array}\]<br><strong>第二个部分为：</strong><br>\[\sum\limits_{0 \le k &lt; m} {\frac{ {kn}}{m}}  = \frac{ {(m - 1)n}}{2}\]<br><strong>第三个部分为：</strong><br>\[d\left( {\frac{0}{m} + \frac{d}{m} +  \cdots  + \frac{ {m - d}}{m}} \right) = \frac{ {m - d}}{2}\]</p><p>所以总的结果为：<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor }  = d\left\lfloor {\frac{x}{d}} \right\rfloor  + \frac{ {(m - 1)n}}{2} + \frac{ {d - m}}{2}\]</p><p>这里我们对结果稍稍变形，可以得到另一个结果：<br>\[\begin{array}{l}\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor }  = d\left\lfloor {\frac{x}{d}} \right\rfloor  + \frac{ {(m - 1)(n - 1)}}{2} + \frac{ {m - 1}}{2} + \frac{ {d - m}}{2}\\ = d\left\lfloor {\frac{x}{d}} \right\rfloor  + \frac{ {(m - 1)(n - 1)}}{2} + \frac{ {d - 1}}{2}\end{array}\]<br>可以发现，$m$和$n$是对称的！所以可以得到如下结论：<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {nk + x}}{m}} \right\rfloor }  = \sum\limits_{0 \le k &lt; n} {\left\lfloor {\frac{ {mk + x}}{n}} \right\rfloor } \]<br>这有什么用呢？当$m$特别大、$n$很小的时候可以大大减少项的个数！</p><p>如果我们令$n=1$，就会发现，得到的式子和之前证过的一个式子一模一样！<br>\[\sum\limits_{0 \le k &lt; m} {\left\lfloor {\frac{ {k + x}}{m}} \right\rfloor }  = \left\lfloor x \right\rfloor \]</p><p>到这里为止，第三章取整就讲完了，下面开始讲第四章数论部分。</p><h1 id="数论相关性质"><a href="#数论相关性质" class="headerlink" title="数论相关性质"></a>数论相关性质</h1><hr><h2 id="整除定义"><a href="#整除定义" class="headerlink" title="整除定义"></a>整除定义</h2><p>\[m|n \Leftrightarrow m &gt; 0,n = mk,k \in \mathbb{Z}\]<br>注意这里整除的定义中要求$m&gt;0$。</p><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p>定义我就不说了，大家应该都知道的。</p><h2 id="欧几里得定理"><a href="#欧几里得定理" class="headerlink" title="欧几里得定理"></a>欧几里得定理</h2><p>又叫辗转相除法，就是用来求最大公约数的。<br>\[\begin{array}{l}\gcd (0,n) = n\\\gcd (m,n) = \gcd (n\bmod m,m)\end{array}\]</p><h2 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h2><p>在用欧几里得定理求到最大公约数之后，反过来可以将最大公约数表示为两个数的线性和：<br>\[\gcd (m,n) = m’m + n’n\]</p><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>如果$k|m,k|n$，那么$k|gcd(m,n)$。</p><h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>\[\sum\limits_{m|n} { {a_m}}  = \sum\limits_{m|n} { {a_{n/m}}} \]<br>这个就是用了交换律，按照因子顺序倒过来算。</p><h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>\[\sum\limits_{m|n} { {a_m}}  = \sum\limits_k {\sum\limits_{m &gt; 0} { {a_m}[n = mk]} } \]<br>这个虽然变成了二重求和，但是对于每个$k$，其实只有一个$m$有效。</p><h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>\[\sum\limits_{m|n} {\sum\limits_{k|m} { {a_{k,m}}} }  = \sum\limits_{k|n} {\sum\limits_{l|(n/k)} { {a_{k,kl}}} } \]<br>这个一眼就不一定能看出来了。</p><p>左边等于：<br>\[\begin{array}{l}\sum\limits_{m|n} {\sum\limits_{k|m} { {a_{k,m}}} }  = \sum\limits_{j,l} {\sum\limits_{k,m &gt; 0} { {a_{k,m}}[n = jm][m = kl]} } \\ = \sum\limits_j {\sum\limits_{k,l &gt; 0} { {a_{k,kl}}[n = jkl]} } \end{array}\]<br>右边等于：<br>\[\begin{array}{l}\sum\limits_{k|n} {\sum\limits_{l|(n/k)} { {a_{k,kl}}} }  = \sum\limits_{j,m} {\sum\limits_{k,l &gt; 0} { {a_{k,kl}}[n = jk][n/k = ml]} } \\ = \sum\limits_m {\sum\limits_{k,l &gt; 0} { {a_{k,kl}}[n = mlk]} } \end{array}\]<br>可以看出左右两边相等。</p><h2 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h2><p>一个整数可以唯一表示为若干个素数乘积：<br>\[n = \prod\limits_p { {p^{ {n_p}}}} ,{n_p} \ge 0\]<br>所以用指数形式来表示一个整数$n$，例如$18 = {2^1} \times {3^2}$，那么$18$可以表示为：<br>\[ &lt; 1,2,0,0, \ldots  &gt; \]<br>最大公约数和最小公倍数也能很方便的用指数形式计算：<br>其中最大公约数的每个素数的指数等于两个数对应指数最小值，最小公倍数的每个素数的指数等于两个数对应指数最大值。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第三章作业解答</title>
      <link href="/2018/04/20/concrete-math-hw3/"/>
      <url>/2018/04/20/concrete-math-hw3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h1><hr><p><strong>题目</strong><br>求$\left\lfloor {nx} \right\rfloor  = n\left\lfloor x \right\rfloor $的充要条件。<br><strong>解答</strong><br>因为</p><p>\[<br>x = \left\lfloor x \right\rfloor  + \{ x\}<br>\]<br>所以</p><p>\[<br>\left\lfloor {nx} \right\rfloor  = \left\lfloor {n(\left\lfloor x \right\rfloor  + \{ x\} )} \right\rfloor  = n\left\lfloor x \right\rfloor  + \left\lfloor {n\{ x\} } \right\rfloor<br>\]<br>要使得$\left\lfloor {nx} \right\rfloor  = n\left\lfloor x \right\rfloor$，就必须有</p><p>\[<br>\left\lfloor {n\{ x\} } \right\rfloor  = 0<br>\]<br>所以</p><p>\[<br>n\{ x\}  &lt; 1<br>\]<br>即</p><p>\[<br>\{ x\}  &lt; \frac{1}{n}<br>\]</p><h1 id="题7"><a href="#题7" class="headerlink" title="题7"></a>题7</h1><hr><p><strong>题目</strong><br>求下列递推式<br>\[\begin{array}{l}{X_n} = n,0 \le n &lt; m\\{X_n} = {X_{n - m}} + 1,n \ge m\end{array}\]<br><strong>解答</strong><br>因为</p><p>\[<br>n - \left\lfloor {\frac{n}{m}} \right\rfloor m = n\bmod m &lt; m<br>\]<br>所以</p><p>\[<br>\begin{array}{l}{X_n} = {X_{n - m}} + 1 = {X_{n - 2m}} + 2 =  \cdots \\ = {X_{n - \left\lfloor {\frac{n}{m}} \right\rfloor m}} + \left\lfloor {\frac{n}{m}} \right\rfloor  = n - \left\lfloor {\frac{n}{m}} \right\rfloor m + \left\lfloor {\frac{n}{m}} \right\rfloor \\ = n\,\bmod \,m + \left\lfloor {\frac{n}{m}} \right\rfloor \end{array}<br>\]</p><h1 id="题8"><a href="#题8" class="headerlink" title="题8"></a>题8</h1><hr><p><strong>题目</strong><br>$n$个物品放到$m$个盒子中，求证至少有一个盒子物品数大于等于$\left\lceil {\frac{n}{m}} \right\rceil$，至少有一个盒子物品数小于等于$\left\lfloor {\frac{n}{m}} \right\rfloor$。<br><strong>解答</strong><br>假设所有的盒子物品数都小于$\left\lceil {\frac{n}{m}} \right\rceil$，那么总物品数$S$满足</p><p>\[<br>S \le m(\left\lceil {\frac{n}{m}} \right\rceil  - 1)<br>\]<br>令$n = qm + r,0 \le r &lt; m$，那么有</p><p>\[<br>S \le m(\left\lceil {q + \frac{r}{m}} \right\rceil  - 1) = qm - m + m\left\lceil {\frac{r}{m}} \right\rceil<br>\]<br>如果$r=0$，那么有</p><p>\[<br>S \le qm - m &lt; n<br>\]<br>如果$r&gt;0$，那么有</p><p>\[<br>S \le qm &lt; n<br>\]<br>这与$S=n$矛盾！所以至少有一个盒子物品数大于等于$\left\lceil {\frac{n}{m}} \right\rceil$。</p><p>假设所有的盒子物品数都大于$\left\lfloor {\frac{n}{m}} \right\rfloor$，那么总物品数$S$满足</p><p>\[<br>S \ge m(\left\lfloor {\frac{n}{m}} \right\rfloor  + 1)<br>\]<br>令$n = qm + r,0 \le r &lt; m$，那么有</p><p>\[<br>S \ge m(\left\lfloor {q + \frac{r}{m}} \right\rfloor  + 1) = qm + m + m\left\lfloor {\frac{r}{m}} \right\rfloor  = qm + m &gt; qm + r = n<br>\]<br>这与$S=n$矛盾！所以至少有一个盒子物品数小于等于$\left\lfloor {\frac{n}{m}} \right\rfloor$。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inside-outside Algorithm in PCFG</title>
      <link href="/2018/04/19/inside-outside/"/>
      <url>/2018/04/19/inside-outside/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>inside-outside算法是用来预测一棵句法分析树的概率的算法，算法建立在文法是乔姆斯基范式（CFG）的基础之上，CFG的定义见<a href="https://en.wikipedia.org/wiki/Chomsky_normal_form" target="_blank" rel="noopener">维基百科</a>。一棵句法分析树的potential定义为它包含的产生式的potential乘积，在PCFG中表示概率，在CRF-CFG中表示特征集合的分数。</p><p>inside-outside算法需要定义两个变量：</p><ul><li>$\alpha (A,i,j)$定义为内部的potential之和，即以$A$为根结点，短语为${x_{i;j}}$的所有可能的子树的potential之和。</li><li>$\beta (A,i,j)$定义为外部的potential之和，即以$A$为根结点，短语为${x_{1;i - 1}}A{x_{j + 1;n}}$的所有可能的子结构的potential之和。</li></ul><p><strong>给定文法CFG，输入字符串${x_{1;n}}$，计算inside和outside值。</strong></p><h1 id="inside"><a href="#inside" class="headerlink" title="inside"></a>inside</h1><hr><p>初始化：<br>如果$A \to {x_i} \in R$，那么$\alpha (A,i,i) = \varphi (A \to {x_i},i,i,i)$。否则就等于0。<br>其中$\varphi (A \to {x_i},i,i,i)$为potential值。</p><p>类似于CKY算法，自底向上计算inside值：<br>\[\alpha (A,i,j) = \sum\limits_{A \to BC \in R} {\sum\limits_{k = i}^{j - 1} {\varphi (A \to BC,i,k,j) \cdot \alpha (B,i,k) \cdot \alpha (C,k + 1,j)} } \]</p><h1 id="outside"><a href="#outside" class="headerlink" title="outside"></a>outside</h1><hr><p>初始化：<br>$\beta (S,1,n) = 1$，其余都等于0。</p><p>outside值要分为两部分计算：<br><img src="1.jpg" alt><br>第一部分是${B \to AC}$，如上图所示。<br><img src="2.jpg" alt><br>第二部分是${B \to CA}$，如上图所示。</p><p>和inside相反，通过自顶向下计算outside值：<br>\[\begin{array}{l}\beta (A,i,j) = \sum\limits_{B \to AC \in R} {\sum\limits_{k = j + 1}^n {\varphi (B \to AC,i,j,k) \cdot \beta (B,i,k) \cdot \alpha (C,j + 1,k)} } \\ + \sum\limits_{B \to CA \in R} {\sum\limits_{k = 1}^{i - 1} {\varphi (B \to CA,k,i - 1,j) \cdot \beta (B,k,j) \cdot \alpha (C,k,i - 1)} } \end{array}\]</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><hr><p>所有可能的句法树potential之和为：<br>\[{Z_s} = \alpha (S,1,n)\]<br>包含产生式$(A \to BC,i,k,j)$的所有可能句法树potential之和是：<br>\[\mu (A \to BC,i,k,j) = \varphi (A \to BC,i,k,j) \cdot \beta (A,i,j) \cdot \alpha (B,i,k) \cdot \alpha (C,k + 1,j)\]<br>存在非终结符$A$，且短语是${x_{i;j}}$的所有可能句法树potential之和是：<br>\[\mu (A,i,j) = \alpha (A,i,j) \cdot \beta (A,i,j)\]</p><h1 id="PCFG参数估计"><a href="#PCFG参数估计" class="headerlink" title="PCFG参数估计"></a>PCFG参数估计</h1><hr><p>参数估计的目的就是为了估计出PCFG的概率$P$，使得所有句子的概率之和最大，采用的是EM迭代法。<br>首先定义：<br>\[\varphi (A \to BC,i,k,j) = P(A \to BC)\]<br>这里$P(A \to BC)$是随机初始化的，满足归一化条件就行。<br>对于语料库的每一条句子，可以计算出：<br>\[\begin{array}{l}count(A \to BC) = \frac { {\sum\limits_{i,k,j} {\mu (A \to BC,i,k,j)} }}{ { {Z_s}}}\\P(A \to BC) = \frac{ {count(A \to BC)}}{ {\sum\limits_r {count(r)} }}\end{array}\]<br>然后算出期望，更新概率，迭代就行了。</p><h1 id="CRF-CFG参数估计"><a href="#CRF-CFG参数估计" class="headerlink" title="CRF-CFG参数估计"></a>CRF-CFG参数估计</h1><hr><p>首先定义:<br>\[\varphi (A \to BC,i,k,j) = \exp \sum\limits_t { {\theta _t}{f_t}(A \to BC,i,k,j)} \]<br>其中$f_t$为特征函数。<br>那么我们的目的就是训练特征参数$\theta$。<br>然后定义似然函数为<br>\[L(D;\theta ) = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s) - {Z_s}} } } \right)}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \]<br>求偏导为<br>\[\frac{ {\partial L(D;\theta )}}{ {\partial {\theta _i}}} = \sum\limits_{(t,s) \in D} {(\sum\limits_{r \in t} { {f_i}(r,s)}  - {E_\theta }[{f_i}|s])}  + \frac{ { {\theta _i}}}{ { {\sigma ^2}}}\]</p><p>这里可能有人看不懂，似然函数和偏导是怎么来的呢？下面我详细写一下过程。<br>似然函数：<br>\[\begin{array}{l}L(D;\theta ) = \sum\limits_{(t,s) \in D} {\log \frac{ {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } }}{ {\sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } }}}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \\ = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} }  - \log \sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } } \right)}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \\ = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} }  - {Z_s}} \right)}  + \sum\limits_i {\frac{ {\theta _i^2}}{ {2{\sigma ^2}}}} \end{array}\]<br>所以偏导为：<br>\[\frac{ {\partial L(D;\theta )}}{ {\partial {\theta _i}}} = \sum\limits_{(t,s) \in D} {\left( {\sum\limits_{r \in t} { {f_i}(r,s)}  - \frac{ {\partial \left( {\log \sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } } \right)}}{ {\partial {\theta _i}}}} \right)}  + \frac{ { {\theta _i}}}{ { {\sigma ^2}}}\]<br>而<br>\[\begin{array}{l}\frac{ {\partial \left( {\log \sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } } \right)}}{ {\partial {\theta _i}}}\\ = \frac{ {\sum\limits_{t \in T(s)} {\left( {\left( {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } \right) \cdot \sum\limits_{r \in t} { {f_i}(r,s)} } \right)} }}{ {\sum\limits_{t \in T(s)} {\exp \sum\limits_{r \in t} {\sum\limits_i { {\theta _i}{f_i}(r,s)} } } }}\\ = {E_\theta }[{f_i}|s]\end{array}\]<br>所以偏导就是这么来的。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第8课（取整进阶）</title>
      <link href="/2018/04/16/concrete-math-8/"/>
      <url>/2018/04/16/concrete-math-8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天主要讲了取整与递归式的结合，还有取模的相关知识。</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>给出下列递归式：<br>\[\begin{array}{l}{K_0}{\rm{ = }}1\\{K_{n + 1}} = 1 + \min (2{K_{\left\lfloor {n/2} \right\rfloor }},3{K_{\left\lfloor {n/3} \right\rfloor }}),n \ge 0\end{array}\]<br>现在不要求你求解，要你证明：<br>\[{K_n} \ge n\]<br>首先想到的就是数学归纳法，假设对于任意$k \le n$，都有${K_k} \ge k$，那么：<br>\[\begin{array}{l}{K_{n + 1}} = 1 + \min (2{K_{\left\lfloor {n/2} \right\rfloor }},3{K_{\left\lfloor {n/3} \right\rfloor }})\\ \ge 1 + \min (2\left\lfloor {\frac{n}{2}} \right\rfloor ,3\left\lfloor {\frac{n}{3}} \right\rfloor )\end{array}\]<br>如果$n = 2k$，那么${K_{n + 1}} \ge 1 + n$。<br>如果$n = 2k + 1$，那么${K_{n + 1}} \ge n$，这时不成立。</p><p>所以数学归纳法无法证明，今后我们会用其他方法来证明这个式子。</p><h1 id="约瑟夫环新解"><a href="#约瑟夫环新解" class="headerlink" title="约瑟夫环新解"></a>约瑟夫环新解</h1><hr><p>还记得约瑟夫环问题吗？详见<a href="http://godweiyang.com/2018/02/27/concrete-math-1/">第一节课</a>。</p><p>这里我们继续推广到一般情况，如果有$n$个人，每隔$q$个人踢掉一个人，最后剩下的是几号？</p><p>初始编号为$1 \ldots n$，现在考虑一种新的编号方式。</p><p>第一个人不会被踢掉，编号加$1$，变成$n + 1$，然后第二个人编号变为$n + 2$，直到第$q$个人，他被踢掉了。</p><p>然后第$q + 1$个人编号继续加$1$，变成了$n + q$，依次下去。</p><p>考虑当前踢到的人编号为$kq$，那么此时已经踢掉了$k$个人，所以接下去的人新的编号为$n + k(q - 1) + 1 \ldots$。</p><p>所以编号为$kq+d$的人编号变成了$n + k(q - 1) + d$，其中$1 \le d &lt; q$。</p><p>直到最后，可以发现活下来的人编号为$qn$，问题是怎么根据这个编号推出他原来的编号？</p><p>以$n = 10$，$q = 3$为例，下图就是每个人新的编号：<br><img src="1.jpg" alt></p><p>令<br>\[N = n + k(q - 1) + d\]<br>所以他上一次的编号是<br>\[kq + d = kq + N - n - k(q - 1) = k + N - n\]<br>因为<br>\[k = \frac{ {N - n - d}}{ {q - 1}} = \left\lfloor {\frac{ {N - n - 1}}{ {q - 1}}} \right\rfloor \]<br>所以上一次编号可以写为<br>\[\left\lfloor {\frac{ {N - n - 1}}{ {q - 1}}} \right\rfloor  + N - n\]</p><p>因此最后存活的人编号可以用如下的算法计算：</p><pre><code>N = qnwhile N &gt; n:    N = k + N - nans = N</code></pre><p>其中$k = \left\lfloor {\frac{ {N - n - 1}}{ {q - 1}}} \right\rfloor $</p><p>如果我们用$D = qn + 1 - N$替代$N$，将会进一步简化算法：<br>\[\begin{array}{l}D = qn + 1 - N\\ = qn + 1 - \left( {\left\lfloor {\frac{ {(qn + 1 - D) - n - 1}}{ {q - 1}}} \right\rfloor  + qn + 1 - D - n} \right)\\ = n + D - \left\lfloor {\frac{ {(q - 1)n - D}}{ {q - 1}}} \right\rfloor \\ = D - \left\lfloor {\frac{ { - D}}{ {q - 1}}} \right\rfloor \\ = D + \left\lceil {\frac{D}{ {q - 1}}} \right\rceil \\ = \left\lceil {\frac{q}{ {q - 1}}D} \right\rceil \end{array}\]</p><p>算法伪代码如下：</p><pre><code>D = 1while D &lt;= (q-1)n:    D = kans = qn + 1 - D</code></pre><p>其中$k = \left\lceil {\frac{q}{ {q - 1}}D} \right\rceil $</p><h1 id="模的性质"><a href="#模的性质" class="headerlink" title="模的性质"></a>模的性质</h1><hr><h2 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h2><p>模定义如下：<br>\[x\bmod y = x - y\left\lfloor {\frac{x}{y}} \right\rfloor \]<br>特别的<br>\[x\bmod 0 = x\]</p><p>与此类似，定义一个与模类似的运算：<br>\[x{\rm{ mumble }}y = y\left\lceil {\frac{x}{y}} \right\rceil  - x\]<br>形象理解如下图所示：<br><img src="2.jpg" alt><br>圆的周长是$y$，一共走过的路长（红色+绿色部分）是$x$，所以$x\bmod y$就是绿色部分，$x{\rm{ mumble }}y$就是一圈长度减去绿色部分。</p><p>模有一些性质：<br>\[c(x\bmod y) = (cx)\bmod (cy)\]</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>考虑如下问题，怎么平均分配$n$个东西给$m$个人？</p><p>很容易想到，首先分给每个人$\left\lfloor {\frac{n}{m}} \right\rfloor $个东西，剩下$n\bmod m$件东西分给前$n\bmod m$个人，一人多一件就行。</p><p>概括起来就是，前$n\bmod m$个人，每人$\left\lceil {\frac{n}{m}} \right\rceil $件，剩下的人，每人$\left\lfloor {\frac{n}{m}} \right\rfloor $件。</p><p>那有没有办法统一表示呢？有的，每个人分到的件数为<br>\[\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil ,1 \le k \le m\]</p><p>为什么呢？假设<br>\[n = qm + r,0 \le r &lt; m\]<br>那么<br>\[\begin{array}{l}\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil  = \left\lceil {\frac{ {qm + r - k + 1}}{m}} \right\rceil \\ = q + \left\lceil {\frac{ {r - k + 1}}{m}} \right\rceil \end{array}\]<br>当$1 \le k \le r$时，<br>\[\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil  = 1\]<br>当$r &lt; k \le m$时，<br>\[\left\lceil {\frac{ {n - k + 1}}{m}} \right\rceil  = 0\]</p><p>得证，因此可以得到如下等式：<br>\[n = \left\lceil {\frac{n}{m}} \right\rceil  + \left\lceil {\frac{ {n - 1}}{m}} \right\rceil  +  \cdots  + \left\lceil {\frac{ {n - m + 1}}{m}} \right\rceil \]</p><p>由$n = \left\lfloor {\frac{n}{2}} \right\rfloor  + \left\lceil {\frac{n}{2}} \right\rceil $<br>可以进一步将其转换为下取整形式：<br>\[n = \left\lfloor {\frac{n}{m}} \right\rfloor  + \left\lfloor {\frac{ {n + 1}}{m}} \right\rfloor  +  \cdots  + \left\lfloor {\frac{ {n + m - 1}}{m}} \right\rfloor \]</p><p>令$n = \left\lfloor {mx} \right\rfloor $<br>我们得到了一个令人惊奇的等式：<br>\[\left\lfloor {mx} \right\rfloor  = \left\lfloor x \right\rfloor  + \left\lfloor {x + \frac{1}{m}} \right\rfloor  +  \cdots  + \left\lfloor {x + \frac{ {m - 1}}{m}} \right\rfloor \]</p><h1 id="HDU3089"><a href="#HDU3089" class="headerlink" title="HDU3089"></a>HDU3089</h1><hr><p>最后用今天介绍的约瑟夫环算法来解决一道经典的ACM题！题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3089" target="_blank" rel="noopener">杭电3089</a>。</p><p>C++代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span>LL <span class="token function">J</span><span class="token punctuation">(</span>LL n<span class="token punctuation">,</span> LL q<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL D <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>D <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        D <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">*</span>D<span class="token operator">+</span>q<span class="token number">-2</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>q<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> q<span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token operator">-</span>D<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL n<span class="token punctuation">,</span> q<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> <span class="token function">J</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比网上各种快速算法还要快哦，理论时间复杂度是$\log n$的。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细Hexo+Github博客搭建小白教程</title>
      <link href="/2018/04/13/hexo-blog/"/>
      <url>/2018/04/13/hexo-blog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><blockquote><p><strong>关注我公众号：算法码上来，获取实时更新</strong>。有任何问题请加 QQ 技术交流群【群号：864832264】。如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</p></blockquote><h1 id="我的博客源代码地址"><a href="#我的博客源代码地址" class="headerlink" title="我的博客源代码地址"></a>我的博客源代码地址</h1><p>大家可以直接素质二连，star&amp;fork我的博客源代码：<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-matery-modified</a>，然后改改配置就可以写文章啦。</p><p>为了减小源码的体积，我将插件目录<code>node_modules</code>进行了压缩，大家下载完后需要解压。另外添加水印需要的字体文件我也删除了，大家可以直接从电脑自带的字体库中拷贝。</p><ul><li>首先运行<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>将所有文件下载到本地。</li><li>解压<code>node_modules.zip</code>，然后删除<code>node_modules.zip</code>和<code>.git</code>文件夹。</li><li>还缺一个字体（为图片添加水印需要用到），去<code>C:\Windows\Fonts</code>下找到<code>STSong Regular</code>，复制到<code>hexo-matery-modified</code>文件夹下。</li></ul><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：</p><ul><li>根目录配置文件<code>_config.yml</code>和主题目录配置文件<code>_config.yml</code>中修改个人信息。</li><li>根目录配置文件中修改<code>deploy</code>一栏的<code>repository</code>。</li><li>根目录配置文件中修改<code>baidu_url_submit</code>一栏的<code>token</code>。</li><li>主题配置文件中修改<code>gitalk</code>一栏，修改方法见正文。</li></ul><p><strong>当然前提是个性化设置章节之前的环境还是需要配置好！</strong></p><p>平时常用命令：</p><pre class="line-numbers language-txt"><code class="language-txt">hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>17年9月的时候开始搭建了第一个自己的独立博客，到现在也稍微像模像样了。很多小伙伴应该也想过搭建一个自己的博客，网上也有一堆详细教程。我在此稍稍总结一下具体的搭建步骤，另外网上很少有修改博客源码的个性化教程，我就稍稍分享一下我的一些修改经验，更多的个性化操作需要你自己以后去摸索。</p><p>具体效果可以参观我的博客：<a href="https://godweiyang.com">godweiyang.com</a>，欢迎大家支持。</p><p>我不是一个前端程序员，有些东西不是很了解，写的有问题或有改进的地方请大家指出。</p><p>首先要了解一下我们搭建博客要用到的框架。Hexo是高效的静态站点生成框架，它基于Node.js。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到你的github上，然后别人就可以看到你的网页啦。是不是很简单？你无需关心网页源代码的具体细节，你只需要用心写好你的博客内容就行。</p><p><strong>目录结构</strong></p><ul><li>安装Node.js</li><li>添加国内镜像源</li><li>安装Git</li><li>注册Github账号</li><li>安装Hexo</li><li>连接Github与本地</li><li>写文章、发布文章</li><li>绑定域名</li><li>备份博客源文件</li><li>博客源代码下载</li><li>个性化设置（matery主题）</li><li>常见问题及解答（FAQ）</li><li>个性化设置（beantech主题，已停更）</li></ul><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>首先下载稳定版<a href="https://nodejs.org/dist/v9.11.1/node-v9.11.1-x64.msi" target="_blank" rel="noopener">Node.js</a>，我这里给的是64位的。</p><p>安装选项全部默认，一路点击<code>Next</code>。</p><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><h1 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h1><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">[下载地址]</a>。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><h1 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h1><p>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>，新建一个项目，如下所示：<br><img src="1.jpg" alt><br>然后如下图所示，输入自己的项目名字，后面一定要加<code>.github.io</code>后缀，README初始化也要勾上。<strong>名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code>。</strong><br><img src="2.jpg" alt><br>然后项目就建成了，点击<code>Settings</code>，向下拉到最后有个<code>GitHub Pages</code>，点击<code>Choose a theme</code>选择一个主题。然后等一会儿，再回到<code>GitHub Pages</code>，会变成下面这样：<br><img src="3.jpg" alt><br>点击那个链接，就会出现自己的网页啦，效果如下：<br><img src="4.jpg" alt></p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以看到我们的博客啦，效果如下：<br><img src="5.jpg" alt></p><p>按<code>ctrl+c</code>关闭本地服务器。</p><h1 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h1><p>首先右键打开git bash，然后输入下面命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"godweiyang"</span><span class="token function">git</span> config --global user.email <span class="token string">"792321264@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用户名和邮箱根据你注册github的信息自行修改。</p><p>然后生成密钥SSH key：</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"792321264@qq.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开<a href="http://github.com" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。<br><img src="6.jpg" alt></p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre class="line-numbers language-bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repository: https://github.com/godweiyang/godweiyang.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>repository修改为你自己的github项目地址。</p><h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p><p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>现在默认的域名还是<code>xxx.github.io</code>，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p><p>以我的百度云为例，如下图所示，添加两条解析记录：<br><img src="7.jpg" alt></p><p>然后打开你的github博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存：<br><img src="8.jpg" alt></p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\study\program\blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到github。</p><h1 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h1><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后<code>git commit -m &quot;xxx&quot;</code>，最后<code>git push origin hexo</code>提交就行了。</p><p>当然我新建了一个仓库存放了源文件，具体效果可以看我的博客源文件仓库：<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-matery-modified</a>。大家也可以先用下文hexo安装方法安装完hexo，然后直接<code>git clone git@github.com:godweiyang/hexo-matery-modified.git</code>克隆我的所有源文件，然后这是我修改完的基本没bug的定制化的博客，就可以直接拿来用啦。</p><p><strong>我这个源文件和原来的主题没有什么区别，只是我把插件都安装完了，有些小bug也修复了，所以拿来就能直接用，方便大家。</strong></p><h1 id="博客源代码下载"><a href="#博客源代码下载" class="headerlink" title="博客源代码下载"></a>博客源代码下载</h1><p>如果大家不想这么麻烦的装一堆东西，然后还要自己修改bug，那么只需要做好上面的准备工作，然后下载我的源代码，改改个人配置就行了。</p><p>源码地址：<a href="https://github.com/godweiyang/hexo-matery-modified" target="_blank" rel="noopener">https://github.com/godweiyang/hexo-matery-modified</a>。大家可以直接下载下来使用，修改个人配置信息即可，当然环境要先搭好。</p><p><strong>如果大家下载好了源代码，就可以直接使用了，基本可以跳过文章后面的部分了！喜欢的记得star并fork哦！</strong></p><h1 id="个性化设置（matery主题）"><a href="#个性化设置（matery主题）" class="headerlink" title="个性化设置（matery主题）"></a>个性化设置（matery主题）</h1><p>下面的个性化设置主要针对的是<code>matery</code>主题，如果你想用我现在博客这个主题，可以直接看这个章节。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>这两天花时间将我的博客换了一个主题，现在这个主题看着更加的炫（zhuang）酷（bi），并且响应式更友好，点起来就很舒服，功能也多很多。</p><p>主题的原地址在这里：<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>，它的文档写得也非常的详细，还有中英文两个版本，作者回复也很及时。效果图如下，可以看出非常合我的口味：<br><img src="21.jpg" alt></p><p>但是我自己使用起来还是遇到了好几个问题，经过两天的不懈摸鱼，终于基本解决了，这里分享一下。</p><p>首先先按照文档教程安装一遍主题，然后是可以正常打开的，如果你是一般使用的话，基本没啥问题了。但是我是重度强迫症，一点小毛病就看着难受，下面列举一下我遇到的问题以及解决方法。</p><h2 id="文章头设置"><a href="#文章头设置" class="headerlink" title="文章头设置"></a>文章头设置</h2><p>首先为了新建文章方便，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p><pre class="line-numbers language-json"><code class="language-json">---title<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span>date<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> date <span class="token punctuation">}</span><span class="token punctuation">}</span>top<span class="token operator">:</span> <span class="token boolean">false</span>cover<span class="token operator">:</span> <span class="token boolean">false</span>password<span class="token operator">:</span>toc<span class="token operator">:</span> <span class="token boolean">true</span>mathjax<span class="token operator">:</span> <span class="token boolean">true</span>summary<span class="token operator">:</span>tags<span class="token operator">:</span>categories<span class="token operator">:</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样新建文章后不用你自己补充了，修改信息就行。</p><h2 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h2><p>原来的主题没有404页面，加一个也不是什么难事。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><pre class="line-numbers language-json"><code class="language-json">---title<span class="token operator">:</span> <span class="token number">404</span>date<span class="token operator">:</span> <span class="token number">2019</span>-<span class="token number">07</span>-<span class="token number">19</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">10</span>type<span class="token operator">:</span> <span class="token string">"404"</span>layout<span class="token operator">:</span> <span class="token string">"404"</span>description<span class="token operator">:</span> <span class="token string">"你来到了没有知识的荒原 :("</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件，内容如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token comment" spellcheck="true">/* don't remove. */</span>    <span class="token selector"><span class="token class">.about-cover</span> </span><span class="token punctuation">{</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">75</span>vh<span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bg-cover pd-header about-cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col s10 offset-s1 m8 offset-m2 l8 offset-l2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>brand<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title center-align<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        404                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description center-align<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        &lt;%= page.description %>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 每天切换 banner 图.  Switch banner image every day.</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="“关于”页面增加简历（可选）"><a href="#“关于”页面增加简历（可选）" class="headerlink" title="“关于”页面增加简历（可选）"></a>“关于”页面增加简历（可选）</h2><p>修改<code>/themes/matery/layout/about.ejs</code>，找到<code>&lt;div class=&quot;card&quot;&gt;</code>标签，然后找到它对应的<code>&lt;/div&gt;</code>标签，接在后面新增一个card，语句如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>card-content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>card-content article-card-content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title center-align<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zoom-in-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-address-book<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">__('myCV')</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>articleContent<span class="token punctuation">"</span></span> <span class="token attr-name">data-aos</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fade-up<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">page.content</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就会多出一张card，然后可以在<code>/source/about/index.md</code>下面写上你的简历了，当然这里的位置随你自己设置，你也可以把简历作为第一个card。</p><h2 id="解决mathjax与代码高亮的冲突"><a href="#解决mathjax与代码高亮的冲突" class="headerlink" title="解决mathjax与代码高亮的冲突"></a>解决mathjax与代码高亮的冲突</h2><p>如果你按照教程安装了代码高亮插件<code>hexo-prism-plugin</code>，单独使用是没有问题的，但如果你又使用了mathjax，并且按照网上教程，安装<code>kramed</code>插件并修改了js文件里的正则表达式（为了解决markdown和mathjax的语法冲突），好了，那你的代码就无法高亮了。解决方法很简单，别用<code>kramed</code>插件了，还用原来自带的<code>marked</code>插件，直接改它的正则表达式就行了，改法如下：</p><p>打开<code>D:\study\program\blog\node_modules\marked\lib\marked.js</code><br><code>escape:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">escape<span class="token operator">:</span> /^\\(<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>(<span class="token punctuation">)</span>#$+\-.!_><span class="token punctuation">]</span><span class="token punctuation">)</span>/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>em:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>\*(?!\*<span class="token punctuation">)</span>/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时在文章里写数学公式基本没有问题了，但是要注意：<br><strong>数学公式中如果出现了连续两个{，中间一定要加空格！</strong></p><h2 id="增加建站时间"><a href="#增加建站时间" class="headerlink" title="增加建站时间"></a>增加建站时间</h2><p>修改<code>/themes/matery/layout/_partial/footer.ejs</code>文件，在最后加上</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script language<span class="token operator">=</span>javascript<span class="token operator">></span>    <span class="token keyword">function</span> <span class="token function">siteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        window<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"siteTime()"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> seconds <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> minutes <span class="token operator">=</span> seconds <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> hours <span class="token operator">=</span> minutes <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> days <span class="token operator">=</span> hours <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> years <span class="token operator">=</span> days <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> today <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayMonth <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayDate <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayHour <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todayMinute <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> todaySecond <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)        year - 作为date对象的年份，为4位年份值        month - 0-11之间的整数，做为date对象的月份        day - 1-31之间的整数，做为date对象的天数        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数        minutes - 0-59之间的整数，做为date对象的分钟数        seconds - 0-59之间的整数，做为date对象的秒数        microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span>        <span class="token keyword">var</span> t1 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">09</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">,</span> <span class="token number">00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//北京时间2018-2-13 00:00:00</span>        <span class="token keyword">var</span> t2 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">UTC</span><span class="token punctuation">(</span>todayYear<span class="token punctuation">,</span> todayMonth<span class="token punctuation">,</span> todayDate<span class="token punctuation">,</span> todayHour<span class="token punctuation">,</span> todayMinute<span class="token punctuation">,</span> todaySecond<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diff <span class="token operator">=</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">;</span>        <span class="token keyword">var</span> diffYears <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>diff <span class="token operator">/</span> years<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffDays <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">/</span> days<span class="token punctuation">)</span> <span class="token operator">-</span> diffYears <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffHours <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days<span class="token punctuation">)</span> <span class="token operator">/</span> hours<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffMinutes <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days <span class="token operator">-</span> diffHours <span class="token operator">*</span> hours<span class="token punctuation">)</span> <span class="token operator">/</span> minutes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> diffSeconds <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>diff <span class="token operator">-</span> <span class="token punctuation">(</span>diffYears <span class="token operator">*</span> <span class="token number">365</span> <span class="token operator">+</span> diffDays<span class="token punctuation">)</span> <span class="token operator">*</span> days <span class="token operator">-</span> diffHours <span class="token operator">*</span> hours <span class="token operator">-</span> diffMinutes <span class="token operator">*</span> minutes<span class="token punctuation">)</span> <span class="token operator">/</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"sitetime"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"本站已运行 "</span> <span class="token operator">+</span>diffYears<span class="token operator">+</span><span class="token string">" 年 "</span><span class="token operator">+</span>diffDays <span class="token operator">+</span> <span class="token string">" 天 "</span> <span class="token operator">+</span> diffHours <span class="token operator">+</span> <span class="token string">" 小时 "</span> <span class="token operator">+</span> diffMinutes <span class="token operator">+</span> <span class="token string">" 分钟 "</span> <span class="token operator">+</span> diffSeconds <span class="token operator">+</span> <span class="token string">" 秒"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/</span>    <span class="token function">siteTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在合适的地方（比如copyright声明后面）加上下面的代码就行了：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sitetime<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改不蒜子初始化计数"><a href="#修改不蒜子初始化计数" class="headerlink" title="修改不蒜子初始化计数"></a>修改不蒜子初始化计数</h2><p>因为不蒜子至今未开放注册，所以没办法在官网修改初始化，只能自己动手了。和上一条一样，在<code>/themes/matery/layout/_partial/footer.ejs</code>文件最后加上：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> int <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>fixCount<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 50ms周期检测函数</span>        <span class="token keyword">var</span> pvcountOffset <span class="token operator">=</span> <span class="token number">80000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化首次数据</span>        <span class="token keyword">var</span> uvcountOffset <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">fixCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"busuanzi_container_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">!=</span> <span class="token string">"none"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> pvcountOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_container_site_pv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"display"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">"none"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_uv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#busuanzi_value_site_uv"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> uvcountOffset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 加上初始数据 </span>                <span class="token function">clearInterval</span><span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 停止检测</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后把上面几行有段代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalTraffic)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_pv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-heart-o<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>        本站总访问量 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_pv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalNumberOfvisitors)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_uv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        人次,<span class="token entity" title="&nbsp;">&amp;nbsp;</span>访客数 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_uv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 人.    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改为：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalTraffic)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_pv<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">='</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-heart-o<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>        本站总访问量 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_pv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.busuanziStatistics</span> <span class="token attr-name">&amp;&amp;</span> <span class="token attr-name">theme.busuanziStatistics.totalNumberOfvisitors)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_container_site_uv<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">='</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>        人次,<span class="token entity" title="&nbsp;">&amp;nbsp;</span>访客数 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>busuanzi_value_site_uv<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white-color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 人.    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是增加了两个<code>style=&#39;display:none&#39;</code>而已。</p><h2 id="添加动漫人物"><a href="#添加动漫人物" class="headerlink" title="添加动漫人物"></a>添加动漫人物</h2><p>其实三步就行了，不用像网上有些教程那么复杂。</p><p><strong>第一步：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-helper-live2d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>第二步：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> live2d-widget-model-shizuku<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>第三步：</strong><br>在根目录配置文件中添加如下代码：</p><pre class="line-numbers language-json"><code class="language-json">live2d<span class="token operator">:</span>  enable<span class="token operator">:</span> <span class="token boolean">true</span>  scriptFrom<span class="token operator">:</span> local  pluginRootPath<span class="token operator">:</span> live2dw/  pluginJsPath<span class="token operator">:</span> lib/  pluginModelPath<span class="token operator">:</span> assets/  tagMode<span class="token operator">:</span> <span class="token boolean">false</span>  log<span class="token operator">:</span> <span class="token boolean">false</span>  model<span class="token operator">:</span>    use<span class="token operator">:</span> live2d-widget-model-shizuku  display<span class="token operator">:</span>    position<span class="token operator">:</span> right    width<span class="token operator">:</span> <span class="token number">150</span>    height<span class="token operator">:</span> <span class="token number">300</span>  mobile<span class="token operator">:</span>    show<span class="token operator">:</span> <span class="token boolean">true</span>  react<span class="token operator">:</span>    opacity<span class="token operator">:</span> <span class="token number">0.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>hexo g</code>再<code>hexo s</code>就能预览出效果了，但是有个注意的地方，我发现<strong>这个动漫人物最好不要和不蒜子同时使用</strong>，不然不蒜子会显示不出来。</p><h2 id="图片添加水印"><a href="#图片添加水印" class="headerlink" title="图片添加水印"></a>图片添加水印</h2><p>为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。</p><p>首先在博客根目录下新建一个<code>watermark.py</code>，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">import</span> sys<span class="token keyword">import</span> glob<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageDraw<span class="token keyword">from</span> PIL <span class="token keyword">import</span> ImageFont<span class="token keyword">def</span> <span class="token function">watermark</span><span class="token punctuation">(</span>post_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> post_name <span class="token operator">==</span> <span class="token string">'all'</span><span class="token punctuation">:</span>        post_name <span class="token operator">=</span> <span class="token string">'*'</span>    dir_name <span class="token operator">=</span> <span class="token string">'source/_posts/'</span> <span class="token operator">+</span> post_name <span class="token operator">+</span> <span class="token string">'/*'</span>    <span class="token keyword">for</span> files <span class="token keyword">in</span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>dir_name<span class="token punctuation">)</span><span class="token punctuation">:</span>        im <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span>files<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>im<span class="token punctuation">.</span>getbands<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>            im <span class="token operator">=</span> im<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">'RGB'</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>        font <span class="token operator">=</span> ImageFont<span class="token punctuation">.</span>truetype<span class="token punctuation">(</span><span class="token string">'STSONG.TTF'</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        draw <span class="token operator">=</span> ImageDraw<span class="token punctuation">.</span>Draw<span class="token punctuation">(</span>im<span class="token punctuation">)</span>        draw<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token punctuation">(</span>im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> im<span class="token punctuation">.</span>size<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                  u<span class="token string">'@yourname'</span><span class="token punctuation">,</span> fill<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> font<span class="token operator">=</span>font<span class="token punctuation">)</span>        im<span class="token punctuation">.</span>save<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        watermark<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[usage] &lt;input>'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字体也放根目录下，自己找字体。然后每次写完一篇文章可以运行<code>python3 watermark.py postname</code>添加水印，如果第一次运行要给所有文章添加水印，可以运行<code>python3 watermark.py all</code>。</p><h2 id="添加网易云音乐BGM"><a href="#添加网易云音乐BGM" class="headerlink" title="添加网易云音乐BGM"></a>添加网易云音乐BGM</h2><p>写文章的时候，想插入一段BGM怎么办？</p><p>首先打开网易云网页版，找到想听的歌曲，然后点击生成外链：<br><img src="15.jpg" alt><br>复制如下代码：<br><img src="16.jpg" alt></p><p>粘贴到文章里就行了，为了美观，设置一下居中，具体代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这里粘贴刚刚复制的代码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="添加评论插件"><a href="#添加评论插件" class="headerlink" title="添加评论插件"></a>添加评论插件</h2><p>主题已经自带了gitalk插件了，所以你只需要去github官网配置好就行了。</p><p>首先打开<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">github</a>申请一个应用，要填四个东西：</p><pre class="line-numbers language-txt"><code class="language-txt">Application name //应用名称，随便填Homepage URL //填自己的博客地址Application description //应用描述，随便填Authorization callback URL //填自己的博客地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后点击注册，会出现两个字符串<code>Client ID</code>和<code>Client Secret</code>，这个要复制出来。</p><p>然后去主题的配置文件<code>_config.yml</code>下修改<code>gitalk</code>那里：</p><pre class="line-numbers language-txt"><code class="language-txt">gitalk:  enable: true  owner: 你的github用户名  repo: 你的github用户名.github.io  oauth:    clientId: 粘贴刚刚注册完显示的字符串    clientSecret: 粘贴刚刚注册完显示的字符串  admin: 你的github用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以后写文章的时候，只要在文章页面登陆过github，就会自动创建评论框，<strong>记得每次写完文章后打开博客文章页面一下</strong>。</p><h2 id="添加百度统计和谷歌统计代码"><a href="#添加百度统计和谷歌统计代码" class="headerlink" title="添加百度统计和谷歌统计代码"></a>添加百度统计和谷歌统计代码</h2><p>首先打开<a href="https://ziyuan.baidu.com/site/index" target="_blank" rel="noopener">百度站长平台</a>，然后点击添加网站，输入网址并选择领域。</p><p>接下来要验证网站所有权，有三种方式，推荐采用HTML标签验证，最简单，将代码复制出来。</p><p>打开<code>themes/matery/layout/_partial/head.ejs</code>，修改下面两行：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>baidu-site-verification<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>google-site-verification<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>content</code>内容改成你自己刚刚复制出来的就行了。</p><h2 id="修复代码块行号不显示bug"><a href="#修复代码块行号不显示bug" class="headerlink" title="修复代码块行号不显示bug"></a>修复代码块行号不显示bug</h2><p>修改<code>themes/matery/source/css/matery.css</code>第95行左右的<code>pre</code>和<code>code</code>两段改为如下代码：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">pre </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* padding: 1.5rem !important; */</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">3.3</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1</span>rem <span class="token number">0</span> <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#272822</span><span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0.35</span>rem<span class="token punctuation">;</span>    <span class="token property">tab-size</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">code </span><span class="token punctuation">{</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">5</span>px<span class="token punctuation">;</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> Inconsolata, Monaco, Consolas, <span class="token string">'Courier New'</span>, Courier, monospace<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* font-size: 0.91rem; */</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#e96900</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#f8f8f8</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">2</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在根目录的<code>_config.yml</code>中设置<code>prism_plugin.line_number</code>为<code>true</code>。</p><h2 id="优化文章url路径"><a href="#优化文章url路径" class="headerlink" title="优化文章url路径"></a>优化文章url路径</h2><p>有教程认为，将博客目录结构改为如下，就能减少层级，有利于搜索引擎的SEO。其实不然，网站内容的层级是按照从首页开始点击几次能到达你的文章来算的，所以你改不改都是两层就到达了，不在首页的也可以通过<code>index-archives-post</code>到达，跟文章url长度没有任何关系，所以如下操作作废，你想改也行，不改也行。但是建议已经建站一段时间的同学千万别改，不然会产生很多死链，并且评论issue全部会清空，很麻烦。</p><p><del>seo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：<code>sitename/year/mounth/day/title</code>四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成<code>sitename/title</code>的形式，并且title最好是用英文，在根目录的<code>_config.yml</code>文件下修改permalink如下：</del></p><pre class="line-numbers language-text"><code class="language-text"># permalink: :year/:month/:day/:title/permalink: :title/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="添加雪花特效"><a href="#添加雪花特效" class="headerlink" title="添加雪花特效"></a>添加雪花特效</h2><p>首先在<code>themes/matery/source/libs/others</code>下新建文件<code>snow.js</code>，并插入如下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/*样式一*/</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span><span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>snow <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> $flake <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'&lt;div id="snowbox" />'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token string">'absolute'</span><span class="token punctuation">,</span><span class="token string">'z-index'</span><span class="token punctuation">:</span><span class="token string">'9999'</span><span class="token punctuation">,</span> <span class="token string">'top'</span><span class="token punctuation">:</span> <span class="token string">'-50px'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">'&amp;#10052;'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    documentHeight  <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    documentWidth   <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    defaults <span class="token operator">=</span> <span class="token punctuation">{</span>        minSize     <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>        maxSize     <span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>        newOn       <span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span>        flakeColor  <span class="token punctuation">:</span> <span class="token string">"#AFDAEF"</span> <span class="token comment" spellcheck="true">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    options <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> defaults<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> interval<span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> startPositionLeft <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> documentWidth <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">,</span>    startOpacity <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    sizeFlake <span class="token operator">=</span> options<span class="token punctuation">.</span>minSize <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> options<span class="token punctuation">.</span>maxSize<span class="token punctuation">,</span>    endPositionTop <span class="token operator">=</span> documentHeight <span class="token operator">-</span> <span class="token number">200</span><span class="token punctuation">,</span>    endPositionLeft <span class="token operator">=</span> startPositionLeft <span class="token operator">-</span> <span class="token number">500</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">500</span><span class="token punctuation">,</span>    durationFall <span class="token operator">=</span> documentHeight <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5000</span><span class="token punctuation">;</span>    $flake<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        left<span class="token punctuation">:</span> startPositionLeft<span class="token punctuation">,</span>        opacity<span class="token punctuation">:</span> startOpacity<span class="token punctuation">,</span>        <span class="token string">'font-size'</span><span class="token punctuation">:</span> sizeFlake<span class="token punctuation">,</span>        color<span class="token punctuation">:</span> options<span class="token punctuation">.</span>flakeColor    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        top<span class="token punctuation">:</span> endPositionTop<span class="token punctuation">,</span>        left<span class="token punctuation">:</span> endPositionLeft<span class="token punctuation">,</span>        opacity<span class="token punctuation">:</span> <span class="token number">0.2</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>durationFall<span class="token punctuation">,</span><span class="token string">'linear'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>newOn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function">snow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>         minSize<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 定义雪花最小尺寸 */</span>        maxSize<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">/* 定义雪花最大尺寸 */</span>        newOn<span class="token punctuation">:</span> <span class="token number">300</span>  <span class="token comment" spellcheck="true">/* 定义密集程度，数字越小越密集 */</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*样式二*/</span><span class="token comment" spellcheck="true">/* 控制下雪 */</span><span class="token keyword">function</span> <span class="token function">snowFall</span><span class="token punctuation">(</span>snow<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 可配置属性 */</span>    snow <span class="token operator">=</span> snow <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maxFlake <span class="token operator">=</span> snow<span class="token punctuation">.</span>maxFlake <span class="token operator">||</span> <span class="token number">200</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 最多片数 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>flakeSize <span class="token operator">=</span> snow<span class="token punctuation">.</span>flakeSize <span class="token operator">||</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 雪花形状 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed <span class="token operator">=</span> snow<span class="token punctuation">.</span>fallSpeed <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 坠落速度 */</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 兼容写法 */</span>requestAnimationFrame <span class="token operator">=</span> window<span class="token punctuation">.</span>requestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>mozRequestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>webkitRequestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>msRequestAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>oRequestAnimationFrame <span class="token operator">||</span>    <span class="token keyword">function</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>cancelAnimationFrame <span class="token operator">=</span> window<span class="token punctuation">.</span>cancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>mozCancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>webkitCancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>msCancelAnimationFrame <span class="token operator">||</span>    window<span class="token punctuation">.</span>oCancelAnimationFrame<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 开始下雪 */</span>snowFall<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 创建画布 */</span>    snowCanvas<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 创建雪花形状 */</span>    createFlakes<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 画雪 */</span>    drawSnow<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 创建画布 */</span><span class="token keyword">function</span> <span class="token function">snowCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 添加Dom结点 */</span>    <span class="token keyword">var</span> snowcanvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">"snowfall"</span><span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span>height <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientHeight<span class="token punctuation">;</span>    snowcanvas<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"style"</span><span class="token punctuation">,</span> <span class="token string">"position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>snowcanvas<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>canvas <span class="token operator">=</span> snowcanvas<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> snowcanvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 窗口大小改变的处理 */</span>    window<span class="token punctuation">.</span>onresize <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        snowcanvas<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* snowcanvas.height = window.innerHeight */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 雪运动对象 */</span><span class="token keyword">function</span> <span class="token function">flakeMove</span><span class="token punctuation">(</span>canvasWidth<span class="token punctuation">,</span> canvasHeight<span class="token punctuation">,</span> flakeSize<span class="token punctuation">,</span> fallSpeed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> canvasWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* x坐标 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> canvasHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* y坐标 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> flakeSize <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 形状 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maxSize <span class="token operator">=</span> flakeSize<span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">/* 最大形状 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>speed <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">+</span> fallSpeed<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* 坠落速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed <span class="token operator">=</span> fallSpeed<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">/* 坠落速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">/* Y方向速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                      <span class="token comment" spellcheck="true">/* X方向速度 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stepSize <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">30</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">/* 步长 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">=</span> <span class="token number">0</span>                                       <span class="token comment" spellcheck="true">/* 步数 */</span><span class="token punctuation">}</span>flakeMove<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>update <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span>        y <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 左右摆动(余弦) */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">0.98</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">+</span><span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>step <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">.</span><span class="token number">05</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stepSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>velY<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>velX<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 飞出边界的处理 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">>=</span> canvas<span class="token punctuation">.</span>width <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">>=</span> canvas<span class="token punctuation">.</span>height <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>canvas<span class="token punctuation">.</span>width<span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>height<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 飞出边界-放置最顶端继续坠落 */</span>flakeMove<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>reset <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxSize <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>speed <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velY <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>velX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染雪花-随机形状（此处可修改雪花颜色！！！）</span>flakeMove<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>render <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> snowFlake <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">createRadialGradient</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    snowFlake<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"rgba(255, 255, 255, 0.9)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 此处是雪花颜色，默认是白色 */</span>    snowFlake<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"rgba(255, 255, 255, 0.5)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 若要改为其他颜色，请自行查 */</span>    snowFlake<span class="token punctuation">.</span><span class="token function">addColorStop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"rgba(255, 255, 255, 0)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 找16进制的RGB 颜色代码。 */</span>    ctx<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> snowFlake<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 创建雪花-定义形状 */</span><span class="token keyword">function</span> <span class="token function">createFlakes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> maxFlake <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxFlake<span class="token punctuation">,</span>        flakes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flakes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        canvas <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>canvas<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxFlake<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flakes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">flakeMove</span><span class="token punctuation">(</span>canvas<span class="token punctuation">.</span>width<span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>height<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flakeSize<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallSpeed<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 画雪 */</span><span class="token keyword">function</span> <span class="token function">drawSnow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> maxFlake <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxFlake<span class="token punctuation">,</span>        flakes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>flakes<span class="token punctuation">;</span>    ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ctx<span class="token punctuation">,</span> canvas <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>canvas<span class="token punctuation">,</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 清空雪花 */</span>    ctx<span class="token punctuation">.</span><span class="token function">clearRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>width<span class="token punctuation">,</span> canvas<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">&lt;</span> maxFlake<span class="token punctuation">;</span> e<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        flakes<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flakes<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*  一帧一帧的画 */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loop <span class="token operator">=</span> <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        drawSnow<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 调用及控制方法 */</span><span class="token keyword">var</span> snow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">snowFall</span><span class="token punctuation">(</span><span class="token punctuation">{</span>maxFlake<span class="token punctuation">:</span><span class="token number">60</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>snow<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在主题配置文件里<code>libs.js</code>里添加一行<code>snow: /libs/others/snow.js</code>。</p><p>在<code>themes/matery/layout/layout.ejs</code>里添加如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 雪花特效 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(theme.snow.enable)</span> <span class="token attr-name">{</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span>&lt;script type="text/javascript" src="<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">theme.libs.js.snow</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token script language-javascript">"<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">}</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后在主题配置文件最后添加：</p><pre class="line-numbers language-txt"><code class="language-txt"># 雪花特效snow:  enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>这个特效和动漫一样，有点花里胡哨，并且可能会造成卡顿，所以我并没有开启，还是给大家一个最干净的阅读体验吧。</p></blockquote><h2 id="动态标签栏"><a href="#动态标签栏" class="headerlink" title="动态标签栏"></a>动态标签栏</h2><p>在<code>theme/matery/layout/layout.ejs</code>下添加如下代码：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"> <span class="token keyword">var</span> OriginTitile <span class="token operator">=</span> document<span class="token punctuation">.</span>title<span class="token punctuation">,</span> st<span class="token punctuation">;</span> document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"visibilitychange"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>hidden <span class="token operator">?</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"Σ(っ °Д °;)っ喔哟，崩溃啦！"</span><span class="token punctuation">,</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"φ(゜▽゜*)♪咦，又好了！"</span><span class="token punctuation">,</span> st <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> document<span class="token punctuation">.</span>title <span class="token operator">=</span> OriginTitile <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3e3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="常见问题及解答（FAQ）"><a href="#常见问题及解答（FAQ）" class="headerlink" title="常见问题及解答（FAQ）"></a>常见问题及解答（FAQ）</h1><p>这个章节主要更新许多同学在搭建博客的过程中咨询我的一些问题。</p><h2 id="为什么本地生成完ssh-key之后没有-ssh文件夹？"><a href="#为什么本地生成完ssh-key之后没有-ssh文件夹？" class="headerlink" title="为什么本地生成完ssh key之后没有.ssh文件夹？"></a>为什么本地生成完ssh key之后没有.ssh文件夹？</h2><p>这是我没有想到会遇到的问题，但是很多人还是遇到了，主要问题就是在输入完<code>ssh-keygen -t rsa -C &quot;792321264@qq.com&quot;</code>之后，很多同学没有按照提示继续输入，而是就这么结束了，然后报错了也没有发现。正确做法是按照提示，一路按回车就行了。</p><h2 id="为什么代码块显示有问题？"><a href="#为什么代码块显示有问题？" class="headerlink" title="为什么代码块显示有问题？"></a>为什么代码块显示有问题？</h2><p>代码要显示正确，要注意以下几个点：</p><ul><li>根目录<code>_config.yml</code>文件下的<code>highlight</code>中的<code>line_number</code>要设置为<code>false</code>，因为行号有bug，当然如果你按照上面教程修复了bug，就可以改成<code>true</code>。</li><li>不要按照网上教程安装<code>kramed</code>插件，已经装了的卸载掉。</li><li>修改<code>node_modules/marked/lib/marked.js</code>文件中的<code>escape</code>和<code>em</code>两行（在538行左右），改成下面：<pre class="line-numbers language-json"><code class="language-json">escape<span class="token operator">:</span> /^\\(<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>(<span class="token punctuation">)</span>#$+\-.!_><span class="token punctuation">]</span><span class="token punctuation">)</span>/<span class="token punctuation">,</span>em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>\*(?!\*<span class="token punctuation">)</span>/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="为什么博客本地预览没问题，push到github上就显示不正常？"><a href="#为什么博客本地预览没问题，push到github上就显示不正常？" class="headerlink" title="为什么博客本地预览没问题，push到github上就显示不正常？"></a>为什么博客本地预览没问题，push到github上就显示不正常？</h2><p>这个问题可能原因有很多，我暂时列举遇到的情况：</p><ul><li>github博客的仓库名称一定要和你的github名字完全一样，比如你github名字叫<code>abc</code>，那么仓库名字一定要是<code>abc.github.io</code>。这是大多数人会犯的错误，会导致显示不正常。</li></ul><h2 id="更换主题之后，配置文件是修改根目录下的还是主题目录下的？"><a href="#更换主题之后，配置文件是修改根目录下的还是主题目录下的？" class="headerlink" title="更换主题之后，配置文件是修改根目录下的还是主题目录下的？"></a>更换主题之后，配置文件是修改根目录下的还是主题目录下的？</h2><p>这个其实都要修改，一般也不会出现重复的属性。具体使用哪个，要看主题的源代码，如果是<code>config.xxx</code>那就是用的根目录配置文件，如果是<code>theme.xxx</code>那就用的是主题目录的配置文件。</p><h2 id="在哪建立github分支？"><a href="#在哪建立github分支？" class="headerlink" title="在哪建立github分支？"></a>在哪建立github分支？</h2><p>点击仓库的<code>settings-branches</code>，右边点击<code>add new branch</code>即可。</p><h1 id="个性化设置（beantech主题，已停更）"><a href="#个性化设置（beantech主题，已停更）" class="headerlink" title="个性化设置（beantech主题，已停更）"></a>个性化设置（beantech主题，已停更）</h1><p><strong>下面的个性化设置主要针对的是我之前使用的<code>beantech</code>主题，当然如果你想用我现在博客这个主题，可以不看这部分。这部分已经停止更新，今后我只会更新<code>matery</code>主题的各种配置。</strong></p><h2 id="更换主题-1"><a href="#更换主题-1" class="headerlink" title="更换主题"></a>更换主题</h2><p>网上大多数主题都是github排名第一的<code>Next</code>主题，但是我个人不是很喜欢，我更喜欢<code>beantech</code>主题，地址在<a href="https://github.com/YenYuHsuan/hexo-theme-beantech" target="_blank" rel="noopener">传送门</a>。</p><p>首先要注意的是，<strong>这个github项目不仅包含了主题文件，还包含了hexo的各种文件</strong>。</p><p>所以首先下载下来这个项目，然后推荐将下图所有文件全部替换你原本博客根目录下的文件：<br><img src="9.jpg" alt></p><p>当然一般的主题和这个主题有点不一样，只含有主题文件夹，所以把整个文件夹丢到<code>theme</code>下就行了。</p><p>然后运行<code>hexo clean</code>清空所有生成的网页缓存，<code>hexo g</code>、<code>hexo d</code>。这时候新的主题网页就生成好了，博客根目录的情况应该大致如下：<br><img src="10.jpg" alt></p><h2 id="博客目录构成介绍"><a href="#博客目录构成介绍" class="headerlink" title="博客目录构成介绍"></a>博客目录构成介绍</h2><p>从上图可以看出，博客的目录结构如下：</p><pre class="line-numbers language-md"><code class="language-md">- node_modules- public- scaffolds- source    - _posts    - about    - archive    - img    - tags- themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>node_modules</code>是node.js各种库的目录，<code>public</code>是生成的网页文件目录，<code>scaffolds</code>里面就三个文件，存储着新文章和新页面的初始设置，<code>source</code>是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，<code>themes</code>存放着主题文件，一般也用不到。</p><p>我们平时写文章只需要关注<code>source/_posts</code>这个文件夹就行了。</p><p>网站图片都保存在<code>D:\study\program\blog\source\img</code>目录下，可以修改成自己的图片。</p><h2 id="修复文档分类bug"><a href="#修复文档分类bug" class="headerlink" title="修复文档分类bug"></a>修复文档分类bug</h2><p>这个主题文档分类功能有个bug，一直没有得到解决，直到最近，我才发现是源文件的单词拼错了。。。</p><p>打开<code>D:\study\program\blog\scaffolds\post.md</code>，单词<code>catagories</code>改为<code>categories</code>。</p><h2 id="添加畅言评论插件"><a href="#添加畅言评论插件" class="headerlink" title="添加畅言评论插件"></a>添加畅言评论插件</h2><p>主题自带了多说评论插件，但是多说已经关闭了，所以我换成了畅言评论插件。</p><p>首先你得注册一个畅言账号，<a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">地址</a>。<br>然后打开如下页面，复制该段代码：<br><img src="11.jpg" alt><br>打开<code>D:\study\program\blog\themes\beantech\layout\post.ejs</code>，将代码粘贴到如下位置：<br><img src="12.jpg" alt><br>然后重新生成一下网页，可以看到效果图如下：<br><img src="13.jpg" alt><br>更多插件例如热评话题之类的，可以自行在畅言后台找到代码添加。</p><h2 id="添加图片放大功能"><a href="#添加图片放大功能" class="headerlink" title="添加图片放大功能"></a>添加图片放大功能</h2><p>首先下载<code>zooming.js</code>文件<a href="https://github.com/godweiyang/godweiyang.github.io/blob/master/js/zooming.js" target="_blank" rel="noopener">地址</a>，保存在<code>D:\study\program\blog\themes\beantech\source\js</code>目录下。</p><p>打开<code>D:\study\program\blog\themes\beantech\layout\post.ejs</code>，在最下方粘贴如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/zooming.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后文章里的图片就可以单击全屏啦。</p><h2 id="添加数学公式显示"><a href="#添加数学公式显示" class="headerlink" title="添加数学公式显示"></a>添加数学公式显示</h2><p>打开<code>D:\study\program\blog\themes\beantech\layout\post.ejs</code>，在最下方粘贴如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://cdn.mathjax.org/mathjax/latest/MathJax.js?config<span class="token punctuation">=</span>default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于markdown语法与mathjax语法存在冲突，所以还需要修改源文件。</p><p>打开<code>D:\study\program\blog\node_modules\marked\lib\marked.js</code><br><code>escape:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">escape<span class="token operator">:</span> /^$<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>(<span class="token punctuation">)</span>#$+\-.!_><span class="token punctuation">]</span><span class="token punctuation">)</span>/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>em:</code>处替换成：</p><pre class="line-numbers language-json"><code class="language-json">em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span><span class="token punctuation">)</span>+?<span class="token punctuation">)</span>\*(?!\*<span class="token punctuation">)</span>/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时在文章里写数学公式基本没有问题了，但是要注意：<br><strong>数学公式中如果出现了连续两个{，中间一定要加空格！</strong></p><p>举个例子:<br>行内公式：$y = f(x)$<br>代码：</p><pre class="line-numbers language-latex"><code class="language-latex"><span class="token equation string">$y = f(x)$</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>行间公式：<br>\[y = {f_{ {g_1}}}(x)\]<br>代码：</p><pre class="line-numbers language-latex"><code class="language-latex">\<span class="token equation string">\[y = {f_{ {g_1}}}(x)<span class="token equation-command regex">\\</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意上面花括号之间有空格！</strong></p><h2 id="添加留言板"><a href="#添加留言板" class="headerlink" title="添加留言板"></a>添加留言板</h2><p>在<code>D:\study\program\blog\themes\beantech\layout</code>中新建<code>bbs.ejs</code>，文件内容如下：</p><pre class="line-numbers language-html"><code class="language-html">---layout: page---<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token selector">header<span class="token class">.intro-header</span></span><span class="token punctuation">{</span>        <span class="token property">background-position</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>     <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- Chinese Version --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh post-container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%-</span> <span class="token attr-name">page.content</span> <span class="token attr-name">%</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>D:\study\program\blog\source</code>中新建<code>\bbs</code>文件夹，里面在新建<code>index.md</code>文件，内容如下：</p><pre class="line-numbers language-json"><code class="language-json">---layout<span class="token operator">:</span> <span class="token string">"bbs"</span>title<span class="token operator">:</span> <span class="token string">"BBS"</span>date<span class="token operator">:</span> <span class="token number">2017</span>-<span class="token number">09</span>-<span class="token number">19</span> <span class="token number">12</span><span class="token operator">:</span><span class="token number">48</span><span class="token operator">:</span><span class="token number">33</span>description<span class="token operator">:</span> <span class="token string">"欢迎交换友链，一起交流学习！"</span>header-img<span class="token operator">:</span> <span class="token string">"img/header_img/home-bg-2-dark.png"</span>comments<span class="token operator">:</span> <span class="token boolean">true</span>---此处替换为你的畅言评论代码~~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加置顶功能"><a href="#添加置顶功能" class="headerlink" title="添加置顶功能"></a>添加置顶功能</h2><p>运行如下两条命令安装置顶插件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> uninstall hexo-generator-index --save<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-index-pin-top --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后打开<code>D:\study\program\blog\themes\beantech\layout\index.ejs</code>，在如下位置添加代码：<br><img src="14.jpg" alt></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%</span> <span class="token attr-name">if</span> <span class="token attr-name">(post.top)</span> <span class="token attr-name">{%</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-thumb-tack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font</span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7D26CD<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>置顶<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post-meta-divider<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>|<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>%}%</span><span class="token punctuation">></span></span>&lt; code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>%}%</span><span class="token punctuation">></span></span>&lt;><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在你想置顶的文章md文件里，添加如下配置选项：</p><pre class="line-numbers language-json"><code class="language-json">top<span class="token operator">:</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="添加访客人数统计和字数统计"><a href="#添加访客人数统计和字数统计" class="headerlink" title="添加访客人数统计和字数统计"></a>添加访客人数统计和字数统计</h2><p>我们使用一个国外的流量统计网站：<a href="gostats.com">gostats.com</a>，首先注册一下。</p><p>然后自己添加网站地址，过程就不详细说了，然后点击<code>Get counter code</code>，选择一个自己喜欢的风格。<br>如下图所示，选择一个样式，选择<code>HTML</code>，生成代码：<br><img src="17.jpg" alt></p><p>复制这段代码到<code>D:\study\program\blog\themes\beantech\layout\_partial\footer.ejs</code>，具体位置如下：<br><img src="18.jpg" alt><br>默认的代码和我图中不一样，因为我不想点击图片跳转到它统计网站的链接，可以模仿我的自行修改。</p><p>字数统计首先安装插件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开<code>D:\study\program\blog\themes\beantech\layout\_partial\footer.ejs</code>，添加如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&lt;%= totalcount(site) %> words altogether<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体位置见上图。</p><h2 id="文章属性配置"><a href="#文章属性配置" class="headerlink" title="文章属性配置"></a>文章属性配置</h2><p>首先解释一下文章开头的属性配置，如下图所示：<br><img src="19.jpg" alt></p><pre class="line-numbers language-json"><code class="language-json">title<span class="token operator">:</span> 文章标题catalog<span class="token operator">:</span> 是否显示段落目录date<span class="token operator">:</span> 文章日期subtitle<span class="token operator">:</span> 子标题header-img<span class="token operator">:</span> 顶部背景图片top<span class="token operator">:</span> 是否置顶tags<span class="token operator">:</span> 标签categories<span class="token operator">:</span> 分类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每次写文章修改每个值就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第7课（取整基础）</title>
      <link href="/2018/04/09/concrete-math-7/"/>
      <url>/2018/04/09/concrete-math-7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>首先声明一下，最近这段时间忙毕设，没时间更新博客了，大家见谅。</p><p>今天这节课开始讲解取整相关知识，主要是数论相关的了。</p><h1 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h1><hr><p>向下取整函数$\left\lfloor x \right\rfloor $定义为小于等于$x$的最大整数。<br>向上取整函数$\left\lceil x \right\rceil $定义为大于等于$x$的最小整数。<br>$\{ x\} $定义为实数$x$的小数部分，即<br>\[\{ x\}  = x - \left\lfloor x \right\rfloor \]</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><hr><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>\[\left\lceil x \right\rceil  - \left\lfloor x \right\rfloor  = [x \in \mathbb{Z}]\]</p><h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>取整函数范围：<br>\[x - 1 &lt; \left\lfloor x \right\rfloor  \le x \le \left\lceil x \right\rceil  &lt; x + 1\]</p><h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>负数的取整：<br>\[\begin{array}{l}\left\lfloor { - x} \right\rfloor  =  - \left\lceil x \right\rceil \\\left\lceil { - x} \right\rceil  =  - \left\lfloor x \right\rfloor \end{array}\]</p><h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>取整函数中的整数可以提取出来：<br>\[\left\lfloor {x + n} \right\rfloor  = \left\lfloor x \right\rfloor  + n\]</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><hr><h2 id="应用1"><a href="#应用1" class="headerlink" title="应用1"></a>应用1</h2><p>证明：<br>\[\left\lfloor {\sqrt {\left\lfloor x \right\rfloor } } \right\rfloor  = \left\lfloor {\sqrt x } \right\rfloor \]</p><p>更一般的，我们还可以证明，对于任意连续、递增的函数$f(x)$，如果它满足<br>\[f(x) \in \mathbb{Z} \Rightarrow x \in \mathbb{Z}\]<br>那么有<br>\[\begin{array}{l}\left\lfloor {f(x)} \right\rfloor  = \left\lfloor {f(\left\lfloor x \right\rfloor )} \right\rfloor \\\left\lceil {f(x)} \right\rceil  = \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \end{array}\]</p><p>我们证明第2个式子，第1个同理可证。</p><p>如果$x = \left\lceil x \right\rceil $，显然成立。</p><p>否则$x &lt; \left\lceil x \right\rceil $，因为$f(x)$递增，所以有<br>\[f(x) &lt; f(\left\lceil x \right\rceil )\]<br>两边同时取整，有<br>\[\left\lceil {f(x)} \right\rceil  \le \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]<br>要证左右两边相等，那么只要证<br>\[\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]<br>不成立即可。假设上式成立，那么由中间值定理，一定存在$x \le y &lt; \left\lceil x \right\rceil $，使得<br>\[f(y) = \left\lceil {f(x)} \right\rceil \]<br><strong>敲黑板！！</strong>这里是怎么来的呢？<br>由下图可以看出，当下面式子成立时，满足中间值定理<br>\[f(x) &lt; \left\lceil {f(x)} \right\rceil  &lt; f(\left\lceil x \right\rceil )\]<br>但是在这里，我们假设是<br>\[\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]<br>那么由$\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil $能否推出$\left\lceil {f(x)} \right\rceil  &lt; f(\left\lceil x \right\rceil )$呢？当然是可以的。<br>\[\begin{array}{l}\left\lceil {f(x)} \right\rceil  &lt; \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \\ \Rightarrow \left\lceil {f(x)} \right\rceil  \le \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil  - 1 &lt; f(\left\lceil x \right\rceil )\end{array}\]<br><img src="1.jpg" alt><br>所以<br>\[f(y) \in \mathbb{Z} \Rightarrow y \in \mathbb{Z}\]<br>又因为$x \le y &lt; \left\lceil x \right\rceil $，所以不存在整数$y$，矛盾！</p><p>所以证得<br>\[\left\lceil {f(x)} \right\rceil  = \left\lceil {f(\left\lceil x \right\rceil )} \right\rceil \]</p><p>另一个特殊的例子是<br>\[\left\lfloor {\frac{ {x + m}}{n}} \right\rfloor  = \left\lfloor {\frac{ {\left\lfloor x \right\rfloor  + m}}{n}} \right\rfloor \]<br>其中$m$和$n$都是整数，并且$n$是正整数。</p><h2 id="应用2"><a href="#应用2" class="headerlink" title="应用2"></a>应用2</h2><p>接着介绍区间相关的性质。</p><p>求1到1000中使得下列式子成立的$n$一共有多少个？<br>\[\left\lfloor {\sqrt[3]{n}} \right\rfloor |n\]<br>求解方法如下：<br>\[\begin{array}{l}W{\rm{ = }}\sum\limits_{1 \le n \le 1000} {\left[ {\left\lfloor {\sqrt[3]{n}} \right\rfloor |n} \right]} \\ = \sum\limits_{k,n} {\left[ {k = \left\lfloor {\sqrt[3]{n}} \right\rfloor } \right]\left[ {k|n} \right]\left[ {1 \le n \le 1000} \right]} \\ = \sum\limits_{k,m,n} {\left[ { {k^3} \le n &lt; { {(k + 1)}^3}} \right]\left[ {n = km} \right]} \left[ {1 \le n \le 1000} \right]\\ = 1 + \sum\limits_{k,m} {\left[ { {k^3} \le km &lt; { {(k + 1)}^3}} \right]} \left[ {1 \le k &lt; 10} \right]\\ = 1 + \sum\limits_{k,m} {\left[ {m \in [{k^2},{ {(k + 1)}^3}/k)} \right]} \left[ {1 \le k &lt; 10} \right]\\ = 1 + \sum\limits_{1 \le k &lt; 10} {(\left\lceil { {k^2} + 3k + 3 + 1/k} \right\rceil  - \left\lceil { {k^2}} \right\rceil )} \\ = 1 + \sum\limits_{1 \le k &lt; 10} {(3k + 4)} \\ = 172\end{array}\]</p><p>继续推广，求1到$N$中使得上面式子成立的$n$有多少个？<br>令<br>\[K = \left\lfloor {\sqrt[3]{N}} \right\rfloor \]<br>也就是小于等于$\left\lfloor {\sqrt[3]{N}} \right\rfloor $的最大整数。<br>所以<br>\[\begin{array}{l}W = \sum\limits_{1 \le k &lt; K} {(3k + 4)}  + \sum\limits_m {\left[ { {K^3} \le Km \le N} \right]} \\ = \left\lfloor {N/K} \right\rfloor  + \frac{1}{2}{K^2} + \frac{5}{2}K - 3\end{array}\]<br>渐进地等于<br>\[W = \frac{3}{2}{N^{2/3}} + O({N^{1/3}})\]</p><h2 id="应用3"><a href="#应用3" class="headerlink" title="应用3"></a>应用3</h2><p>定义一个实数的谱为：<br>\[Spec(\alpha ) = \{ \left\lfloor \alpha  \right\rfloor ,\left\lfloor {2\alpha } \right\rfloor ,\left\lfloor {3\alpha } \right\rfloor , \ldots \} \]</p><p>很容易证明如果两个实数$\alpha  \ne \beta $，那么<br>\[Spec(\alpha ) \ne Spec(\beta )\]</p><p>假设$\alpha  &lt; \beta $，那么令<br>\[m(\beta  - \alpha ) \ge 1\]<br>所以<br>$m\beta  \ge m\alpha  + 1 \Rightarrow \left\lfloor {m\beta } \right\rfloor  &gt; \left\lfloor {m\alpha } \right\rfloor $<br>所以集合$Spec(\beta )$中小于$\left\lfloor {m\alpha } \right\rfloor $的元素个数小于$m$。而集合$Spec(\alpha )$中小于$\left\lfloor {m\alpha } \right\rfloor $的元素个数大于等于$m$。所以两个集合不相等。</p><p>谱有很多奇妙的性质，例如下面两个谱：<br>\[\begin{array}{l}Spec(\sqrt 2 ) = \{ \left\lfloor {\sqrt 2 } \right\rfloor ,\left\lfloor {2\sqrt 2 } \right\rfloor ,\left\lfloor {3\sqrt 2 } \right\rfloor , \ldots \} \\Spec(2{\rm{ + }}\sqrt 2 ) = \{ \left\lfloor {2{\rm{ + }}\sqrt 2 } \right\rfloor ,\left\lfloor {2(2{\rm{ + }}\sqrt 2 )} \right\rfloor ,\left\lfloor {3(2{\rm{ + }}\sqrt 2 )} \right\rfloor , \ldots \} \end{array}\]<br>可以发现，这两个谱正好划分了正整数集。<br>证明方法也很简单，只要证明对任意正整数$n$，两个集合中小于$n$的元素个数之和为$n$，过程如下：<br>\[\begin{array}{l}\left\lfloor {k\sqrt 2 } \right\rfloor  \le n\\ \Rightarrow k\sqrt 2  &lt; n + 1\\ \Rightarrow k &lt; \frac{ {n + 1}}{ {\sqrt 2 }}\end{array}\]<br>所以第一个集合中小于$n$的元素个数为<br>\[\left\lfloor {\frac{ {n + 1}}{ {\sqrt 2 }}} \right\rfloor \]<br>同理第二个集合中小于$n$的元素个数为<br>\[\left\lfloor {\frac{ {n + 1}}{ {2 + \sqrt 2 }}} \right\rfloor \]<br>所以总个数为<br>\[\begin{array}{l}\left\lfloor {\frac{ {n + 1}}{ {\sqrt 2 }}} \right\rfloor  + \left\lfloor {\frac{ {n + 1}}{ {2 + \sqrt 2 }}} \right\rfloor \\ = \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  + \left\lfloor {\frac{ {2 - \sqrt 2 }}{2}(n + 1)} \right\rfloor \\ = n + 1 + \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  + \left\lfloor { - \frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor \\ = n + 1 + \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  + \left\lfloor {\frac{ {\sqrt 2 }}{2}(n + 1)} \right\rfloor  - 1\\ = n\end{array}\]<br>得证。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第6课（下降阶乘幂）</title>
      <link href="/2018/04/02/concrete-math-6/"/>
      <url>/2018/04/02/concrete-math-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>上节课讲到下降阶乘幂和差分运算，这节课继续讲它和差分的各种性质。</p><h1 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h1><hr><p>首先在后面章节会证明，${(x + y)^{\underline{m}}}$的二项展开形式和普通的${(x + y)^m}$是一样的，这里提一下，暂时用不到。</p><h1 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h1><hr><p>接下来给出下降阶乘幂为负数的定义：<br>\[{x^{ \underline{- m}}} = \frac{1}{ {(x + 1)(x + 2) \ldots (x + m)}}\]</p><h1 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h1><hr><p>和普通幂${x^{m + n}} = {x^m}{x^n}$不同，下降阶乘幂有如下性质：<br>\[{x^{\underline{m + n}}} = {x^{\underline{m}}}{(x - m)^{\underline{n}}}\]</p><h1 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h1><hr><p>上一节课说到，定义下降阶乘幂的好处就是为了求差分方便，下降阶乘幂的差分为：<br>\[\Delta ({x^{\underline{m}}}) = m{x^{\underline{ {m - 1}}}}\]<br>反之，类比不定积分，它的不定和为：<br>\[\sum\nolimits_a^b { {x^{\underline{m}}}\delta x}  = \left. {\frac{ { {x^{\underline{m + 1}}}}}{ {m + 1}}} \right|_a^b\]</p><p>但是这里$m \ne  - 1$，那要是$m =  - 1$怎么办呢？<br>直接运用差分定义可以求出<br>\[\begin{array}{l}{x^{ \underline{- 1}}} = \frac{1}{ {x + 1}} = \Delta f(x) = f(x + 1) - f(x)\\ \Rightarrow f(x) = {H_x}\end{array}\]</p><p>所以<br>\[\sum\nolimits_a^b { {x^{\underline{m}}}\delta x}  = \left\{ {\begin{array}{*{20}{c}}{\left. {\frac{ { {x^{\underline{m + 1}}}}}{ {m + 1}}} \right|_a^b,m \ne  - 1}\\{\left. { {H_x}} \right|_a^b,m =  - 1}\end{array}} \right.\]</p><h1 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h1><hr><p>在微积分里面，$e^x$的导数是它自身。那么什么函数的差分是自身呢？<br>通过定义可以很容易算出来：<br>\[\begin{array}{l}f(x + 1) - f(x) = f(x)\\ \Rightarrow f(x + 1) = 2f(x)\\ \Rightarrow f(x) = {2^x}\end{array}\]</p><p>进一步推广可以得到：<br>\[\Delta ({c^x}) = {c^{x + 1}} - {c^x} = (c - 1){c^x}\]<br>所以得到如下一种新的等比数列计算方式：<br>\[\sum\limits_{a \le k &lt; b} { {c^k}}  = \sum\nolimits_a^b { {c^x}\delta x}  = \left. {\frac{ { {c^x}}}{ {c - 1}}} \right|_a^b = \frac{ { {c^b} - {c^a}}}{ {c - 1}}\]</p><h1 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h1><hr><p>结合律和分配律在差分运算里也适用。<br>\[\begin{array}{l}\Delta (cf) = c\Delta (f)\\\Delta (f + g) = \Delta (f) + \Delta (g)\end{array}\]</p><h1 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h1><hr><p>类似分部积分，这里也可以分部来求差分。<br>\[\begin{array}{l}\Delta (u(x)v(x)) = u(x + 1)v(x + 1) - u(x)v(x)\\ = u(x + 1)v(x + 1) - u(x)v(x + 1) + u(x)v(x + 1) - u(x)v(x)\\ = [u(x + 1) - u(x)]v(x + 1) + u(x)[v(x + 1) - v(x)]\\ = u(x)\Delta (v(x)) + v(x + 1)\Delta (u(x))\end{array}\]<br>这里给出一个新的记号叫做移位运算：<br>\[Ef(x) = f(x + 1)\]<br>所以就得到了差分的分部运算法则：<br>\[\Delta (uv) = u\Delta (v) + Ev\Delta (u)\]<br>对两边求和，又可以得到不定求和的分部运算法则：<br>\[\sum {u\Delta (v)}  = uv - \sum {Ev\Delta (u)} \]</p><p>这个分部法则非常有用，下面举两个例子来说明一下怎么用。</p><h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>一道老题，计算：<br>\[\sum\limits_{k = 0}^n {k{2^k}} \]<br>首先计算<br>\[\sum {x{2^x}\delta x} \]<br>在这里可以令<br>\[u = x,v = {2^x}\]<br>所以<br>\[\sum {x{2^x}\delta x}  = x{2^x} - \sum { {2^{x + 1}}\delta x}  = x{2^x} - {2^{x + 1}} + C\]<br>那么求和式就可以转化为不定求和来算了：<br>\[\begin{array}{l}\sum\limits_{k = 0}^n {k{2^k}}  = \sum\nolimits_0^{n + 1} {x{2^x}\delta x} \\ = \left. {x{2^x} - {2^{x + 1}}} \right|_0^{n + 1}\\ = (n - 1){2^{n + 1}} + 2\end{array}\]</p><h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p>计算<br>\[\sum\limits_{0 \le k &lt; n} {k{H_k}} \]<br>首先计算<br>\[\sum {x{H_x}\delta x} \]<br>这里注意要令<br>\[u = {H_x},\Delta v = x\]<br>不能倒过来哦，因为$H_x$的不定和很难求出来的。所以<br>\[\begin{array}{l}\sum {x{H_x}\delta x}  = \frac{ { {x^{\underline{2}}}}}{2}{H_x} - \sum {\frac{ { { {(x + 1)}^{\underline{2}}}}}{2}} {x^{ \underline{- 1}}}\delta x\\ = \frac{ { {x^{\underline{2}}}}}{2}{H_x} - \frac{1}{2}\sum { {x^{\underline{1}}}\delta x} \\ = \frac{ { {x^{\underline{2}}}}}{2}{H_x} - \frac{ { {x^{\underline{2}}}}}{4} + C\end{array}\]</p><p>所以<br>\[\sum\limits_{0 \le k &lt; n} {k{H_k}}  = \sum\nolimits_0^n {x{H_x}\delta x}  = \frac{ { {n^{\underline{2}}}}}{2}({H_n} - \frac{1}{2})\]</p><h1 id="无限求和"><a href="#无限求和" class="headerlink" title="无限求和"></a>无限求和</h1><hr><p>回顾一下以前我们是怎么计算下面求和式的。<br>\[S = {\rm{1}} + \frac{1}{2} + \frac{1}{4} +  \cdots \]<br>首先两边同时乘2，得到：<br>\[2S = 2 + {\rm{1}} + \frac{1}{2} + \frac{1}{4} +  \cdots  = 2 + S\]<br>解出<br>\[S = 2\]</p><p>那么可不可以用同样的方法计算下面式子呢？<br>\[T = 1 + 2 + 4 + 8 +  \cdots \]<br>两边同时乘2，得到：<br>\[2T = 2 + 4 + 8 +  \cdots  = T - 1\]<br>解出<br>\[T = -1\]<br>显然不可能，因为这里的$T$是发散的，所以不能这么求。那么如何用一般的方法来求解呢？</p><p>首先我们只考虑正数求和，求解$\sum\limits_{k \in K} { {a_k}} $，其中$K$是一个无限集合。<br>那么，如果存在$A$，使得对任意$F \subset K$，都有<br>\[\sum\limits_{k \in F} { {a_k}}  \le A\]<br>那么我们说这个最小的$A$就是$\sum\limits_{k \in K} { {a_k}} $的结果。<br>如果不存在这么一个$A$，那么这个求和式就是发散的，即结果为正无穷。</p><p>一般使用中，对于$K = N$，我们可以令$F = \{ 0,1,2, \ldots ,n\} $<br>所以<br>\[\sum\limits_{k \ge 0} { {a_k}}  = \mathop {\lim }\limits_{n \to \infty } \sum\limits_{k = 0}^n { {a_k}} \]</p><p>举两个例子，比如<br>\[\sum\limits_{k \ge 0} { {x^k}}  = \mathop {\lim }\limits_{n \to \infty } \frac{ {1 - {x^{n + 1}}}}{ {1 - x}} = \left\{ {\begin{array}{*{20}{c}}{\frac{1}{ {1 - x}},0 \le x &lt; 1}\\{\infty ,x \ge 1}\end{array}} \right.\]<br>再如：<br>\[\sum\limits_{k \ge 0} {\frac{1}{ {(k + 1)(k + 2)}}}  = \sum\limits_{k \ge 0} { {k^{ \underline{- 2}}}}  = \mathop {\lim }\limits_{n \to \infty } \sum\limits_{k = 0}^n { {k^{ \underline{- 2}}}}  = \mathop {\lim }\limits_{n \to \infty } \left. {\frac{ { {k^{ \underline{- 1}}}}}{ { - 1}}} \right|_0^{n + 1} = 1\]</p><p>剩下的问题就是如何求有正有负的和式？</p><p>可以考虑的方案就是用不同的配对，将正负组合在一起，从而相消求和。</p><p>但是不同的组合方式会得到不同的答案。就比如：<br>\[\sum\limits_{k \ge 0} { { {( - 1)}^k}}  = 1 - 1 + 1 - 1 +  \cdots \]<br>有两种组合方式：<br>\[(1 - 1) + (1 - 1) +  \cdots  = 0\]<br>和<br>\[1 - (1 - 1) - (1 - 1) -  \cdots  = 1\]<br>得到了两种不同的结果。</p><p>事实上，我们可以将正数和负数分开求和，因为正数求和我们已经解决了，所以我们定义：<br>\[x = {x^ + } - {x^ - }\]<br>其中<br>\[{x^ + } = x \cdot [x &gt; 0],{x^ - } =  - x \cdot [x &lt; 0]\]</p><p>所以求和式可以分成两部分分别求和：<br>\[\sum\limits_{k \in K} { {a_k}}  = \sum\limits_{k \in K} { {a_k}^ + }  - \sum\limits_{k \in K} { {a_k}^ - } \]</p><p>最后推广到二重求和：<br>\[\sum\limits_{j \in J,k \in {K_j}} { {a_{j,k}}}  = \sum\limits_{j \in J} {\sum\limits_{k \in {K_j}} { {a_{j,k}}} }  = \sum\limits_{j \in J} { {A_j}}  = A\]</p><p>这里也没啥好细说的，就先了解了解吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第5课（8种方法求和）</title>
      <link href="/2018/03/26/concrete-math-5/"/>
      <url>/2018/03/26/concrete-math-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天继续讲求和的方法。<br>针对以下求和式，我们用8种方法来求解：<br>\[{S_n} = \sum\limits_{0 \le k \le n} { {k^2}} \]<br>大家应该都已经背上了它的答案：<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><h1 id="方法0"><a href="#方法0" class="headerlink" title="方法0"></a>方法0</h1><hr><p><strong>查表。</strong><br>这就不用说了，很多文献都有现成的解，拿来直接用就行了。<br>再给大家推荐一个整数序列查询网站OEIS：<a href="http://oeis.org/" target="_blank" rel="noopener">链接</a></p><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><hr><p><strong>猜答案，然后用数学归纳法证明。</strong><br>这个也不多说了，前提是你得猜得出来，这题的公式还是很难猜的。</p><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><hr><p><strong>扰动法。</strong><br>令<br>\[T = \sum\limits_{0 \le k \le n} { {k^3}} \]<br>所以<br>\[\begin{array}{l}T + {(n + 1)^3}\\ = \sum\limits_{1 \le k \le n + 1} { {k^3}} \\ = \sum\limits_{1 \le k \le n + 1} { { {(k - 1)}^3}}  + \sum\limits_{1 \le k \le n + 1} {(3{k^2} - 3k + 1)} \\ = \sum\limits_{0 \le k \le n} { {k^3}}  + \sum\limits_{1 \le k \le n + 1} {[3{ {(k - 1)}^2} + 3k - 2]} \\ = T + 3{S_n} + \frac{ {3(n + 2)(n + 1)}}{2} - 2(n + 1)\end{array}\]<br>解出<br>\[3{S_n} = {(n + 1)^3} - \frac{ {3(n + 2)(n + 1)}}{2} + 2(n + 1) = n(n + \frac{1}{2})(n + 1)\]<br>最终得到<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>可以看出，我们本来是要对$k^2$求和的，但是只要对$k^3$用扰动法求和即可，因为求和过程中$k^3$项会被抵消掉。</p><h1 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h1><hr><p><strong>成套方法。</strong><br>定义如下递归式：<br>\[\begin{array}{l}{R_0} = \alpha \\{R_n} = {R_{n - 1}} + \beta  + \gamma n + \delta {n^2}\end{array}\]<br>由<a href="http://godweiyang.com/2018/03/05/concrete-math-2/">第2课</a>可知，设解的形式为：<br>\[{R_n} = A(n)\alpha  + B(n)\beta  + C(n)\gamma  + D(n)\delta \]<br>分别令${R_n} = 1,n,{n^2}$可以解出<br>\[A(n) = 1,B(n) = n,C(n) = \frac{ {n(n + 1)}}{2}\]<br>再另${R_n} = {n^3}$，可以得到<br>\[3D(n) = {n^3} + 3C(n) - B(n) = n(n + \frac{1}{2})(n + 1)\]<br>即<br>\[D(n) = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>这时如果令<br>\[\alpha  = \beta  = \gamma  = 0,\delta  = 1\]<br>那么<br>\[{R_n} = \sum\limits_{0 \le k \le n} { {k^2}}  = D(n) = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><h1 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h1><hr><p><strong>积分法</strong><br>求和式可以近似成积分\[\int_0^n { {x^2}dx}  = {n^3}/3\]<br>但是还少算了一部分误差，设为$E_n$，则有<br>\[{E_n} = {S_n} - \frac{1}{3}{n^3} = {S_{n - 1}} + {n^2} - \frac{1}{3}{n^3} = {E_{n - 1}} + n - \frac{1}{3}\]<br>解得<br>\[{E_n} = \frac{ {3{n^2} + n}}{6}\]<br>所以<br>\[{S_n} = {E_n} + \frac{1}{3}{n^3} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>其实这种方法就是把最高次直接给算出来了，低次项可以直接求和的。</p><h1 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h1><hr><p><strong>扩展成二重指标求和</strong><br>\[\begin{array}{l}{S_n} = \sum\limits_{1 \le k \le n} { {k^2}}  = \sum\limits_{1 \le j \le k \le n} { {k^2}} \\ = \sum\limits_{1 \le j \le n} {\sum\limits_{j \le k \le n} k } \\ = \sum\limits_{1 \le j \le n} {(\frac{ {j + n}}{2})(n - j + 1)} \\ = \frac{1}{2}\sum\limits_{1 \le j \le n} {(n(n + 1) + j - {j^2})} \\ = \frac{1}{2}{n^2}(n + 1) + \frac{1}{4}n(n + 1) - \frac{1}{2}{S_n}\\ = \frac{1}{2}n(n + \frac{1}{2})(n + 1) - \frac{1}{2}{S_n}\end{array}\]<br>所以<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><h1 id="方法6"><a href="#方法6" class="headerlink" title="方法6"></a>方法6</h1><hr><p><strong>用有限微分求和</strong><br>微分的形式大家都知道，如下：<br>\[\Delta f(x) = f(x + 1) - f(x)\]<br>那如果我们定义<br>\[f(x) = {x^m}\]<br>则有<br>\[\Delta f(x) = {(x + 1)^m} - {x^m}\]<br>似乎并不能和导数形式统一起来，用起来也不方便，那么我们定义一个新的函数，叫做<strong>下降阶乘幂</strong>：<br>\[f(x) = {x^{\underline{m}}} = x(x - 1) \ldots (x - m + 1)\]<br>同理还可以定义<strong>上升阶乘幂</strong>。<br>这个函数有一个很好的性质，那就是<br>\[\Delta ({x^{\underline{m}}}) = m{x^{\underline{ {m - 1}}}}\]<br>令<br>\[g(x) = \Delta f(x)\]<br>那么和积分类似，有<br>\[\sum\nolimits_a^b {g(x)\delta x}  = f(b) - f(a)\]<br>所以<br>\[\sum\limits_{0 \le k &lt; n} { {k^{\underline{m}}}}  = \left. {\frac{ { {k^{ {\underline{m + 1}}}}}}{ {m + 1}}} \right|_0^n = \frac{ { {n^{ {\underline{m + 1}}}}}}{ {m + 1}}\]</p><p>因为有<br>\[{k^2} = {k^{\underline{2}}} + {k^{\underline{1}}}\]<br>所以<br>\[\sum\limits_{0 \le k &lt; n} { {k^2}}  = \frac{ { {n^{\underline{3}}}}}{3} + \frac{ { {n^{\underline{2}}}}}{2} = \frac{ {n(n - 1)(2n - 1)}}{6}\]<br>同样可以得到<br>\[{S_n} = \frac{ {n(n + 1)(2n + 1)}}{6}\]</p><p>下降阶乘幂还有很多好用的性质，下节课继续。</p><h1 id="方法7"><a href="#方法7" class="headerlink" title="方法7"></a>方法7</h1><hr><p><strong>生成函数。</strong><br>以后章节会讲。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第二章作业解答</title>
      <link href="/2018/03/19/concrete-math-hw2/"/>
      <url>/2018/03/19/concrete-math-hw2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这章作业提前先做掉了，不是很难，有些算着麻烦了一点，就是倒数第二题不大解释的清楚。</p><p><img src="1.jpg" alt><br><img src="2.jpg" alt><br><img src="3.jpg" alt><br><img src="4.jpg" alt><br><img src="5.jpg" alt><br><img src="6.jpg" alt><br><img src="7.jpg" alt><br><img src="8.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第4课（多重求和方法）</title>
      <link href="/2018/03/19/concrete-math-4/"/>
      <url>/2018/03/19/concrete-math-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天讲了多重求和，也就是一个和式由多个下标来指定。</p><p>首先是最简单的形式：<br>\[\sum\limits_{1 \le j,k \le n} { {a_j}{b_k}}  = (\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {a_k}} )\]</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>下面给出一个对称矩阵：<br>\[A(i,j) = {a_i}{a_j}\]<br>求：<br>\[S = \sum\limits_{1 \le j \le k \le n} { {a_j}{a_k}} \]<br>这是这个矩阵的上三角加对角线求和，因为是对称的嘛，可以补全下三角，加上对角线就行了。<br>\[2S = \sum\limits_{1 \le j,k \le n} { {a_j}{a_k}}  + \sum\limits_{1 \le j = k \le n} { {a_j}{a_k}}  = {(\sum\limits_{1 \le k \le n} { {a_k}} )^2} + \sum\limits_{1 \le k \le n}^{} { {a_k}^2} \]<br>所以<br>\[S = \frac{1}{2}({(\sum\limits_{1 \le k \le n} { {a_k}} )^2} + \sum\limits_{1 \le k \le n}^{} { {a_k}^2} )\]</p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><hr><p>下面再看一个例子：<br>\[S = \sum\limits_{1 \le j &lt; k \le n} {({a_j} - {a_k})({b_j} - {b_k})} \]<br>同样模仿上例调换$j,k$位置，得到：<br>\[\begin{array}{l}2S = \sum\limits_{1 \le j,k \le n} {({a_j} - {a_k})({b_j} - {b_k})}  - \sum\limits_{1 \le j = k \le n} {({a_j} - {a_k})({b_j} - {b_k})} \\ = \sum\limits_{1 \le j,k \le n} {({a_j}{b_j} - {a_j}{b_k} - {a_k}{b_j} + {a_k}{b_k})} \\ = 2\sum\limits_{1 \le j,k \le n} { {a_j}{b_j}}  - 2\sum\limits_{1 \le j,k \le n} { {a_j}{b_k}} \\ = 2n\sum\limits_{1 \le j \le n} { {a_j}{b_j}}  - 2(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} )\end{array}\]<br>所以<br>\[S = n\sum\limits_{1 \le j \le n} { {a_j}{b_j}}  - (\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} )\]<br>至此解完，然后可以推出一个著名的不等式————切比雪夫不等式：<br>\[(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} ) = n\sum\limits_{1 \le j \le n} { {a_j}{b_j}}  - \sum\limits_{1 \le j &lt; k \le n} {({a_j} - {a_k})({b_j} - {b_k})} \]<br>如果<br>\[{a_1} \le {a_2} \le  \cdots  \le {a_n},{b_1} \le {b_2} \le  \cdots  \le {b_n}\]<br>那么<br>\[(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} ) \le n\sum\limits_{1 \le j \le n} { {a_j}{b_j}} \]<br>反之如果<br>\[{a_1} \le {a_2} \le  \cdots  \le {a_n},{b_1} \ge {b_2} \ge  \cdots  \ge {b_n}\]<br>那么<br>\[(\sum\limits_{1 \le j \le n} { {a_j}} )(\sum\limits_{1 \le k \le n} { {b_k}} ) \ge n\sum\limits_{1 \le j \le n} { {a_j}{b_j}} \]<br>更一般的结论，给定两个序列$a$和$b$，求下面式子最大值与最小值：<br>\[\sum\limits_{k = 1}^n { {a_k}{b_{p(k)}}} \]<br>其中$p(k)$是$\{ 1,2, \cdots ,n\} $的一个排列。<br>答案是$b$增序最大，降序最小，至于为什么，下面给出两种证明方法。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><img src="1.jpg" alt><br>如上图所示，$a$和$b$按照递增顺序排列，每个方格的面积代表$a_i$与$b_j$的乘积，记为$s_{ij}$。<br>那么上面的求和式其实就是每一行每一列都必须有且只有一块被取。<br>考虑第一行，如果不取$s_{11}$，取其他的$s_{1j}$，那么第一列也只能取其他的$s_{i1}$，这样的话$s_{ij}$也就取不了了。但是发现<br>\[s_{11}+s_{ij} \ge s_{i1}+s_{1j}\]<br>并且两种取法影响的行和列都是相同的，这说明了，取$s_{i1}$和$s_{1j}$不如取$s_{11}$和$s_{ij}$。所以$s_{11}$必取，然后第一行第一列就不能取了。剩下的方阵用相同的方法可以得出必取$s_{22}, \cdots ,s_{nn}$，也就是主对角线。<br>同理最小取法用副对角线可以推出。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>设数列$a$和$b$非单调递减，那么有如下证明：<br>\[\begin{array}{l}{S_k} = \sum\limits_{i = 1}^k { {b_i}} ,{ {S’}_k} = \sum\limits_{i = 1}^k { {b_{p(i)}}} \\ \Rightarrow {S_k} \le { {S’}_k}\\ \Rightarrow \\\sum\limits_{i = 1}^n { {a_i}{b_i}}  = {S_1}{a_1} - {S_1}{a_2} + {S_2}{a_2} - {S_2}{a_3} +  \cdots  + {S_n}{a_n}\\ = \sum\limits_{i = 1}^{n - 1} { {S_i}} ({a_i} - {a_{i + 1}}) + {S_n}{a_n}\\ \ge \sum\limits_{i = 1}^{n - 1} { { {S’}_i}} ({a_i} - {a_{i + 1}}) + {S_n}{a_n}\\ = \sum\limits_{i = 1}^n { {a_i}{b_{p(i)}}} \end{array}\]<br>反之亦证。</p><p>题外话，其实切比雪夫不等式原来是以微积分形式给出的：<br>如果函数$f(x)$和$g(x)$非单调递减，那么有：<br>\[(\int_a^b {f(x)dx} )(\int_a^b {g(x)dx} ) \le (b - a)(\int_a^b {f(x)g(x)dx} )\]</p><h1 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h1><hr><p>求<br>\[S = \sum\limits_{1 \le j &lt; k \le n} {\frac{1}{ {k - j}}} \]<br>我将用三种方法来求解这个式子。</p><h3 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h3><p>首先将$j$和$k$分开，首先计算对$j$求和：<br>\[\begin{array}{l}S = \sum\limits_{1 \le k \le n} {\sum\limits_{1 \le j &lt; k} {\frac{1}{ {k - j}}} } \\ = \sum\limits_{1 \le k \le n} {\sum\limits_{1 \le k - j &lt; k} {\frac{1}{j}} } \\ = \sum\limits_{1 \le k \le n} {\sum\limits_{0 &lt; j \le k - 1} {\frac{1}{j}} } \\ = \sum\limits_{1 \le k \le n} { {H_{k - 1}}} \\ = \sum\limits_{0 \le k &lt; n} { {H_k}} \end{array}\]</p><h3 id="方法2-1"><a href="#方法2-1" class="headerlink" title="方法2"></a>方法2</h3><p>先计算对$k$求和：<br>\[\begin{array}{l}S = \sum\limits_{1 \le j \le n} {\sum\limits_{j &lt; k \le n} {\frac{1}{ {k - j}}} } \\ = \sum\limits_{1 \le j \le n} {\sum\limits_{j &lt; k + j \le n} {\frac{1}{k}} } \\ = \sum\limits_{1 \le j \le n} {\sum\limits_{0 &lt; k \le n - j} {\frac{1}{k}} } \\ = \sum\limits_{1 \le j \le n} { {H_{n - j}}} \\ = \sum\limits_{0 \le j &lt; n} { {H_j}} \end{array}\]</p><h3 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h3><p>按对角线求和：<br>\[\begin{array}{l}S = \sum\limits_{1 \le j &lt; k \le n} {\frac{1}{ {k - j}}} \\ = \sum\limits_{1 \le j &lt; k + j \le n} {\frac{1}{k}} \\ = \sum\limits_{1 \le k \le n} {\sum\limits_{1 \le j \le n - k} {\frac{1}{k}} } \\ = \sum\limits_{1 \le k \le n} {\frac{ {n - k}}{k}} \\ = n\sum\limits_{1 \le k \le n} {\frac{1}{k} - } \sum\limits_{1 \le k \le n} 1 \\ = n{H_n} - n\end{array}\]</p><p>由此得到了一个完全不同的表示形式！<br>所以我们得到了：<br>\[\sum\limits_{0 \le j &lt; n} { {H_j}}  = n{H_n} - n\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业论文相关细节记录</title>
      <link href="/2018/03/18/graduate-technique/"/>
      <url>/2018/03/18/graduate-technique/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h1><hr><p>这是玄学，姑且就设为我的QQ号，看起来效果不错。</p><h1 id="神经网络维数"><a href="#神经网络维数" class="headerlink" title="神经网络维数"></a>神经网络维数</h1><hr><p>不断测试发现，64维效果最好，但最后可能改成512维的。<br>而且64维的话CPU跑的比GPU还要快6倍，但是512维的话GPU就比CPU快6倍左右了。<br>所以维度低还是用CPU比较好。</p><h1 id="结点分数"><a href="#结点分数" class="headerlink" title="结点分数"></a>结点分数</h1><hr><p>\[\begin{array}{l}Score(A \to BC) = \lambda d \cdot (W \cdot e + b) + Spcfg(A)\\Spcfg(A) = \log (Spcfg(B) \cdot Spcfg(C) \cdot p(A \to BC))\end{array}\]<br>其中$d,W,b$是权值矩阵，$\lambda$是超参数，测试发现设为100左右效果最好。</p><h1 id="结点表示"><a href="#结点表示" class="headerlink" title="结点表示"></a>结点表示</h1><hr><p>\[e = LST{M^{left}}({e_{right}})\]<br>至于用左儿子还是右儿子作为LSTM，还是加一层动态规划记录两者最优值，小数据上暂时没有太大差别。</p><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><hr><p>\[L(\theta ) = Scor{e_{predict}}(ROOT) - Scor{e_{gold}}(ROOT) + k \cdot \Delta (predict,gold) + \frac{1}{2}{\left| \theta  \right|^2}\]<br>其中正则项加了可以使loss下降更稳定，但是效果貌似不如不加，可能是因为数据集太小吧。<br>$k$一般取0.1。</p><h1 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h1><hr><p>batch取50左右效果最好，不过我用的是dynet自带的自动batch，手动batch还不是很会写，所以效率提升不是很大。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><hr><p>原来是4层循环，用时特别久，改进了一下变成6层循环效率大大提高。<br>原算法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">0</span> to n    <span class="token keyword">for</span> j <span class="token keyword">from</span> <span class="token number">0</span> to n        <span class="token keyword">for</span> k <span class="token keyword">from</span> i to j            <span class="token keyword">for</span> A<span class="token operator">-</span><span class="token operator">></span>BC <span class="token keyword">in</span> grammar                balabala<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改进算法：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">0</span> to n    <span class="token keyword">for</span> j <span class="token keyword">from</span> <span class="token number">0</span> to n        <span class="token keyword">for</span> k <span class="token keyword">from</span> i to j            <span class="token keyword">for</span> B <span class="token keyword">in</span> nodetype<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                <span class="token keyword">for</span> C <span class="token keyword">in</span> nodetype<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                    <span class="token keyword">for</span> A <span class="token keyword">in</span> panode<span class="token punctuation">[</span>BC<span class="token punctuation">]</span>                        balabala<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="未来改进"><a href="#未来改进" class="headerlink" title="未来改进"></a>未来改进</h1><hr><ul><li>如果测试集中的句法规则在训练集中没有出现的话，会直接产生None的结果，是否可以考虑产生新的规则，这样就可以对所有句子进行句法分析了？</li><li>效率虽然有了很大提升，但是大数据依然跑的很慢，可以考虑加上手动batch、减少规则数量、动态规划算法优化等等。</li></ul><p>最后附上我的主要代码（丑是丑了点，不喜勿喷，封装什么的以后再说）：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict <span class="token keyword">as</span> dd<span class="token punctuation">,</span> defaultdict<span class="token keyword">from</span> itertools <span class="token keyword">import</span> count<span class="token keyword">import</span> re<span class="token keyword">import</span> time<span class="token keyword">import</span> math<span class="token keyword">import</span> _dynet <span class="token keyword">as</span> dydyparams <span class="token operator">=</span> dy<span class="token punctuation">.</span>DynetParams<span class="token punctuation">(</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>from_args<span class="token punctuation">(</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>set_requested_gpus<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>set_mem<span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>set_random_seed<span class="token punctuation">(</span><span class="token number">792321264</span><span class="token punctuation">)</span>dyparams<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># read train file</span>DEBUG <span class="token operator">=</span> <span class="token boolean">True</span>train_string_file <span class="token operator">=</span> <span class="token string">"data/train.strings"</span>train_tree_file <span class="token operator">=</span> <span class="token string">"data/train.trees.pre.unk"</span>dev_string_file <span class="token operator">=</span> <span class="token string">"data/dev.strings"</span>dev_tree_file <span class="token operator">=</span> <span class="token string">"data/dev.trees"</span>dev_parse_file <span class="token operator">=</span> <span class="token string">"data/dev.parses"</span><span class="token keyword">if</span> DEBUG<span class="token punctuation">:</span>    train_string_file <span class="token operator">=</span> <span class="token string">"data/train_small.strings"</span>    train_tree_file <span class="token operator">=</span> <span class="token string">"data/train_small.trees.pre.unk"</span>    dev_string_file <span class="token operator">=</span> <span class="token string">"data/dev_small.strings"</span>    dev_tree_file <span class="token operator">=</span> <span class="token string">"data/dev_small.trees"</span>    dev_parse_file <span class="token operator">=</span> <span class="token string">"data/dev_small.parses"</span>train_string <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>train_tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">with</span> open<span class="token punctuation">(</span>train_string_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>        train_string<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span>        <span class="token keyword">for</span> word <span class="token keyword">in</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>word<span class="token punctuation">)</span>words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"&lt;unk>"</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span>train_tree_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>        train_tree<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span>w2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>    w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span>i2w <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> w2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>nwords <span class="token operator">=</span> len<span class="token punctuation">(</span>w2i<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># read grammar file</span>nonTerms <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>rules_set1 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>rules_set2 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>rules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>lexicons <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>origText <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>probs <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>node_pa <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">def</span> <span class="token function">read_grammar</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>    grammar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    file <span class="token operator">=</span> open<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> rule <span class="token keyword">in</span> file<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># AAA -> # BBB @ prob</span>        tokens <span class="token operator">=</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">"\-\>|\@"</span><span class="token punctuation">,</span> rule<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        lhs <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        rhs <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span>r<span class="token string">'\''</span><span class="token punctuation">)</span>        rhs <span class="token operator">=</span> rhs<span class="token punctuation">.</span>strip<span class="token punctuation">(</span>r<span class="token string">'\"'</span><span class="token punctuation">)</span>        prob <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        probs<span class="token punctuation">[</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> float<span class="token punctuation">(</span>prob<span class="token punctuation">)</span>        nonTerms<span class="token punctuation">.</span>add<span class="token punctuation">(</span>lhs<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            rules_set1<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            rules_set2<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> rhs <span class="token keyword">in</span> node_pa<span class="token punctuation">:</span>                node_pa<span class="token punctuation">[</span>rhs<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>lhs<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                node_pa<span class="token punctuation">[</span>rhs<span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>                node_pa<span class="token punctuation">[</span>rhs<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>lhs<span class="token punctuation">)</span>        rules<span class="token punctuation">[</span>lhs<span class="token punctuation">]</span> <span class="token operator">=</span> rhs        <span class="token keyword">if</span> len<span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">and</span> rhs <span class="token operator">!=</span> <span class="token string">'&lt;unk>'</span><span class="token punctuation">:</span>            lexicons<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token keyword">if</span> DEBUG<span class="token punctuation">:</span>    grammar <span class="token operator">=</span> read_grammar<span class="token punctuation">(</span><span class="token string">'data/pcfg_small'</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    grammar <span class="token operator">=</span> read_grammar<span class="token punctuation">(</span><span class="token string">'data/pcfg'</span><span class="token punctuation">)</span><span class="token keyword">print</span> rules_set1<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rules_set2<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># LSTM and parameters initialization</span>EPOCH <span class="token operator">=</span> <span class="token number">40</span>EMBDDING_SIZE <span class="token operator">=</span> <span class="token number">512</span>lamda <span class="token operator">=</span> <span class="token number">100</span>k <span class="token operator">=</span> <span class="token number">0.1</span>model <span class="token operator">=</span> dy<span class="token punctuation">.</span>ParameterCollection<span class="token punctuation">(</span><span class="token punctuation">)</span>builder <span class="token operator">=</span> dy<span class="token punctuation">.</span>FastLSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">,</span> model<span class="token punctuation">)</span>trainer <span class="token operator">=</span> dy<span class="token punctuation">.</span>AdamTrainer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>WORDS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>nwords<span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>pd <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>pW <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>EMBDDING_SIZE<span class="token punctuation">,</span> EMBDDING_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span>pb <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>EMBDDING_SIZE<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ==============================================================</span><span class="token comment" spellcheck="true"># construct trees</span><span class="token keyword">class</span> <span class="token class-name">MTree</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lhs<span class="token punctuation">,</span> wrd<span class="token operator">=</span>None<span class="token punctuation">,</span> subs<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>label <span class="token operator">=</span> lhs        self<span class="token punctuation">.</span>word <span class="token operator">=</span> wrd        self<span class="token punctuation">.</span>subs <span class="token operator">=</span> subs        self<span class="token punctuation">.</span>str <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">is_lexicon</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>word <span class="token keyword">is</span> <span class="token operator">not</span> None    <span class="token keyword">def</span> <span class="token function">dostr</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"(%s %s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>label<span class="token punctuation">,</span> self<span class="token punctuation">.</span>word<span class="token punctuation">)</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_lexicon<span class="token punctuation">(</span><span class="token punctuation">)</span> \                <span class="token keyword">else</span> <span class="token string">"(%s %s)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>label<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> self<span class="token punctuation">.</span>subs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token boolean">True</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>str <span class="token keyword">is</span> None<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>str <span class="token operator">=</span> self<span class="token punctuation">.</span>dostr<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>str<span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>    begin <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    end <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    A <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> next <span class="token operator">not</span> <span class="token keyword">in</span> backPointers<span class="token punctuation">:</span>        <span class="token keyword">if</span> next <span class="token keyword">in</span> terminals<span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#base condition</span>            word <span class="token operator">=</span> origText<span class="token punctuation">[</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            node <span class="token operator">=</span> MTree<span class="token punctuation">(</span>lhs<span class="token operator">=</span>A<span class="token punctuation">,</span> subs<span class="token operator">=</span>None<span class="token punctuation">,</span> wrd<span class="token operator">=</span>word<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span>split<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=</span> backPointers<span class="token punctuation">[</span>next<span class="token punctuation">]</span>    next1 <span class="token operator">=</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span>    next2 <span class="token operator">=</span> <span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span>    t1<span class="token punctuation">,</span> s1 <span class="token operator">=</span> helper<span class="token punctuation">(</span>next1<span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    t2<span class="token punctuation">,</span> s2 <span class="token operator">=</span> helper<span class="token punctuation">(</span>next2<span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>MTree<span class="token punctuation">(</span>lhs<span class="token operator">=</span>A<span class="token punctuation">,</span> subs<span class="token operator">=</span><span class="token punctuation">[</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">]</span><span class="token punctuation">,</span> wrd<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>text<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> backPointers<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    t<span class="token punctuation">,</span> s <span class="token operator">=</span> helper<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'S'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">math_log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">100</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">score_calc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> p<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> d <span class="token operator">*</span> <span class="token punctuation">(</span>W <span class="token operator">*</span> p <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> lamda <span class="token operator">+</span> s_pcfg<span class="token keyword">def</span> <span class="token function">cal_loss</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> gold<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> result <span class="token operator">==</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> dy<span class="token punctuation">.</span>inputTensor<span class="token punctuation">(</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span>len<span class="token punctuation">(</span>gold<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> result<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    gold <span class="token operator">=</span> gold<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    cnt <span class="token operator">=</span> dy<span class="token punctuation">.</span>inputTensor<span class="token punctuation">(</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> cnt<span class="token keyword">def</span> <span class="token function">cal_gold</span><span class="token punctuation">(</span>gold<span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    words <span class="token operator">=</span> gold<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        A <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        word <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># print gold, word, w2i[word]</span>        LSTM <span class="token operator">=</span> builder<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>        TMP <span class="token operator">=</span> LSTM<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>WORDS_LOOKUP<span class="token punctuation">[</span>w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        e <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>        s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> e<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> s<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">,</span> TMP<span class="token punctuation">,</span> A<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        sz <span class="token operator">=</span> len<span class="token punctuation">(</span>gold<span class="token punctuation">)</span>        p <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>                p <span class="token operator">=</span> i                <span class="token keyword">break</span>        m <span class="token operator">=</span> <span class="token number">0</span>        cnt <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">:</span>                cnt <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> gold<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">:</span>                cnt <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                m <span class="token operator">=</span> i                <span class="token keyword">break</span>        x1<span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s1_pcfg<span class="token punctuation">,</span> LSTM1<span class="token punctuation">,</span> B <span class="token operator">=</span> cal_gold<span class="token punctuation">(</span>gold<span class="token punctuation">[</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">:</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        x2<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s2_pcfg<span class="token punctuation">,</span> LSTM2<span class="token punctuation">,</span> C <span class="token operator">=</span> cal_gold<span class="token punctuation">(</span>gold<span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">2</span> <span class="token punctuation">:</span> sz<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        A <span class="token operator">=</span> gold<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>p<span class="token punctuation">]</span>        TMP <span class="token operator">=</span> LSTM2<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>x1<span class="token punctuation">)</span>        e <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>        s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>C<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> s1_pcfg <span class="token operator">+</span> s2_pcfg        ss1 <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> e<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> ss1<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">,</span> TMP<span class="token punctuation">,</span> A<span class="token punctuation">)</span>total_time <span class="token operator">=</span> <span class="token number">0.0</span><span class="token comment" spellcheck="true"># print nonTerms.__len__()</span>ff <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"loss.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">"epoch %d"</span> <span class="token operator">%</span> epoch    sumloss <span class="token operator">=</span> <span class="token number">0</span>    num <span class="token operator">=</span> len<span class="token punctuation">(</span>train_string<span class="token punctuation">)</span>    batch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> line <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_string<span class="token punctuation">)</span><span class="token punctuation">:</span>        sstart <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        gold <span class="token operator">=</span> train_tree<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>        sent <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>        origText <span class="token operator">=</span> list<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>        d <span class="token operator">=</span> pd<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>        W <span class="token operator">=</span> pW<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>        b <span class="token operator">=</span> pb<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>        terminals <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        embdding <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        score <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>        score_pcfg <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>        backPointers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        LSTM <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        node_rules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            begin <span class="token operator">=</span> i            end <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>            word <span class="token operator">=</span> sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">for</span> A <span class="token keyword">in</span> nonTerms<span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span> <span class="token keyword">in</span> rules_set1<span class="token punctuation">:</span>                    LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> builder<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>                    LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>WORDS_LOOKUP<span class="token punctuation">[</span>w2i<span class="token punctuation">[</span>sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                    score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    terminals<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> word                    node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        <span class="token keyword">for</span> span <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> begin <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> span <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                end <span class="token operator">=</span> begin <span class="token operator">+</span> span                node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> split <span class="token keyword">in</span> range<span class="token punctuation">(</span>begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> B <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        <span class="token keyword">for</span> C <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                            X <span class="token operator">=</span> B<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>C                            <span class="token keyword">if</span> X <span class="token keyword">in</span> node_pa<span class="token punctuation">:</span>                                <span class="token keyword">for</span> A <span class="token keyword">in</span> node_pa<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">:</span>                                    node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>                                    TMP <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                    p <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                                    s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span>                                    s <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> p<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span>                                    <span class="token comment" spellcheck="true"># print (d * (W * p + b) * 100).value(), s_pcfg</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> score <span class="token operator">or</span> s<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                        LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> TMP                                        score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s                                        score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s_pcfg                                        embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> p                                        backPointers<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>split<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>        t<span class="token punctuation">,</span> s <span class="token operator">=</span> backtrack<span class="token punctuation">(</span>sent<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>        result <span class="token operator">=</span> None        <span class="token keyword">if</span> t <span class="token operator">!=</span> None<span class="token punctuation">:</span>            result <span class="token operator">=</span> t<span class="token punctuation">.</span>dostr<span class="token punctuation">(</span><span class="token punctuation">)</span>        golds_e<span class="token punctuation">,</span> golds<span class="token punctuation">,</span> golds_pcfg<span class="token punctuation">,</span> lstm<span class="token punctuation">,</span> S <span class="token operator">=</span> cal_gold<span class="token punctuation">(</span>gold<span class="token punctuation">,</span> d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> b<span class="token punctuation">)</span>        cnt <span class="token operator">=</span> cal_loss<span class="token punctuation">(</span>result<span class="token punctuation">,</span> gold<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># loss = dy.abs(s - golds) + cnt * k</span>        loss <span class="token operator">=</span> dy<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>s <span class="token operator">-</span> golds<span class="token punctuation">)</span> <span class="token operator">+</span> cnt <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">0.5</span> <span class="token operator">*</span> <span class="token punctuation">(</span>dy<span class="token punctuation">.</span>l2_norm<span class="token punctuation">(</span>W<span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span>l2_norm<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> dy<span class="token punctuation">.</span>l2_norm<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>        sumloss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>        batch<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>batch<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">50</span><span class="token punctuation">:</span>            loss <span class="token operator">=</span> dy<span class="token punctuation">.</span>esum<span class="token punctuation">(</span>batch<span class="token punctuation">)</span>            loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            trainer<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>            dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>            batch <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        eend <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># print "time of sent ", idx, ": ", eend - sstart</span>        <span class="token keyword">if</span> idx <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> idx <span class="token operator">%</span> <span class="token number">500</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> <span class="token string">"time of 500 sent: "</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>eend <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>idx <span class="token operator">/</span> <span class="token number">500</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># print idx, " -------------"</span>            <span class="token comment" spellcheck="true"># print "result: " + result</span>            <span class="token comment" spellcheck="true"># print "gold:   " + gold</span>            <span class="token comment" spellcheck="true"># print "loss: ", loss.value()</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    total_time <span class="token operator">+=</span> end <span class="token operator">-</span> start    <span class="token keyword">print</span> <span class="token string">"epoch time: "</span><span class="token punctuation">,</span> end <span class="token operator">-</span> start    <span class="token keyword">print</span> <span class="token string">"epoch loss: "</span><span class="token punctuation">,</span> sumloss <span class="token operator">/</span> num    ff<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'%f\n'</span><span class="token operator">%</span><span class="token punctuation">(</span>sumloss <span class="token operator">/</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">"total time: "</span><span class="token punctuation">,</span> total_timefh <span class="token operator">=</span> open<span class="token punctuation">(</span>dev_string_file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span>outfile <span class="token operator">=</span> open<span class="token punctuation">(</span>dev_parse_file<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>    sent <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    origText <span class="token operator">=</span> list<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> word <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>sent<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> word <span class="token operator">not</span> <span class="token keyword">in</span> lexicons<span class="token punctuation">:</span>            sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'&lt;unk>'</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    d <span class="token operator">=</span> pd<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>    W <span class="token operator">=</span> pW<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> pb<span class="token punctuation">.</span>expr<span class="token punctuation">(</span><span class="token punctuation">)</span>    terminals <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    embdding <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    score <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>    score_pcfg <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>float<span class="token punctuation">)</span>    backPointers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    LSTM <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    node_rules <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        begin <span class="token operator">=</span> i        end <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        word <span class="token operator">=</span> sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> A <span class="token keyword">in</span> nonTerms<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span> <span class="token keyword">in</span> rules_set1<span class="token punctuation">:</span>                LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> builder<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>                LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>WORDS_LOOKUP<span class="token punctuation">[</span>w2i<span class="token punctuation">[</span>sent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                terminals<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> word                node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>    <span class="token keyword">for</span> span <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> begin <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> span <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            end <span class="token operator">=</span> begin <span class="token operator">+</span> span            node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> split <span class="token keyword">in</span> range<span class="token punctuation">(</span>begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> B <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">for</span> C <span class="token keyword">in</span> node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        X <span class="token operator">=</span> B<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>C                        <span class="token keyword">if</span> X <span class="token keyword">in</span> node_pa<span class="token punctuation">:</span>                            <span class="token keyword">for</span> A <span class="token keyword">in</span> node_pa<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">:</span>                                node_rules<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>A<span class="token punctuation">)</span>                                TMP <span class="token operator">=</span> LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                                p <span class="token operator">=</span> TMP<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span>                                s_pcfg <span class="token operator">=</span> math_log<span class="token punctuation">(</span>probs<span class="token punctuation">[</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> split<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>split<span class="token punctuation">,</span> end<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">]</span>                                s <span class="token operator">=</span> score_calc<span class="token punctuation">(</span>d<span class="token punctuation">,</span> W<span class="token punctuation">,</span> p<span class="token punctuation">,</span> b<span class="token punctuation">,</span> lamda<span class="token punctuation">,</span> s_pcfg<span class="token punctuation">)</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> score <span class="token operator">or</span> s<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                                    LSTM<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> TMP                                    score<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s                                    score_pcfg<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> s_pcfg                                    embdding<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> p                                    backPointers<span class="token punctuation">[</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>split<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>    t<span class="token punctuation">,</span> s <span class="token operator">=</span> backtrack<span class="token punctuation">(</span>sent<span class="token punctuation">,</span> backPointers<span class="token punctuation">,</span> terminals<span class="token punctuation">,</span> score<span class="token punctuation">)</span>    <span class="token keyword">if</span> t <span class="token operator">==</span> None<span class="token punctuation">:</span>        outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"None\n"</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> t<span class="token punctuation">.</span>dostr<span class="token punctuation">(</span><span class="token punctuation">)</span>        outfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>result<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第3课（递归式转化为求和求解）</title>
      <link href="/2018/03/12/concrete-math-3/"/>
      <url>/2018/03/12/concrete-math-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天讲了一种将递归式转化为求和的方法。</p><p>考虑如下递归式：<br>\[{a_n}{T_n} = {b_n}{T_{n - 1}} + {c_n}\]<br>两边同时乘以$s_n$得到：<br>\[{s_n}{a_n}{T_n} = {s_n}{b_n}{T_{n - 1}} + {s_n}{c_n}\]<br>要想转化成可以求和的递归式，那么必须有：<br>\[{s_n}{b_n} = {s_{n - 1}}{a_{n - 1}}\]<br>也就是：<br>\[{s_n} = \frac { { {a_{n - 1}}{a_{n - 2}} \cdots {a_1}}}{ { {b_n}{b_{n - 1}} \cdots {b_2}}}\]<br>这时令<br>\[{S_n} = {s_n}{a_n}{T_n}\]<br>得到：<br>\[{S_n} = {S_{n - 1}} + {s_n}{c_n}\]<br>这时就可以转化为求和了，解出：<br>\[{S_n} = {s_0}{a_0}{T_0} + \sum\limits_{k = 1}^n { {s_k}{c_k}} \]<br>所以<br>\[{T_n} = \frac{1}{ { {s_n}{a_n}}}({s_0}{a_0}{T_0} + \sum\limits_{k = 1}^n { {s_k}{c_k}} )\]</p><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><hr><p>设$n$个数快速排序的操作次数为$C_n$，那么有<br>\[\begin{array}{l}{C_0} = 0\\{C_n} = n + 1 + \frac{2}{n}\sum\limits_{k = 0}^{n - 1} { {C_k}} ,n &gt; 0\end{array}\]<br>用$n-1$取代$n$可以得到<br>\[{C_{n - 1}} = n + \frac{2}{ {n - 1}}\sum\limits_{k = 0}^{n - 2} { {C_k}} ,n &gt; 1\]<br>两式相减可以得到<br>\[\begin{array}{l}{C_0} = 0\\n{C_n} = (n + 1){C_{n - 1}} + 2n,n &gt; 0\end{array}\]<br>由上面方法可以得到<br>\[{a_n} = n,{b_n} = n + 1,{c_n} = 2n\]<br>所以<br>\[{s_n} = \frac{2}{ {n(n + 1)}}\]<br>进而可以求出<br>\[{C_n} = 2(n + 1)\sum\limits_{k = 1}^n {\frac{1}{ {k + 1}}} \]<br>这里介绍一个概念叫做调和级数：<br>\[{H_n} = 1 + \frac{1}{2} +  \cdots  + \frac{1}{n} = \sum\limits_{k = 1}^n {\frac{1}{k}} \]<br>所以<br>\[{C_n} = 2(n + 1){H_n} - 2n\]</p><h1 id="求和三大定律"><a href="#求和三大定律" class="headerlink" title="求和三大定律"></a>求和三大定律</h1><hr><p>结合律、分配率、交换律。这里就不展开说了，相信你们都知道的。<br>来两题简单的例题说明一下。</p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><hr><p>求<br>\[S = \sum\limits_{0 \le k \le n} {(a + bk)} \]<br>普通的方法每个人应该都会，等差数列嘛。这里用求和定律来做一做。<br>用$n-k$取代$k$，得到<br>\[S = \sum\limits_{0 \le n - k \le n} {(a + b(n - k))} \]<br>即<br>\[S = \sum\limits_{0 \le k \le n} {(a + b(n - k))} \]<br>两式相加得到<br>\[2S = \sum\limits_{0 \le k \le n} {(2a + bn)}  = (2a + bn)\sum\limits_{0 \le k \le n} 1  = (2a + bn)(n + 1)\]<br>所以<br>\[S = (2a + bn)(n + 1)/2\]</p><h1 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h1><hr><p>求<br>\[S = \sum\limits_{0 \le k \le n} {k{x^k}} \]<br>这里用到另一种求和的方法。<br>两边同时加上第$n+1$项，得到<br>\[\begin{array}{l}S + (n + 1){x^{n + 1}}\\ = \sum\limits_{0 \le k \le n + 1} {k{x^k}} \\ = \sum\limits_{1 \le k \le n + 1} {k{x^k}} \\ = \sum\limits_{0 \le k \le n} {(k + 1){x^{k + 1}}} \\ = x\sum\limits_{0 \le k \le n} {(k{x^k} + {x^k})} \\ = xS + x\sum\limits_{0 \le k \le n} { {x^k}} \\ = xS + x\frac{ {1 - {x^{n + 1}}}}{ {1 - x}}\end{array}\]<br>所以<br>\[S = \frac{ {x - (n + 1){x^{n + 1}} + n{x^{n + 2}}}}{ { { {(1 - x)}^2}}}\]<br>这里介绍另一种方法来求解。<br>令<br>\[f(x) = \sum\limits_{0 \le k \le n} { {x^k}}  = \frac{ {1 - {x^{n + 1}}}}{ {1 - x}}\]<br>求导得到<br>\[f’(x) = \sum\limits_{0 \le k \le n} {k{x^{k - 1}}}  = \frac{1}{x}S\]<br>所以<br>\[\frac{1}{x}S = \frac{ {\partial f}}{ {\partial x}}(\frac{ {1 - {x^{n + 1}}}}{ {1 - x}}) = \frac{ {1 - (n + 1){x^n} + n{x^{n + 1}}}}{ { { {(1 - x)}^2}}}\]<br>同样可以得到<br>\[S = \frac{ {x - (n + 1){x^{n + 1}} + n{x^{n + 2}}}}{ { { {(1 - x)}^2}}}\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16.04下Nvidia+Cuda8.0+Dynet安装教程</title>
      <link href="/2018/03/09/nvidia-cuda-dynet/"/>
      <url>/2018/03/09/nvidia-cuda-dynet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>之前也在笔记本上装过几次cuda，均以失败告终，网上的教程都没有完全能拿来用的，多多少少都会出现一些问题。<br>这次终于完完全全安装成功了，可喜可贺。。。说起来都是泪。</p><p>注意显卡驱动安装最新版就行了，但是cuda最好还是别安装最新版了，装个8.0版本吧，不然都是泪。</p><p>最终版本为ubuntu16.04 + cuda8.0 + gcc5.4。</p><h1 id="NVIDIA驱动安装"><a href="#NVIDIA驱动安装" class="headerlink" title="NVIDIA驱动安装"></a>NVIDIA驱动安装</h1><hr><p>进入<a href="http://www.nvidia.com/Download/index.aspx?lang=en-us" target="_blank" rel="noopener">NVIDIA官网</a>，选择适合自己显卡的驱动，下载后是一个.run文件。</p><p>清除之前安装过的NVIDIA：<code>sudo apt-get remove --purge nvidia*</code></p><p>禁止nouveau等驱动：<code>sudo gedit /etc/modprob.d/blacklist.conf</code></p><p>加入下列语句并保存：</p><pre><code>blacklist vga16fbblacklist nouveaublacklist rivafbblacklist nvidiafbblacklist rivatv</code></pre><p>执行<code>sudo update-initramfs -u</code>并重启<code>reboot</code>。</p><p>按<code>ctrl+alt+f1</code>，登录命令行界面。</p><p>执行<code>sudo service lightdm stop</code></p><p>进入NVIDIA.run目录，运行<code>sudo sh ./NVIDIA.run –no-x-check –no-nouveau-check –no-opengl-files</code></p><p>安装过程中会报错，直接无视。会问你要不要自动更新X配置文件，选择是就行了。</p><p>重启。输入<code>sudo nvidia-smi</code>或者<code>nvidia-settings</code>，如果显示显卡信息，那么恭喜你安装成功了。</p><h1 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h1><hr><p>进入<a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">cuda官网</a>，根据自己版本下载cuda.run文件。</p><p>执行<code>sudo sh cuda.run</code>，注意中间问你要不要安装驱动程序，选择no</p><p>执行<code>sudo gedit /etc/profile</code><br>添加下列语句并保存：</p><pre><code>export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$LD_LIBRARY_PATH</code></pre><p>重启，打开<code>/NVIDIA_CUDA-8.0_Samples/1_Utilities/deviceQuery</code></p><p>执行<code>sudo make</code>和<code>./deviceQuery</code>，如果出现显卡信息，那么cuda安装成功了。</p><h1 id="Dynet安装"><a href="#Dynet安装" class="headerlink" title="Dynet安装"></a>Dynet安装</h1><hr><p>首先安装Anaconda，过程就不说了，直接运行shell脚本就行了。</p><p>然后重要的地方来了，创建虚拟环境，在虚拟环境里安装dynet！！！</p><p>执行</p><pre><code>conda create --name python2 python=2 cython numpysource activate python2</code></pre><p>然后CPU版本的话很简单，直接执行<code>pip install dynet</code>就行了。</p><p>GPU版本执行<code>BACKEND=cuda pip install git+https://github.com/clab/dynet#egg=dynet -i https://pypi.tuna.tsinghua.edu.cn/simple</code>。</p><p>然后就成功啦，但是运行dynet程序的时候还是会报错，找不到libcudart库，这时执行下面三条语句就行了：</p><pre><code>sudo cp /usr/local/cuda-8.0/lib64/libcudart.so.8.0 /usr/local/lib/libcudart.so.8.0 &amp;&amp; sudo ldconfigsudo cp /usr/local/cuda-8.0/lib64/libcublas.so.8.0 /usr/local/lib/libcublas.so.8.0 &amp;&amp; sudo ldconfigsudo cp /usr/local/cuda-8.0/lib64/libcurand.so.8.0 /usr/local/lib/libcurand.so.8.0 &amp;&amp; sudo ldconfig</code></pre><p>然后终于可以运行了，感动哭了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynet </tag>
            
            <tag> cuda </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第一章作业解答</title>
      <link href="/2018/03/05/concrete-math-hw1/"/>
      <url>/2018/03/05/concrete-math-hw1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这是我的第一章作业答案，只有四题，标准答案太精简了。</p><p>总体做下来，只有最后一题的第二小问一开始算错了，正如题目所说，的确有点难想。我看了标准答案的式子，想了一会儿才想出来的。。。</p><p><img src="1.jpg" alt><br><img src="2.jpg" alt><br><img src="3.jpg" alt><br><img src="4.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第2课（成套方法求解递归式）</title>
      <link href="/2018/03/05/concrete-math-2/"/>
      <url>/2018/03/05/concrete-math-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天主要讲了关于递推式和求和的一些方法，主要是成套方法。</p><h1 id="约瑟夫环推广"><a href="#约瑟夫环推广" class="headerlink" title="约瑟夫环推广"></a>约瑟夫环推广</h1><p>上一节课说到，约瑟夫环问题的解是<br>\[f(n) = 2l + 1\]<br>其中$n = {2^m} + l$<br>将$n$写成二进制可以发现，$f(n)$就是$n$的二进制循环左移1位。<br>现在做一下推广，求解如下递推式：<br>\[\begin{array}{l}f(1) = \alpha \\f(2n) = 2f(n) + \beta \\f(2n + 1) = 2f(n) + \gamma \end{array}\]<br>可以设<br>\[f(n) = A(n)\alpha  + B(n)\beta  + C(n)\gamma \]<br>同样，令$n = {2^m} + l$<br>可以解出<br>\[\begin{array}{l}A(n) = {2^m}\\B(n) = {2^m} - 1 - l\\C(n) = l\end{array}\]<br>再从二进制角度理解一下，将递推式继续推广：<br>\[\begin{array}{l}f(j) = {\alpha _j},1 \le j &lt; d\\f(dn + j) = cf(n) + {\beta _j},0 \le j \le d,n \ge 1\end{array}\]<br>可以得到解为<br>\[f({({b_m}{b_{m - 1}} \ldots {b_1}{b_0})_d}) = {({\alpha _{ {b_m}}}{\beta _{ {b_{m - 1}}}}{\beta _{ {b_{m - 2}}}} \ldots {\beta _{ {b_1}}}{\beta _{ {b_0}}})_c}\]</p><h1 id="递推式求和"><a href="#递推式求和" class="headerlink" title="递推式求和"></a>递推式求和</h1><p>求解如下递推式：<br>\[\begin{array}{l}{R_0} = \alpha \\{R_n} = {R_{n - 1}} + \beta n + \gamma \end{array}\]<br>用成套方法求解，设<br>\[{R_n} = A(n)\alpha  + B(n)\beta  + C(n)\gamma \]<br>首先令${R_n} = 1$，可以得到$\alpha  = 1,\beta  = 0,\gamma  = 0$，所以$A(n) = 1$。<br>再令${R_n} = n$，可以得到$\alpha  = 0,\beta  = 0,\gamma  = 1$，所以$C(n) = n$。<br>最后令${R_n} = {n^2}$，可以得到$\alpha  = 0,\beta  = 2,\gamma  =  - 1$，所以$2B(n) - C(n) = {n^2}$，所以$B(n) = ({n^2} + n)/2$</p><p>再来一个更复杂的递推式：<br>\[\begin{array}{l}{R_0} = \alpha \\{R_n} = 2{R_{n - 1}} + \beta n + \gamma \end{array}\]<br>同样的方法，设<br>\[{R_n} = A(n)\alpha  + B(n)\beta  + C(n)\gamma \]<br>首先令${R_n} = 1$，可以得到$\alpha  = 1,\beta  = 0,\gamma  = -1$，所以$A(n) - C(n) = 1$。<br>再令${R_n} = n$，可以得到$\alpha  = 0,\beta  = -1,\gamma  = 2$，所以$2C(n) - B(n) = n$。<br>这时候能不能令${R_n} = {n^2}$呢？答案是不能，因为如果${R_n} = {n^2}$，那么<br>\[{n^2} = 2{(n - 1)^2} + \beta n + \gamma \]显然不可能成立。<br>观察系数，可以令${R_n} = 2^n$，可以得到$\alpha  = 1,\beta  = 0,\gamma  = 0$，所以$A(n) = 2^n$。<br>所以<br>\[A(n) = {2^n},B(n) = {2^{n + 1}} - n + 2,C(n) = {2^n} + 1\]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>具体数学-第1课（递归求解实际问题）</title>
      <link href="/2018/02/27/concrete-math-1/"/>
      <url>/2018/02/27/concrete-math-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这学期提前选修了研究生的课程：具体数学、人工智能前沿、NLP讨论班，就随便记记具体数学每一节课所学的东西吧。</p><p>第一节课讲的都是一些很简单的东西，这里就一带而过了。</p><h1 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h1><hr><p>这是个老生常谈的问题了，n个盘子，3个柱子的汉诺塔问题，最少移动次数记为$T(n)$。<br>那么\[T(n)=2T(n-1)+1\]<br>边界条件为$T(0)=0$。<br>解出\[T(n)=2^n-1\]<br>验证可以采用数学归纳法，这里就不多说了。</p><h1 id="直线分割平面问题"><a href="#直线分割平面问题" class="headerlink" title="直线分割平面问题"></a>直线分割平面问题</h1><hr><p>这也是个高中问题了，n条直线最多分割平面为几部分，记为$L(n)$。<br>那么\[L(n)=L(n-1)+n\]<br>边界条件为$L(0)=1$。<br>解出\[L(n)=n(n+1)/2+1\]</p><p>这题有个扩展，n个V型最多分割平面为几部分？<br>解决思路如下：<br><img src="1.jpg" alt><br>如上图所示，将V型补全（红色虚线部分），那么就转化为了$2n$条直线划分平面数，那么n个V型划分数只要减去$2n$就行了，所以答案为：<br>\[Z(n)=L(2n)-2n=2n^2-n+1\]</p><h1 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h1><hr><p>这个问题暴力求解的话模拟就行了，复杂度是$O(n^2)$的，这里探索一种直接求解的方法。<br>分两种情况讨论：<br>当有$2n$个人时，踢掉$n$个人之后，情况如下图所示<br><img src="2.jpg" alt><br>观察对应关系可以得出<br>\[J(2n)=2J(n)-1\]<br>同理，当有$2n+1$个人时，踢掉$n+1$个人之后，情况如下图所示<br><img src="3.jpg" alt><br>观察对应关系可以得出<br>\[J(2n+1)=2J(n)+1\]<br>边界条件为<br>\[J(1)=1\]<br>这个递推式很难求解，但是枚举出前面几项可以发现，如果令$n=2^m+l$，其中$2^m$是小于等于$n$的最大2的幂，那么<br>\[J(n)=2l+1\]<br>正确性可以通过数学归纳法求证。</p><p>第一节课就讲了这么多，约瑟夫环还有很多问题值得探讨，下节课继续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业论文代码实现思路</title>
      <link href="/2018/02/26/biyelunwen/"/>
      <url>/2018/02/26/biyelunwen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>一个寒假就写了个基本的代码，难受啊，整理一下思路吧，好久不看代码头都大了。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><hr><p>首先使用的是PTB数据集，原始的数据是长这样的：<br>(S (NP-SBJ (NNP Ms.) (NNP Haag) ) (VP (VBZ plays) (NP (NNP Elianti) )) (. .) )</p><p>因为不一定是二叉树，所以要先预处理成二叉树，这里全部借用了github上别人的代码来进行预处理，二叉化之后变成了这样：<br>(S (S*^. (NP-SBJ (NNP Ms.) (NNP Haag)) (VP (VBZ plays) (NP_NNP Elianti))) (. .))</p><p>然后将整个数据集中出现次数过小的单词替换为unk：<br>(S (S*^. (NP-SBJ (NNP Ms.) (NNP Haag)) (VP (VBZ plays) (NP_NNP &lt; unk&gt;))) (. .))</p><p>最后还需要将每个训练数据对应的句子单独提取出来，方便训练时用，比如上面的例子提取出来就是：<br>Ms. Haag plays Elianti . </p><h1 id="文法规则提取"><a href="#文法规则提取" class="headerlink" title="文法规则提取"></a>文法规则提取</h1><hr><p>接着还是利用现成代码将数据集中出现的所有文法生成规则提取出来，保存到文件pcfg中。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><hr><p>这部分大部分代码是自己写的，也有一部分是从CKY算法代码修改得到的。</p><p>首先将数据集中出现的所有单词和词向量数组下标一一映射，词性类别也做一个映射吧。</p><p>然后初始化神经网络的各个参数，要训练的权值矩阵一共有两个，$W$和$d$，接下来就是训练了。</p><p>训练过程是这样的，采用了动态规划的思想，用三个维度$i$，$j$，$A$来表示这个句子从第$i$个位置到第$j$个位置且类别为$A$的信息。<br>用$e(i,j,A)$作为每个结点的向量表示，然后对他的儿子的所有情况进行遍历：<br>\[e(i,j,A) = \tanh (W \cdot [e(i,k,B),e(k,j,C)]) + type[A]\]<br>然后计算这个节点的分数：<br>\[s(i,j,A) = d \cdot e(i,j,A)\]<br>找出能使得分数最大的那个分割点和对应的类别，保存下来。</p><p>这样动态规划做好之后一棵树实际上就已经建好了，再回溯生成这棵树就好了。</p><p>但是这棵树很不准确的，刚开始就是随意生成的，所以要和标准树进行对比，计算出损失函数进行反向传播。</p><p>所以接下来用当前的权值矩阵计算出标准树的分数，然后对刚刚生成的结果和这个标准括号序列进行对比，我就直接粗暴统计出两个字符串有多少位置不同，记为$cnt$。</p><p>总的损失函数就是：<br>\[\left| {result - gold + cnt} \right|\]<br>然后进行反向传播就行了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><hr><p>在测试集上面直接照搬训练过程代码就行了，按照动态规划生成一棵树就行了。</p><p>然后用现成的代码和标准结果进行对比，得出F1值。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><hr><p>总的来说，大体就是这样的了，但是还有很多问题没有解决。</p><ul><li>动态规划结合一个节点的两个子节点的时候，现在还只是直接连接的，准备将其改成LSTM的结点函数。</li><li>改成LSTM的话就有左右结点的顺序问题，准备再加一个维度，0和1分别表示左右儿子的顺序。</li><li>我在$e(i,j,A) = \tanh (W \cdot [e(i,k,B),e(k,j,C)]) + type[A]$加了一个$type[A]$，其实原来没有这个的，但是不加会出现一个很大的问题，就是会出现A1-&gt;B,C和A2-&gt;B,C这两种情况，但是不加的话两种情况算出的分数是一样的，先入为主，后算的那种就永远不会考虑了。所以我强行加上了父节点类型向量，来区别这两种情况。但是具体怎么加还没有个说法，我只是随便试试。</li><li>关于损失函数，论文里写的就是$result - gold + cnt$，但是这样并不能保证非负，我就强行加上了一个绝对值。貌似也可以收敛了，到底应该怎么搞不清楚。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二零一七年终总结</title>
      <link href="/2018/01/22/2017-conclusion/"/>
      <url>/2018/01/22/2017-conclusion/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>时间过得很快，终于等到放寒假了，虽然这几个月没有课，天天和放假也没啥区别呢。细数一下，还有5个月就要毕业了吧，大一刚入学的场景却依然清楚地记得，转眼间就成了老学长了呢。闲来无事，随便写写，有感而发，无病呻吟而已。</p><h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><hr><p>回顾我的2017，没做什么事，令我能记得就3件大事吧：</p><ul><li>失恋ing</li><li>ACM退役</li><li>顺利保研</li></ul><p><strong>第一件事</strong>就不想过多回忆了，<strong>2014.12.13 ~ 2017.03.01</strong>，曲终人散。<br><img src="749826.jpg" alt><br>最后引用《我的少女时代》里的一句话吧。</p><blockquote><p>每人都有一颗林真心，遇见是最美好的小幸运，谢谢你出现在我的青春里。</p></blockquote><p><img src="1.jpg" alt><br><strong>第二件事</strong>其实也是黯淡退出吧，大三下开始课程繁忙，也就没怎么训练了，再加上暑假考驾照，于是乎就退役了。回顾三年来，从大一入学时电脑都没怎么碰过的小白，到现在算法也略有所知，也是付出过很大的努力吧，毕竟当年每天刷题，为了一个bug而熬夜到凌晨。最后也算是混了个水水的金牌，奖项不算耀眼。但最重要的是从这段经历中，学到了拼搏、坚持的一种精神，这对以后的研究生涯想必也有很大帮助。<br><img src="2.jpg" alt><br><strong>第三件事</strong>也是意料之中吧，没有什么波折。纠结了很多，虽然<strong>专业第一</strong>，但是最后还是选择保了本校。要问原因，也许是校园情怀，也许是导师人很好，也许是为了方便更早研究，也许就是懒吧。现在尘埃落定，靠人靠天不如靠自己，继续努力吧。<br><img src="3.jpg" alt></p><p>过去的一年，学业未有很大长进，看着同学们整页的4.0绩点，心里倒也没有什么不平衡了。下学期保了研之后选了一门研究生的文本挖掘课，也马马虎虎读了几十篇论文，也算是对自然语言处理和深度学习入了个门，最后的presentation做的还算满意。</p><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><hr><p>今年最重要的大事莫过于毕业论文了，因为以后要做的方向是句法分析，所以导师给我的毕业论文安排的就是《基于循环神经网络的成分句法分析》。虽然说是基于ACL2013的一篇论文改编的，但是目前为止，我还没有发现有人做和这个完全一样的。也许最后写的好的话可以直接发paper了。</p><p>但是目前基本的框架还没完全搭建起来吧，代码还不是很熟练，现在只写了一个最基础的动态规划+RNN。最近有如下计划：</p><ul><li>准备试一下动态规划+LSTM。</li><li>然后动态规划扩增一个维度，用来保存左右结点的head结点。</li><li>如果这个写好了，就可以和我github找到的PCFG+CYK代码融合了，准备加上每个结点的POS。</li><li>最后加入预训练词向量应该就基本完成了。</li></ul><p>希望能顺利毕业吧，前一段时间一直对一些实现细节有些困惑，代码还写错了，还以为理论错了。也不知道最后出来的结果会怎么样，希望能不错。</p><p>生活方面，最近半年越来越懒了，极少出门，睡得晚，起的也晚。最近买了把尤克里里，也算是陶冶陶冶情操吧，不至于一直盯着电脑。现在也小有长进，能弹一点点了。</p><p>现在能聊天的人越来越少了，QQ微信放那一天也不一定会有人来找，就算有人也多半是咨询问题的，等一个可以交心的人吧。有时我也想过，我是不是太像中央空调了，对所有人都这么有耐心，到头来却还是一个人，付出那么多最后还是一无所有。<br><img src="4.jpg" alt><br>最后还是祝自己2018年顺利吧，希望毕业顺利，研究生涯小有收获，最后等一个有缘人吧。</p><blockquote><p>我遇见谁，会有怎样的对白。<br>我等的人，她在多远的未来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top-down Tree Long Short-Term Memory Networks</title>
      <link href="/2018/01/15/paperdaily-4/"/>
      <url>/2018/01/15/paperdaily-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>昨天又鸽了一天，由于水平有限，最主要还是懒，一篇paper看了两天才看了个大概。最近很颓废啊，白天啥都不想干一天就这么过去了，明天开始还是写写毕设代码吧，再好好研究研究。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这次介绍的仍然是树状LSTM，但是这次是在依存句法树上做的LSTM。主要功能就是给定一个句子的依存句法树，预测这个句子的生成概率。实验主要是在Microsoft Sentence Completion Challenge上面进行的，取得了不错的效果。不仅如此，这个模型还可以对依存句法分析产生的依存句法树进行重排序，从而提升依存句法分析的效果。（PS. 又让我联想到了我的毕业论文，用SU-RNN对PCFG产生的成分句法树进行重排序。。。。。。都是泪，代码还没开始动。）</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>首先介绍几个概念。</p><h3 id="依存路径"><a href="#依存路径" class="headerlink" title="依存路径"></a>依存路径</h3><p><img src="1.png" alt><br>如上图所示，虚线箭头就是依存树中的箭头，其中$w_0$就是$w_1$到$w_n$的head结点。那么$w_1$就是$w_0$左边的第一个结点，边$(w_0,w_1)$类型叫做$LEFT$边，而继续向左，例如边$(w_{k-1},w_k)$类型叫做$NX-LEFT$边。同理，向右的边也有两种类型$RIGHT$和$NX-RIGHT$。</p><p>那么依存路径$\mathcal D(w)$定义为从$ROOT$结点到$w$结点的路径，注意不是原来依存树的路径哦。具体计算方式如下：<br><img src="2.png" alt><br>以上图为例，原来$w_0$到$w_n$的路径为${w_0} \to {w_n}$，而现在变成了${w_0} \to {w_1} \to {w_2} \to  \ldots  \to {w_n}$。</p><p>那么给定依存树$T$，句子$S$的概率可以表示为<br><img src="3.png" alt><br>由于每个句子都有$ROOT$，所以就不需要计算它的概率了。$w$按照树$T$的宽度优先搜索顺序访问。</p><h3 id="树状LSTMs"><a href="#树状LSTMs" class="headerlink" title="树状LSTMs"></a>树状LSTMs</h3><p>那么问题就是如何计算$P(w|\mathcal D(w))$了。我们定义4种LSTM：GEN-L,GEN-R,GEN-NX-L,GEN-NX-R，分别用来表示上文中提到的四种类型的边：LEFT,RIGHT,NX-LEFT,NX-RIGHT。</p><p>每个结点的表示如下计算：</p><p><img src="4.png" alt><br>概率表示为：<br><img src="5.png" alt></p><p>注意这里为了简化计算，省略了全部的偏移向量。</p><p>这里用了深层LSTM的内部结点函数，具体直接看公式吧，有点晕。。。<br><img src="6.png" alt><br><img src="7.png" alt><br>直接附上原文解释：<br><img src="8.png" alt><br><img src="9.png" alt></p><h3 id="左依赖树状LSTMs"><a href="#左依赖树状LSTMs" class="headerlink" title="左依赖树状LSTMs"></a>左依赖树状LSTMs</h3><p>上面的方法忽略了同一个结点向左向右依赖之间的联系，举个例子，The car factory sold cars，如果只根据向右的依赖，由sold是无法推出cars的，而加上左依赖The car factory之后就能推出了，所以就提出了这种改进。结构如下：<br><img src="10.png" alt></p><p>也就是计算向右依赖的第一个结点之前，先计算完向左依赖的所有结点（上图绿色箭头部分），然后将最后一个隐含层输出作为向右依赖的第一个结点的输入。<br>首先是左边依赖的表示计算，注意和之前的向左计算方向是反的：<br><img src="11.png" alt><br>然后是向右依赖的计算：<br><img src="12.png" alt></p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>定义两种损失函数，分别对应小规模数据和大规模数据。<br><img src="14.png" alt><br><img src="15.png" alt></p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><hr><p>我就只关注了这个模型的附属品————句法分析上的性能。<br><img src="13.png" alt><br>看起来左依赖树状LSTMs相比树状LSTM基本没有提升，可能在其他任务上不一样吧。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这个模型看了我两天，感觉以前没见过，还挺新奇的（事实是我孤陋寡闻了）。而且我也不知道搞这么复杂究竟能有多大的性能提升，感觉上训练时间会很长？性价比不是很高？</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> NAACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Head-Lexicalized Bidirectional Tree LSTMs</title>
      <link href="/2018/01/13/paperdaily-3/"/>
      <url>/2018/01/13/paperdaily-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>首先给大家说明一下，前两天因为新入手了一个ukulele（就是下图这玩意），所以痴迷于学习弹奏，没有更新博客。照这个节奏下去，PaperDaily恐怕是要变成PaperWeekly了。（囧。。。）寒假一定要学会《小幸运》，嗯。<br><img src="ukulele.jpg" alt></p><p>好了，今天开始恢复吧（说不准过两天我又鸽了，嘻嘻嘻）。</p><p>今天要讲的这篇是TACL2017的，是关于树状LSTM的。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>前两年已经有人提出了树状LSTM的概念，之前一直不知道是个啥高大上的结构。其实就是递归神经网络中的结点单元替换成LSTM的结点单元。那有人要问了，LSTM不是有$x$输入吗，还有一个$h_{t-1}$输入，那这树状的哪来这两个输入？其实很简单，只要把这两个输入替换成左右儿子的输出表示就行了。瞬间感觉也没啥意思，就是换了结点函数，使得树状LSTM具有了遗忘功能，从而能够处理很长的句子罢了。</p><p>今天介绍的这篇paper就是在这基础上做了两点改进。</p><ul><li>除了左右儿子作为输入之外，还增加了$x$输入。$x$是啥呢？就是左右儿子中的头结点，头结点的话传统方法是根据规则来判断谁是头结点的，这里省去了这些复杂的步骤，直接将头结点的判断丢进神经网络中训练。</li><li>增加了反向的树状LSTM，也就是top-down的LSTM。那有人就很好奇了，一个结点分解成两个结点，怎么可能？其实从头结点到任意一个其他结点的路径都可以看成一个独立的LSTM，如果向左参数就是$U_L$，否则就是$U_R$。</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p><img src="1.png" alt><br>图1是序列LSTM和树状LSTM的结构区别，这个树状LSTM是之前传统的树状LSTM，不带head结点的。</p><p>之前的基本的树状LSTM的结点单元的具体公式如下：<br><img src="5.png" alt><br>具体我就不解释了（懒。。。），自行类比序列LSTM。</p><p>加入head结点之后，公式区别如下（加粗所示）：<br><img src="2.png" alt><br><img src="3.png" alt><br><img src="4.png" alt></p><p>那么top-down是怎么做的呢？<br><img src="6.png" alt><br>这里可以看出来，向左向右是用的两套不同的参数。注意到，top-down方向的LSTM前提是一定要用head机制作为支撑！不然头结点的$x$算不出来的话是没有办法计算的哦。</p><p>具体训练过程等等就不再阐述了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>这个模型主要是用在了文本分类和情感分类上，我在想能不能用在我的毕设上面。</p><p>我觉得head机制可以加进去，但是反向LSTM貌似是不可行的，因为这里的短语结构树全部是给定的，所以向下计算知道什么时候停止。但是我是做句法分析任务的，没有给定句法树，向下计算无法知道什么时候停止扩展，情况有无数种！向上计算倒是无所谓，最多卡特兰数级别，加上动态规划，可以缩小到$n\log n$级别。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> TACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parsing with Compositional Vector Grammars</title>
      <link href="/2018/01/10/paperdaily-2/"/>
      <url>/2018/01/10/paperdaily-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>今天也没看新的paper，就讲讲我的毕设的paper吧，估计等我文本挖掘这门课上完，也不会再看太多序列标注相关的了，重点要转移到parsing了。毕竟序列标注效果也已经很好了，迁移学习方面也暂时不想弄，以后研究重点还是可能在parsing吧。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇paper名字叫做基于成分向量文法的句法分析，那么这是个什么东西呢？大家都知道（也许不知道？我就默认知道了( ╯□╰ )）概率上下文无关文法（PCFG）吧，这是基于传统方法的短语结构句法分析，也叫成分句法分析，还有一种叫做依存句法分析，现在大多数是做这个的。但是传统的成分句法分析无法解决歧义的问题，因为PCFG是基于上下文无关的独立性假设的，但是自然语言是一种上下文有关文法，必然会产生歧义。</p><p>那么如何消除这种歧义呢，Socher提出了SU-RNN的模型，引入了短语的语义表示，具体是什么样子的呢？</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>这个模型概括起来是这样的：首先用PCFG产生k-best句法树，比如产生概率最大的20棵句法树。然后对这k-best棵句法树每棵树都跑一遍SU-RNN，计算出每棵树的得分，然后综合PCFG得分和SU-RNN得分，对他们进行重排序，然后得到排名最高的句法树。</p><p>那么怎么通过SU-RNN计算一棵树的得分呢？</p><p>首先上一张图，看看SU-RNN是个什么结构：<br><img src="1.png" alt><br>可以看出，每个节点不仅含有它的类别表示，还有一个向量表示它的语义信息。而SU-RNN与之前提出过的RNN不一样的是，这里的每个节点的$W$权值矩阵全部是不同的，依赖于它的子节点的类别。<br>每个节点的语义表示向量计算方法如下：<br>\[{p^{(1)}} = f\left( { {W^{(B,C)}}\left[ {\begin{array}{*{20}{c}}b\\c\end{array}} \right]} \right)\]而这个节点的得分表示为<br>\[s({p^{(1)}}) = {({v^{(B,C)}})^T}{p^{(1)}} + \log P({P_1} \to B{\rm{ }}C)\]最后一整棵树的得分就是<br>\[s(CVG(\theta ,x,\hat y)) = \sum\limits_{d \in N(\hat y)} {s({p^d})} \]这样就可以枚举所有的句法树，然后计算得到得分最高的那棵树就是最终的句法树了。</p><p>但是这样枚举的话复杂度太高了，要知道一个长度为$n$的句子，可能的句法树有$Catalan(n)$种。而且是无法用动态规划算法来计算最优句法树的，因为SU-RNN破坏了上下文无关的独立性假设（因为反向传播？其实我也不是太懂。。。）。所以就要用到之前所说的先用PCFG得到k-best棵句法树，然后用SU-RNN重排序了。</p><p>那么用SU-RNN计算完得到最优树之后，怎么计算它与gold-tree之间的差异，从而得到loss呢？</p><p>本文计算两棵树差异的公式如下：<br>\[\Delta ({y_i},\hat y) = \sum\limits_{d \in N(\hat y)} {\kappa 1\{ d \notin N({y_i})\} } \]最终的损失函数定义为：<br>\[J(\theta ) = \frac{1}{m}\sum\limits_{i = 1}^m { {r_i}(\theta )}  + \frac{\lambda }{2}{\left| \theta  \right|^2}\]其中<br>\[{r_i}(\theta ) = \mathop {\max }\limits_{\hat y \in Y({x_i})} (s(CVG({x_i},\hat y)) + \Delta ({y_i},\hat y)) - s(CVG({x_i},{y_i}))\]也就是要尽量最大化标准树的得分，减小预测树的得分。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p><img src="2.png" alt><br>可以看出，SU-RNN结果比以往的结果都要好，但是没有最后两行的好。。。最后两个具体是啥我也没去细看。</p><h1 id="我的毕设任务"><a href="#我的毕设任务" class="headerlink" title="我的毕设任务"></a>我的毕设任务</h1><hr><p>其实我的任务不用PCFG，看起来减少了工作量？嘿嘿，其实貌似麻烦的一笔啊。。。我的模型主要的思想就是直接用SU-RNN训练出句法分析树！那枚举复杂度太高了怎么办？用动态规划啊！不是不能用吗？没事，假装它能用，要是效果好强行解释一波就行了。。。而且原模型的RNN是递归神经网络哦，这次我改成了循环神经网络，用LSTM来计算得分。看起来貌似挺麻烦的，纠结了好几天。LSTM每个节点总得有一个$x$输入，一个$h$隐层输入吧，所以可能还要给每两个节点指定一个作为head。。。</p><p>感觉心态炸了哦，一堆非主流写法？也不知道最后能不能写出来，也不知道写出来结果怎么样。。。说不定要延毕了？哈哈，自嘲一波吧，暑假好好研究研究了，python基础还是不行，写起来太累了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 句法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Empower Sequence Labeling with Task-Aware Neural Language Model</title>
      <link href="/2018/01/09/paperdaily-1/"/>
      <url>/2018/01/09/paperdaily-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>自从这学期没课以来，一直过着非正常人的生活，作息时间比正常人推迟了3个小时：<strong>3点睡觉、12点起床、15点吃午饭、21点吃晚饭。</strong>因此决定不再如此颓废，每日泛读一篇顶会paper，了解其大概思想即可，然后大概将思想发出来，美其名曰：PaperDaily，就从今天开始吧。</p><p>今天要讲的这篇是昨天偶然看到的，AAAI18的paper，正好与我文本挖掘课大作业主题一样，所以就看了一下。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>这篇paper提出的模型叫做LM-LSTM-CRF，看起来和前面讲过的加入语言模型的两篇没有大区别，事实是区别的确不是很大。之前讲过的transfer模型基本都是共享一部分模型（底层模型），上层模型都是每个任务有各自独立的模型。然而这篇paper的模型所有部分全部共享，这就会带来许多表示上面的问题。于是这篇paper和以往最大的区别就是在character level LSTM之上加入了一个highway layer，用来将LSTM产生的字符表示映射到不同的表示空间，这样语言模型（这里的语言模型是基于字符层面的）和序列标注模型就可以共享character level LSTM。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>不多说，直接上图：<br><img src="1.png" alt></p><h3 id="character-level-LSTM"><a href="#character-level-LSTM" class="headerlink" title="character level LSTM"></a>character level LSTM</h3><p>这里和传统的差不多，只是改每个token单独训练一个LSTM为所有字符联合训练上下文表示（为了语言模型共用嘛），但是只在两个tokens之间输出token表示。</p><h3 id="highway-layer"><a href="#highway-layer" class="headerlink" title="highway layer"></a>highway layer</h3><p>其实就是对输出做了线性变换+门操作，具体表示如下：<br>\[\begin{array}{l}m = H(n) = t \odot g({W_H}n + {b_H}) + (1 - t) \odot n\\t = \sigma ({W_T}n + {b_T})\end{array}\]最终一共产生四个highway输出，分别是前后向序列标注表示和前后向语言模型表示。而序列标注的LSTM输入共有三个，分别是词向量、前后向序列标注表示。</p><h3 id="word-level-LSTM"><a href="#word-level-LSTM" class="headerlink" title="word level LSTM"></a>word level LSTM</h3><p>和传统的没什么不同。。。</p><h3 id="CRF-layer"><a href="#CRF-layer" class="headerlink" title="CRF layer"></a>CRF layer</h3><p>没什么不一样。。。</p><h3 id="joint-training"><a href="#joint-training" class="headerlink" title="joint training"></a>joint training</h3><p>总的损失函数就是语言模型损失函数加上序列标注损失函数，系数这里设置为1:1。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>直接上图，这里和之前我看过的几篇paper都进行了比较，还是非常bang的！<br><img src="2.png" alt><br>注意到，他们的结果和<code>Peter 2017.</code>比较还是差了一点，因为<code>Peter 2017.</code>虽然也使用了语言模型作为辅助训练，但是他们语言模型是在大量无标注数据下进行训练的，而且花费时间特别长！而本文根本不需要任何辅助数据，少量标注数据？足够了！就在他们上面联合训练一个语言模型就行了，花费时间大大缩短。</p><p>其实我个人认为，这零点几的提升意义并不是很大，时间大大缩短倒是挺不错的，毕竟<code>Peter 2017.</code>那篇32个GPU都要训练半个月。。。<br>更远一步思考，也许可以将语言模型和序列标注独立开来训练，先用语言模型来训练character level LSTM，再用它产生每个token的表示，直接输入到序列标注的LSTM中，当然highway layer还是必要的，毕竟表示空间是不同的。这样可以利用大量的无标注数据了，但是训练时间也会大大加长，而且感觉和<code>Peter 2017.</code>的模型区别貌似不大了？只是联合训练了一个character level LSTM而已。</p><p>以上都是我的拙见，毕竟这篇也就粗略读了一下没仔细看，各位有什么想法也欢迎和我讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> 迁移学习 </tag>
            
            <tag> AAAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词性标注+语言模型简易实现</title>
      <link href="/2018/01/01/pos-lm/"/>
      <url>/2018/01/01/pos-lm/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>文本挖掘课的project，实现的是词性标注，增加了语言模型表示。<br>语言模型在小数据下会过拟合，但是大数据训练要三个星期。。。所以还是放弃了，不添加语言模型好了。<br>词性标注的话如果添加CRF效果反而会下降，也是很奇怪哦。。。如果直接用最裸的BiLSTM+charRNN的话，F1也能有97%左右，知足了，就这样吧。<br>数据和完整程序下载地址：<a href="https://github.com/godweiyang/text-mining" target="_blank" rel="noopener">传送门</a></p><p>下面是两组实验结果，由于速度太慢了，一组要1小时训练时间，所以就没有加语言模型，而且只训练了10轮。</p><p>第一组：</p><pre><code>DEBUG = FalseHASLM = FalseLM_EPOCH = 5TAG_EPOCH = 10MAX_LIK_ITERS = 3--------Language Model Training----------------Sequence Tagger Training--------epoch 0 finishedtotal loss:  0.29375948742total F1:  0.949073958671 0.395180722892epoch 1 finishedtotal loss:  0.132068497052total F1:  0.954682553531 0.427710843373epoch 2 finishedtotal loss:  0.110233872966total F1:  0.960266221303 0.483734939759epoch 3 finishedtotal loss:  0.0115048246573total F1:  0.944312884812 0.367469879518epoch 4 finishedtotal loss:  0.00533642838205total F1:  0.947378916669 0.375903614458epoch 5 finishedtotal loss:  0.00460870711354total F1:  0.945584166314 0.34156626506epoch 6 finishedtotal loss:  0.00420810207526total F1:  0.931001819677 0.269277108434epoch 7 finishedtotal loss:  0.00402948848795total F1:  0.943490290899 0.321084337349epoch 8 finishedtotal loss:  0.00390113119154total F1:  0.952813021911 0.431325301205epoch 9 finishedtotal loss:  0.00367663722034total F1:  0.938579654511 0.31265060241if SCONJyou PRONcould AUXsee VERBthat SCONJi PRONam AUXthe DETone NOUNwho PRONunderstands VERByou PRON. PUNC</code></pre><p>第二组：</p><pre><code>DEBUG = FalseHASLM = FalseLM_EPOCH = 5TAG_EPOCH = 10MAX_LIK_ITERS = 10--------Language Model Training----------------Sequence Tagger Training--------epoch 0 finishedtotal loss:  0.304520357251total F1:  0.948201510582 0.387951807229epoch 1 finishedtotal loss:  0.133941903738total F1:  0.957175262358 0.457228915663epoch 2 finishedtotal loss:  0.111774144948total F1:  0.959019866889 0.455421686747epoch 3 finishedtotal loss:  0.100073265445total F1:  0.960814617245 0.475301204819epoch 4 finishedtotal loss:  0.0922900494867total F1:  0.962310242541 0.487951807229epoch 5 finishedtotal loss:  0.0862275558798total F1:  0.963681232395 0.485542168675epoch 6 finishedtotal loss:  0.0811706444901total F1:  0.963706159484 0.492168674699epoch 7 finishedtotal loss:  0.0776693911075total F1:  0.962808784306 0.484939759036epoch 8 finishedtotal loss:  0.0741868944795total F1:  0.9630331281 0.495180722892epoch 9 finishedtotal loss:  0.0714286559878total F1:  0.963407034424 0.486144578313if SCONJyou PRONcould AUXsee VERBthat SCONJi PRONam VERBthe DETone NOUNwho PRONunderstands VERByou PRON. PUNC</code></pre><p>可以看出来，加了CRF（第一组）效果反而差了一点点，对最后例句的词性标注唯一的区别在于”am”是助动词AUX还是动词VERB，我发现训练集里两种都有，区别也不大。</p><p>完整代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token punctuation">,</span> defaultdict<span class="token keyword">from</span> itertools <span class="token keyword">import</span> count<span class="token keyword">import</span> random<span class="token keyword">import</span> dynet <span class="token keyword">as</span> dy<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npDEBUG <span class="token operator">=</span> <span class="token boolean">False</span>HASLM <span class="token operator">=</span> <span class="token boolean">False</span>LM_EPOCH <span class="token operator">=</span> <span class="token number">5</span>TAG_EPOCH <span class="token operator">=</span> <span class="token number">10</span><span class="token comment" spellcheck="true"># CRF parameters</span>MAX_LIK_ITERS <span class="token operator">=</span> <span class="token number">3</span>SMALL_NUMBER <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1e10</span>MARGIN <span class="token operator">=</span> <span class="token number">0</span>lm_train_file <span class="token operator">=</span> <span class="token string">"LM_TRAIN"</span>lm_test_file <span class="token operator">=</span> <span class="token string">"LM_DEV"</span>train_file <span class="token operator">=</span> <span class="token string">"TAG_TRAIN"</span>dev_file <span class="token operator">=</span> <span class="token string">"TAG_DEV"</span><span class="token keyword">if</span> DEBUG<span class="token punctuation">:</span>    lm_train_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span>    lm_test_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span>    train_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span>    dev_file <span class="token operator">+=</span> <span class="token string">"_SMALL"</span><span class="token comment" spellcheck="true"># Language Model</span><span class="token keyword">print</span> <span class="token string">"--------Language Model Training--------"</span><span class="token keyword">def</span> <span class="token function">read_lm</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> file<span class="token punctuation">(</span>fname<span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>            sent <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>            sent<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"&lt;s>"</span><span class="token punctuation">)</span>            <span class="token keyword">yield</span> sentlm_train <span class="token operator">=</span> list<span class="token punctuation">(</span>read_lm<span class="token punctuation">(</span>lm_train_file<span class="token punctuation">)</span><span class="token punctuation">)</span>lm_test <span class="token operator">=</span> list<span class="token punctuation">(</span>read_lm<span class="token punctuation">(</span>lm_test_file<span class="token punctuation">)</span><span class="token punctuation">)</span>lm_words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> sent <span class="token keyword">in</span> lm_train<span class="token punctuation">:</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> sent<span class="token punctuation">:</span>        lm_words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">)</span>lm_words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_UNK_"</span><span class="token punctuation">)</span>lm_w2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> lm_words<span class="token punctuation">:</span>    lm_w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span>lm_i2w <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> lm_w2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>lm_nwords <span class="token operator">=</span> len<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">)</span>lm_model <span class="token operator">=</span> dy<span class="token punctuation">.</span>Model<span class="token punctuation">(</span><span class="token punctuation">)</span>lm_trainer <span class="token operator">=</span> dy<span class="token punctuation">.</span>AdamTrainer<span class="token punctuation">(</span>lm_model<span class="token punctuation">)</span>lm_WORDS_LOOKUP <span class="token operator">=</span> lm_model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>lm_nwords<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lm_RNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> lm_model<span class="token punctuation">)</span>lm_pW <span class="token operator">=</span> lm_model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>lm_nwords<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span>lm_pb <span class="token operator">=</span> lm_model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span>lm_nwords<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">calc_lm_loss</span><span class="token punctuation">(</span>sent<span class="token punctuation">)</span><span class="token punctuation">:</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    W <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>lm_pW<span class="token punctuation">)</span>    b <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>lm_pb<span class="token punctuation">)</span>    f_init <span class="token operator">=</span> lm_RNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    wids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> sent<span class="token punctuation">:</span>        <span class="token keyword">if</span> w <span class="token keyword">in</span> lm_words<span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span><span class="token string">"_UNK_"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> f_init<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wids<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> wid <span class="token keyword">in</span> wids<span class="token punctuation">:</span>        score <span class="token operator">=</span> W <span class="token operator">*</span> s<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> b        loss <span class="token operator">=</span> dy<span class="token punctuation">.</span>pickneglogsoftmax<span class="token punctuation">(</span>score<span class="token punctuation">,</span> wid<span class="token punctuation">)</span>        losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wid<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> dy<span class="token punctuation">.</span>esum<span class="token punctuation">(</span>losses<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">calc_lm_embdding</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    f_init <span class="token operator">=</span> lm_RNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    wids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span>        <span class="token keyword">if</span> w <span class="token keyword">in</span> lm_words<span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span><span class="token string">"_UNK_"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    wids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>lm_w2i<span class="token punctuation">[</span><span class="token string">"&lt;s>"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> f_init<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wids<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> wid <span class="token keyword">in</span> wids<span class="token punctuation">:</span>        outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">.</span>output<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>add_input<span class="token punctuation">(</span>lm_WORDS_LOOKUP<span class="token punctuation">[</span>wid<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> outputs<span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>    <span class="token keyword">for</span> ITER <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>LM_EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>        lm_num_tagged <span class="token operator">=</span> lm_cum_loss <span class="token operator">=</span> <span class="token number">0</span>        random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>lm_train<span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> s <span class="token keyword">in</span> lm_train<span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span> calc_lm_loss<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            lm_cum_loss <span class="token operator">+=</span> loss_exp<span class="token punctuation">.</span>scalar_value<span class="token punctuation">(</span><span class="token punctuation">)</span>            lm_num_tagged <span class="token operator">+=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>            loss_exp<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            lm_trainer<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> DEBUG <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span> <span class="token string">"train loss "</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> lm_cum_loss <span class="token operator">/</span> lm_num_tagged        dev_loss <span class="token operator">=</span> dev_words <span class="token operator">=</span> <span class="token number">0</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> sent <span class="token keyword">in</span> lm_test<span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span> calc_lm_loss<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>            dev_loss <span class="token operator">+=</span> loss_exp<span class="token punctuation">.</span>scalar_value<span class="token punctuation">(</span><span class="token punctuation">)</span>            dev_words <span class="token operator">+=</span> len<span class="token punctuation">(</span>sent<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># if DEBUG == False:</span>            <span class="token comment" spellcheck="true">#     i += 1</span>            <span class="token comment" spellcheck="true">#     if i % 100 == 0:</span>            <span class="token comment" spellcheck="true">#         print "dev loss ", i, ": ", dev_loss / dev_words</span>        <span class="token keyword">print</span> <span class="token string">"epoch %r finished"</span> <span class="token operator">%</span> ITER        <span class="token keyword">print</span> <span class="token string">"total train loss: "</span><span class="token punctuation">,</span> lm_cum_loss <span class="token operator">/</span> lm_num_tagged        <span class="token keyword">print</span> <span class="token string">"total dev loss: "</span><span class="token punctuation">,</span> dev_loss <span class="token operator">/</span> dev_words<span class="token comment" spellcheck="true"># Tagger</span><span class="token keyword">print</span> <span class="token string">"--------Sequence Tagger Training--------"</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>fname<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> file<span class="token punctuation">(</span>fname<span class="token punctuation">)</span> <span class="token keyword">as</span> fh<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> fh<span class="token punctuation">:</span>            line <span class="token operator">=</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>            sent <span class="token operator">=</span> <span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>x<span class="token punctuation">.</span>rsplit<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> line<span class="token punctuation">]</span>            <span class="token keyword">yield</span> senttrain <span class="token operator">=</span> list<span class="token punctuation">(</span>read<span class="token punctuation">(</span>train_file<span class="token punctuation">)</span><span class="token punctuation">)</span>dev <span class="token operator">=</span> list<span class="token punctuation">(</span>read<span class="token punctuation">(</span>dev_file<span class="token punctuation">)</span><span class="token punctuation">)</span>words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>chars <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>wc <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> sent <span class="token keyword">in</span> train<span class="token punctuation">:</span>    <span class="token keyword">for</span> w<span class="token punctuation">,</span> p <span class="token keyword">in</span> sent<span class="token punctuation">:</span>        words<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">)</span>        tags<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        chars<span class="token punctuation">.</span>update<span class="token punctuation">(</span>w<span class="token punctuation">)</span>        wc<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_UNK_"</span><span class="token punctuation">)</span>words<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_S_"</span><span class="token punctuation">)</span>tags<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"_S_"</span><span class="token punctuation">)</span>chars<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"&lt;*>"</span><span class="token punctuation">)</span>w2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>    w2i<span class="token punctuation">[</span>word<span class="token punctuation">]</span>i2w <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> w2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>t2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> tag <span class="token keyword">in</span> tags<span class="token punctuation">:</span>    t2i<span class="token punctuation">[</span>tag<span class="token punctuation">]</span>i2t <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> t2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>c2i <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>count<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token keyword">for</span> char <span class="token keyword">in</span> chars<span class="token punctuation">:</span>    c2i<span class="token punctuation">[</span>char<span class="token punctuation">]</span>i2c <span class="token operator">=</span> <span class="token punctuation">{</span>i<span class="token punctuation">:</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> i <span class="token keyword">in</span> c2i<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>UNK <span class="token operator">=</span> w2i<span class="token punctuation">[</span><span class="token string">"_UNK_"</span><span class="token punctuation">]</span>S_W <span class="token operator">=</span> w2i<span class="token punctuation">[</span><span class="token string">"_S_"</span><span class="token punctuation">]</span>S_T <span class="token operator">=</span> t2i<span class="token punctuation">[</span><span class="token string">"_S_"</span><span class="token punctuation">]</span>nwords <span class="token operator">=</span> len<span class="token punctuation">(</span>w2i<span class="token punctuation">)</span>ntags  <span class="token operator">=</span> len<span class="token punctuation">(</span>t2i<span class="token punctuation">)</span>nchars  <span class="token operator">=</span> len<span class="token punctuation">(</span>c2i<span class="token punctuation">)</span>model <span class="token operator">=</span> dy<span class="token punctuation">.</span>Model<span class="token punctuation">(</span><span class="token punctuation">)</span>trainer <span class="token operator">=</span> dy<span class="token punctuation">.</span>AdamTrainer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>WORDS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>nwords<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">)</span>CHARS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>nchars<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>TRANS_LOOKUP <span class="token operator">=</span> model<span class="token punctuation">.</span>add_lookup_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>ntags<span class="token punctuation">,</span> ntags<span class="token punctuation">)</span><span class="token punctuation">)</span>pH <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>pO <span class="token operator">=</span> model<span class="token punctuation">.</span>add_parameters<span class="token punctuation">(</span><span class="token punctuation">(</span>ntags<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>bwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>    fwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>    bwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>cFwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span>cBwdRNN <span class="token operator">=</span> dy<span class="token punctuation">.</span>LSTMBuilder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">word_rep</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> cf_init<span class="token punctuation">,</span> cb_init<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> wc<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">:</span>        w_index <span class="token operator">=</span> w2i<span class="token punctuation">[</span>w<span class="token punctuation">]</span>        <span class="token keyword">return</span> WORDS_LOOKUP<span class="token punctuation">[</span>w_index<span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        pad_char <span class="token operator">=</span> c2i<span class="token punctuation">[</span><span class="token string">"&lt;*>"</span><span class="token punctuation">]</span>        char_ids <span class="token operator">=</span> <span class="token punctuation">[</span>pad_char<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>c2i<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> w<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pad_char<span class="token punctuation">]</span>        char_embs <span class="token operator">=</span> <span class="token punctuation">[</span>CHARS_LOOKUP<span class="token punctuation">[</span>cid<span class="token punctuation">]</span> <span class="token keyword">for</span> cid <span class="token keyword">in</span> char_ids<span class="token punctuation">]</span>        fw_exps <span class="token operator">=</span> cf_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>char_embs<span class="token punctuation">)</span>        bw_exps <span class="token operator">=</span> cb_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>char_embs<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dy<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span> fw_exps<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bw_exps<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">build_tagging_graph</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>    lm_wembs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>        lm_wembs <span class="token operator">=</span> calc_lm_embdding<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    dy<span class="token punctuation">.</span>renew_cg<span class="token punctuation">(</span><span class="token punctuation">)</span>    H <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>pH<span class="token punctuation">)</span>    O <span class="token operator">=</span> dy<span class="token punctuation">.</span>parameter<span class="token punctuation">(</span>pO<span class="token punctuation">)</span>    f_init <span class="token operator">=</span> fwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    b_init <span class="token operator">=</span> bwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    cf_init <span class="token operator">=</span> cFwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    cb_init <span class="token operator">=</span> cBwdRNN<span class="token punctuation">.</span>initial_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    wembs <span class="token operator">=</span> <span class="token punctuation">[</span>word_rep<span class="token punctuation">(</span>w<span class="token punctuation">,</span> cf_init<span class="token punctuation">,</span> cb_init<span class="token punctuation">)</span> <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">]</span>    <span class="token keyword">if</span> HASLM<span class="token punctuation">:</span>        wembs1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> lmw<span class="token punctuation">,</span> w <span class="token keyword">in</span> zip<span class="token punctuation">(</span>lm_wembs<span class="token punctuation">,</span> wembs<span class="token punctuation">)</span><span class="token punctuation">:</span>            wv <span class="token operator">=</span> w<span class="token punctuation">.</span>value<span class="token punctuation">(</span><span class="token punctuation">)</span>            wv<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>lmw<span class="token punctuation">)</span>            wembs1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>wv<span class="token punctuation">)</span>        wembs <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>inputTensor<span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token keyword">for</span> w <span class="token keyword">in</span> wembs1<span class="token punctuation">]</span>    wembs <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>noise<span class="token punctuation">(</span>we<span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> we <span class="token keyword">in</span> wembs<span class="token punctuation">]</span>    fw_exps <span class="token operator">=</span> f_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>wembs<span class="token punctuation">)</span>    bw_exps <span class="token operator">=</span> b_init<span class="token punctuation">.</span>transduce<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>wembs<span class="token punctuation">)</span><span class="token punctuation">)</span>    bi_exps <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">[</span>f<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> f<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>fw_exps<span class="token punctuation">,</span> reversed<span class="token punctuation">(</span>bw_exps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    exps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> bi_exps<span class="token punctuation">:</span>        r_t <span class="token operator">=</span> O <span class="token operator">*</span> <span class="token punctuation">(</span>dy<span class="token punctuation">.</span>tanh<span class="token punctuation">(</span>H <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>        exps<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r_t<span class="token punctuation">)</span>    <span class="token keyword">return</span> exps<span class="token keyword">def</span> <span class="token function">viterbi_decoding</span><span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> gold_tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Initialize</span>    init_prob <span class="token operator">=</span> <span class="token punctuation">[</span>SMALL_NUMBER<span class="token punctuation">]</span> <span class="token operator">*</span> ntags    init_prob<span class="token punctuation">[</span>S_T<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    for_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>inputVector<span class="token punctuation">(</span>init_prob<span class="token punctuation">)</span>    best_ids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    trans_exprs <span class="token operator">=</span> <span class="token punctuation">[</span>TRANS_LOOKUP<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token keyword">for</span> tid <span class="token keyword">in</span> range<span class="token punctuation">(</span>ntags<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># Perform the forward pass through the sentence</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span><span class="token punctuation">:</span>        my_best_ids <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        my_best_exprs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> next_tag <span class="token keyword">in</span> range<span class="token punctuation">(</span>ntags<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># Calculate vector for single next tag</span>            next_single_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> trans_exprs<span class="token punctuation">[</span>next_tag<span class="token punctuation">]</span>            next_single <span class="token operator">=</span> next_single_expr<span class="token punctuation">.</span>npvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># Find and save the best score</span>            my_best_id <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>next_single<span class="token punctuation">)</span>            my_best_ids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>my_best_id<span class="token punctuation">)</span>            my_best_exprs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>next_single_expr<span class="token punctuation">,</span> my_best_id<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Concatenate the scores for all vectors together</span>        for_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span>my_best_exprs<span class="token punctuation">)</span> <span class="token operator">+</span> vec        <span class="token comment" spellcheck="true"># Give a bonus to all but the correct tag if using margin</span>        <span class="token keyword">if</span> MARGIN <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> len<span class="token punctuation">(</span>gold_tags<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            adjust <span class="token operator">=</span> <span class="token punctuation">[</span>MARGIN<span class="token punctuation">]</span> <span class="token operator">*</span> ntags            adjust<span class="token punctuation">[</span>t2i<span class="token punctuation">[</span>gold_tags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            for_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> dy<span class="token punctuation">.</span>inputVector<span class="token punctuation">(</span>adjust<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Save the best ids</span>        best_ids<span class="token punctuation">.</span>append<span class="token punctuation">(</span>my_best_ids<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Perform the final step to the sentence terminal symbol</span>    next_single_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> trans_exprs<span class="token punctuation">[</span>S_T<span class="token punctuation">]</span>    next_single <span class="token operator">=</span> next_single_expr<span class="token punctuation">.</span>npvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>    my_best_id <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>next_single<span class="token punctuation">)</span>    best_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>next_single_expr<span class="token punctuation">,</span> my_best_id<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Perform the reverse pass</span>    best_path <span class="token operator">=</span> <span class="token punctuation">[</span>i2t<span class="token punctuation">[</span>my_best_id<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> my_best_ids <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>best_ids<span class="token punctuation">)</span><span class="token punctuation">:</span>        my_best_id <span class="token operator">=</span> my_best_ids<span class="token punctuation">[</span>my_best_id<span class="token punctuation">]</span>        best_path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i2t<span class="token punctuation">[</span>my_best_id<span class="token punctuation">]</span><span class="token punctuation">)</span>    best_path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># Remove final &lt;s></span>    best_path<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Return the best path and best score as an expression</span>    <span class="token keyword">return</span> best_path<span class="token punctuation">,</span> best_expr<span class="token keyword">def</span> <span class="token function">forced_decoding</span><span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Initialize</span>    for_expr <span class="token operator">=</span> dy<span class="token punctuation">.</span>scalarInput<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    for_tag <span class="token operator">=</span> S_T    <span class="token comment" spellcheck="true"># Perform the forward pass through the sentence</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> vec <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span><span class="token punctuation">:</span>         my_tag <span class="token operator">=</span> t2i<span class="token punctuation">[</span>tags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        for_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>TRANS_LOOKUP<span class="token punctuation">[</span>my_tag<span class="token punctuation">]</span><span class="token punctuation">,</span> for_tag<span class="token punctuation">)</span> <span class="token operator">+</span> vec<span class="token punctuation">[</span>my_tag<span class="token punctuation">]</span>        for_tag <span class="token operator">=</span> my_tag    for_expr <span class="token operator">=</span> for_expr <span class="token operator">+</span> dy<span class="token punctuation">.</span>pick<span class="token punctuation">(</span>TRANS_LOOKUP<span class="token punctuation">[</span>S_T<span class="token punctuation">]</span><span class="token punctuation">,</span> for_tag<span class="token punctuation">)</span>    <span class="token keyword">return</span> for_expr<span class="token keyword">def</span> <span class="token function">viterbi_sent_loss</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>    vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    viterbi_tags<span class="token punctuation">,</span> viterbi_score <span class="token operator">=</span> viterbi_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> tags<span class="token punctuation">)</span>    <span class="token keyword">if</span> viterbi_tags <span class="token operator">!=</span> tags<span class="token punctuation">:</span>        reference_score <span class="token operator">=</span> forced_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">,</span> tags<span class="token punctuation">)</span>        <span class="token keyword">return</span> viterbi_score <span class="token operator">-</span> reference_score    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> dy<span class="token punctuation">.</span>scalarInput<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">sent_loss</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>    vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    errs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> v<span class="token punctuation">,</span>t <span class="token keyword">in</span> zip<span class="token punctuation">(</span>vecs<span class="token punctuation">,</span>tags<span class="token punctuation">)</span><span class="token punctuation">:</span>        tid <span class="token operator">=</span> t2i<span class="token punctuation">[</span>t<span class="token punctuation">]</span>        err <span class="token operator">=</span> dy<span class="token punctuation">.</span>pickneglogsoftmax<span class="token punctuation">(</span>v<span class="token punctuation">,</span> tid<span class="token punctuation">)</span>        errs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token keyword">return</span> dy<span class="token punctuation">.</span>esum<span class="token punctuation">(</span>errs<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">tag_sent</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>    vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    vecs <span class="token operator">=</span> <span class="token punctuation">[</span>dy<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> vecs<span class="token punctuation">]</span>    probs <span class="token operator">=</span> <span class="token punctuation">[</span>v<span class="token punctuation">.</span>npvalue<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> vecs<span class="token punctuation">]</span>    tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> prb <span class="token keyword">in</span> probs<span class="token punctuation">:</span>        tag <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>prb<span class="token punctuation">)</span>        tags<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i2t<span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> tags<span class="token keyword">for</span> ITER <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>TAG_EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>    num_tagged <span class="token operator">=</span> cum_loss <span class="token operator">=</span> <span class="token number">0</span>    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>train<span class="token punctuation">)</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> s <span class="token keyword">in</span> train<span class="token punctuation">:</span>        words <span class="token operator">=</span> <span class="token punctuation">[</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> s<span class="token punctuation">]</span>        golds <span class="token operator">=</span> <span class="token punctuation">[</span>t <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> s<span class="token punctuation">]</span>        <span class="token keyword">if</span> ITER <span class="token operator">&lt;</span> MAX_LIK_ITERS<span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span>  sent_loss<span class="token punctuation">(</span>words<span class="token punctuation">,</span> golds<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            loss_exp <span class="token operator">=</span>  viterbi_sent_loss<span class="token punctuation">(</span>words<span class="token punctuation">,</span> golds<span class="token punctuation">)</span>        cum_loss <span class="token operator">+=</span> loss_exp<span class="token punctuation">.</span>scalar_value<span class="token punctuation">(</span><span class="token punctuation">)</span>        num_tagged <span class="token operator">+=</span> len<span class="token punctuation">(</span>golds<span class="token punctuation">)</span>        loss_exp<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        trainer<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> DEBUG <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">1000</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">print</span> <span class="token string">"train loss "</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">": "</span><span class="token punctuation">,</span> cum_loss <span class="token operator">/</span> num_tagged    good_sent <span class="token operator">=</span> bad_sent <span class="token operator">=</span> good <span class="token operator">=</span> bad <span class="token operator">=</span> <span class="token number">0.0</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> sent <span class="token keyword">in</span> dev<span class="token punctuation">:</span>        words <span class="token operator">=</span> <span class="token punctuation">[</span>w <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> sent<span class="token punctuation">]</span>        golds <span class="token operator">=</span> <span class="token punctuation">[</span>t <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> sent<span class="token punctuation">]</span>        <span class="token keyword">if</span> ITER <span class="token operator">&lt;</span> MAX_LIK_ITERS<span class="token punctuation">:</span>            tags <span class="token operator">=</span> tag_sent<span class="token punctuation">(</span>words<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>            tags<span class="token punctuation">,</span> loss_exp <span class="token operator">=</span> viterbi_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span>        <span class="token keyword">if</span> tags <span class="token operator">==</span> golds<span class="token punctuation">:</span> good_sent <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> bad_sent <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> go<span class="token punctuation">,</span> gu <span class="token keyword">in</span> zip<span class="token punctuation">(</span>golds<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> go <span class="token operator">==</span> gu<span class="token punctuation">:</span> good <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> bad <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># if DEBUG == False:</span>        <span class="token comment" spellcheck="true">#     i += 1</span>        <span class="token comment" spellcheck="true">#     if i % 1000 == 0:</span>        <span class="token comment" spellcheck="true">#         print "F1 ", i, ": ", good / (good + bad)</span>    <span class="token keyword">print</span> <span class="token string">"epoch %r finished"</span> <span class="token operator">%</span> ITER    <span class="token keyword">print</span> <span class="token string">"total loss: "</span><span class="token punctuation">,</span> cum_loss <span class="token operator">/</span> num_tagged    <span class="token keyword">print</span> <span class="token string">"total F1: "</span><span class="token punctuation">,</span> good <span class="token operator">/</span> <span class="token punctuation">(</span>good <span class="token operator">+</span> bad<span class="token punctuation">)</span><span class="token punctuation">,</span> good_sent <span class="token operator">/</span> <span class="token punctuation">(</span>good_sent <span class="token operator">+</span> bad_sent<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">tagging</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">:</span>    words <span class="token operator">=</span> sentence<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> TAG_EPOCH <span class="token operator">&lt;=</span> MAX_LIK_ITERS<span class="token punctuation">:</span>        tags <span class="token operator">=</span> tag_sent<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        vecs <span class="token operator">=</span> build_tagging_graph<span class="token punctuation">(</span>words<span class="token punctuation">)</span>        tags<span class="token punctuation">,</span> loss_exp <span class="token operator">=</span> viterbi_decoding<span class="token punctuation">(</span>vecs<span class="token punctuation">)</span>    <span class="token keyword">for</span> w<span class="token punctuation">,</span> t <span class="token keyword">in</span> zip<span class="token punctuation">(</span>words<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> w<span class="token punctuation">,</span> t<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sentence <span class="token operator">=</span> <span class="token string">"if you could see that i am the one who understands you ."</span>    tagging<span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> dynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Tagging with Little Labeled Data</title>
      <link href="/2017/12/30/text-minning-ppt/"/>
      <url>/2017/12/30/text-minning-ppt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>历经几个星期的磨难，文本挖掘课的presentation课件初稿基本完成了，1月中下旬开讲，这次讲的是基于少量标注数据的序列标注，下面是我的综述。</p><h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><hr><ul><li>Sequence Tagging</li><li>Semi-supervised Learning</li><li>Transfer Learning</li><li>Conclusions</li><li>References</li></ul><h1 id="Sequence-Tagging"><a href="#Sequence-Tagging" class="headerlink" title="Sequence Tagging"></a>Sequence Tagging</h1><hr><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><strong>Definition</strong><br>Sequence tagging is a type of pattern recognition task that involves the algorithmic assignment of a categorical label to each member of a sequence of observed values.<br><strong>Significance</strong><br>Sequence tagging is one of the first stages in most natural language processing applications, such as part-of-speech tagging, chunking and named entity recognition.<br><strong>Approaches</strong></p><ul><li><del>Traditional models</del><ul><li><del>Hidden Markov Models</del></li><li><del>Conditional Random Fields</del></li></ul></li><li>Neural network models<ul><li>RNN, LSTM, GRU</li></ul></li></ul><h3 id="Neural-Network-Model"><a href="#Neural-Network-Model" class="headerlink" title="Neural Network Model"></a>Neural Network Model</h3><p><img src="1.png" alt></p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><img src="3.png" alt></p><h3 id="Sequence-Tagging-with-Little-Labeled-Data"><a href="#Sequence-Tagging-with-Little-Labeled-Data" class="headerlink" title="Sequence Tagging with Little Labeled Data"></a>Sequence Tagging with Little Labeled Data</h3><p><strong>Backgrounds</strong><br>Although recent neural networks obtain state-of-the-art performance on several sequence tagging tasks, they can’t be used for tasks with little labeled data.<br><strong>Approaches</strong></p><ul><li><del>Self-taught learning</del></li><li><del>Active learning</del></li><li><del>Transductive learning</del></li><li>Semi-supervised learning</li><li>Transfer learning</li></ul><h1 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h1><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><strong>Language Models Added</strong></p><ul><li>Semi-supervised Multitask Learning for Sequence Labeling. Marek Rei. ACL17.</li><li>Semi-supervised Sequence Tagging with Bidirectional Language Models. Matthew et al. ACL17.</li></ul><p><strong>Graph-based</strong></p><ul><li>Efficient Graph-Based Semi-Supervised Learning of Structured Tagging Models. Subramanya et al. EMNLP10.</li><li>Scientific Information Extraction with Semi-supervised Neural Tagging. Luan et al. EMNLP17.</li><li>Graph-based Semi-supervised Acoustic Modeling in DNN-based Speech Recognition. Liu et al. IEEE SLT14.</li></ul><h3 id="Language-Models-Added"><a href="#Language-Models-Added" class="headerlink" title="Language Models Added"></a>Language Models Added</h3><p><img src="2.png" alt></p><h3 id="Language-Modeling-Objective"><a href="#Language-Modeling-Objective" class="headerlink" title="Language Modeling Objective"></a>Language Modeling Objective</h3><p>\[\begin{array}{l}\overrightarrow { {m_t}}  = \tanh (\overrightarrow { {W_m}} \overrightarrow { {h_t}} )\\\overleftarrow { {m_t}}  = \tanh (\overleftarrow { {W_m}} \overleftarrow { {h_t}} )\\P({w_{t + 1}}|\overrightarrow { {m_t}} ) = {\rm{softmax}}(\overrightarrow { {W_q}} \overrightarrow { {m_t}} )\\P({w_{t - 1}}|\overleftarrow { {m_t}} ) = {\rm{softmax}}(\overleftarrow { {W_q}} \overleftarrow { {m_t}} )\\\overrightarrow E  =  - \sum\limits_{t = 1}^{T - 1} {\log (P({w_{t + 1}}|\overrightarrow { {m_t}} ))} \\\overleftarrow E  =  - \sum\limits_{t = 2}^T {\log (P({w_{t - 1}}|\overleftarrow { {m_t}} ))} \\E = E + \gamma (\overrightarrow E  + \overleftarrow E )\end{array}\]</p><h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p><img src="4.png" alt><br><img src="5.png" alt></p><h3 id="Language-Models-Added-1"><a href="#Language-Models-Added-1" class="headerlink" title="Language Models Added"></a>Language Models Added</h3><p><img src="6.png" alt></p><h3 id="Bidirectional-Language-Model"><a href="#Bidirectional-Language-Model" class="headerlink" title="Bidirectional Language Model"></a>Bidirectional Language Model</h3><p>\[\begin{array}{l}h_k^{LM} = [\overrightarrow {h_k^{LM}} ;\overleftarrow {h_k^{LM}} ]\\{h_{k,1}} = [\overrightarrow { {h_{k,1}}} ;\overleftarrow { {h_{k,1}}} ;h_k^{LM}]\end{array}\]<br><strong>Alternative</strong></p><ul><li>Replace $[\overrightarrow { {h_{k,1}}} ;\overleftarrow { {h_{k,1}}} ;h_k^{LM}]$ with $f([\overrightarrow { {h_{k,1}}} ;\overleftarrow { {h_{k,1}}} ;h_k^{LM}])$.</li><li>Concatenate the LM embeddings at different locations in the baseline sequence tagger.</li><li>Decrease the number of parameters in the second RNN layer.</li></ul><h3 id="Results-2"><a href="#Results-2" class="headerlink" title="Results"></a>Results</h3><p><img src="7.png" alt><br><img src="8.png" alt></p><h3 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>The language model transfer across domains.</li><li>The model is robust even when trained on a large number of labeled data.</li><li>Training the sequence tagging model and language model together increases performance.</li></ul><h3 id="Graph-based"><a href="#Graph-based" class="headerlink" title="Graph-based"></a>Graph-based</h3><ul><li>Steps<ul><li>Construct a graph of tokens based on their semantic similarity.</li><li>Use the CRF marginal as a regularization term to do label propagation on the graph.</li><li>The smoothed posterior is then used to either interpolate with the CRF marginal or as an additional feature to the neural network.</li></ul></li><li>Graph Construction<ul><li>${w_{uv}} = {d_e}(u,v)$ if $v \in K(u)$ or $u \in K(v)$.</li></ul></li><li>Label Propagation<br><img src="9.png" alt></li><li>Uncertain Label Marginalizing<br>\[\mathcal{Y}({x_t}) = \left\{ {\begin{array}{*{20}{c}}{\{ {y_t}\} }&amp;{ {\rm{if \ }}p({y_t}|x;\theta ) &gt; \eta }\\{ {\rm{All \ label \ types}}}&amp;{ {\rm{otherwise}}}\end{array}} \right.\]</li><li>Score<br>\[\phi (y;x,\theta ) = \sum\limits_{t = 0}^n { {T_{ {y_t},{y_{t + 1}}}}}  + \sum\limits_{t = 1}^n { {P_{t,{y_t}}}} \]</li><li>Probability<br>\[{p_\theta }(\mathcal{Y}({x^k})|{x^k}) = \frac{ {\sum\nolimits_{ {y^k} \in \mathcal{Y}({x^k})} {\exp (\phi ({y^k};{x^k},\theta ))} }}{ {\sum\nolimits_{y’ \in Y} {\exp (\phi (y’;x,\theta ))} }}\]<br><img src="10.png" alt></li></ul><h3 id="Results-3"><a href="#Results-3" class="headerlink" title="Results"></a>Results</h3><p><img src="11.png" alt></p><h3 id="Conclusions-1"><a href="#Conclusions-1" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>In-domain data performs better than cross-domain data.</li><li>The combination of in-domain data and ULM algorithms performs well.</li><li>We can add language models into the model in the future to capture the context information.</li></ul><h1 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h1><hr><h3 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h3><p><strong>Cross-domain Transfer</strong></p><ul><li>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks. Yang et al. ICLR17.</li><li>Improving Named Entity Recognition for Chinese Social Media with Word Segmentation Representation Learning. Peng et al. ACL16.</li><li>Multi-task Domain Adaptation for Sequence Tagging. Peng et al. Workshop17.</li></ul><p><strong>Cross-lingual Transfer</strong></p><ul><li>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks. Yang et al. ICLR17.</li><li>Cross-Lingual Transfer Learning for POS Tagging without Cross-Lingual Resources. Kim et al. EMNLP17.</li></ul><h3 id="Cross-domain-Transfer"><a href="#Cross-domain-Transfer" class="headerlink" title="Cross-domain Transfer"></a>Cross-domain Transfer</h3><ul><li>Label mapping exist<br><img src="13.png" alt></li><li>Disparate label sets<br><img src="12.png" alt></li></ul><p><img src="20.png" alt><br><img src="15.png" alt></p><h3 id="Domain-Projections"><a href="#Domain-Projections" class="headerlink" title="Domain Projections"></a>Domain Projections</h3><ul><li>Domain Masks<br>\[\begin{array}{l}{m_1} = [\overrightarrow 1 ,\overrightarrow 1 ,\overrightarrow 0 ],{m_2} = [\overrightarrow 1 ,\overrightarrow 0 ,\overrightarrow 1 ]\\\hat h = {m_d} \odot h\end{array}\]</li><li>Linear Projection<br>\[\hat h = {T_d}h\]</li></ul><h3 id="Results-4"><a href="#Results-4" class="headerlink" title="Results"></a>Results</h3><p><img src="16.png" alt></p><h3 id="Conclusions-2"><a href="#Conclusions-2" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>Multi-task learning can help domain adaptation.</li><li>The number of shared parameters has great impact on the performance.</li><li>We may use other domain adaptation methods besides parameter sharing and representation learning.</li></ul><h3 id="Cross-lingual-Transfer"><a href="#Cross-lingual-Transfer" class="headerlink" title="Cross-lingual Transfer"></a>Cross-lingual Transfer</h3><p><img src="17.png" alt><br><img src="18.png" alt></p><ul><li>Sequence Tagging Loss<br>\[{\mathcal{L}_p} =  - \sum\limits_{i = 1}^S {\sum\limits_{j = 1}^N { {p_{i,j}}\log ({ {\hat p}_{i,j}})} }\]</li><li>Language Classifier Loss<br>\[{\mathcal{L}_a} =  - \sum\limits_{i = 1}^S { {l_i}\log ({ {\hat l}_i})}\]</li><li>Bidirectional Language Model Loss<br>\[{\mathcal{L}_l} =  - \sum\limits_{i = 1}^S {\sum\limits_{j = 1}^N {\log (P({w_{j + 1}}|{f_j})) + \log (P({w_{j - 1}}|{b_j}))} }\]</li><li>Total Loss<br>\[\mathcal{L} = {w_s}({\mathcal{L}_p} + \lambda {\mathcal{L}_a} + \lambda {\mathcal{L}_l})\]</li></ul><h3 id="Results-5"><a href="#Results-5" class="headerlink" title="Results"></a>Results</h3><p><img src="19.png" alt></p><h3 id="Conclusions-3"><a href="#Conclusions-3" class="headerlink" title="Conclusions"></a>Conclusions</h3><ul><li>The language classifier can train the common LSTM to be language-agnostic.</li><li>Either too many or too little labeled data decrease the performance.</li><li>Multiple source languages can be used to increase the performance.</li></ul><h1 id="Conclusions-4"><a href="#Conclusions-4" class="headerlink" title="Conclusions"></a>Conclusions</h1><hr><h3 id="Semi-supervised-Learning-vs-Transfer-Learning"><a href="#Semi-supervised-Learning-vs-Transfer-Learning" class="headerlink" title="Semi-supervised Learning vs Transfer Learning"></a>Semi-supervised Learning vs Transfer Learning</h3><ul><li>It seems that semi-supervised learning is better than transfer learning on some tasks.</li><li>Semi-supervised learning is not always useful for the lack of unlabeled data in the same domain.</li><li>Andrew Ng had said that transfer learning is an important research direction in the next five years.</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><ul><li>Semi-supervised learning and transfer learning can be combined to increase performance.</li><li>Other methods like active learning can be added.</li></ul><h1 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h1><hr><p>Xuezhe Ma and Eduard Hovy. (2016).<br><strong>End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF.</strong><br><em>In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 1064–1074, Berlin, Germany, August 7-12, 2016.</em></p><p>Marek Rei. (2017).<br><strong>Semi-supervised Multitask Learning for Sequence Labeling.</strong><br><em>In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 2121–2130, Vancouver, Canada, July 30 - August 4, 2017.</em></p><p>Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. (2017).<br><strong>Semi-supervised Sequence Tagging with Bidirectional Language Models.</strong><br><em>In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 1756–1765, Vancouver, Canada, July 30 - August 4, 2017.</em></p><p>Yi Luan, Mari Ostendorf, Hannaneh Hajishirzi. (2017).<br><strong>Scientific Information Extraction with Semi-supervised Neural Tagging.</strong><br><em>In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2631–2641, Copenhagen, Denmark, September 7–11, 2017.</em></p><p>Zhilin Yang, Ruslan Salakhutdinov, William W. Cohen. (2017).<br><strong>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks.</strong><br><em>In ICLR 2017.</em></p><p>Joo-Kyung Kim, Young-Bum Kim, Ruhi Sarikaya, Eric Fosler-Lussier. (2017).<br><strong>Cross-Lingual Transfer Learning for POS Tagging without Cross-Lingual Resources.</strong><br><em>In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2822–2828, Copenhagen, Denmark, September 7–11, 2017.</em></p><p>Nanyun Peng, Mark Dredze. (2017).<br><strong>Multi-task Domain Adaptation for Sequence Tagging.</strong><br><em>In Proceedings of the 2nd Workshop on Representation Learning for NLP, pages 91–100, Vancouver, Canada, August 3, 2017.</em></p><p>Amarnag Subramanya, Slav Petrov, Fernando Pereira. (2010).<br><strong>Efficient Graph-Based Semi-Supervised Learning of Structured Tagging Models.</strong><br><em>In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 167–176, MIT, Massachusetts, USA, 9-11 October 2010.</em></p><p>Yuzong Liu, Katrin Kirchhoff. (2014).<br><strong>Graph-based Semi-supervised Acoustic Modeling in DNN-based Speech Recognition.</strong><br><em>In IEEE SLT 2014.</em></p><p>Nanyun Peng, Mark Dredze. (2016).<br><strong>Improving Named Entity Recognition for Chinese Social Media with Word Segmentation Representation Learning.</strong><br><em>In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 149–155, Berlin, Germany, August 7-12, 2016.</em></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华东师范大学LaTeX幻灯片模板</title>
      <link href="/2017/12/29/ecnu-ppt/"/>
      <url>/2017/12/29/ecnu-ppt/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>分享一套自用ppt模板，使用 <code>XeLaTeX</code> 编译<br>链接地址：<a href="https://github.com/godweiyang/ECNU_BeamerTemplate" target="_blank" rel="noopener">传送门</a></p><h1 id="界面示例"><a href="#界面示例" class="headerlink" title="界面示例"></a>界面示例</h1><p><img src="1.png" alt><br>觉得还可以的下载了用哦，欢迎修改的更美观！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
            <tag> ppt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scientific Information Extraction with Semi-supervised Neural Tagging</title>
      <link href="/2017/12/19/emnlp17-2/"/>
      <url>/2017/12/19/emnlp17-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/D/D17/D17-1279.pdf" target="_blank" rel="noopener">D17-1279</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>这篇论文研究的是科技论文的信息抽取问题，比如给你一篇paper，你要找出其中的Task（任务）、Process（过程方法）、Material（资料数据）三种实体。<br>这个问题可以归类为序列标注问题，但是科技论文的标注数据还是很少的，于是本文提出了一种基于图的半监督序列标注算法。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>背景就是近几年来论文发表数量越来越多，要对这些论文进行信息抽取，概括这篇论文的摘要。<br>由于标注过的论文很少，大量论文那都是无标注的，所以需要一个半监督的方法来进行序列标注。本文有三大贡献：一是结果比以往的更好啦，二是提出一种半监督序列标注方法，使用基于图的标签传播和可信度数据选择，三是探索了不同的利用无标注数据的方法，比如无监督的表示初始化和半监督的模型训练。</p><p>以往的工作大多是基于迁移学习的，本文提出的模型比他们结果都要好（ps.迁移学习和半监督方法都说自己最好。。。）</p><h1 id="2-模型"><a href="#2-模型" class="headerlink" title="2 模型"></a>2 模型</h1><hr><p>基本的模型就不用说了，就是传统的CNN+LSTM+CRF序列标注模型。<br>本文的重点就在于无标注数据的使用上，采用了基于图的标签传播算法，来对无标注数据进行标注，并添加到序列标注模型中进行训练。</p><h1 id="3-半监督学习"><a href="#3-半监督学习" class="headerlink" title="3 半监督学习"></a>3 半监督学习</h1><hr><p>具体是怎么标注的呢？<br>概括起来就是首先计算出每个无标注数据的后验概率，然后改进基本序列标注模型中的CRF，使它能够考虑到标签的不确定性。</p><h3 id="基于图的后验估计"><a href="#基于图的后验估计" class="headerlink" title="基于图的后验估计"></a>基于图的后验估计</h3><p>估计后验概率方法如下：<br>首先基于词的语义相似度构造出一个图，然后使用CRF边际函数作为正则化因子在图上进行标签传播，最后应用到神经网络中。</p><h4 id="图的构造"><a href="#图的构造" class="headerlink" title="图的构造"></a>图的构造</h4><p>图中的结点代表单词，边代表词之间的语义相似性。整个图的结点数量等于标注数据和未标注数据总单词数。<br>单词的表示是用前后共5个单词的词向量、和他最近的动词的词向量、一组离散特征例如词性和大写连接而成，然后用PCA降维到100维。<br>定义两个结点之间的边权重等于欧几里得距离，如果两个点中至少一个点在另一个点的K近邻里。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> EMNLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cross-Lingual Transfer Learning for POS Tagging without Cross-Lingual Resources</title>
      <link href="/2017/12/19/emnlp17-1/"/>
      <url>/2017/12/19/emnlp17-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/D/D17/D17-1302.pdf" target="_blank" rel="noopener">D17-1302</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>本文介绍了一个跨语言的序列标注迁移模型，和以往不同的是，不需要大量的跨语言语料。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>之前正好才看过一篇Yang et al. (2017)的论文Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks，还写了博客笔记<a href="http://godweiyang.com/2017/11/13/ICLR17-1/">[传送门]</a>。然而本文上来就说，他的模型不好！因为他的模型共享了字符层，其他层都是独立的，这样就导致了两种字符没有交集的语言迁移会很困难。<br>于是本文提出了基于一个公有LSTM和一个私有LSTM的模型。不过，我还是没明白这个字符层和前文批判的那个有啥区别。。。</p><h1 id="2-模型"><a href="#2-模型" class="headerlink" title="2 模型"></a>2 模型</h1><hr><p>模型结构如下图所示：<br><img src="1.png" alt></p><h3 id="跨语言训练"><a href="#跨语言训练" class="headerlink" title="跨语言训练"></a>跨语言训练</h3><p>整体训练过程是这样的：首先输入一个句子，对于每个单词中的每个字符，输入到双向LSTM中，取前向后向LSTM的最后一个隐含层输出，连接到一起来作为词的表示。然后输入到公有和私有LSTM中训练，最后的损失函数有三个。<br>图中蓝色部分是公有部分，红色部分是私有部分。紫色部分是不同语言预测出的结果，三个红色方框是三个损失函数。<br>其中softmax层的损失函数定义为：<br><img src="2.png" alt><br>$S$是句子个数，$N$是当前句子单词数，${p_{i,j}}$第$i$个句子的第$j$个标签，${\hat p_{i,j}}$是预测标签。</p><h3 id="语言对抗训练"><a href="#语言对抗训练" class="headerlink" title="语言对抗训练"></a>语言对抗训练</h3><p>为了让公有的LSTM部分变得语言无关，所以要对他进行语言对抗训练。<br>首先对公有LSTM的输出进行CNN/MaxPool编码（其实就是每一个维度取最大值），三个卷积层，得到三个向量，再连接到一起得到最终的向量表示，经过一个梯度反转层，最后输入到语言鉴别器。<br>这个语言鉴别器就是一个单隐含层的全连接的神经网络，激活函数用的是Leaky ReLU，具体就是当x&gt;=0时，f(x)=x；当x&lt;0时，f(x)=ax，这里a取0.2。<br>最后得到的损失函数定义为：<br><img src="3.png" alt><br>其中${l_{i}}$是第i个句子的语言，${\hat l_{i}}$是预测出的语言（原文说的是softmax输出的标签？？？这里不是很理解）。<br>由于经过了梯度反转层，所以这个语言鉴别器并不能鉴别出是哪一种语言，反而对两种语言的界限混淆了，使得它变得越来越语言无关了。</p><h3 id="双向语言模型"><a href="#双向语言模型" class="headerlink" title="双向语言模型"></a>双向语言模型</h3><p>这个就不用多说了，很多地方都用到了，之前的两篇半监督序列标注的论文也都提到了加入语言模型来提升效果，而且注意的是，就算是没有标注的数据也可以加入进语言模型的训练。<br>语言模型的损失函数定义为：<br><img src="4.png" alt><br>其中f和b分别代表前向和后向LSTM输出。<br>最终，三个损失函数合并起来定义一个总的损失函数：<br><img src="5.png" alt><br>其中$\lambda $随着训练进行缓慢的从0上升到1，这是为了增加额外损失函数的训练稳定性。<br>而$w_{s}$是为了给源语言和目标语言不同的权重的，当训练目标语言是，权重为1，否则权重为目标语言训练集大小/源语言训练集大小。</p><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h1><p>实验针对目标语言训练句子数为1280、320和32分别做了对比。<br>其中1280个句子的结果如下：<br><img src="6.png" alt><br>可以看出加入迁移学习后结果提升还是比较大的，表格中c表示公有LSTM，l表示语言模型，p表示私有LSTM，a表示语言对抗训练。本文的模型(c,p,l+a)结果是最好的。<br>320个句子的结果如下：<br><img src="7.png" alt><br>依然有提升，但是提升很不明显了，而且有几种语言直接采用私有LSTM+语言模型效果反而最好。原因就是目标语言的训练数据太少了，不足以训练出完美的公有和私有模型。<br>32个句子的训练数据就没有放出具体结果，结果依然有略微提升的，但是已经可以忽略不计了。<br>反过来思考，如果用上全部的目标语言训练数据，那么出来的结果会怎么样？事实是反而下降了，还不如直接用私有LSTM。<br>最后还做了一个实验，就是用多种不同的源语言+目标语言来训练模型，发现效果比用单种源语言效果好。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> EMNLP </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequence Tagging with Little Labeled Data</title>
      <link href="/2017/11/29/textminning/"/>
      <url>/2017/11/29/textminning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>文本挖掘课presentation还有一个多月了，依然很迷茫，不知道选什么课题。<br>最近看了一些序列标注相关的paper，暂且就准备挑一个相关的点做了，打算做一个“基于少量标注数据的序列标注”。</p><h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><hr><p>基于少量标注数据的序列标注，主要有两种方法：迁移学习和半监督学习。<br>代表性的paper分别有：<br><a href="https://arxiv.org/pdf/1703.06345.pdf" target="_blank" rel="noopener">Yang Z, Salakhutdinov R, Cohen W W. Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks. ICLR, 2017.</a><br><a href="https://arxiv.org/pdf/1705.00108.pdf" target="_blank" rel="noopener">Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. Semi-supervised sequence tagging with bidirectional language models. ACL, 2017.</a><br>具体该讲些什么，该怎么讲，等我慢慢补充吧。<br>其中传统的半监督序列标注模型有基于HMM之类的，这里就不说了。<br>下面说说几个基于双向LSTM的。</p><h3 id="Marek-Rei-Semi-supervised-Multitask-Learning-for-Sequence-Labeling-ACL-2017"><a href="#Marek-Rei-Semi-supervised-Multitask-Learning-for-Sequence-Labeling-ACL-2017" class="headerlink" title="Marek Rei. Semi-supervised Multitask Learning for Sequence Labeling. ACL, 2017."></a>Marek Rei. <em>Semi-supervised Multitask Learning for Sequence Labeling. ACL, 2017.</em></h3><p><img src="1.png" alt><br>这篇论文介绍了一个附加了语言模型的LSTM序列标注模型。<br>就是在传统的序列标注模型隐含层输出上额外附加了一层语言模型输出，总的损失函数也加上了语言模型的损失函数，共同训练。<br><img src="2.png" alt><br><img src="3.png" alt><br><img src="4.png" alt><br><img src="5.png" alt><br>其中E就是原始序列标注模型的损失。<br>当然了，这个模型不需要额外的未标注数据，只要用到少量的标注数据就行了。</p><h3 id="Matthew-E-Peters-Waleed-Ammar-Chandra-Bhagavatula-Russell-Power-Semi-supervised-sequence-tagging-with-bidirectional-language-models-ACL-2017"><a href="#Matthew-E-Peters-Waleed-Ammar-Chandra-Bhagavatula-Russell-Power-Semi-supervised-sequence-tagging-with-bidirectional-language-models-ACL-2017" class="headerlink" title="Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. Semi-supervised sequence tagging with bidirectional language models. ACL, 2017."></a>Matthew E. Peters, Waleed Ammar, Chandra Bhagavatula, Russell Power. <em>Semi-supervised sequence tagging with bidirectional language models. ACL, 2017.</em></h3><p>这篇论文就是半监督序列标注模型中我看到的效果最好的一个了。<br>和上面一篇相同的是，都加入了语言模型，来对单词上下文信息进行编码。但是不同的是，上文将语言模型和序列标注模型融合在了一起，所以只需要少量的标注数据就行了，无法利用大量的无标注数据。这篇的模型将其分开，预先对大量的无标注数据训练语言模型，然后将训练好的词表示加入到序列标注模型中，和原始的词向量结合，然后进行训练。<br>模型结构如下所示：<br><img src="6.png" alt></p><h3 id="Yi-Luan-Mari-Ostendorf-Hannaneh-Hajishirzi-Scientific-Information-Extraction-with-Semi-supervised-Neural-Tagging-EMNLP-2017"><a href="#Yi-Luan-Mari-Ostendorf-Hannaneh-Hajishirzi-Scientific-Information-Extraction-with-Semi-supervised-Neural-Tagging-EMNLP-2017" class="headerlink" title="Yi Luan, Mari Ostendorf, Hannaneh Hajishirzi. Scientific Information Extraction with Semi-supervised Neural Tagging. EMNLP, 2017."></a>Yi Luan, Mari Ostendorf, Hannaneh Hajishirzi. <em>Scientific Information Extraction with Semi-supervised Neural Tagging. EMNLP, 2017.</em></h3><p>这篇论文任务是科技文章的关键词提取，然后分类为task、process、material三类，可以将其看成一个序列标注任务。<br>这篇论文介绍了一种基于图的半监督方法</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> 迁移学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理实践期末大作业</title>
      <link href="/2017/11/16/sw-compiler/"/>
      <url>/2017/11/16/sw-compiler/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这学期编译原理实践期末大作业是编写一个简化swift语法编译器，代码等到学期结束再上传百度云，现在先上传一个测试运行程序，bug很多。<br><a href="https://pan.baidu.com/s/1jHDbtcy" target="_blank" rel="noopener">程序地址</a>，密码是cnfj，在大四上文件夹下。<br>主界面：<br><img src="1.png" alt><br>支持常用编辑以及编译运行和单步调试查看数据栈。<br>目前暂时只做了跳过注释、mod、odd、自增、自减、常量定义、repeat这几个扩展点，其他再说吧，做的很烂，及格就行。</p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transfer Learning for Sequence Tagging with Hierarchical Recurrent Networks</title>
      <link href="/2017/11/13/iclr17-1/"/>
      <url>/2017/11/13/iclr17-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://arxiv.org/pdf/1703.06345.pdf" target="_blank" rel="noopener">链接</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>探索一种神经序列标注的迁移学习方法，适用于源任务有大量标注标签，但是目标任务标注标签很少的情况，主要有三个方面：跨领域、跨应用、跨语言。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>序列标注任务的一个难点就是怎样将知识从一个任务迁移到另一个任务上面去，通常被叫做“迁移学习”。<br>这里对三种任务（跨领域、跨应用、跨语言）分别提出了参数共享的神经网络结构，实验结果也很好。即使标注标签很多，结果也比以前的结果更好。</p><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a>2 相关工作</h1><hr><p>NLP迁移学习通常有两种方法，一种是基于资源的迁移，另一种是基于模型的迁移。<br>基于资源的迁移需要大量的跨语言语料，而且通常只用在跨语言任务了，在跨领域和跨应用方面还没什么应用。<br>基于模型的迁移就不需要大量的额外资源了，只要探索源任务和目标任务之间的相似性和相关性，通过修改模型结构、训练算法、特征表示。<br>这里的模型就是基于模型的迁移。和以往不同的是，这个模型利用了深度递归神经网之间的一般性，可以在跨领域、跨应用、跨语言之间转换。</p><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h1><hr><p><img src="1.png" alt><br>上图分别是基本模型、跨领域模型、跨应用模型、跨语言模型。</p><h3 id="3-1-基本模型"><a href="#3-1-基本模型" class="headerlink" title="3.1 基本模型"></a>3.1 基本模型</h3><p>首先字符层输入每个字符表示，输出单词的字符层表示，然后和词向量结合作为每个词的表示，然后经过一个CNN或者RNN，隐含层输出再经过一个CRF得到每个词的标签。</p><h3 id="3-2-迁移学习结构"><a href="#3-2-迁移学习结构" class="headerlink" title="3.2 迁移学习结构"></a>3.2 迁移学习结构</h3><p>跨领域、跨应用、跨语言每种一个迁移结构，和基本模型不同的是，共享的参数不同。</p><h4 id="3-2-1-跨领域迁移"><a href="#3-2-1-跨领域迁移" class="headerlink" title="3.2.1 跨领域迁移"></a>3.2.1 跨领域迁移</h4><p>跨领域迁移有两种情况，一种是两个领域标签存在映射关系，一种是不存在映射关系。<br>第一种情况结构如图b所示，可以共享CRF层以及下面的所有层，最后加一个标签映射的步骤就行了<br>第二种情况结构如图c所示，CRF层独立训练。</p><h4 id="3-2-2-跨应用迁移"><a href="#3-2-2-跨应用迁移" class="headerlink" title="3.2.2 跨应用迁移"></a>3.2.2 跨应用迁移</h4><p>这里假设两种应用是同一种语言，所以和跨领域标签无映射关系类似，用的是图c的结构。</p><h4 id="3-2-3-跨语言迁移"><a href="#3-2-3-跨语言迁移" class="headerlink" title="3.2.3 跨语言迁移"></a>3.2.3 跨语言迁移</h4><p>这里重点放在两种字母表相同的语言上，比如英语和西班牙语。<br>由于字符相同，所以采用图d结构，共享字符层和词向量。</p><h3 id="3-3-训练"><a href="#3-3-训练" class="headerlink" title="3.3 训练"></a>3.3 训练</h3><p>假设从任务$s$迁移到任务$t$，训练集分为$X_s$和$X_t$，参数分为$W_s$和$W_t$。其中模型参数还分为任务特定参数和共享参数：<br>\[{W_s} = {W_{s,spec}} \cup {W_{shared}},{W_t} = {W_{t,spec}} \cup {W_{shared}}\]训练过程如下：<br>每一次迭代，都采用二项分布随机抽取一个任务$s$或$t$，然后训练该任务特定模型参数和共享参数。由于源任务和目标任务收敛速度不一定一样，所以对目标任务提前停止。</p><h3 id="3-4-模型实现"><a href="#3-4-模型实现" class="headerlink" title="3.4 模型实现"></a>3.4 模型实现</h3><p>RNN采用GRU，假设隐含层输出为$h$，输出标签为$y$，定义CRF的目标函数为<br>\[f(h,y) - \log \sum\limits_{y’ \in \gamma (h)} {\exp (f(h,y’) + \cos {\rm{t}}(y,y’))} \]</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h1><p><img src="2.png" alt><br><img src="3.png" alt><br>上图是实验结果，其中跨领域迁移：ade，跨应用迁移：fgh，跨语言迁移：ij，跨领域和应用：b，跨领域、应用和语言：c。<br><img src="4.png" alt><br>上表是各类任务在不同标签率下迁移学习和无迁移学习的性能对比。<br>可以看出三种迁移结构性能提升的顺序是A&gt;B&gt;C，因为结构C比如跨语言模型，源任务和目标任务相似性很小。<br><img src="5.png" alt><br>上图是和其他模型比较的结果。</p><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h1><hr><p>提出一种神经序列标注的迁移学习方法，主要有三个方面：跨领域、跨应用、跨语言。<br>以下三个因素对迁移学习性能有很大影响：目标任务标签数量、源任务和目标任务相关性、能够共享的参数数量。<br>在以后的工作中，可以在跨语言迁移学习中尝试结合基于模型的迁移和基于资源的迁移。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
            <tag> ICLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Implicitly-Defined Neural Networks for Sequence Labeling</title>
      <link href="/2017/10/25/acl17-2027/"/>
      <url>/2017/10/25/acl17-2027/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/P/P17/P17-2027.pdf" target="_blank" rel="noopener">P17-2027</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>这篇论文介绍了一种新奇的、隐式定义神经网络，并且描述了计算它的方法。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>传统的双向RNN只能单独计算两个方向的隐含层，现在介绍一种新的机制，将两个方向的信息直接结合起来计算。</p><h1 id="2-INN"><a href="#2-INN" class="headerlink" title="2 INN"></a>2 INN</h1><hr><h3 id="2-1-传统的RNN"><a href="#2-1-传统的RNN" class="headerlink" title="2.1 传统的RNN"></a>2.1 传统的RNN</h3><p>经典的RNN给定一个输入序列$[{\xi _1},{\xi _2}, \ldots ,{\xi _n}]$和初始隐含层状态${h_s}$，然后迭代产生后续的隐含层状态：<br>\[\begin{array}{l}{h_1} = f({\xi _1},{h_s})\\{h_2} = f({\xi _2},{h_1})\\ \cdots \\{h_n} = f({\xi _n},{h_{n - 1}})\end{array}\]LSTM、GRU和其他的相关变体计算方法也都类似，都是像下图这样线性计算，每一时刻的状态只依赖于当前输入和前一时刻的状态。<br><img src="1.png" alt></p><h3 id="2-2-改进结构"><a href="#2-2-改进结构" class="headerlink" title="2.2 改进结构"></a>2.2 改进结构</h3><p>这篇论文中这样计算隐含层状态：<br>\[{h_t} = f({\xi _t},{h_{t - 1}},{h_{t + 1}})\]这样整个隐含层状态序列的等式就是隐式的，记为：<br>\[H = [{h_1},{h_2}, \ldots ,{h_n}]\]在这个神经网络中，定义如下变量：数据$X$、标签$Y$、参数$\theta$，定义如下函数：<br>输入层变换：<br>\[\xi  = g(\theta ,X)\]隐式隐含层：<br>\[H = F(\theta ,\xi ,H)\]损失函数：<br>\[L = \ell (\theta ,H,Y)\]定义${h_s}$和${h_e}$为边界状态，$n$为输入序列长度，$F$函数构造出了一系列非线性等式：<br>\[\begin{array}{l}{h_1} = f({h_s},{h_2},{\xi _1})\\ \cdots \\{h_i} = f({h_{i - 1}},{h_{i + 1}},{\xi _i})\\ \cdots \\{h_n} = f({h_{n - 1}},{h_e},{\xi _n})\end{array}\]INN结构如下图：<br><img src="2.png" alt></p><h3 id="2-3-计算前向传播"><a href="#2-3-计算前向传播" class="headerlink" title="2.3 计算前向传播"></a>2.3 计算前向传播</h3><p>为了计算等式$H = F(H)$，采用拟牛顿法。<br>令$G = H - F(H)$，转化为计算等式$G = 0$。<br>\[\begin{array}{l}{H_{n + 1}} = {H_n} - {({\nabla _H}G)^{ - 1}}G\\{H_{n + 1}} = {H_n} - {(I - {\nabla _H}F)^{ - 1}}({H_n} - F({H_n}))\end{array}\]注意到$(I - {\nabla _H}F)$是一个稀疏矩阵，所以采用Krylov子空间方法，具体是稳定双共轭梯度法(BICG-STAB)算法来计算。</p><h3 id="2-4-梯度"><a href="#2-4-梯度" class="headerlink" title="2.4 梯度"></a>2.4 梯度</h3><p>为了训练模型，采用随机梯度下降，定义损失函数：<br>\[{\nabla _\theta }L = {\nabla _\theta }\ell  + {\nabla _H}\ell {\nabla _\theta }H\]其中<br>\[{\nabla _\theta }H = {\nabla _\theta }F + {\nabla _H}F{\nabla _\theta }H + {\nabla _\xi }F{\nabla _\theta }\xi \]所以<br>\[{\nabla _\theta }H = {(I - {\nabla _H}F)^{ - 1}}({\nabla _\theta }F + {\nabla _\xi }F{\nabla _\theta }\xi )\]所以整个梯度就是<br>\[{\nabla _\theta }L = {\nabla _\theta }\ell  + {\nabla _H}\ell {(I - {\nabla _H}F)^{ - 1}}({\nabla _\theta }F + {\nabla _\xi }F{\nabla _\theta }\xi )\]</p><h3 id="2-5-转换函数"><a href="#2-5-转换函数" class="headerlink" title="2.5 转换函数"></a>2.5 转换函数</h3><p>回忆在GRU中，有如下转换函数：<br>\[\begin{array}{l}{h_t} = (1 - {z_t}){ {\hat h}_t} + {z_t}{ {\tilde h}_t}\\{ {\tilde h}_t} = \tanh (W{x_t} + U({r_t}{ {\hat h}_t}) + \tilde b)\\{z_t} = \sigma ({W_z}{x_t} + {U_z}{ {\hat h}_t} + {b_z})\\{r_t} = \sigma ({W_r}{x_t} + {U_r}{ {\hat h}_t} + {b_r})\end{array}\]其中在GRU中${ {\hat h}_t} = {h_{t - 1}}$，在INN中做一个替代：<br>\[\begin{array}{l}{ {\hat h}_t} = s{h_{t - 1}} + (1 - s){h_{t + 1}}\\s = \frac{ { {s_p}}}{ { {s_p} + {s_n}}}\\{s_p} = \sigma ({W_p}{x_t} + {U_p}{h_{t - 1}} + {b_p})\\{s_n} = \sigma ({W_n}{x_t} + {U_n}{h_{t + 1}} + {b_n})\end{array}\]</p><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h1><hr><h3 id="序列标注"><a href="#序列标注" class="headerlink" title="序列标注"></a>序列标注</h3><p>如下图所示，这个模型的效果甚至比标准的序列标注器还要好！<br><img src="3.png" alt></p><h1 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h1><hr><p>介绍了一种隐式定义神经网络，应用到了序列标注任务上，效果比双向LSTM、双向GRU等还要好。<br>还有一些工作可以改进，比如可以在双向LSTM上面改造INN，加速计算${(I - {\nabla _H}F)^{ - 1}}$等等。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semi-supervised sequence tagging with bidirectional language models</title>
      <link href="/2017/10/03/acl17-1161/"/>
      <url>/2017/10/03/acl17-1161/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/P/P17/P17-1161.pdf" target="_blank" rel="noopener">P17-1161</a></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><hr><p>从未标注文本中学习到的预训练词向量已经成为NLP任务神经网络结构的重要组成部分。<br>但是大多数情况下，现在的循环神经网络还是从极少的标注数据中学习上下文相关的表示。<br>所以这篇论文研究一种通用的半监督学习方法，将从双向语言模型中预训练出来的词向量加到NLP系统中，把它应用到序列标注任务中。<br>我们在两个NLP任务上做实验：NER和chunking。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><hr><p>这篇论文我们探讨一种半监督学习方法，不需要额外的标注数据。<br>我们使用一个神经语言模型，在大量未标注数据上训练，计算出每个位置上下文的编码，然后应用到半监督的标注模型中。<br>我们第一个主要贡献是证明了语言模型训练出的上下文相关表示在半监督标注模型中是很有用的。<br>第二个贡献是多使用一个后向的语言模型效果更好。<br>同时我们发现没必要针对某个领域数据来专门训练。</p><h1 id="2-语言模型增强的序列标注"><a href="#2-语言模型增强的序列标注" class="headerlink" title="2 语言模型增强的序列标注"></a>2 语言模型增强的序列标注</h1><hr><h3 id="2-1-概览"><a href="#2-1-概览" class="headerlink" title="2.1 概览"></a>2.1 概览</h3><p>这个模型的主要结构如图所示：<br><img src="1.jpg" alt><br>主要过程可以分为3步：</p><ul><li>首先在大量的未标注数据上训练词向量和一个神经语言模型</li><li>然后提取一个句子中每个单词的词向量表示与语言模型表示</li><li>最后将它们应用到监督序列标注模型中。</li></ul><p>具体的结构如下图所示：<br><img src="2.jpg" alt></p><h3 id="2-2-基本的序列标注模型"><a href="#2-2-基本的序列标注模型" class="headerlink" title="2.2 基本的序列标注模型"></a>2.2 基本的序列标注模型</h3><p>我们用到的基本的序列标注模型是一个分层的神经序列标注模型，如上图左半部分所示。<br>给定一个句子$({t_1},{t_2}, \ldots ,{t_N})$，首先对于每个单词${t_k}$产生一个表示${x_k}$，其中${x_k}$是由这个单词基于字符的表示${c_k}$和词向量表示${w_k}$连接而成：<br>\[\begin{array}{l}{c_k} = C({t_k};{\theta _c})\\{w_k} = E({t_k};{\theta _w})\\{x_k} = [{c_k};{w_k}]\end{array}\]字符表示${c_k}$捕获的是这个单词的形态信息，可以用CNN或者RNN来实现。<br>词向量表示${w_k}$是从预训练的词向量表中直接提取的。<br>为了学习到上下文相关的表示，我们采用多层双向RNN。<br>对于每个单词${x_k}$，第${i}$层隐含层${h_{k,i}}$是由前向隐含层状态${ {\vec h}_{k,i}}$和后向隐含层状态${ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,i}}$连接而成。<br>对于第一层隐含层，${h_{k,1}}$由${x_k}$经过如下运算获得：<br>\[\begin{array}{l}{ {\vec h}_{k,1}} = { {\vec R}_1}({x_k},{ {\vec h}_{k - 1,1}};{\theta _{ { {\vec R}_1}}})\\{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}} = { {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over R} }_1}({x_k},{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k + 1,1}};{\theta _{ { {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over R} }_1}}})\\{h_{k,1}} = [{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}}]\end{array}\]这个实验中我们使用2层隐含层，并且使用GRU或者LSTM作为双向RNN。<br>最后，最后一层隐含层的输出${h_{k,L}}$被输出到一个稠密层，用来预测每个标签的评分。<br>由于在我们的序列标注任务中，连续的标签之间是有依赖性的，所以联合起来预测一整个句子的标签比单独预测每个单词的标签更好。<br>因此，我们增加了额外的一层来计算相邻两个标签之间的条件随机场损失，然后用Viterbi算法来寻找概率最大的标签序列。</p><h3 id="2-3-双向语言模型"><a href="#2-3-双向语言模型" class="headerlink" title="2.3 双向语言模型"></a>2.3 双向语言模型</h3><p>一个语言模型是用来计算一个句子$({t_1},{t_2}, \ldots ,{t_N})$的概率：<br>\[p({t_1},{t_2}, \ldots ,{t_N}) = \prod\limits_{k - 1}^N {p({t_k}|{t_1},{t_2}, \ldots ,{t_{k - 1}})} \]之前的研究将每个单词的字符表示或者词向量表示送到多层LSTM中，用$({t_1},{t_2}, \ldots ,{t_k})$来求出隐含层${ {\vec h}^{LM}}_k$，这就是第$k$个单词的前向语言模型表示，同时也是语言模型LSTM层最顶端的输出。最后用softmax层来预测${t_{k + 1}}$的概率。<br>当然再加上一个后向语言模型表示效果就更好了：<br>\[p({t_1},{t_2}, \ldots ,{t_N}) = \prod\limits_{k - 1}^N {p({t_k}|{t_{k + 1}},{t_{k + 2}}, \ldots ,{t_N})} \]后向语言模型表示实现方式和前向相似，产生输出${ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }^{LM}}_k$<br>注意到在这个模型中，前向后向语言模型是独立的，不共享任何参数。</p><h3 id="2-4-结合语言模型和序列模型"><a href="#2-4-结合语言模型和序列模型" class="headerlink" title="2.4 结合语言模型和序列模型"></a>2.4 结合语言模型和序列模型</h3><p>我们结合的模型TagLM是将语言模型的词表示当作额外的输入传送到序列标注模型中。<br>在实验中，我们发现将语言模型表示和序列模型第一层隐含层输出结合效果最好。表示如下：<br>\[{h_{k,1}} = [{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}};{h_k}^{LM}]\]有许多方法可以结合语言模型表示和序列模型第一层隐含层输出，比如用一个非线性函数来结合：<br>\[{h_{k,1}} = f([{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}};{h_k}^{LM}])\]另一种可能的方法是用类似注意力模型的机制，给每个单词的语言模型表示加上权重，然后再加进序列模型中。<br>本次实验中直接结合效果已经很好了，所以没有尝试其他方法。</p><h1 id="3-实验"><a href="#3-实验" class="headerlink" title="3 实验"></a>3 实验</h1><hr><p>我们在两个NLP任务上做实验：NER和chunking，使用F1评价指标和BIOES标注体系。<br>我们对数据做了预处理，对所有字母小写处理，将所有数字替换成0。</p><h4 id="CoNLL-2003-NER"><a href="#CoNLL-2003-NER" class="headerlink" title="CoNLL 2003 NER"></a>CoNLL 2003 NER</h4><p>CoNLL 2003 NER任务包含了路透社RCV1语料库，它是由4种不同的实体类型标注的：PER、LOC、ORG、MISC，包含了标准的训练集、验证集和测试集。<br>我们的序列模型的字符表示使用了80个隐含层和25维字符表示的双向GRU。上面的序列层使用了两个300个隐含层的双向GRU。为了正则化，每个GRU的输入都添加了25%的dropout。</p><h4 id="CoNLL-2000-chunking"><a href="#CoNLL-2000-chunking" class="headerlink" title="CoNLL 2000 chunking"></a>CoNLL 2000 chunking</h4><p>CoNLL 2000 chunking任务使用华尔街日报第15~18章训练，第20章测试。定义了11种句法分块类型，我们从训练集随机标记出1000个句子作为验证集。<br>序列模型字符表示使用了30维字符表示和带有30个宽度为3字符滤波器的CNN。上面的序列层使用了两个200个隐含层的双向GRU。每个GRU的输入都添加了50%的dropout。</p><h4 id="预训练语言模型"><a href="#预训练语言模型" class="headerlink" title="预训练语言模型"></a>预训练语言模型</h4><p>我们在1B Word Benchmark上面训练语言模型，包含了8亿个单词。<br>我们使用两个2048个单元，512维的LSTM，在4个GPU上进行参数的同步更新，在10轮训练后就停止训练。</p><h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>所有的实验都采用Adam优化器在5.0处进行梯度截断。<br>提前结束训练来防止过拟合，采用以下方法来决定什么时候停止训练：开始时学习率设为0.001，观察验证集每一轮的性能，当验证集上的性能达到最高时，将学习率降低一个数量级，再训练5次，再降低一个数量级，再训练5次，最后停止训练。</p><h3 id="3-1-综合系统结果"><a href="#3-1-综合系统结果" class="headerlink" title="3.1 综合系统结果"></a>3.1 综合系统结果</h3><p>表1和表2比较的是TagLM和其他没有额外标注数据的模型结果。<br>表3和表4比较的是TagLM和其他包含额外标注数据的模型结果。<br><img src="3.jpg" alt><br><img src="4.jpg" alt></p><ul><li>增加外部标注数据<br>尽管我们没有使用外部标注数据，但是我们效果依然比其他模型要好。表3和表4还可以看出这个模型加了语言模型后的提升是最大的。</li></ul><h3 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2 分析"></a>3.2 分析</h3><p>为了解释我们的TagLM的特性，我们在CoNLL 2003 NER上做了许多额外的实验。</p><h4 id="怎样使用语言模型表示？"><a href="#怎样使用语言模型表示？" class="headerlink" title="怎样使用语言模型表示？"></a>怎样使用语言模型表示？</h4><p>在这个实验中，我们将语言模型产生的表示连接到序列模型的不同位置：</p><ul><li>连接到第一个RNN的输入层：<br>\[{x_k} = [{c_k};{w_k};{h_k}^{LM}]\]</li><li>连接到第一个RNN的输出层：<br>\[{h_{k,1}} = [{ {\vec h}_{k,1}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,1}};{h_k}^{LM}]\]</li><li>连接到第二个RNN的输出层：<br>\[{h_{k,2}} = [{ {\vec h}_{k,2}};{ {\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\leftarrow$}} \over h} }_{k,2}};{h_k}^{LM}]\]</li></ul><p>表5显示出第二种位置是效果最好的，我们猜测原因可能是因为第二层RNN可以捕获第一层RNN产生的任务特定的上下文和语言模型产生的通用的上下文之间的互相联系。<br><img src="5.jpg" alt></p><h4 id="用哪一种语言模型重要吗？"><a href="#用哪一种语言模型重要吗？" class="headerlink" title="用哪一种语言模型重要吗？"></a>用哪一种语言模型重要吗？</h4><p>从表6可以看出，前向传播使用CNN-BIG-LSTM，后向传播使用LSTM-2048-512效果是最好的，但是我们没有测试后向也是CNN-BIG-LSTM的，那样效果估计会更好。<br><img src="6.jpg" alt></p><h4 id="任务特定RNN的重要性"><a href="#任务特定RNN的重要性" class="headerlink" title="任务特定RNN的重要性"></a>任务特定RNN的重要性</h4><p>我们把任务特定的RNN去掉了，只用语言模型和稠密层和CRF来预测输出标签，结果非常的差。说明还是需要任务特定RNN来对标注数据编码产生必要的信息的。</p><h4 id="数据集的大小"><a href="#数据集的大小" class="headerlink" title="数据集的大小"></a>数据集的大小</h4><p>通过在大数据和小数据上做实验，得出如下结论：<br>以往的模型在小数据上从无语言模型到有语言模型提升都是很大的，但是在大数据上提升就非常的少了。<br>而我们的TagLM不论是小数据还是大数据性能提升都非常的大。</p><h4 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h4><p>由于第二层RNN的输入加入了语言模型表示，所以维数增加了，但是对实验效果几乎没有影响的。<br>我们通过两个实验来验证：</p><ul><li>增加不包含语言模型的序列模型的第二层RNN维数。</li><li>减少TagLM的第二层RNN维数。</li></ul><p>性能提升都非常的少，而且还说明了TagLM增加的参数对性能是有略微削弱的。</p><h4 id="语言模型要跟随语料库领域而改变吗？"><a href="#语言模型要跟随语料库领域而改变吗？" class="headerlink" title="语言模型要跟随语料库领域而改变吗？"></a>语言模型要跟随语料库领域而改变吗？</h4><p>答案是不需要，之前都是在新闻语料上做的训练，我们直接把它应用到了科技语料库上，性能依然有很大提升。</p><h1 id="4-相关工作"><a href="#4-相关工作" class="headerlink" title="4 相关工作"></a>4 相关工作</h1><hr><h4 id="未标注数据"><a href="#未标注数据" class="headerlink" title="未标注数据"></a>未标注数据</h4><h4 id="神经语言模型"><a href="#神经语言模型" class="headerlink" title="神经语言模型"></a>神经语言模型</h4><h4 id="解释RNN状态"><a href="#解释RNN状态" class="headerlink" title="解释RNN状态"></a>解释RNN状态</h4><h4 id="其他序列标注模型"><a href="#其他序列标注模型" class="headerlink" title="其他序列标注模型"></a>其他序列标注模型</h4><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><hr><ul><li>提出了一种简单、通用的半监督方法，使用预训练的神经语言模型，来给序列标注模型增加上下文表示。</li><li>我们的方法在NER和chunking任务上比其他的方法都要好。</li><li>多使用一个后向的语言模型效果更好。</li><li>即使语言模型在不同领域的语料库上训练，或者序列模型在大数据量的标注数据上训练，效果依然有很大提升。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 序列标注 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text安装与配置教程</title>
      <link href="/2017/10/02/sublime/"/>
      <url>/2017/10/02/sublime/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>Sublime Text是我一直使用的代码编辑器，我喜爱它的原因就是好看啊！当然打开速度毋庸置疑啦，毕竟不是IDE。这里我把我的安装与配置步骤教给大家，如有未尽之处，大家自己摸索咯，也欢迎与我交流。<br>先附上一张美图：<br><img src="sublime.png" alt></p><h1 id="安装Sublime-Text-3"><a href="#安装Sublime-Text-3" class="headerlink" title="安装Sublime Text 3"></a>安装Sublime Text 3</h1><hr><p>下载地址请点击<a href="https://download.sublimetext.com/Sublime%20Text%20Build%203143%20x64%20Setup.exe" target="_blank" rel="noopener">这里</a>。<br>安装过程就不多说了，一直点<code>next</code>就行了。</p><h1 id="配置C-运行环境"><a href="#配置C-运行环境" class="headerlink" title="配置C++运行环境"></a>配置C++运行环境</h1><hr><p>装完后可以直接写代码了，但是不能运行C++的哦，还需要配置运行环境。</p><ul><li><p>首先要安装C++的编译器MinGW，可以直接去官网下（<a href="http://www.mingw.org/" target="_blank" rel="noopener">传送门</a>）。不过我自己是直接下的CodeBlocks（<a href="https://downloads.sourceforge.net/project/codeblocks/Binaries/16.01/Windows/codeblocks-16.01mingw-setup.exe" target="_blank" rel="noopener">传送门</a>），然后用的自带的MinGW。</p></li><li><p>装完编译器之后在<code>我的电脑</code>右键，依次点击<code>属性 - 高级系统设置 - 环境变量</code>，在<code>系统变量</code>中找到<code>Path</code>，编辑它，新建一条，添加MinGW路径，以我的为例是<code>E:\software\codeblocks\MinGW\bin</code>。</p></li><li><p>打开Sublime Text，依次点击<code>Tools - Build System - new Build System</code>，粘贴以下代码：</p><pre><code>{  &quot;encoding&quot;: &quot;utf-8&quot;,  &quot;working_dir&quot;: &quot;$file_path&quot;,  &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,  &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,  &quot;selector&quot;: &quot;source.c++&quot;,  &quot;variants&quot;:   [      {          &quot;name&quot;: &quot;Run&quot;,          &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;      }  ]}</code></pre></li><li><p>然后<code>ctrl+s</code>保存，命名为c++11。</p></li></ul><p>这时候随便写一个C++代码，然后<code>Tools - Build System</code>选择<code>c++11</code>，然后按<code>ctrl+b</code>就可以运行啦。<br>我这配置的是控制台运行的C++，所以支持输入数据的哦！</p><h1 id="配置Java运行环境"><a href="#配置Java运行环境" class="headerlink" title="配置Java运行环境"></a>配置Java运行环境</h1><hr><ul><li>首先下载Java的编译器jdk（<a href="http://download.oracle.com/otn-pub/java/jdk/9+181/jdk-9_windows-x64_bin.exe" target="_blank" rel="noopener">传送门</a>），安装过程就不说了。</li><li>环境变量应该不用自己添加了，安装过程会帮你自动添加。</li><li>打开Sublime Text，依次点击<code>Tools - Build System - new Build System</code>，粘贴以下代码：<pre><code>{  &quot;cmd&quot;: [&quot;javac&quot;,&quot;-d&quot;,&quot;.&quot;,&quot;$file&quot;],  &quot;file_regex&quot;: &quot;^(...*?):([0-9]*):?([0-9]*)&quot;,  &quot;selector&quot;: &quot;source.java&quot;,  &quot;encoding&quot;:&quot;cp936&quot;,  //执行完上面的命令就结束  // 下面的命令需要按Ctrl+Shift+b来运行  &quot;variants&quot;:  [      {          &quot;name&quot;: &quot;Run&quot;,          &quot;shell&quot;: true,          &quot;cmd&quot; : [&quot;start&quot;,&quot;cmd&quot;,&quot;/c&quot;, &quot;java ${file_base_name} &amp;echo. &amp; pause&quot;],           //c是执行完命令后关闭cmd窗口,          //k是执行完命令后不关闭cmd窗口。          // echo. 相当于输入一个回车          // pause命令使cmd窗口按任意键后才关闭          &quot;working_dir&quot;: &quot;${file_path}&quot;,          &quot;encoding&quot;:&quot;cp936&quot;      }  ]}</code></pre></li><li>然后<code>ctrl+s</code>保存，命名为JavaC。</li></ul><p>这时候随便写一个Java代码，然后<code>Tools - Build System</code>选择<code>JavaC</code>，然后按<code>ctrl+b</code>就可以运行啦。<br>我这配置的是控制台运行的Java，所以支持输入数据的哦！</p><h1 id="配置Python运行环境"><a href="#配置Python运行环境" class="headerlink" title="配置Python运行环境"></a>配置Python运行环境</h1><hr><ul><li>强烈推荐配合Python发行版本Anaconda使用，下载地址（<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">传送门</a>），下载速度有点慢，推荐使用迅雷下载。安装过程就不多说了。一定要记得安装过程中有一步添加系统变量一定要勾上！</li><li>然后…就没有然后了，Python运行环境安装就是这么简单，直接按<code>ctrl+b</code>就能运行了，但是不支持输入数据哦，想要输入数据的话要安装<code>Sublime REPL</code>插件，请看后面的教程。</li></ul><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>Sublime Text的强大之处就是可以安装各种插件满足你的需求。<br>安装过程很简单：</p><ul><li>首先要安装插件管理工具<code>Package Control</code>，按<code>ctrl+shift+p</code>，输入<code>Install Package</code>，按回车，等待安装完毕。</li><li>然后<code>Preferences</code>选项菜单就会出现<code>Package Control</code>子菜单。</li><li>然后按<code>ctrl+shift+p</code>，输入各种插件名称就能安装啦。</li></ul><p>下面推荐几个我使用的插件，其他的可以自行百度搜索。</p><ul><li>Anaconda<br>这个需要你先安装了Anaconda，然后可以提供各种强大的功能，比如代码提示、函数文档查询、代码风格纠正等等。</li><li>SublimeREPL<br>这个是为了Python输入数据准备的插件，装完之后点击<code>Preferences - Key Bindings</code>，在<code>User</code>文件里粘贴以下代码：<pre><code>  [       { &quot;keys&quot;: [&quot;f5&quot;],          &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,          &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:          {              &quot;id&quot;: &quot;repl_python_run&quot;,              &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;          }      }  ]</code></pre>  然后运行Python代码时直接按<code>F5</code>就行啦！<br>下面两个随意装。</li><li>SublimeHighLight<br>装完之后选中你要复制的代码，右键<code>Copy as RTF</code>，然后粘贴到Word里就会保留代码格式，很漂亮的啊！</li><li>ConvertToUTF8<br>这是为了某些中文显示准备的插件，貌似不怎么用得到，随意装吧。</li></ul><p>我用的就这些啦，Sublime Text写代码还是很方便的，现在基本不用其他的IDE了，能少打开一个软件是一个嘛。</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><hr><p>直接递上<a href="http://www.jb51.net/softjc/180873.html" target="_blank" rel="noopener">传送门</a>。</p><h1 id="sublime配置"><a href="#sublime配置" class="headerlink" title="sublime配置"></a>sublime配置</h1><p><strong>Settings:</strong></p><pre><code>{    &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.sublime-color-scheme&quot;,    &quot;font_options&quot;:    [        &quot;gdi&quot;    ],    &quot;font_size&quot;: 14,    &quot;ignored_packages&quot;:    [        &quot;Vintage&quot;    ],    &quot;theme&quot;: &quot;Adaptive.sublime-theme&quot;,    &quot;translate_tabs_to_spaces&quot;: true,    &quot;expand_tabs_on_save&quot;: true,    &quot;tab_size&quot;: 4,}</code></pre><p><strong>Anaconda Settings User:</strong></p><pre><code>{    &quot;python_interpreter&quot;: &quot;E:/software/anaconda/python.exe&quot;,    &quot;suppress_word_completions&quot;: false,    &quot;suppress_explicit_completions&quot;: false,    &quot;complete_parameters&quot;: true,    &quot;complete__all_parameters&quot;: true,    &quot;anaconda_linting&quot;: false,    &quot;swallow_startup_errors&quot;: true,    &quot;auto_formatting&quot;: true,    &quot;enable_docstrings_tooltip&quot;: true,    &quot;enable_signatures_tooltip&quot;: true,    &quot;display_signatures&quot;: true,}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第二周编程练习2</title>
      <link href="/2017/09/20/dlhw2/"/>
      <url>/2017/09/20/dlhw2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这次练习是实现logistic回归模型的神经网络，来预测一张图片是不是一只猫。<br>我把代码整合在了一起，如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> h5py<span class="token keyword">import</span> scipy<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> scipy <span class="token keyword">import</span> ndimage<span class="token keyword">from</span> lr_utils <span class="token keyword">import</span> load_datasettrain_set_x_orig<span class="token punctuation">,</span> train_set_y<span class="token punctuation">,</span> test_set_x_orig<span class="token punctuation">,</span> test_set_y<span class="token punctuation">,</span> classes <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token punctuation">)</span>m_train <span class="token operator">=</span> train_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>m_test <span class="token operator">=</span> test_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>num_px <span class="token operator">=</span> train_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>train_set_x_flatten <span class="token operator">=</span> train_set_x_orig<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>train_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Ttest_set_x_flatten <span class="token operator">=</span> test_set_x_orig<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>test_set_x_orig<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Ttrain_set_x <span class="token operator">=</span> train_set_x_flatten <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">.</span>test_set_x <span class="token operator">=</span> test_set_x_flatten <span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">.</span><span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> s<span class="token keyword">def</span> <span class="token function">initialize_with_zeros</span><span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>    w <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>shape <span class="token operator">==</span> <span class="token punctuation">(</span>dim<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> float<span class="token punctuation">)</span> <span class="token operator">or</span> isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> w<span class="token punctuation">,</span> bdim <span class="token operator">=</span> <span class="token number">2</span>w<span class="token punctuation">,</span> b <span class="token operator">=</span> initialize_with_zeros<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">propagate</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    A <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>w<span class="token punctuation">.</span>T<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span>    cost <span class="token operator">=</span> <span class="token operator">-</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>Y <span class="token operator">*</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> Y<span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> A<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> m    dw <span class="token operator">=</span> X<span class="token punctuation">.</span>dot<span class="token punctuation">(</span><span class="token punctuation">(</span>A <span class="token operator">-</span> Y<span class="token punctuation">)</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span> <span class="token operator">/</span> m    db <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>A <span class="token operator">-</span> Y<span class="token punctuation">)</span> <span class="token operator">/</span> m    <span class="token keyword">assert</span><span class="token punctuation">(</span>dw<span class="token punctuation">.</span>shape <span class="token operator">==</span> w<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>dtype <span class="token operator">==</span> float<span class="token punctuation">)</span>    cost <span class="token operator">=</span> np<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>cost<span class="token punctuation">)</span>    <span class="token keyword">assert</span><span class="token punctuation">(</span>cost<span class="token punctuation">.</span>shape <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    grads <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"dw"</span><span class="token punctuation">:</span> dw<span class="token punctuation">,</span>             <span class="token string">"db"</span><span class="token punctuation">:</span> db<span class="token punctuation">}</span>    <span class="token keyword">return</span> grads<span class="token punctuation">,</span> costw<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>grads<span class="token punctuation">,</span> cost <span class="token operator">=</span> propagate<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">optimize</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> num_iterations<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    costs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_iterations<span class="token punctuation">)</span><span class="token punctuation">:</span>        grads<span class="token punctuation">,</span> cost <span class="token operator">=</span> propagate<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">)</span>        dw <span class="token operator">=</span> grads<span class="token punctuation">[</span><span class="token string">"dw"</span><span class="token punctuation">]</span>        db <span class="token operator">=</span> grads<span class="token punctuation">[</span><span class="token string">"db"</span><span class="token punctuation">]</span>        w <span class="token operator">=</span> w <span class="token operator">-</span> learning_rate <span class="token operator">*</span> dw        b <span class="token operator">=</span> b <span class="token operator">-</span> learning_rate <span class="token operator">*</span> db        <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            costs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cost<span class="token punctuation">)</span>        <span class="token keyword">if</span> print_cost <span class="token operator">and</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"Cost after iteration %i: %f"</span> <span class="token operator">%</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">)</span>    params <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"w"</span><span class="token punctuation">:</span> w<span class="token punctuation">,</span>              <span class="token string">"b"</span><span class="token punctuation">:</span> b<span class="token punctuation">}</span>    grads <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"dw"</span><span class="token punctuation">:</span> dw<span class="token punctuation">,</span>             <span class="token string">"db"</span><span class="token punctuation">:</span> db<span class="token punctuation">}</span>    <span class="token keyword">return</span> params<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> costsparams<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> costs <span class="token operator">=</span> optimize<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> num_iterations<span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> learning_rate <span class="token operator">=</span> <span class="token number">0.009</span><span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    Y_prediction <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>    w <span class="token operator">=</span> w<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    A <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>w<span class="token punctuation">.</span>T<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>A<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> A<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0.5</span><span class="token punctuation">:</span>            Y_prediction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            Y_prediction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>      <span class="token keyword">assert</span><span class="token punctuation">(</span>Y_prediction<span class="token punctuation">.</span>shape <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> Y_prediction<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这样看起来太乱太复杂了，于是最后一个练习将训练过程合并成了一个model，代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">model</span><span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> Y_test<span class="token punctuation">,</span> num_iterations <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> learning_rate <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    w<span class="token punctuation">,</span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span>    parameters<span class="token punctuation">,</span> grads<span class="token punctuation">,</span> costs <span class="token operator">=</span> optimize<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X_train<span class="token punctuation">,</span> Y_train<span class="token punctuation">,</span> num_iterations<span class="token punctuation">,</span> learning_rate<span class="token punctuation">,</span> print_cost<span class="token punctuation">)</span>    w <span class="token operator">=</span> parameters<span class="token punctuation">[</span><span class="token string">"w"</span><span class="token punctuation">]</span>    b <span class="token operator">=</span> parameters<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span>    Y_prediction_test <span class="token operator">=</span> predict<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X_test<span class="token punctuation">)</span>    Y_prediction_train <span class="token operator">=</span> predict<span class="token punctuation">(</span>w<span class="token punctuation">,</span> b<span class="token punctuation">,</span> X_train<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"train accuracy: {} %"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>Y_prediction_train <span class="token operator">-</span> Y_train<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test accuracy: {} %"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>np<span class="token punctuation">.</span>abs<span class="token punctuation">(</span>Y_prediction_test <span class="token operator">-</span> Y_test<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"costs"</span><span class="token punctuation">:</span> costs<span class="token punctuation">,</span>         <span class="token string">"Y_prediction_test"</span><span class="token punctuation">:</span> Y_prediction_test<span class="token punctuation">,</span>          <span class="token string">"Y_prediction_train"</span> <span class="token punctuation">:</span> Y_prediction_train<span class="token punctuation">,</span>          <span class="token string">"w"</span> <span class="token punctuation">:</span> w<span class="token punctuation">,</span>          <span class="token string">"b"</span> <span class="token punctuation">:</span> b<span class="token punctuation">,</span>         <span class="token string">"learning_rate"</span> <span class="token punctuation">:</span> learning_rate<span class="token punctuation">,</span>         <span class="token string">"num_iterations"</span><span class="token punctuation">:</span> num_iterations<span class="token punctuation">}</span>    <span class="token keyword">return</span> dd <span class="token operator">=</span> model<span class="token punctuation">(</span>train_set_x<span class="token punctuation">,</span> train_set_y<span class="token punctuation">,</span> test_set_x<span class="token punctuation">,</span> test_set_y<span class="token punctuation">,</span> num_iterations <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span> learning_rate <span class="token operator">=</span> <span class="token number">0.005</span><span class="token punctuation">,</span> print_cost <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第二周编程练习1</title>
      <link href="/2017/09/20/dlhw1/"/>
      <url>/2017/09/20/dlhw1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这次编程练习是吴恩达深度学习公开课第二周的配套练习，地址：<a href="https://www.coursera.org/learn/neural-networks-deep-learning" target="_blank" rel="noopener">coursera</a>。</p><h1 id="1-Building-basic-functions-with-numpy"><a href="#1-Building-basic-functions-with-numpy" class="headerlink" title="1 - Building basic functions with numpy"></a>1 - Building basic functions with numpy</h1><hr><h2 id="1-1-sigmoid-function-np-exp"><a href="#1-1-sigmoid-function-np-exp" class="headerlink" title="1.1 - sigmoid function, np.exp()"></a>1.1 - sigmoid function, np.exp()</h2><p>Exercise: Build a function that returns the sigmoid of a real number x. Use <code>math.exp(x)</code> for the exponential function.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: basic_sigmoid</span><span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">basic_sigmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute sigmoid of x.    Arguments:    x -- A scalar    Return:    s -- sigmoid(x)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> sbasic_sigmoid<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exercise: Implement the sigmoid function using <code>numpy</code>.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: sigmoid</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np <span class="token comment" spellcheck="true"># this means you can access numpy functions by writing np.function() instead of numpy.function()</span><span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute the sigmoid of x    Arguments:    x -- A scalar or numpy array of any size    Return:    s -- sigmoid(x)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    s <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> sx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-Sigmoid-gradient"><a href="#1-2-Sigmoid-gradient" class="headerlink" title="1.2 - Sigmoid gradient"></a>1.2 - Sigmoid gradient</h2><p>Exercise: Implement the function <code>sigmoid_grad()</code> to compute the gradient of the sigmoid function with respect to its input x. The formula is:<br>\[sigmoid\_derivative(x) = \sigma’(x) = \sigma(x) (1 - \sigma(x))\]</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: sigmoid_derivative</span><span class="token keyword">def</span> <span class="token function">sigmoid_derivative</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Compute the gradient (also called the slope or derivative) of the sigmoid function with respect to its input x.    You can store the output of the sigmoid function into variables and then use it to calculate the gradient.    Arguments:    x -- A scalar or numpy array    Return:    ds -- Your computed gradient.    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 2 lines of code)</span>    s <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    ds <span class="token operator">=</span> s <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> dsx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"sigmoid_derivative(x) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>sigmoid_derivative<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-Reshaping-arrays"><a href="#1-3-Reshaping-arrays" class="headerlink" title="1.3 - Reshaping arrays"></a>1.3 - Reshaping arrays</h2><p>Exercise: Implement <code>image2vector()</code> that takes an input of shape (length, height, 3) and returns a vector of shape (length*height*3, 1). </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: image2vector</span><span class="token keyword">def</span> <span class="token function">image2vector</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Argument:    image -- a numpy array of shape (length, height, depth)    Returns:    v -- a vector of shape (length*height*depth, 1)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    v <span class="token operator">=</span> image<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>image<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> v<span class="token comment" spellcheck="true"># This is a 3 by 3 by 2 array, typically images will be (num_px_x, num_px_y,3) where 3 represents the RGB values</span>image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.67826139</span><span class="token punctuation">,</span>  <span class="token number">0.29380381</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.90714982</span><span class="token punctuation">,</span>  <span class="token number">0.52835647</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.4215251</span> <span class="token punctuation">,</span>  <span class="token number">0.45017551</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.92814219</span><span class="token punctuation">,</span>  <span class="token number">0.96677647</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.85304703</span><span class="token punctuation">,</span>  <span class="token number">0.52351845</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.19981397</span><span class="token punctuation">,</span>  <span class="token number">0.27417313</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.60659855</span><span class="token punctuation">,</span>  <span class="token number">0.00533165</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.10820313</span><span class="token punctuation">,</span>  <span class="token number">0.49978937</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">0.34144279</span><span class="token punctuation">,</span>  <span class="token number">0.94630077</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"image2vector(image) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>image2vector<span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-Normalizing-rows"><a href="#1-4-Normalizing-rows" class="headerlink" title="1.4 - Normalizing rows"></a>1.4 - Normalizing rows</h2><p>Exercise: Implement <code>normalizeRows()</code> to normalize the rows of a matrix. After applying this function to an input matrix x, each row of x should be a vector of unit length (meaning length 1).</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: normalizeRows</span><span class="token keyword">def</span> <span class="token function">normalizeRows</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Implement a function that normalizes each row of the matrix x (to have unit length).    Argument:    x -- A numpy matrix of shape (n, m)    Returns:    x -- The normalized (by row) numpy matrix. You are allowed to modify x.    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 2 lines of code)</span>    <span class="token comment" spellcheck="true"># Compute x_norm as the norm 2 of x. Use np.linalg.norm(..., ord = 2, axis = ..., keepdims = True)</span>    x_norm <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> keepdims <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Divide x by its norm.</span>    x <span class="token operator">=</span> x <span class="token operator">/</span> x_norm    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> xx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"normalizeRows(x) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>normalizeRows<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-Broadcasting-and-the-softmax-function"><a href="#1-5-Broadcasting-and-the-softmax-function" class="headerlink" title="1.5 - Broadcasting and the softmax function"></a>1.5 - Broadcasting and the softmax function</h2><p>Exercise: Implement a <code>softmax</code> function using numpy. You can think of softmax as a normalizing function used when your algorithm needs to classify two or more classes. You will learn more about softmax in the second course of this specialization.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: softmax</span><span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Calculates the softmax for each row of the input x.    Your code should work for a row vector and also for matrices of shape (n, m).    Argument:    x -- A numpy matrix of shape (n,m)    Returns:    s -- A numpy matrix equal to the softmax of x, of shape (n,m)    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 3 lines of code)</span>    <span class="token comment" spellcheck="true"># Apply exp() element-wise to x. Use np.exp(...).</span>    x_exp <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Create a vector x_sum that sums each row of x_exp. Use np.sum(..., axis = 1, keepdims = True).</span>    x_sum <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>x_exp<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdims<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Compute softmax(x) by dividing x_exp by x_sum. It should automatically use numpy broadcasting.</span>    s <span class="token operator">=</span> x_exp <span class="token operator">/</span> x_sum    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> sx <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"softmax(x) = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>softmax<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-Vectorization"><a href="#2-Vectorization" class="headerlink" title="2 - Vectorization"></a>2 - Vectorization</h1><hr><h2 id="2-1-Implement-the-L1-and-L2-loss-functions"><a href="#2-1-Implement-the-L1-and-L2-loss-functions" class="headerlink" title="2.1 - Implement the L1 and L2 loss functions"></a>2.1 - Implement the L1 and L2 loss functions</h2><p>Exercise: Implement the numpy vectorized version of the <code>L1</code> loss. You may find the function <code>abs(x)</code> (absolute value of x) useful.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: L1</span><span class="token keyword">def</span> <span class="token function">L1</span><span class="token punctuation">(</span>yhat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Arguments:    yhat -- vector of size m (predicted labels)    y -- vector of size m (true labels)    Returns:    loss -- the value of the L1 loss function defined above    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    loss <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>y <span class="token operator">-</span> yhat<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> lossyhat <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"L1 = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>L1<span class="token punctuation">(</span>yhat<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Exercise: Implement the numpy vectorized version of the <code>L2</code> loss. There are several way of implementing the <code>L2</code> loss but you may find the function <code>np.dot()</code> useful. As a reminder, if $x = [x_1, x_2, …, x_n]$, then <code>np.dot(x,x)</code> = $\sum_{j=0}^n x_j^{2}$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># GRADED FUNCTION: L2</span><span class="token keyword">def</span> <span class="token function">L2</span><span class="token punctuation">(</span>yhat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Arguments:    yhat -- vector of size m (predicted labels)    y -- vector of size m (true labels)    Returns:    loss -- the value of the L2 loss function defined above    """</span>    <span class="token comment" spellcheck="true">### START CODE HERE ### (≈ 1 line of code)</span>    loss <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>y <span class="token operator">-</span> yhat<span class="token punctuation">,</span> y <span class="token operator">-</span> yhat<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">### END CODE HERE ###</span>    <span class="token keyword">return</span> lossyhat <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"L2 = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>L2<span class="token punctuation">(</span>yhat<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第二周学习笔记</title>
      <link href="/2017/09/19/dl2/"/>
      <url>/2017/09/19/dl2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>这周开始将会学到神经网络编程的基础知识。</p><h1 id="2-1-二分分类"><a href="#2-1-二分分类" class="headerlink" title="2.1 二分分类"></a>2.1 二分分类</h1><hr><p><img src="13.jpg" alt></p><p>二分类问题就是给定一个输入$x$，预测它的标签$y$是0还是1。拿预测一张图片是不是猫来举例子，一张图片大小为${\rm{64}} \times {\rm{64}}$，将它转化为三个矩阵分别代表RGB分量。再将三个矩阵合并成一个大小为${\rm{(64}} \times {\rm{64}} \times {\rm{3,1)}}$的矩阵作为输入$x$。</p><p>下面给出一些以后要用到的符号表示。</p><p>一个样本用$(x,y)$表示，其中$x \in {R^{ {n_x}}}$，$y \in \{ 0,1\} $，那么$m$个训练样本就可以用集合$\\{ ({x^{(1)}},{y^{(1)}}),({x^{(2)}},{y^{(2)}}), \ldots ,({x^{(m)}},{y^{(m)}})\\} $来表示。</p><p>我们还可以将所有样本特征值用一个矩阵表示：<br>\[X = \left[ {\begin{array}{*{20}{l}} \vdots &amp; \vdots &amp; \cdots &amp; \vdots \\\\{ {x^{(1)}}}&amp;{ {x^{(2)}}}&amp; \cdots &amp;{ {x^{(m)}}}\\\\ \vdots &amp; \vdots &amp; \cdots &amp; \vdots \end{array}} \right]\]</p><p>其中$X \in {R^{ {n_x} \times m}}$。<br>所有样本标签也可以用一个矩阵表示：<br>\[Y = \left[ {\begin{array}{*{20}{l}}{ {y^{(1)}}}&amp;{ {y^{(2)}}}&amp; \cdots &amp;{ {y^{(m)}}}\end{array}} \right]\]</p><p>其中$Y \in {R^{1 \times m}}$。</p><h1 id="2-2-logistic回归"><a href="#2-2-logistic回归" class="headerlink" title="2.2 logistic回归"></a>2.2 logistic回归</h1><hr><p>logistic回归就是用线性函数来拟合输出标签。具体定义为，输入特征$X \in {R^{n_x}}$，参数$w \in {R^{n_x}}$，$b \in {R}$。那么令输出标签<br>\[{ {\hat y}^{(i)}} = \sigma ({w^T}{x^{^{(i)}}} + b)\]<br>其中\[\sigma ({x^{^{(i)}}}) = \frac{1}{ {1 + {e^{ - {x^{^{(i)}}}}}}}\]</p><h1 id="2-3-logistic回归损失函数"><a href="#2-3-logistic回归损失函数" class="headerlink" title="2.3 logistic回归损失函数"></a>2.3 logistic回归损失函数</h1><hr><p>损失函数衡量的是输出标签${\hat y}$与真实标签$y$之间的差距，有很多种定义方法，下面是常用的两种：<br>\[L({ {\hat y}^{^{(i)}}},{y^{^{(i)}}}) = \frac{1}{2}{({ {\hat y}^{^{(i)}}} - {y^{^{(i)}}})^2}\]和<br>\[L({ {\hat y}^{^{(i)}}},{y^{^{(i)}}}) =  - [{y^{(i)}}\log ({ {\hat y}^{(i)}}) + (1 - {y^{(i)}})\log (1 - { {\hat y}^{(i)}})]\]<br>一般我们使用下面一种损失函数，具体原因最后一节课会讲到，因为它是个凸函数，方便梯度下降。</p><p>如果有$m$个样本，那么总的损失函数就定义为<br>\[J(w,b) = \frac{1}{m}\sum\limits_{i - 1}^m {L({ {\hat y}^{^{(i)}}},{y^{^{(i)}}})}  =  - \frac{1}{m}\sum\limits_{i - 1}^m {[{y^{(i)}}\log ({ {\hat y}^{(i)}}) + (1 - {y^{(i)}})\log (1 - { {\hat y}^{(i)}})]} \]</p><h1 id="2-4-梯度下降法"><a href="#2-4-梯度下降法" class="headerlink" title="2.4 梯度下降法"></a>2.4 梯度下降法</h1><hr><p>通过重复<br>\[w: = w - \alpha \frac{ {\partial J(w,b)}}{ {\partial w}}\]<br>和<br>\[b: = b - \alpha \frac{ {\partial J(w,b)}}{ {\partial b}}\]<br>来不断更新$w$和$b$，使得$w$和$b$接近最优值。</p><h1 id="2-7-计算图"><a href="#2-7-计算图" class="headerlink" title="2.7 计算图"></a>2.7 计算图</h1><hr><p><img src="14.jpg" alt></p><p>如上图所示就是一个计算图，初始结点都是输入值，中间一个结点表示一个运算，最后一个结点就是输出值。</p><h1 id="2-8-计算图的导数计算"><a href="#2-8-计算图的导数计算" class="headerlink" title="2.8 计算图的导数计算"></a>2.8 计算图的导数计算</h1><hr><p><img src="15.jpg" alt></p><p>反向传播的时候只要沿着红色的箭头利用求导链式法则来对每个参数求导就行了。</p><h1 id="2-9-logistic回归中的梯度下降"><a href="#2-9-logistic回归中的梯度下降" class="headerlink" title="2.9 logistic回归中的梯度下降"></a>2.9 logistic回归中的梯度下降</h1><hr><p><img src="16.jpg" alt></p><p>logistic回归的计算图如上图所示，导数如下：<br>\[\frac{ {\partial L(a,y)}}{ {\partial a}} =  - \frac{y}{a} + \frac{ {1 - y}}{ {1 - a}}\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial z}} = \frac{ {\partial L(a,y)}}{ {\partial a}} \cdot \frac{ {\partial a}}{ {\partial z}} = ( - \frac{y}{a} + \frac{ {1 - y}}{ {1 - a}}) \cdot a(1 - a) = a - y\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial {w_1}}} = {x_1} \cdot \frac{ {\partial L(a,y)}}{ {\partial z}} = {x_1}(a - y)\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial {w_2}}} = {x_2} \cdot \frac{ {\partial L(a,y)}}{ {\partial z}} = {x_2}(a - y)\]<br>\[\frac{ {\partial L(a,y)}}{ {\partial b}} = \frac{ {\partial L(a,y)}}{ {\partial z}} = a - y\]</p><h1 id="2-10-m-个样本的梯度下降"><a href="#2-10-m-个样本的梯度下降" class="headerlink" title="2.10 $m$个样本的梯度下降"></a>2.10 $m$个样本的梯度下降</h1><hr><p><img src="17.jpg" alt></p><p>$m$个样本的梯度其实就是每个样本的梯度求和，如图所示的伪代码中，用一层<code>for</code>循环来对梯度进行求和。在后面的课程中我们将会摒弃这种做法，用更快速的向量化方法来进行计算。</p><h1 id="2-11-向量化"><a href="#2-11-向量化" class="headerlink" title="2.11 向量化"></a>2.11 向量化</h1><hr><p>向量化就是将例如${w^T}x$这样的矩阵点乘用python的<code>numpy</code>库函数<code>dot</code>代替普通的<code>for</code>循环。示例代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npa <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>c <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token keyword">print</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-12-向量化的更多例子"><a href="#2-12-向量化的更多例子" class="headerlink" title="2.12 向量化的更多例子"></a>2.12 向量化的更多例子</h1><hr><p>经验法则是能不使用<code>for</code>循环就尽量不要使用，用向量来代替。更多的向量化例子有<code>np.exp()</code>，<code>np.sum()</code>等等。</p><h1 id="2-13-向量化logistic回归"><a href="#2-13-向量化logistic回归" class="headerlink" title="2.13 向量化logistic回归"></a>2.13 向量化logistic回归</h1><hr><p>之前提到的算法是用<code>for</code>循环来计算所有的${ {\hat y}^{(i)}} = \sigma ({w^T}{x^{^{(i)}}} + b)$。现在可以使用向量化来加快计算速度，只要计算$Y = \sigma ({w^T}X + b)$即可。</p><h1 id="2-14-向量化logistic回归的梯度输出"><a href="#2-14-向量化logistic回归的梯度输出" class="headerlink" title="2.14 向量化logistic回归的梯度输出"></a>2.14 向量化logistic回归的梯度输出</h1><hr><p>logistic回归的梯度用向量可以表示为<br>\[dz = A - Y\]<br>\[dw = \frac{1}{m}Xd{z^T}\]<br>下面两节课都是讲的python的广播和向量的一些说明，在此就不细讲了，大家可以去查看python文档。其中讲到的一个写python程序的好习惯就是用到向量的时候如果不确定维数，那么你就<code>reshape()</code>一下，还有就是加一句<code>assert()</code>语句判断一下维数。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达深度学习公开课第一周学习笔记</title>
      <link href="/2017/09/19/dl1/"/>
      <url>/2017/09/19/dl1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>保了研暂时也没什么事干，从今天开始学一学吴恩达最近发布的深度学习课程。顺便在博客上做做笔记，梳理一下。</p><p>coursera上面的课程要钱，还贼贵。所以我就直接在网易公开课上面看免费版的了，免费版没有作业和练习，是一个很大的缺憾。因为这门课很大的一个亮点就是高质量的编程题。顺带附上这门课的地址：<a href="https://mooc.study.163.com/learn/deeplearning_ai-2001281002?tid=2001392029#/learn/content" target="_blank" rel="noopener">吴恩达深度学习公开课</a></p><h1 id="1-2-什么是神经网络？"><a href="#1-2-什么是神经网络？" class="headerlink" title="1.2 什么是神经网络？"></a>1.2 什么是神经网络？</h1><hr><p>这节课是深度学习的入门课，首先给出了深度学习的定义：深度学习就是训练神经网络。那么问题来了，什么是神经网络？这节课就介绍了神经网络的概念。<br><img src="5.jpg" alt></p><p>首先从一个房价预测的例子讲起，已知房子大小和对应的房价，用一条曲线拟合这些点。那么用一条直线就可以了，但是房价不能为负，所以左边恒为0，这个函数就是“线性修正单元”，即ReLU。</p><p><img src="6.jpg" alt></p><p>这就是最基本的神经元，输入一个房子大小也就是$x$，经过一个神经单元运算之后，输出房价也就是$y$。</p><p><img src="7.jpg" alt></p><p>更复杂的情况下，房价还取决于更多的因素，比如房子大小、房间数量、邮编、周边富裕程度。</p><p>我们不会具体指明中间一层的神经单元代表什么，神经网络想怎么算就怎么算。所以上图从左到右三层分别叫做输入层、隐含层、输出层。</p><p>值得注意的是，神经网络只要你喂给了它足够多的$(x,y)$训练数据，那么它就可以训练出一个从$x$到$y$的精准映射函数。</p><p>这就是最基本的神经网络和监督学习的例子，也就是你任意输入一个$x$，神经网络都可以预测出一个对应的$y$。</p><p>下一讲将会更加深入的讲解监督学习的相关算法。</p><h1 id="1-3-用神经网络进行监督学习"><a href="#1-3-用神经网络进行监督学习" class="headerlink" title="1.3 用神经网络进行监督学习"></a>1.3 用神经网络进行监督学习</h1><hr><p>神经网络最近被媒体炒作的沸沸扬扬，其实绝大多数神经网络创造的价值都来自于一种机器学习算法：监督学习。</p><p><img src="8.jpg" alt></p><p>可以看出，监督学习就是输入一个特征$x$，然后学习得到一个输出$y$。监督学习在很多不同领域有重要应用，比如之前提到的房价预测，还有在线广告、计算机视觉、语音识别、机器翻译和自动驾驶等等。</p><p>他们所应用的神经网络结构也都是不同的。其中房价预测和在线广告用的是标准的神经网络。而计算机视觉处理的是空间上的图像，所以用到的是卷积神经网络(CNN)。语音识别和机器翻译因为都是处理的时间相关的序列，所以用到的是循环神经网络(RNN)。而自动驾驶就更加的复杂了，既要处理图像，又要处理雷达信息，所以要用混合神经网络。</p><p><img src="9.jpg" alt></p><p>上图就是三种神经网络的基本结构，CNN擅长处理图像相关的数据，RNN擅长处理序列相关的数据。</p><p><img src="10.jpg" alt></p><p>输入的数据也分为两大类：结构化数据和非结构化数据。结构化数据就是指数据的数据库，每一个数据都是有明确的含义的，比如房子的大小，房间的数量等等。非结构化数据就是指音频、图像、文本之类的数据。</p><p>人类天生就更擅长理解非结构化数据，但是计算机就不行了。近几年来，神经网络的发展让计算机也能非常好的理解非结构化数据了。在实际应用中，最好要将结构化数据和非结构化数据结合起来，才能发挥出最好的性能。</p><p>其实神经网络几十年前就已经提出来了，那为什么最近几年才流行起来呢？下一节吴恩达老师将会给我们带来答案。</p><h1 id="1-4-为什么深度学习会兴起"><a href="#1-4-为什么深度学习会兴起" class="headerlink" title="1.4 为什么深度学习会兴起?"></a>1.4 为什么深度学习会兴起?</h1><hr><p>上节课最后提到，神经网络几十年前就有了，那为什么最近几年才兴起呢？</p><p><img src="11.jpg" alt></p><p>吴恩达通过一张图很好的解释了原因。如上图所示，$x$轴是数据量，$y$轴是机器学习算法的效率，具体来说就是图像识别的准确率等等。</p><p>可以看出，随着数据量的增大，机器学习算法的效率也随之增大。但是传统的机器学习算法比如支持向量机(SVM)在数据量大到一个程度之后会进入“平台期”，不会再上升了。而不同规模的神经网络会一直上升，只要你数据足够多。</p><p>所以在今天要想得到更好的效果，就要训练一个大规模的神经网络，这个大规模指的是两个方面：一个是神经网络的隐含层单元足够多，也就是参数足够多，一个就是数据规模要足够多。但是这最终也是有瓶颈的，因为神经网络太大了之后计算效率就会下降，训练时间会特别长。数据也会耗尽，没有无限的数据。</p><p>从技术上面来说，上图$x$轴的数据代表的是“有标签的数据”，也就是每个输入$x$都有一个标签$y$与之对应，一组数据就是一对$(x,y)$。在以后的课程中，我们都使用$m$来表示数据的规模，也就是$x$轴的数值。</p><p></p><p>在上图中我们还可以看出，在数据量比较小的时候，传统机器学习算法甚至会优于神经网络。因为它的性能基于手工设计组件的优劣和一些算法细节上面的优化，比如特征的提取等等。但是训练数据规模大了以后，神经网络就稳定优于传统机器学习方法了。</p><p><img src="12.jpg" alt></p><p>影响神经网络性能的因素主要有三点：数据规模、计算能力、算法。</p><p>数据规模之前已经提到过了。计算能力的话因为最近几年CPU和GPU的发展，计算能力得到很大的提升，所以训练时间也大大缩短。算法优化也是为了缩短训练时间，课上举了一个算法优化的例子。</p><p></p><p>以前神经网络激活函数都是用的sigmoid函数，图像如上图所示。但是存在一个问题，就是一直训练下去会出现梯度消失的问题，反映在函数图象上就是当输入太小时斜率会趋于0。所以后来换成了ReLU函数，在大于0的时候斜率恒为1。</p><p></p><p>图的右半部分是神经网络训练的流程。首先你要想出一个算法，然后你要实现代码，最后运行结果进行训练。如果训练时间很短，比如10分钟或者一天以内，那么你就可以调整算法，继续优化训练。如果训练时间要一个月，那么你就只能实现很少的想法了。</p><p></p><p>可喜的是，现在数据和硬件还在继续发展着，我们要做的就是继续研究新的算法和进行算法的优化。所以我们坚信，深度学习还会继续发展进步下去。</p><p></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吴恩达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Make Context More Useful? An Empirical Study on Context-Aware Neural Conversational Models</title>
      <link href="/2017/09/19/context/"/>
      <url>/2017/09/19/context/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>论文链接：<a href="https://www.aclweb.org/anthology/P/P17/P17-2036.pdf" target="_blank" rel="noopener">P17-2036</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>最近许多研究者都注意到了上下文在对话系统中的重要性，也做了很多的研究，但是没有系统的比较来分析怎么样才能有效地利用上下文。我们做了详细的研究来比较不同的模型，研究上下文在对话系统中的作用。同时，我们提出了度量上下文与查询之间相关性的方法，比其他方法性能都出色。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><hr><p>对话系统有两种典型的研究设置：单轮和多轮。单轮就是只输入查询$q$，输出答案$r$。但是大多数现实的对话都是要多轮的，就是要结合上下文来做出回答。<br>很多研究者都意识到了上下文的重要性，也提出了很多方法。一种是直接将上下文和查询向量连接到一起，另一种是分层模型。有很多方法来结合上下文和查询，比如池化和连接。但是没有人对它们做过比较。<br>这篇论文里，我们在Seq2Seq的对话系统上对上下文模型做研究。我们关注两个问题：</p><ul><li>我们怎么样才能更好的利用上下文？</li><li>上下文对神经对话系统的影响是什么？</li></ul><p>未分层模型通常使用经典的encode-decoder框架，我们实验中用的是RNN+GRU，decode时beamsearch大小为5。分层模型有三种方法结合上下文和查询：池化、连接、连续整合。<br><img src="hierarchical_model.jpg" alt><br><img src="2.jpg" alt><br>但是我们发现加权后的实验结果还不如直接使用最后一个隐含层的结果，我们猜测是因为这个RNN不是很长，所以对前面的结果保存的比较好，所以我们实验直接使用最后一个隐含层作为输出。<br>衡量上下文和查询的相关程度：<br>\[{s_{ {c_i}}} = sim({c_i},q) = \frac{ { {e_{c_i} } \cdot {e_q}}}{ {\left\| {e_{c_i}} \right\| \cdot \left\| { {e_q}} \right\|}}\]<br>其中：\[{e_{c_i}} = \sum\limits_{w \in {c_i}} {e_w} ,{e_q} = \sum\limits_{w’ \in {c_i}} {e_w’} \]<br>归一化：<br>\[\alpha _{c_i} = \frac{ {\exp ({s_{ {c_i}}})}} { {\sum\nolimits_{j = 0}^n {\exp ({s_{ {c_i}}})}  + \exp ({s_q})}}\]<br>\[{ {\alpha _q} = \frac{ {\exp ({s_q})}}{ {\sum\nolimits_{j = 0}^n {\exp ({s_{ {c_i}}})}  + \exp ({s_q})}}}\]<br>两种连接方法：</p><ul><li>WSeq(sum):<br>\[{v_{enc}} = \sum\limits_{i = 0}^n { {\alpha _{ {c_i}}}{h_{ {c_i}}} + {\alpha _q}{h_q}} \]</li><li>WSeq(concat):<br>\[{v_{enc}} = \left[ { {\alpha _{ {c_0}}}{h_{ {c_0}}}; \ldots ;{\alpha _{ {c_n}}}{h_{ {c_n}}};{\alpha _q}{h_q}} \right]\]</li></ul><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><hr><p>我们在百度贴吧问答数据集上做实验。<br><img src="1.jpg" alt></p><h1 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h1><hr><p>虽然BLEU不适合用来度量对话系统这种开放式的系统。但是我们没有足够的人力物力来对结果一一标注，所以还是采用BLEU。下面回到最开始提出的两个问题。</p><ul><li>我们怎么样才能更好的利用上下文？<br>首先我们发现采用上下文实验结果的确比不采用的更好了。然后分层的模型结果比不分层的更好。我们猜测原因可能是对话系统不同于其他NLP任务，对话系统句子可能出自不同的人。让每个上下文保持独立很重要，而不是简单的池化结合到一起，所以直接连接起来效果更好。上下文和查询相关性对系统有帮助。</li><li>上下文对神经对话系统的影响是什么？<br><img src="3.jpg" alt><br>可以看出，采用上下文的模型能产生更长、更有意义、更多样性的回答。我们还发现了一个有趣的现象：一个encode-decoder模型如果想要生成有意义的回答，必须要足够多的有意义的信息提供给它。这解释了为什么seq2seq在其他NLP任务表现得很好，但是在对话系统表现得不好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL </tag>
            
            <tag> NLP </tag>
            
            <tag> 问答系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研第一，我还是选择留在了本校</title>
      <link href="/2017/09/19/baoyan/"/>
      <url>/2017/09/19/baoyan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>保研去哪？其实我刚开始也纠结过。看到其他同学忙着申报各大名校，我也曾经动摇过，但是现在却没什么感觉了。很多人不理解为什么第一不去试试清北复交，我承认，这些学校是优势很大，毕竟还是高了一个档次的。<br>想当年高考时，我的梦想就是考上清华，但是最后考砸了只能来了华师。现在想来也罢了，或许本来就没有那个实力吧。从小学开始，我就一直是考上了最好的学校却去了低一个档次的学校。那时候都是因为体质不好吧，不让去太远的学校，现在反而习惯了那种拿第一的感觉。<br>暑假开始前，很多人就准备报名夏令营了，我却回家考驾照了，一个也没报。其实当时就已经打算留读本校了，当时考虑是研究生阶段学校影响没有导师和专业强了，而且其他学校导师也都不熟悉，很难找到一个人品好学术好的好导师，于是就决心本校找一个了。其他原因也都是些无关紧要的了，比如本校环境熟悉、还不用大费周折搬家等等，说起来挺幼稚，哪有前途重要。<br>现在也差不多定了吧，我觉得还是成事在人吧。既然自己选择了这条路，不去走更宽敞的路，那就要把它走好。去了好学校不能骄纵，留在差学校也不能自暴自弃吧，就当作是激励自己的动力吧。<br>还是谢谢大家的关心，让你们失望了，我不是没有梦想，也不是懒。只要你足够努力，梦想在哪里都能发芽。<br>看来不能因为保了研而放松自己了，还有那么多为了考研在奋斗的学生。下面一年三大计划：毕业论文、实习、研一的活。不管是保了研的还是还在考研的或者准备工作的，大家一起加油吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位长者关于保研的一些人生经验</title>
      <link href="/2017/09/19/recommend/"/>
      <url>/2017/09/19/recommend/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><p>经过三年的艰苦学习，终于也艰难保上研了，因此在此给学弟学妹们一点人生经验，粗鄙之见，大家随便看看。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><hr><ul><li>好好学习自然不用多说，自觉性是最重要的，作业不能拖拉，不要拖到最后一刻才做作业。<br>就拿我自己说吧，我每次上完课都会立即把上课讲的再看一遍，把没听懂的搞懂，不然时间长了会慢慢忘掉的，等到期末就更难搞懂了。还有就是作业，我每次都会当天就开始做，尽量提前很早做完。这样好处多多哦，既可以不至于最后一天很忙，又可以把作业完成的很好，最后自然就拿高分啦。</li><li>图书馆可以多去去的，虽然我这一年都没去过。<br>想当年大一大二在闵行的时候，那时候还是有女票的(&gt;﹏&lt;)，基本上天天都会去图书馆呆着吧，很怀念那时候的日子。</li><li>上课少玩手机，多听讲，这样期末复习起来才轻松一点。<br>不过我自己上课也玩哈哈哈，我也有很多课听不懂或者很无聊的课，都会戳一戳手机解解闷。有时下午太困了还会打个盹。但是一定要记住，课上缺的，课后一定要补回来，就算花再多时间也要弄懂。</li></ul><h1 id="竞赛项目"><a href="#竞赛项目" class="headerlink" title="竞赛项目"></a>竞赛项目</h1><hr><ul><li>有实力和天赋的话搞搞ACM竞赛也是好处极大的，奖学金和保研加分多多的，也极大提升代码能力。<br>想当年我刚高中毕业的那个暑假，还连信息学竞赛都没听说过，但是出于兴趣暑假自学了c语言和基础的算法。于是刚开学就被招进了ACM实验室。不过当时搞的人也少，于是我也就有了出去打比赛的机会。现在这几年人越来越多了，要好好加油了啊。<br>不过我后来太懒了，都没怎么训练，现在光荣的退役咯，老学长只能给你们加油了。</li><li>项目的话我没怎么搞过，真心想搞可以好好弄弄，想水一水的那就别浪费时间了，加分也不多。<br>想当年还有过打算搞搞大夏杯啥的，后来也没了音讯，毕竟ACM太忙了。</li></ul><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><hr><ul><li>也别老学习啊，多累啊，出去散散步逛逛街玩玩。<br>找个女票啊，带她一起出去玩玩。实在没有的话，和好基友出去玩也行啊！</li><li>日常开黑打打游戏啊，但别耽误了学习做作业。<br>像我就玩英雄联盟、炉石之类的啊，别玩物丧志，通宵玩伤了身体就好。室友之间有个共同爱好挺不错的。</li></ul><h1 id="恋爱"><a href="#恋爱" class="headerlink" title="恋爱"></a>恋爱</h1><hr><ul><li>这方面我很失败，就不谈经验了，谈谈教训吧。</li><li>要好好待人家，别只顾自己学习和玩乐。</li><li>别太自私，毕竟人家为你付出了青春。</li><li>为我自己加油。</li></ul><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><hr><ul><li>千万别熬夜了，大一大二你还年轻，熬得起。等到了大三大四，身体吃不消了，你会越来越感觉累的。</li><li>还是那句话，学在平时，别在考试前最后一天通宵学习。</li><li>现在想来，还是多运动运动散散步好，整天呆在宿舍太闷了，恐怕是老了吧。</li></ul><p>最后附上今年保研最终排名，见笑了（好基友非要我给他打码，那我就照办了）：<br><img src="top.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOJ3328. 时空交织的代价</title>
      <link href="/2017/09/19/eoj3328/"/>
      <url>/2017/09/19/eoj3328/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><hr><p>给定$n$个点和每个点在$x$轴上面的位置和每个点的权值，求出点对之间的费用总和。其中某两个点$i$，$j$之间的费用定义为$ | p_i - p_j | \times max\{v_i, v_j\} $。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr><p>对于每个点，计算它左边权值小于它的点与它点对费用之和：\[{v_i}\sum\limits_j {({p_i} - {p_j})}  = k{v_i}{p_i} - {v_i}\sum\limits_j {p_j} \]其中$k$是左边权值小于它的点的数量，$\sum\limits_j {p_j}$是它们的权值之和，可以用两个树状数组统计。右边同理。<br>首先按照$p$从小到大排序。对于每个点用树状数组分别统计出左右两边$v$比它小的$v$之和与数量，然后直接计算结果即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iterator></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;numeric></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iomanip></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;complex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cassert></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cctype></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bitset></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;deque></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stack></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;deque></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;new></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//#pragma comment(linker, "/STACK:102400000,102400000")</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> LL<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PII<span class="token punctuation">;</span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span>PII<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> PIII<span class="token punctuation">;</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span>vec<span class="token operator">></span> mat<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> PB push_back</span><span class="token macro property">#<span class="token directive keyword">define</span> MP(a, b) make_pair(a, b)</span><span class="token macro property">#<span class="token directive keyword">define</span> FI first</span><span class="token macro property">#<span class="token directive keyword">define</span> SE second</span><span class="token macro property">#<span class="token directive keyword">define</span> gcd(x, y) __gcd(x, y)</span><span class="token macro property">#<span class="token directive keyword">define</span> gcd3(x, y, z) __gcd(__gcd(x, y), z)</span><span class="token keyword">const</span> <span class="token keyword">double</span> EPS <span class="token operator">=</span> <span class="token number">1e-15</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> PI <span class="token operator">=</span> <span class="token function">acos</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">const</span> LL INFL <span class="token operator">=</span> <span class="token number">0x3f3f3f3f3f3f3f3fLL</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">200000</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MOD <span class="token operator">=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>LL bit<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> bit1<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">;</span>LL <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>s <span class="token operator">+</span><span class="token operator">=</span> bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">-</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> LL x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>bit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">+</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>LL <span class="token function">sum1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LL s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>s <span class="token operator">+</span><span class="token operator">=</span> bit1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">-</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> LL x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span>bit1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        i <span class="token operator">+</span><span class="token operator">=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">struct</span> node <span class="token punctuation">{</span>    LL p<span class="token punctuation">,</span> v<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> node<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> p <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>node a<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    LL ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL cnt <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL s <span class="token operator">=</span> <span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span>ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p <span class="token operator">-</span> s<span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL cnt <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL s <span class="token operator">=</span> <span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span>ans <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">-</span> cnt <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>bit1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> bit1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LL cnt <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LL s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">sum1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">;</span>        <span class="token punctuation">(</span>ans <span class="token operator">-</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">-</span> cnt <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span> <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span> <span class="token operator">*</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">=</span> MOD<span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add1</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ans <span class="token operator">%</span> MOD <span class="token operator">+</span> MOD<span class="token punctuation">)</span> <span class="token operator">%</span> MOD<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eoj </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
